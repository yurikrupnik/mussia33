// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/crossplane/crossplane/apis/apiextensions/v1

package v1

import (
	"k8s.io/apimachinery/pkg/runtime"
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	corev1 "k8s.io/api/core/v1"
)

// A CompositionMode determines what mode of Composition is used
#CompositionMode: string // #enumCompositionMode

#enumCompositionMode:
	#CompositionModeResources |
	#CompositionModePipeline

// CompositionModeResources indicates that a Composition uses what is
// commonly referred to as "Patch & Transform" or P&T composition. This mode
// of Composition uses an array of resources, each a template for a composed
// resource.
#CompositionModeResources: #CompositionMode & "Resources"

// CompositionModePipeline indicates that a Composition specifies a pipeline
// of Composition Functions, each of which is responsible for producing
// composed resources that Crossplane should create or update.
//
// THIS IS A BETA FEATURE. It is not honored if the relevant Crossplane
// feature flag is disabled.
#CompositionModePipeline: #CompositionMode & "Pipeline"

// TypeReference is used to refer to a type for declaring compatibility.
#TypeReference: {
	// APIVersion of the type.
	apiVersion: string @go(APIVersion)

	// Kind of the type.
	kind: string @go(Kind)
}

// A PatchSet is a set of patches that can be reused from all resources within
// a Composition.
#PatchSet: {
	// Name of this PatchSet.
	name: string @go(Name)

	// Patches will be applied as an overlay to the base resource.
	patches: [...#Patch] @go(Patches,[]Patch)
}

// ComposedTemplate is used to provide information about how the composed resource
// should be processed.
#ComposedTemplate: {
	// A Name uniquely identifies this entry within its Composition's resources
	// array. Names are optional but *strongly* recommended. When all entries in
	// the resources array are named entries may added, deleted, and reordered
	// as long as their names do not change. When entries are not named the
	// length and order of the resources array should be treated as immutable.
	// Either all or no entries must be named.
	// +optional
	name?: null | string @go(Name,*string)

	// Base is the target resource that the patches will be applied on.
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:EmbeddedResource
	base: runtime.#RawExtension @go(Base)

	// Patches will be applied as overlay to the base resource.
	// +optional
	patches?: [...#Patch] @go(Patches,[]Patch)

	// ConnectionDetails lists the propagation secret keys from this target
	// resource to the composition instance connection secret.
	// +optional
	connectionDetails?: [...#ConnectionDetail] @go(ConnectionDetails,[]ConnectionDetail)

	// ReadinessChecks allows users to define custom readiness checks. All checks
	// have to return true in order for resource to be considered ready. The
	// default readiness check is to have the "Ready" condition to be "True".
	// +optional
	// +kubebuilder:default={{type:"MatchCondition",matchCondition:{type:"Ready",status:"True"}}}
	readinessChecks?: [...#ReadinessCheck] @go(ReadinessChecks,[]ReadinessCheck)
}

// ReadinessCheckType is used for readiness check types.
#ReadinessCheckType: string // #enumReadinessCheckType

#enumReadinessCheckType:
	#ReadinessCheckTypeNonEmpty |
	#ReadinessCheckTypeMatchString |
	#ReadinessCheckTypeMatchInteger |
	#ReadinessCheckTypeMatchTrue |
	#ReadinessCheckTypeMatchFalse |
	#ReadinessCheckTypeMatchCondition |
	#ReadinessCheckTypeNone

#ReadinessCheckTypeNonEmpty:       #ReadinessCheckType & "NonEmpty"
#ReadinessCheckTypeMatchString:    #ReadinessCheckType & "MatchString"
#ReadinessCheckTypeMatchInteger:   #ReadinessCheckType & "MatchInteger"
#ReadinessCheckTypeMatchTrue:      #ReadinessCheckType & "MatchTrue"
#ReadinessCheckTypeMatchFalse:     #ReadinessCheckType & "MatchFalse"
#ReadinessCheckTypeMatchCondition: #ReadinessCheckType & "MatchCondition"
#ReadinessCheckTypeNone:           #ReadinessCheckType & "None"

// ReadinessCheck is used to indicate how to tell whether a resource is ready
// for consumption
#ReadinessCheck: {
	// Type indicates the type of probe you'd like to use.
	// +kubebuilder:validation:Enum="MatchString";"MatchInteger";"NonEmpty";"MatchCondition";"MatchTrue";"MatchFalse";"None"
	type: #ReadinessCheckType @go(Type)

	// FieldPath shows the path of the field whose value will be used.
	// +optional
	fieldPath?: string @go(FieldPath)

	// MatchString is the value you'd like to match if you're using "MatchString" type.
	// +optional
	matchString?: string @go(MatchString)

	// MatchInt is the value you'd like to match if you're using "MatchInt" type.
	// +optional
	matchInteger?: int64 @go(MatchInteger)

	// MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
	// +optional
	matchCondition?: null | #MatchConditionReadinessCheck @go(MatchCondition,*MatchConditionReadinessCheck)
}

// MatchConditionReadinessCheck is used to indicate how to tell whether a resource is ready
// for consumption
#MatchConditionReadinessCheck: {
	// Type indicates the type of condition you'd like to use.
	// +kubebuilder:default="Ready"
	type: xpv1.#ConditionType @go(Type)

	// Status is the status of the condition you'd like to match.
	// +kubebuilder:default="True"
	status: corev1.#ConditionStatus @go(Status)
}

// A ConnectionDetailType is a type of connection detail.
#ConnectionDetailType: string // #enumConnectionDetailType

#enumConnectionDetailType:
	#ConnectionDetailTypeUnknown |
	#ConnectionDetailTypeFromConnectionSecretKey |
	#ConnectionDetailTypeFromFieldPath |
	#ConnectionDetailTypeFromValue

#ConnectionDetailTypeUnknown:                 #ConnectionDetailType & "Unknown"
#ConnectionDetailTypeFromConnectionSecretKey: #ConnectionDetailType & "FromConnectionSecretKey"
#ConnectionDetailTypeFromFieldPath:           #ConnectionDetailType & "FromFieldPath"
#ConnectionDetailTypeFromValue:               #ConnectionDetailType & "FromValue"

// ConnectionDetail includes the information about the propagation of the connection
// information from one secret to another.
#ConnectionDetail: {
	// Name of the connection secret key that will be propagated to the
	// connection secret of the composition instance. Leave empty if you'd like
	// to use the same key name.
	// +optional
	name?: null | string @go(Name,*string)

	// Type sets the connection detail fetching behaviour to be used. Each
	// connection detail type may require its own fields to be set on the
	// ConnectionDetail object. If the type is omitted Crossplane will attempt
	// to infer it based on which other fields were specified. If multiple
	// fields are specified the order of precedence is:
	// 1. FromValue
	// 2. FromConnectionSecretKey
	// 3. FromFieldPath
	// +optional
	// +kubebuilder:validation:Enum=FromConnectionSecretKey;FromFieldPath;FromValue
	type?: null | #ConnectionDetailType @go(Type,*ConnectionDetailType)

	// FromConnectionSecretKey is the key that will be used to fetch the value
	// from the composed resource's connection secret.
	// +optional
	fromConnectionSecretKey?: null | string @go(FromConnectionSecretKey,*string)

	// FromFieldPath is the path of the field on the composed resource whose
	// value to be used as input. Name must be specified if the type is
	// FromFieldPath.
	// +optional
	fromFieldPath?: null | string @go(FromFieldPath,*string)

	// Value that will be propagated to the connection secret of the composite
	// resource. May be set to inject a fixed, non-sensitive connection secret
	// value, for example a well-known port.
	// +optional
	value?: null | string @go(Value,*string)
}

// A PipelineStep in a Composition Function pipeline.
#PipelineStep: {
	// Step name. Must be unique within its Pipeline.
	step: string @go(Step)

	// FunctionRef is a reference to the Composition Function this step should
	// execute.
	functionRef: #FunctionReference @go(FunctionRef)

	// Input is an optional, arbitrary Kubernetes resource (i.e. a resource
	// with an apiVersion and kind) that will be passed to the Composition
	// Function as the 'input' of its RunFunctionRequest.
	// +optional
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:EmbeddedResource
	input?: null | runtime.#RawExtension @go(Input,*runtime.RawExtension)
}

// A FunctionReference references a Composition Function that may be used in a
// Composition pipeline.
#FunctionReference: {
	// Name of the referenced Function.
	name: string @go(Name)
}

// A StoreConfigReference references a secret store config that may be used to
// write connection details.
#StoreConfigReference: {
	// Name of the referenced StoreConfig.
	name: string @go(Name)
}
