// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Account is the Schema for the Accounts API. Enables Security Hub for an AWS account.
 *
 * @schema Account
 */
export class Account extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Account"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'Account',
  }

  /**
   * Renders a Kubernetes manifest for "Account".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccountProps): any {
    return {
      ...Account.GVK,
      ...toJson_AccountProps(props),
    };
  }

  /**
   * Defines a "Account" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccountProps) {
    super(scope, id, {
      ...Account.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Account.GVK,
      ...toJson_AccountProps(resolved),
    };
  }
}

/**
 * Account is the Schema for the Accounts API. Enables Security Hub for an AWS account.
 *
 * @schema Account
 */
export interface AccountProps {
  /**
   * @schema Account#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccountSpec defines the desired state of Account
   *
   * @schema Account#spec
   */
  readonly spec: AccountSpec;

}

/**
 * Converts an object of type 'AccountProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountProps(obj: AccountProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccountSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccountSpec defines the desired state of Account
 *
 * @schema AccountSpec
 */
export interface AccountSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccountSpecDeletionPolicy;

  /**
   * @schema AccountSpec#forProvider
   */
  readonly forProvider: AccountSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AccountSpec#initProvider
   */
  readonly initProvider?: AccountSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AccountSpec#managementPolicies
   */
  readonly managementPolicies?: AccountSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccountSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccountSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccountSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccountSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccountSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccountSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccountSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpec(obj: AccountSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccountSpecForProvider(obj.forProvider),
    'initProvider': toJson_AccountSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AccountSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AccountSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccountSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountSpecDeletionPolicy
 */
export enum AccountSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccountSpecForProvider
 */
export interface AccountSpecForProvider {
  /**
   * Whether to automatically enable new controls when they are added to standards that are enabled. By default, this is set to true, and new controls are enabled automatically. To not automatically enable new controls, set this to false.
   *
   * @schema AccountSpecForProvider#autoEnableControls
   */
  readonly autoEnableControls?: boolean;

  /**
   * Updates whether the calling account has consolidated control findings turned on. If the value for this field is set to SECURITY_CONTROL, Security Hub generates a single finding for a control check even when the check applies to multiple enabled standards. If the value for this field is set to STANDARD_CONTROL, Security Hub generates separate findings for a control check when the check applies to multiple enabled standards. For accounts that are part of an organization, this value can only be updated in the administrator account.
   *
   * @schema AccountSpecForProvider#controlFindingGenerator
   */
  readonly controlFindingGenerator?: string;

  /**
   * Whether to enable the security standards that Security Hub has designated as automatically enabled including:  AWS Foundational Security Best Practices v1.0.0 and CIS AWS Foundations Benchmark v1.2.0. Defaults to true.
   *
   * @default true.
   * @schema AccountSpecForProvider#enableDefaultStandards
   */
  readonly enableDefaultStandards?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccountSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AccountSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecForProvider(obj: AccountSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoEnableControls': obj.autoEnableControls,
    'controlFindingGenerator': obj.controlFindingGenerator,
    'enableDefaultStandards': obj.enableDefaultStandards,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AccountSpecInitProvider
 */
export interface AccountSpecInitProvider {
  /**
   * Whether to automatically enable new controls when they are added to standards that are enabled. By default, this is set to true, and new controls are enabled automatically. To not automatically enable new controls, set this to false.
   *
   * @schema AccountSpecInitProvider#autoEnableControls
   */
  readonly autoEnableControls?: boolean;

  /**
   * Updates whether the calling account has consolidated control findings turned on. If the value for this field is set to SECURITY_CONTROL, Security Hub generates a single finding for a control check even when the check applies to multiple enabled standards. If the value for this field is set to STANDARD_CONTROL, Security Hub generates separate findings for a control check when the check applies to multiple enabled standards. For accounts that are part of an organization, this value can only be updated in the administrator account.
   *
   * @schema AccountSpecInitProvider#controlFindingGenerator
   */
  readonly controlFindingGenerator?: string;

  /**
   * Whether to enable the security standards that Security Hub has designated as automatically enabled including:  AWS Foundational Security Best Practices v1.0.0 and CIS AWS Foundations Benchmark v1.2.0. Defaults to true.
   *
   * @default true.
   * @schema AccountSpecInitProvider#enableDefaultStandards
   */
  readonly enableDefaultStandards?: boolean;

}

/**
 * Converts an object of type 'AccountSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecInitProvider(obj: AccountSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoEnableControls': obj.autoEnableControls,
    'controlFindingGenerator': obj.controlFindingGenerator,
    'enableDefaultStandards': obj.enableDefaultStandards,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AccountSpecManagementPolicies
 */
export enum AccountSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccountSpecProviderConfigRef
 */
export interface AccountSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecProviderConfigRef#policy
   */
  readonly policy?: AccountSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderConfigRef(obj: AccountSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccountSpecPublishConnectionDetailsTo
 */
export interface AccountSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccountSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccountSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsTo(obj: AccountSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccountSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccountSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccountSpecWriteConnectionSecretToRef
 */
export interface AccountSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccountSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccountSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccountSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecWriteConnectionSecretToRef(obj: AccountSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSpecProviderConfigRefPolicy
 */
export interface AccountSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderConfigRefPolicy(obj: AccountSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRef
 */
export interface AccountSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccountSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToConfigRef(obj: AccountSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccountSpecPublishConnectionDetailsToMetadata
 */
export interface AccountSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToMetadata(obj: AccountSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecProviderConfigRefPolicyResolution
 */
export enum AccountSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecProviderConfigRefPolicyResolve
 */
export enum AccountSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccountSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccountSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ActionTarget is the Schema for the ActionTargets API. Creates Security Hub custom action.
 *
 * @schema ActionTarget
 */
export class ActionTarget extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ActionTarget"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'ActionTarget',
  }

  /**
   * Renders a Kubernetes manifest for "ActionTarget".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ActionTargetProps): any {
    return {
      ...ActionTarget.GVK,
      ...toJson_ActionTargetProps(props),
    };
  }

  /**
   * Defines a "ActionTarget" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ActionTargetProps) {
    super(scope, id, {
      ...ActionTarget.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ActionTarget.GVK,
      ...toJson_ActionTargetProps(resolved),
    };
  }
}

/**
 * ActionTarget is the Schema for the ActionTargets API. Creates Security Hub custom action.
 *
 * @schema ActionTarget
 */
export interface ActionTargetProps {
  /**
   * @schema ActionTarget#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ActionTargetSpec defines the desired state of ActionTarget
   *
   * @schema ActionTarget#spec
   */
  readonly spec: ActionTargetSpec;

}

/**
 * Converts an object of type 'ActionTargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetProps(obj: ActionTargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ActionTargetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionTargetSpec defines the desired state of ActionTarget
 *
 * @schema ActionTargetSpec
 */
export interface ActionTargetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ActionTargetSpec#deletionPolicy
   */
  readonly deletionPolicy?: ActionTargetSpecDeletionPolicy;

  /**
   * @schema ActionTargetSpec#forProvider
   */
  readonly forProvider: ActionTargetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ActionTargetSpec#initProvider
   */
  readonly initProvider?: ActionTargetSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ActionTargetSpec#managementPolicies
   */
  readonly managementPolicies?: ActionTargetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ActionTargetSpec#providerConfigRef
   */
  readonly providerConfigRef?: ActionTargetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ActionTargetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ActionTargetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ActionTargetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ActionTargetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ActionTargetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpec(obj: ActionTargetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ActionTargetSpecForProvider(obj.forProvider),
    'initProvider': toJson_ActionTargetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ActionTargetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ActionTargetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ActionTargetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ActionTargetSpecDeletionPolicy
 */
export enum ActionTargetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ActionTargetSpecForProvider
 */
export interface ActionTargetSpecForProvider {
  /**
   * The name of the custom action target.
   *
   * @schema ActionTargetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The description for the custom action target.
   *
   * @schema ActionTargetSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ActionTargetSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ActionTargetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecForProvider(obj: ActionTargetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ActionTargetSpecInitProvider
 */
export interface ActionTargetSpecInitProvider {
  /**
   * The name of the custom action target.
   *
   * @schema ActionTargetSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The description for the custom action target.
   *
   * @schema ActionTargetSpecInitProvider#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ActionTargetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecInitProvider(obj: ActionTargetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ActionTargetSpecManagementPolicies
 */
export enum ActionTargetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ActionTargetSpecProviderConfigRef
 */
export interface ActionTargetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActionTargetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActionTargetSpecProviderConfigRef#policy
   */
  readonly policy?: ActionTargetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ActionTargetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecProviderConfigRef(obj: ActionTargetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActionTargetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsTo
 */
export interface ActionTargetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ActionTargetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ActionTargetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ActionTargetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecPublishConnectionDetailsTo(obj: ActionTargetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ActionTargetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ActionTargetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ActionTargetSpecWriteConnectionSecretToRef
 */
export interface ActionTargetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ActionTargetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ActionTargetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ActionTargetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecWriteConnectionSecretToRef(obj: ActionTargetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ActionTargetSpecProviderConfigRefPolicy
 */
export interface ActionTargetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActionTargetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ActionTargetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActionTargetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ActionTargetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ActionTargetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecProviderConfigRefPolicy(obj: ActionTargetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsToConfigRef
 */
export interface ActionTargetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ActionTargetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecPublishConnectionDetailsToConfigRef(obj: ActionTargetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsToMetadata
 */
export interface ActionTargetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ActionTargetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecPublishConnectionDetailsToMetadata(obj: ActionTargetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActionTargetSpecProviderConfigRefPolicyResolution
 */
export enum ActionTargetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActionTargetSpecProviderConfigRefPolicyResolve
 */
export enum ActionTargetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj: ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FindingAggregator is the Schema for the FindingAggregators API. Manages a Security Hub finding aggregator
 *
 * @schema FindingAggregator
 */
export class FindingAggregator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FindingAggregator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'FindingAggregator',
  }

  /**
   * Renders a Kubernetes manifest for "FindingAggregator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FindingAggregatorProps): any {
    return {
      ...FindingAggregator.GVK,
      ...toJson_FindingAggregatorProps(props),
    };
  }

  /**
   * Defines a "FindingAggregator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FindingAggregatorProps) {
    super(scope, id, {
      ...FindingAggregator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FindingAggregator.GVK,
      ...toJson_FindingAggregatorProps(resolved),
    };
  }
}

/**
 * FindingAggregator is the Schema for the FindingAggregators API. Manages a Security Hub finding aggregator
 *
 * @schema FindingAggregator
 */
export interface FindingAggregatorProps {
  /**
   * @schema FindingAggregator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FindingAggregatorSpec defines the desired state of FindingAggregator
   *
   * @schema FindingAggregator#spec
   */
  readonly spec: FindingAggregatorSpec;

}

/**
 * Converts an object of type 'FindingAggregatorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorProps(obj: FindingAggregatorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FindingAggregatorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FindingAggregatorSpec defines the desired state of FindingAggregator
 *
 * @schema FindingAggregatorSpec
 */
export interface FindingAggregatorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FindingAggregatorSpec#deletionPolicy
   */
  readonly deletionPolicy?: FindingAggregatorSpecDeletionPolicy;

  /**
   * @schema FindingAggregatorSpec#forProvider
   */
  readonly forProvider: FindingAggregatorSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FindingAggregatorSpec#initProvider
   */
  readonly initProvider?: FindingAggregatorSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FindingAggregatorSpec#managementPolicies
   */
  readonly managementPolicies?: FindingAggregatorSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FindingAggregatorSpec#providerConfigRef
   */
  readonly providerConfigRef?: FindingAggregatorSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FindingAggregatorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FindingAggregatorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FindingAggregatorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FindingAggregatorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FindingAggregatorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpec(obj: FindingAggregatorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FindingAggregatorSpecForProvider(obj.forProvider),
    'initProvider': toJson_FindingAggregatorSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FindingAggregatorSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FindingAggregatorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FindingAggregatorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FindingAggregatorSpecDeletionPolicy
 */
export enum FindingAggregatorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FindingAggregatorSpecForProvider
 */
export interface FindingAggregatorSpecForProvider {
  /**
   * Indicates whether to aggregate findings from all of the available Regions or from a specified list. The options are ALL_REGIONS, ALL_REGIONS_EXCEPT_SPECIFIED or SPECIFIED_REGIONS. When ALL_REGIONS or ALL_REGIONS_EXCEPT_SPECIFIED are used, Security Hub will automatically aggregate findings from new Regions as Security Hub supports them and you opt into them.
   *
   * @schema FindingAggregatorSpecForProvider#linkingMode
   */
  readonly linkingMode?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FindingAggregatorSpecForProvider#region
   */
  readonly region: string;

  /**
   * List of regions to include or exclude
   *
   * @schema FindingAggregatorSpecForProvider#specifiedRegions
   */
  readonly specifiedRegions?: string[];

}

/**
 * Converts an object of type 'FindingAggregatorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecForProvider(obj: FindingAggregatorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linkingMode': obj.linkingMode,
    'region': obj.region,
    'specifiedRegions': obj.specifiedRegions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FindingAggregatorSpecInitProvider
 */
export interface FindingAggregatorSpecInitProvider {
  /**
   * Indicates whether to aggregate findings from all of the available Regions or from a specified list. The options are ALL_REGIONS, ALL_REGIONS_EXCEPT_SPECIFIED or SPECIFIED_REGIONS. When ALL_REGIONS or ALL_REGIONS_EXCEPT_SPECIFIED are used, Security Hub will automatically aggregate findings from new Regions as Security Hub supports them and you opt into them.
   *
   * @schema FindingAggregatorSpecInitProvider#linkingMode
   */
  readonly linkingMode?: string;

  /**
   * List of regions to include or exclude
   *
   * @schema FindingAggregatorSpecInitProvider#specifiedRegions
   */
  readonly specifiedRegions?: string[];

}

/**
 * Converts an object of type 'FindingAggregatorSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecInitProvider(obj: FindingAggregatorSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linkingMode': obj.linkingMode,
    'specifiedRegions': obj.specifiedRegions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FindingAggregatorSpecManagementPolicies
 */
export enum FindingAggregatorSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FindingAggregatorSpecProviderConfigRef
 */
export interface FindingAggregatorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FindingAggregatorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FindingAggregatorSpecProviderConfigRef#policy
   */
  readonly policy?: FindingAggregatorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FindingAggregatorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecProviderConfigRef(obj: FindingAggregatorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FindingAggregatorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsTo
 */
export interface FindingAggregatorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FindingAggregatorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FindingAggregatorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FindingAggregatorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecPublishConnectionDetailsTo(obj: FindingAggregatorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FindingAggregatorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FindingAggregatorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FindingAggregatorSpecWriteConnectionSecretToRef
 */
export interface FindingAggregatorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FindingAggregatorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FindingAggregatorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FindingAggregatorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecWriteConnectionSecretToRef(obj: FindingAggregatorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FindingAggregatorSpecProviderConfigRefPolicy
 */
export interface FindingAggregatorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FindingAggregatorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FindingAggregatorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FindingAggregatorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FindingAggregatorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FindingAggregatorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecProviderConfigRefPolicy(obj: FindingAggregatorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRef
 */
export interface FindingAggregatorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FindingAggregatorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecPublishConnectionDetailsToConfigRef(obj: FindingAggregatorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsToMetadata
 */
export interface FindingAggregatorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FindingAggregatorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecPublishConnectionDetailsToMetadata(obj: FindingAggregatorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FindingAggregatorSpecProviderConfigRefPolicyResolution
 */
export enum FindingAggregatorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FindingAggregatorSpecProviderConfigRefPolicyResolve
 */
export enum FindingAggregatorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy(obj: FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Insight is the Schema for the Insights API. Provides a Security Hub custom insight resource.
 *
 * @schema Insight
 */
export class Insight extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Insight"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'Insight',
  }

  /**
   * Renders a Kubernetes manifest for "Insight".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InsightProps): any {
    return {
      ...Insight.GVK,
      ...toJson_InsightProps(props),
    };
  }

  /**
   * Defines a "Insight" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InsightProps) {
    super(scope, id, {
      ...Insight.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Insight.GVK,
      ...toJson_InsightProps(resolved),
    };
  }
}

/**
 * Insight is the Schema for the Insights API. Provides a Security Hub custom insight resource.
 *
 * @schema Insight
 */
export interface InsightProps {
  /**
   * @schema Insight#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InsightSpec defines the desired state of Insight
   *
   * @schema Insight#spec
   */
  readonly spec: InsightSpec;

}

/**
 * Converts an object of type 'InsightProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightProps(obj: InsightProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InsightSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InsightSpec defines the desired state of Insight
 *
 * @schema InsightSpec
 */
export interface InsightSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InsightSpec#deletionPolicy
   */
  readonly deletionPolicy?: InsightSpecDeletionPolicy;

  /**
   * @schema InsightSpec#forProvider
   */
  readonly forProvider: InsightSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InsightSpec#initProvider
   */
  readonly initProvider?: InsightSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InsightSpec#managementPolicies
   */
  readonly managementPolicies?: InsightSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InsightSpec#providerConfigRef
   */
  readonly providerConfigRef?: InsightSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InsightSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InsightSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InsightSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InsightSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InsightSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpec(obj: InsightSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InsightSpecForProvider(obj.forProvider),
    'initProvider': toJson_InsightSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InsightSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InsightSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InsightSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InsightSpecDeletionPolicy
 */
export enum InsightSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InsightSpecForProvider
 */
export interface InsightSpecForProvider {
  /**
   * A configuration block including one or more (up to 10 distinct) attributes used to filter the findings included in the insight. The insight only includes findings that match criteria defined in the filters. See filters below for more details.
   *
   * @schema InsightSpecForProvider#filters
   */
  readonly filters?: InsightSpecForProviderFilters[];

  /**
   * The attribute used to group the findings for the insight e.g., if an insight is grouped by ResourceId, then the insight produces a list of resource identifiers.
   *
   * @schema InsightSpecForProvider#groupByAttribute
   */
  readonly groupByAttribute?: string;

  /**
   * The name of the custom insight.
   *
   * @schema InsightSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InsightSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'InsightSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProvider(obj: InsightSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filters': obj.filters?.map(y => toJson_InsightSpecForProviderFilters(y)),
    'groupByAttribute': obj.groupByAttribute,
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema InsightSpecInitProvider
 */
export interface InsightSpecInitProvider {
  /**
   * A configuration block including one or more (up to 10 distinct) attributes used to filter the findings included in the insight. The insight only includes findings that match criteria defined in the filters. See filters below for more details.
   *
   * @schema InsightSpecInitProvider#filters
   */
  readonly filters?: InsightSpecInitProviderFilters[];

  /**
   * The attribute used to group the findings for the insight e.g., if an insight is grouped by ResourceId, then the insight produces a list of resource identifiers.
   *
   * @schema InsightSpecInitProvider#groupByAttribute
   */
  readonly groupByAttribute?: string;

  /**
   * The name of the custom insight.
   *
   * @schema InsightSpecInitProvider#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProvider(obj: InsightSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filters': obj.filters?.map(y => toJson_InsightSpecInitProviderFilters(y)),
    'groupByAttribute': obj.groupByAttribute,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InsightSpecManagementPolicies
 */
export enum InsightSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InsightSpecProviderConfigRef
 */
export interface InsightSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InsightSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InsightSpecProviderConfigRef#policy
   */
  readonly policy?: InsightSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InsightSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecProviderConfigRef(obj: InsightSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InsightSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InsightSpecPublishConnectionDetailsTo
 */
export interface InsightSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InsightSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InsightSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InsightSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InsightSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InsightSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InsightSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecPublishConnectionDetailsTo(obj: InsightSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InsightSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InsightSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InsightSpecWriteConnectionSecretToRef
 */
export interface InsightSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InsightSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InsightSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InsightSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecWriteConnectionSecretToRef(obj: InsightSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFilters
 */
export interface InsightSpecForProviderFilters {
  /**
   * AWS account ID that a finding is generated in. See String_Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#awsAccountId
   */
  readonly awsAccountId?: InsightSpecForProviderFiltersAwsAccountId[];

  /**
   * The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#companyName
   */
  readonly companyName?: InsightSpecForProviderFiltersCompanyName[];

  /**
   * Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#complianceStatus
   */
  readonly complianceStatus?: InsightSpecForProviderFiltersComplianceStatus[];

  /**
   * A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#confidence
   */
  readonly confidence?: InsightSpecForProviderFiltersConfidence[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#createdAt
   */
  readonly createdAt?: InsightSpecForProviderFiltersCreatedAt[];

  /**
   * The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#criticality
   */
  readonly criticality?: InsightSpecForProviderFiltersCriticality[];

  /**
   * A finding's description. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#description
   */
  readonly description?: InsightSpecForProviderFiltersDescription[];

  /**
   * The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsConfidence
   */
  readonly findingProviderFieldsConfidence?: InsightSpecForProviderFiltersFindingProviderFieldsConfidence[];

  /**
   * The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsCriticality
   */
  readonly findingProviderFieldsCriticality?: InsightSpecForProviderFiltersFindingProviderFieldsCriticality[];

  /**
   * The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsRelatedFindingsId
   */
  readonly findingProviderFieldsRelatedFindingsId?: InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId[];

  /**
   * The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsRelatedFindingsProductArn
   */
  readonly findingProviderFieldsRelatedFindingsProductArn?: InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn[];

  /**
   * The finding provider value for the severity label. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsSeverityLabel
   */
  readonly findingProviderFieldsSeverityLabel?: InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel[];

  /**
   * The finding provider's original value for the severity. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsSeverityOriginal
   */
  readonly findingProviderFieldsSeverityOriginal?: InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal[];

  /**
   * One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values include: Software and Configuration Checks, TTPs, Effects, Unusual Behaviors, and Sensitive Data Identifications. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsTypes
   */
  readonly findingProviderFieldsTypes?: InsightSpecForProviderFiltersFindingProviderFieldsTypes[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#firstObservedAt
   */
  readonly firstObservedAt?: InsightSpecForProviderFiltersFirstObservedAt[];

  /**
   * The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#generatorId
   */
  readonly generatorId?: InsightSpecForProviderFiltersGeneratorId[];

  /**
   * The security findings provider-specific identifier for a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#id
   */
  readonly id?: InsightSpecForProviderFiltersId[];

  /**
   * A keyword for a finding. See Keyword Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#keyword
   */
  readonly keyword?: InsightSpecForProviderFiltersKeyword[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#lastObservedAt
   */
  readonly lastObservedAt?: InsightSpecForProviderFiltersLastObservedAt[];

  /**
   * The name of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#malwareName
   */
  readonly malwareName?: InsightSpecForProviderFiltersMalwareName[];

  /**
   * The filesystem path of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#malwarePath
   */
  readonly malwarePath?: InsightSpecForProviderFiltersMalwarePath[];

  /**
   * The state of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#malwareState
   */
  readonly malwareState?: InsightSpecForProviderFiltersMalwareState[];

  /**
   * The type of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#malwareType
   */
  readonly malwareType?: InsightSpecForProviderFiltersMalwareType[];

  /**
   * The destination domain of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkDestinationDomain
   */
  readonly networkDestinationDomain?: InsightSpecForProviderFiltersNetworkDestinationDomain[];

  /**
   * The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkDestinationIpv4
   */
  readonly networkDestinationIpv4?: InsightSpecForProviderFiltersNetworkDestinationIpv4[];

  /**
   * The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkDestinationIpv6
   */
  readonly networkDestinationIpv6?: InsightSpecForProviderFiltersNetworkDestinationIpv6[];

  /**
   * The destination port of network-related information about a finding. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkDestinationPort
   */
  readonly networkDestinationPort?: InsightSpecForProviderFiltersNetworkDestinationPort[];

  /**
   * Indicates the direction of network traffic associated with a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkDirection
   */
  readonly networkDirection?: InsightSpecForProviderFiltersNetworkDirection[];

  /**
   * The protocol of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkProtocol
   */
  readonly networkProtocol?: InsightSpecForProviderFiltersNetworkProtocol[];

  /**
   * The source domain of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkSourceDomain
   */
  readonly networkSourceDomain?: InsightSpecForProviderFiltersNetworkSourceDomain[];

  /**
   * The source IPv4 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkSourceIpv4
   */
  readonly networkSourceIpv4?: InsightSpecForProviderFiltersNetworkSourceIpv4[];

  /**
   * The source IPv6 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkSourceIpv6
   */
  readonly networkSourceIpv6?: InsightSpecForProviderFiltersNetworkSourceIpv6[];

  /**
   * The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkSourceMac
   */
  readonly networkSourceMac?: InsightSpecForProviderFiltersNetworkSourceMac[];

  /**
   * The source port of network-related information about a finding. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkSourcePort
   */
  readonly networkSourcePort?: InsightSpecForProviderFiltersNetworkSourcePort[];

  /**
   * The text of a note. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#noteText
   */
  readonly noteText?: InsightSpecForProviderFiltersNoteText[];

  /**
   * The timestamp of when the note was updated. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#noteUpdatedAt
   */
  readonly noteUpdatedAt?: InsightSpecForProviderFiltersNoteUpdatedAt[];

  /**
   * The principal that created a note. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#noteUpdatedBy
   */
  readonly noteUpdatedBy?: InsightSpecForProviderFiltersNoteUpdatedBy[];

  /**
   * The date/time that the process was launched. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processLaunchedAt
   */
  readonly processLaunchedAt?: InsightSpecForProviderFiltersProcessLaunchedAt[];

  /**
   * The name of the process. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processName
   */
  readonly processName?: InsightSpecForProviderFiltersProcessName[];

  /**
   * The parent process ID. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processParentPid
   */
  readonly processParentPid?: InsightSpecForProviderFiltersProcessParentPid[];

  /**
   * The path to the process executable. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processPath
   */
  readonly processPath?: InsightSpecForProviderFiltersProcessPath[];

  /**
   * The process ID. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processPid
   */
  readonly processPid?: InsightSpecForProviderFiltersProcessPid[];

  /**
   * The date/time that the process was terminated. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processTerminatedAt
   */
  readonly processTerminatedAt?: InsightSpecForProviderFiltersProcessTerminatedAt[];

  /**
   * The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#productArn
   */
  readonly productArn?: InsightSpecForProviderFiltersProductArn[];

  /**
   * A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. See Map Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#productFields
   */
  readonly productFields?: InsightSpecForProviderFiltersProductFields[];

  /**
   * The name of the solution (product) that generates findings. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#productName
   */
  readonly productName?: InsightSpecForProviderFiltersProductName[];

  /**
   * The recommendation of what to do about the issue described in a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#recommendationText
   */
  readonly recommendationText?: InsightSpecForProviderFiltersRecommendationText[];

  /**
   * The updated record state for the finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#recordState
   */
  readonly recordState?: InsightSpecForProviderFiltersRecordState[];

  /**
   * The solution-generated identifier for a related finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#relatedFindingsId
   */
  readonly relatedFindingsId?: InsightSpecForProviderFiltersRelatedFindingsId[];

  /**
   * The ARN of the solution that generated a related finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#relatedFindingsProductArn
   */
  readonly relatedFindingsProductArn?: InsightSpecForProviderFiltersRelatedFindingsProductArn[];

  /**
   * The IAM profile ARN of the instance. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceIamInstanceProfileArn
   */
  readonly resourceAwsEc2InstanceIamInstanceProfileArn?: InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn[];

  /**
   * The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceImageId
   */
  readonly resourceAwsEc2InstanceImageId?: InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId[];

  /**
   * The IPv4 addresses associated with the instance. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceIpv4Addresses
   */
  readonly resourceAwsEc2InstanceIpv4Addresses?: InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses[];

  /**
   * The IPv6 addresses associated with the instance. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceIpv6Addresses
   */
  readonly resourceAwsEc2InstanceIpv6Addresses?: InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses[];

  /**
   * The key name associated with the instance. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceKeyName
   */
  readonly resourceAwsEc2InstanceKeyName?: InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName[];

  /**
   * The date and time the instance was launched. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceLaunchedAt
   */
  readonly resourceAwsEc2InstanceLaunchedAt?: InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt[];

  /**
   * The identifier of the subnet that the instance was launched in. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceSubnetId
   */
  readonly resourceAwsEc2InstanceSubnetId?: InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId[];

  /**
   * The instance type of the instance. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceType
   */
  readonly resourceAwsEc2InstanceType?: InsightSpecForProviderFiltersResourceAwsEc2InstanceType[];

  /**
   * The identifier of the VPC that the instance was launched in. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceVpcId
   */
  readonly resourceAwsEc2InstanceVpcId?: InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId[];

  /**
   * The creation date/time of the IAM access key related to a finding. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsIamAccessKeyCreatedAt
   */
  readonly resourceAwsIamAccessKeyCreatedAt?: InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt[];

  /**
   * The status of the IAM access key related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsIamAccessKeyStatus
   */
  readonly resourceAwsIamAccessKeyStatus?: InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus[];

  /**
   * The user associated with the IAM access key related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsIamAccessKeyUserName
   */
  readonly resourceAwsIamAccessKeyUserName?: InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName[];

  /**
   * The canonical user ID of the owner of the S3 bucket. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsS3BucketOwnerId
   */
  readonly resourceAwsS3BucketOwnerId?: InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId[];

  /**
   * The display name of the owner of the S3 bucket. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsS3BucketOwnerName
   */
  readonly resourceAwsS3BucketOwnerName?: InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName[];

  /**
   * The identifier of the image related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceContainerImageId
   */
  readonly resourceContainerImageId?: InsightSpecForProviderFiltersResourceContainerImageId[];

  /**
   * The name of the image related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceContainerImageName
   */
  readonly resourceContainerImageName?: InsightSpecForProviderFiltersResourceContainerImageName[];

  /**
   * The date/time that the container was started. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceContainerLaunchedAt
   */
  readonly resourceContainerLaunchedAt?: InsightSpecForProviderFiltersResourceContainerLaunchedAt[];

  /**
   * The name of the container related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceContainerName
   */
  readonly resourceContainerName?: InsightSpecForProviderFiltersResourceContainerName[];

  /**
   * The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceDetailsOther
   */
  readonly resourceDetailsOther?: InsightSpecForProviderFiltersResourceDetailsOther[];

  /**
   * The canonical identifier for the given resource type. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceId
   */
  readonly resourceId?: InsightSpecForProviderFiltersResourceId[];

  /**
   * The canonical AWS partition name that the Region is assigned to. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourcePartition
   */
  readonly resourcePartition?: InsightSpecForProviderFiltersResourcePartition[];

  /**
   * The canonical AWS external Region name where this resource is located. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceRegion
   */
  readonly resourceRegion?: InsightSpecForProviderFiltersResourceRegion[];

  /**
   * A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceTags
   */
  readonly resourceTags?: InsightSpecForProviderFiltersResourceTags[];

  /**
   * Specifies the type of the resource that details are provided for. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceType
   */
  readonly resourceType?: InsightSpecForProviderFiltersResourceType[];

  /**
   * The label of a finding's severity. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#severityLabel
   */
  readonly severityLabel?: InsightSpecForProviderFiltersSeverityLabel[];

  /**
   * A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#sourceUrl
   */
  readonly sourceUrl?: InsightSpecForProviderFiltersSourceUrl[];

  /**
   * The category of a threat intelligence indicator. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorCategory
   */
  readonly threatIntelIndicatorCategory?: InsightSpecForProviderFiltersThreatIntelIndicatorCategory[];

  /**
   * The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorLastObservedAt
   */
  readonly threatIntelIndicatorLastObservedAt?: InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt[];

  /**
   * The source of the threat intelligence. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorSource
   */
  readonly threatIntelIndicatorSource?: InsightSpecForProviderFiltersThreatIntelIndicatorSource[];

  /**
   * The URL for more details from the source of the threat intelligence. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorSourceUrl
   */
  readonly threatIntelIndicatorSourceUrl?: InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl[];

  /**
   * The type of a threat intelligence indicator. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorType
   */
  readonly threatIntelIndicatorType?: InsightSpecForProviderFiltersThreatIntelIndicatorType[];

  /**
   * The value of a threat intelligence indicator. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorValue
   */
  readonly threatIntelIndicatorValue?: InsightSpecForProviderFiltersThreatIntelIndicatorValue[];

  /**
   * A finding's title. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#title
   */
  readonly title?: InsightSpecForProviderFiltersTitle[];

  /**
   * A finding type in the format of namespace/category/classifier that classifies a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#type
   */
  readonly type?: InsightSpecForProviderFiltersType[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#updatedAt
   */
  readonly updatedAt?: InsightSpecForProviderFiltersUpdatedAt[];

  /**
   * A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#userDefinedValues
   */
  readonly userDefinedValues?: InsightSpecForProviderFiltersUserDefinedValues[];

  /**
   * The veracity of a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#verificationState
   */
  readonly verificationState?: InsightSpecForProviderFiltersVerificationState[];

  /**
   * The status of the investigation into a finding. See Workflow Status Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#workflowStatus
   */
  readonly workflowStatus?: InsightSpecForProviderFiltersWorkflowStatus[];

}

/**
 * Converts an object of type 'InsightSpecForProviderFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFilters(obj: InsightSpecForProviderFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId?.map(y => toJson_InsightSpecForProviderFiltersAwsAccountId(y)),
    'companyName': obj.companyName?.map(y => toJson_InsightSpecForProviderFiltersCompanyName(y)),
    'complianceStatus': obj.complianceStatus?.map(y => toJson_InsightSpecForProviderFiltersComplianceStatus(y)),
    'confidence': obj.confidence?.map(y => toJson_InsightSpecForProviderFiltersConfidence(y)),
    'createdAt': obj.createdAt?.map(y => toJson_InsightSpecForProviderFiltersCreatedAt(y)),
    'criticality': obj.criticality?.map(y => toJson_InsightSpecForProviderFiltersCriticality(y)),
    'description': obj.description?.map(y => toJson_InsightSpecForProviderFiltersDescription(y)),
    'findingProviderFieldsConfidence': obj.findingProviderFieldsConfidence?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsConfidence(y)),
    'findingProviderFieldsCriticality': obj.findingProviderFieldsCriticality?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsCriticality(y)),
    'findingProviderFieldsRelatedFindingsId': obj.findingProviderFieldsRelatedFindingsId?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId(y)),
    'findingProviderFieldsRelatedFindingsProductArn': obj.findingProviderFieldsRelatedFindingsProductArn?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn(y)),
    'findingProviderFieldsSeverityLabel': obj.findingProviderFieldsSeverityLabel?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel(y)),
    'findingProviderFieldsSeverityOriginal': obj.findingProviderFieldsSeverityOriginal?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal(y)),
    'findingProviderFieldsTypes': obj.findingProviderFieldsTypes?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsTypes(y)),
    'firstObservedAt': obj.firstObservedAt?.map(y => toJson_InsightSpecForProviderFiltersFirstObservedAt(y)),
    'generatorId': obj.generatorId?.map(y => toJson_InsightSpecForProviderFiltersGeneratorId(y)),
    'id': obj.id?.map(y => toJson_InsightSpecForProviderFiltersId(y)),
    'keyword': obj.keyword?.map(y => toJson_InsightSpecForProviderFiltersKeyword(y)),
    'lastObservedAt': obj.lastObservedAt?.map(y => toJson_InsightSpecForProviderFiltersLastObservedAt(y)),
    'malwareName': obj.malwareName?.map(y => toJson_InsightSpecForProviderFiltersMalwareName(y)),
    'malwarePath': obj.malwarePath?.map(y => toJson_InsightSpecForProviderFiltersMalwarePath(y)),
    'malwareState': obj.malwareState?.map(y => toJson_InsightSpecForProviderFiltersMalwareState(y)),
    'malwareType': obj.malwareType?.map(y => toJson_InsightSpecForProviderFiltersMalwareType(y)),
    'networkDestinationDomain': obj.networkDestinationDomain?.map(y => toJson_InsightSpecForProviderFiltersNetworkDestinationDomain(y)),
    'networkDestinationIpv4': obj.networkDestinationIpv4?.map(y => toJson_InsightSpecForProviderFiltersNetworkDestinationIpv4(y)),
    'networkDestinationIpv6': obj.networkDestinationIpv6?.map(y => toJson_InsightSpecForProviderFiltersNetworkDestinationIpv6(y)),
    'networkDestinationPort': obj.networkDestinationPort?.map(y => toJson_InsightSpecForProviderFiltersNetworkDestinationPort(y)),
    'networkDirection': obj.networkDirection?.map(y => toJson_InsightSpecForProviderFiltersNetworkDirection(y)),
    'networkProtocol': obj.networkProtocol?.map(y => toJson_InsightSpecForProviderFiltersNetworkProtocol(y)),
    'networkSourceDomain': obj.networkSourceDomain?.map(y => toJson_InsightSpecForProviderFiltersNetworkSourceDomain(y)),
    'networkSourceIpv4': obj.networkSourceIpv4?.map(y => toJson_InsightSpecForProviderFiltersNetworkSourceIpv4(y)),
    'networkSourceIpv6': obj.networkSourceIpv6?.map(y => toJson_InsightSpecForProviderFiltersNetworkSourceIpv6(y)),
    'networkSourceMac': obj.networkSourceMac?.map(y => toJson_InsightSpecForProviderFiltersNetworkSourceMac(y)),
    'networkSourcePort': obj.networkSourcePort?.map(y => toJson_InsightSpecForProviderFiltersNetworkSourcePort(y)),
    'noteText': obj.noteText?.map(y => toJson_InsightSpecForProviderFiltersNoteText(y)),
    'noteUpdatedAt': obj.noteUpdatedAt?.map(y => toJson_InsightSpecForProviderFiltersNoteUpdatedAt(y)),
    'noteUpdatedBy': obj.noteUpdatedBy?.map(y => toJson_InsightSpecForProviderFiltersNoteUpdatedBy(y)),
    'processLaunchedAt': obj.processLaunchedAt?.map(y => toJson_InsightSpecForProviderFiltersProcessLaunchedAt(y)),
    'processName': obj.processName?.map(y => toJson_InsightSpecForProviderFiltersProcessName(y)),
    'processParentPid': obj.processParentPid?.map(y => toJson_InsightSpecForProviderFiltersProcessParentPid(y)),
    'processPath': obj.processPath?.map(y => toJson_InsightSpecForProviderFiltersProcessPath(y)),
    'processPid': obj.processPid?.map(y => toJson_InsightSpecForProviderFiltersProcessPid(y)),
    'processTerminatedAt': obj.processTerminatedAt?.map(y => toJson_InsightSpecForProviderFiltersProcessTerminatedAt(y)),
    'productArn': obj.productArn?.map(y => toJson_InsightSpecForProviderFiltersProductArn(y)),
    'productFields': obj.productFields?.map(y => toJson_InsightSpecForProviderFiltersProductFields(y)),
    'productName': obj.productName?.map(y => toJson_InsightSpecForProviderFiltersProductName(y)),
    'recommendationText': obj.recommendationText?.map(y => toJson_InsightSpecForProviderFiltersRecommendationText(y)),
    'recordState': obj.recordState?.map(y => toJson_InsightSpecForProviderFiltersRecordState(y)),
    'relatedFindingsId': obj.relatedFindingsId?.map(y => toJson_InsightSpecForProviderFiltersRelatedFindingsId(y)),
    'relatedFindingsProductArn': obj.relatedFindingsProductArn?.map(y => toJson_InsightSpecForProviderFiltersRelatedFindingsProductArn(y)),
    'resourceAwsEc2InstanceIamInstanceProfileArn': obj.resourceAwsEc2InstanceIamInstanceProfileArn?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn(y)),
    'resourceAwsEc2InstanceImageId': obj.resourceAwsEc2InstanceImageId?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId(y)),
    'resourceAwsEc2InstanceIpv4Addresses': obj.resourceAwsEc2InstanceIpv4Addresses?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses(y)),
    'resourceAwsEc2InstanceIpv6Addresses': obj.resourceAwsEc2InstanceIpv6Addresses?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses(y)),
    'resourceAwsEc2InstanceKeyName': obj.resourceAwsEc2InstanceKeyName?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName(y)),
    'resourceAwsEc2InstanceLaunchedAt': obj.resourceAwsEc2InstanceLaunchedAt?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt(y)),
    'resourceAwsEc2InstanceSubnetId': obj.resourceAwsEc2InstanceSubnetId?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId(y)),
    'resourceAwsEc2InstanceType': obj.resourceAwsEc2InstanceType?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceType(y)),
    'resourceAwsEc2InstanceVpcId': obj.resourceAwsEc2InstanceVpcId?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId(y)),
    'resourceAwsIamAccessKeyCreatedAt': obj.resourceAwsIamAccessKeyCreatedAt?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt(y)),
    'resourceAwsIamAccessKeyStatus': obj.resourceAwsIamAccessKeyStatus?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus(y)),
    'resourceAwsIamAccessKeyUserName': obj.resourceAwsIamAccessKeyUserName?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName(y)),
    'resourceAwsS3BucketOwnerId': obj.resourceAwsS3BucketOwnerId?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId(y)),
    'resourceAwsS3BucketOwnerName': obj.resourceAwsS3BucketOwnerName?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName(y)),
    'resourceContainerImageId': obj.resourceContainerImageId?.map(y => toJson_InsightSpecForProviderFiltersResourceContainerImageId(y)),
    'resourceContainerImageName': obj.resourceContainerImageName?.map(y => toJson_InsightSpecForProviderFiltersResourceContainerImageName(y)),
    'resourceContainerLaunchedAt': obj.resourceContainerLaunchedAt?.map(y => toJson_InsightSpecForProviderFiltersResourceContainerLaunchedAt(y)),
    'resourceContainerName': obj.resourceContainerName?.map(y => toJson_InsightSpecForProviderFiltersResourceContainerName(y)),
    'resourceDetailsOther': obj.resourceDetailsOther?.map(y => toJson_InsightSpecForProviderFiltersResourceDetailsOther(y)),
    'resourceId': obj.resourceId?.map(y => toJson_InsightSpecForProviderFiltersResourceId(y)),
    'resourcePartition': obj.resourcePartition?.map(y => toJson_InsightSpecForProviderFiltersResourcePartition(y)),
    'resourceRegion': obj.resourceRegion?.map(y => toJson_InsightSpecForProviderFiltersResourceRegion(y)),
    'resourceTags': obj.resourceTags?.map(y => toJson_InsightSpecForProviderFiltersResourceTags(y)),
    'resourceType': obj.resourceType?.map(y => toJson_InsightSpecForProviderFiltersResourceType(y)),
    'severityLabel': obj.severityLabel?.map(y => toJson_InsightSpecForProviderFiltersSeverityLabel(y)),
    'sourceUrl': obj.sourceUrl?.map(y => toJson_InsightSpecForProviderFiltersSourceUrl(y)),
    'threatIntelIndicatorCategory': obj.threatIntelIndicatorCategory?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorCategory(y)),
    'threatIntelIndicatorLastObservedAt': obj.threatIntelIndicatorLastObservedAt?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt(y)),
    'threatIntelIndicatorSource': obj.threatIntelIndicatorSource?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorSource(y)),
    'threatIntelIndicatorSourceUrl': obj.threatIntelIndicatorSourceUrl?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl(y)),
    'threatIntelIndicatorType': obj.threatIntelIndicatorType?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorType(y)),
    'threatIntelIndicatorValue': obj.threatIntelIndicatorValue?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorValue(y)),
    'title': obj.title?.map(y => toJson_InsightSpecForProviderFiltersTitle(y)),
    'type': obj.type?.map(y => toJson_InsightSpecForProviderFiltersType(y)),
    'updatedAt': obj.updatedAt?.map(y => toJson_InsightSpecForProviderFiltersUpdatedAt(y)),
    'userDefinedValues': obj.userDefinedValues?.map(y => toJson_InsightSpecForProviderFiltersUserDefinedValues(y)),
    'verificationState': obj.verificationState?.map(y => toJson_InsightSpecForProviderFiltersVerificationState(y)),
    'workflowStatus': obj.workflowStatus?.map(y => toJson_InsightSpecForProviderFiltersWorkflowStatus(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFilters
 */
export interface InsightSpecInitProviderFilters {
  /**
   * AWS account ID that a finding is generated in. See String_Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#awsAccountId
   */
  readonly awsAccountId?: InsightSpecInitProviderFiltersAwsAccountId[];

  /**
   * The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#companyName
   */
  readonly companyName?: InsightSpecInitProviderFiltersCompanyName[];

  /**
   * Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#complianceStatus
   */
  readonly complianceStatus?: InsightSpecInitProviderFiltersComplianceStatus[];

  /**
   * A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#confidence
   */
  readonly confidence?: InsightSpecInitProviderFiltersConfidence[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#createdAt
   */
  readonly createdAt?: InsightSpecInitProviderFiltersCreatedAt[];

  /**
   * The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#criticality
   */
  readonly criticality?: InsightSpecInitProviderFiltersCriticality[];

  /**
   * A finding's description. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#description
   */
  readonly description?: InsightSpecInitProviderFiltersDescription[];

  /**
   * The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#findingProviderFieldsConfidence
   */
  readonly findingProviderFieldsConfidence?: InsightSpecInitProviderFiltersFindingProviderFieldsConfidence[];

  /**
   * The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#findingProviderFieldsCriticality
   */
  readonly findingProviderFieldsCriticality?: InsightSpecInitProviderFiltersFindingProviderFieldsCriticality[];

  /**
   * The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#findingProviderFieldsRelatedFindingsId
   */
  readonly findingProviderFieldsRelatedFindingsId?: InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsId[];

  /**
   * The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#findingProviderFieldsRelatedFindingsProductArn
   */
  readonly findingProviderFieldsRelatedFindingsProductArn?: InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsProductArn[];

  /**
   * The finding provider value for the severity label. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#findingProviderFieldsSeverityLabel
   */
  readonly findingProviderFieldsSeverityLabel?: InsightSpecInitProviderFiltersFindingProviderFieldsSeverityLabel[];

  /**
   * The finding provider's original value for the severity. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#findingProviderFieldsSeverityOriginal
   */
  readonly findingProviderFieldsSeverityOriginal?: InsightSpecInitProviderFiltersFindingProviderFieldsSeverityOriginal[];

  /**
   * One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values include: Software and Configuration Checks, TTPs, Effects, Unusual Behaviors, and Sensitive Data Identifications. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#findingProviderFieldsTypes
   */
  readonly findingProviderFieldsTypes?: InsightSpecInitProviderFiltersFindingProviderFieldsTypes[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#firstObservedAt
   */
  readonly firstObservedAt?: InsightSpecInitProviderFiltersFirstObservedAt[];

  /**
   * The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#generatorId
   */
  readonly generatorId?: InsightSpecInitProviderFiltersGeneratorId[];

  /**
   * The security findings provider-specific identifier for a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#id
   */
  readonly id?: InsightSpecInitProviderFiltersId[];

  /**
   * A keyword for a finding. See Keyword Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#keyword
   */
  readonly keyword?: InsightSpecInitProviderFiltersKeyword[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#lastObservedAt
   */
  readonly lastObservedAt?: InsightSpecInitProviderFiltersLastObservedAt[];

  /**
   * The name of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#malwareName
   */
  readonly malwareName?: InsightSpecInitProviderFiltersMalwareName[];

  /**
   * The filesystem path of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#malwarePath
   */
  readonly malwarePath?: InsightSpecInitProviderFiltersMalwarePath[];

  /**
   * The state of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#malwareState
   */
  readonly malwareState?: InsightSpecInitProviderFiltersMalwareState[];

  /**
   * The type of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#malwareType
   */
  readonly malwareType?: InsightSpecInitProviderFiltersMalwareType[];

  /**
   * The destination domain of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkDestinationDomain
   */
  readonly networkDestinationDomain?: InsightSpecInitProviderFiltersNetworkDestinationDomain[];

  /**
   * The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkDestinationIpv4
   */
  readonly networkDestinationIpv4?: InsightSpecInitProviderFiltersNetworkDestinationIpv4[];

  /**
   * The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkDestinationIpv6
   */
  readonly networkDestinationIpv6?: InsightSpecInitProviderFiltersNetworkDestinationIpv6[];

  /**
   * The destination port of network-related information about a finding. See Number Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkDestinationPort
   */
  readonly networkDestinationPort?: InsightSpecInitProviderFiltersNetworkDestinationPort[];

  /**
   * Indicates the direction of network traffic associated with a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkDirection
   */
  readonly networkDirection?: InsightSpecInitProviderFiltersNetworkDirection[];

  /**
   * The protocol of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkProtocol
   */
  readonly networkProtocol?: InsightSpecInitProviderFiltersNetworkProtocol[];

  /**
   * The source domain of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkSourceDomain
   */
  readonly networkSourceDomain?: InsightSpecInitProviderFiltersNetworkSourceDomain[];

  /**
   * The source IPv4 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkSourceIpv4
   */
  readonly networkSourceIpv4?: InsightSpecInitProviderFiltersNetworkSourceIpv4[];

  /**
   * The source IPv6 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkSourceIpv6
   */
  readonly networkSourceIpv6?: InsightSpecInitProviderFiltersNetworkSourceIpv6[];

  /**
   * The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkSourceMac
   */
  readonly networkSourceMac?: InsightSpecInitProviderFiltersNetworkSourceMac[];

  /**
   * The source port of network-related information about a finding. See Number Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#networkSourcePort
   */
  readonly networkSourcePort?: InsightSpecInitProviderFiltersNetworkSourcePort[];

  /**
   * The text of a note. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#noteText
   */
  readonly noteText?: InsightSpecInitProviderFiltersNoteText[];

  /**
   * The timestamp of when the note was updated. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#noteUpdatedAt
   */
  readonly noteUpdatedAt?: InsightSpecInitProviderFiltersNoteUpdatedAt[];

  /**
   * The principal that created a note. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#noteUpdatedBy
   */
  readonly noteUpdatedBy?: InsightSpecInitProviderFiltersNoteUpdatedBy[];

  /**
   * The date/time that the process was launched. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#processLaunchedAt
   */
  readonly processLaunchedAt?: InsightSpecInitProviderFiltersProcessLaunchedAt[];

  /**
   * The name of the process. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#processName
   */
  readonly processName?: InsightSpecInitProviderFiltersProcessName[];

  /**
   * The parent process ID. See Number Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#processParentPid
   */
  readonly processParentPid?: InsightSpecInitProviderFiltersProcessParentPid[];

  /**
   * The path to the process executable. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#processPath
   */
  readonly processPath?: InsightSpecInitProviderFiltersProcessPath[];

  /**
   * The process ID. See Number Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#processPid
   */
  readonly processPid?: InsightSpecInitProviderFiltersProcessPid[];

  /**
   * The date/time that the process was terminated. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#processTerminatedAt
   */
  readonly processTerminatedAt?: InsightSpecInitProviderFiltersProcessTerminatedAt[];

  /**
   * The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#productArn
   */
  readonly productArn?: InsightSpecInitProviderFiltersProductArn[];

  /**
   * A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. See Map Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#productFields
   */
  readonly productFields?: InsightSpecInitProviderFiltersProductFields[];

  /**
   * The name of the solution (product) that generates findings. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#productName
   */
  readonly productName?: InsightSpecInitProviderFiltersProductName[];

  /**
   * The recommendation of what to do about the issue described in a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#recommendationText
   */
  readonly recommendationText?: InsightSpecInitProviderFiltersRecommendationText[];

  /**
   * The updated record state for the finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#recordState
   */
  readonly recordState?: InsightSpecInitProviderFiltersRecordState[];

  /**
   * The solution-generated identifier for a related finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#relatedFindingsId
   */
  readonly relatedFindingsId?: InsightSpecInitProviderFiltersRelatedFindingsId[];

  /**
   * The ARN of the solution that generated a related finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#relatedFindingsProductArn
   */
  readonly relatedFindingsProductArn?: InsightSpecInitProviderFiltersRelatedFindingsProductArn[];

  /**
   * The IAM profile ARN of the instance. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsEc2InstanceIamInstanceProfileArn
   */
  readonly resourceAwsEc2InstanceIamInstanceProfileArn?: InsightSpecInitProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn[];

  /**
   * The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsEc2InstanceImageId
   */
  readonly resourceAwsEc2InstanceImageId?: InsightSpecInitProviderFiltersResourceAwsEc2InstanceImageId[];

  /**
   * The IPv4 addresses associated with the instance. See Ip Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsEc2InstanceIpv4Addresses
   */
  readonly resourceAwsEc2InstanceIpv4Addresses?: InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv4Addresses[];

  /**
   * The IPv6 addresses associated with the instance. See Ip Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsEc2InstanceIpv6Addresses
   */
  readonly resourceAwsEc2InstanceIpv6Addresses?: InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv6Addresses[];

  /**
   * The key name associated with the instance. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsEc2InstanceKeyName
   */
  readonly resourceAwsEc2InstanceKeyName?: InsightSpecInitProviderFiltersResourceAwsEc2InstanceKeyName[];

  /**
   * The date and time the instance was launched. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsEc2InstanceLaunchedAt
   */
  readonly resourceAwsEc2InstanceLaunchedAt?: InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAt[];

  /**
   * The identifier of the subnet that the instance was launched in. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsEc2InstanceSubnetId
   */
  readonly resourceAwsEc2InstanceSubnetId?: InsightSpecInitProviderFiltersResourceAwsEc2InstanceSubnetId[];

  /**
   * The instance type of the instance. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsEc2InstanceType
   */
  readonly resourceAwsEc2InstanceType?: InsightSpecInitProviderFiltersResourceAwsEc2InstanceType[];

  /**
   * The identifier of the VPC that the instance was launched in. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsEc2InstanceVpcId
   */
  readonly resourceAwsEc2InstanceVpcId?: InsightSpecInitProviderFiltersResourceAwsEc2InstanceVpcId[];

  /**
   * The creation date/time of the IAM access key related to a finding. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsIamAccessKeyCreatedAt
   */
  readonly resourceAwsIamAccessKeyCreatedAt?: InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAt[];

  /**
   * The status of the IAM access key related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsIamAccessKeyStatus
   */
  readonly resourceAwsIamAccessKeyStatus?: InsightSpecInitProviderFiltersResourceAwsIamAccessKeyStatus[];

  /**
   * The user associated with the IAM access key related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsIamAccessKeyUserName
   */
  readonly resourceAwsIamAccessKeyUserName?: InsightSpecInitProviderFiltersResourceAwsIamAccessKeyUserName[];

  /**
   * The canonical user ID of the owner of the S3 bucket. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsS3BucketOwnerId
   */
  readonly resourceAwsS3BucketOwnerId?: InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerId[];

  /**
   * The display name of the owner of the S3 bucket. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceAwsS3BucketOwnerName
   */
  readonly resourceAwsS3BucketOwnerName?: InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerName[];

  /**
   * The identifier of the image related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceContainerImageId
   */
  readonly resourceContainerImageId?: InsightSpecInitProviderFiltersResourceContainerImageId[];

  /**
   * The name of the image related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceContainerImageName
   */
  readonly resourceContainerImageName?: InsightSpecInitProviderFiltersResourceContainerImageName[];

  /**
   * The date/time that the container was started. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceContainerLaunchedAt
   */
  readonly resourceContainerLaunchedAt?: InsightSpecInitProviderFiltersResourceContainerLaunchedAt[];

  /**
   * The name of the container related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceContainerName
   */
  readonly resourceContainerName?: InsightSpecInitProviderFiltersResourceContainerName[];

  /**
   * The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceDetailsOther
   */
  readonly resourceDetailsOther?: InsightSpecInitProviderFiltersResourceDetailsOther[];

  /**
   * The canonical identifier for the given resource type. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceId
   */
  readonly resourceId?: InsightSpecInitProviderFiltersResourceId[];

  /**
   * The canonical AWS partition name that the Region is assigned to. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourcePartition
   */
  readonly resourcePartition?: InsightSpecInitProviderFiltersResourcePartition[];

  /**
   * The canonical AWS external Region name where this resource is located. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceRegion
   */
  readonly resourceRegion?: InsightSpecInitProviderFiltersResourceRegion[];

  /**
   * A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceTags
   */
  readonly resourceTags?: InsightSpecInitProviderFiltersResourceTags[];

  /**
   * Specifies the type of the resource that details are provided for. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#resourceType
   */
  readonly resourceType?: InsightSpecInitProviderFiltersResourceType[];

  /**
   * The label of a finding's severity. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#severityLabel
   */
  readonly severityLabel?: InsightSpecInitProviderFiltersSeverityLabel[];

  /**
   * A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#sourceUrl
   */
  readonly sourceUrl?: InsightSpecInitProviderFiltersSourceUrl[];

  /**
   * The category of a threat intelligence indicator. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#threatIntelIndicatorCategory
   */
  readonly threatIntelIndicatorCategory?: InsightSpecInitProviderFiltersThreatIntelIndicatorCategory[];

  /**
   * The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#threatIntelIndicatorLastObservedAt
   */
  readonly threatIntelIndicatorLastObservedAt?: InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAt[];

  /**
   * The source of the threat intelligence. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#threatIntelIndicatorSource
   */
  readonly threatIntelIndicatorSource?: InsightSpecInitProviderFiltersThreatIntelIndicatorSource[];

  /**
   * The URL for more details from the source of the threat intelligence. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#threatIntelIndicatorSourceUrl
   */
  readonly threatIntelIndicatorSourceUrl?: InsightSpecInitProviderFiltersThreatIntelIndicatorSourceUrl[];

  /**
   * The type of a threat intelligence indicator. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#threatIntelIndicatorType
   */
  readonly threatIntelIndicatorType?: InsightSpecInitProviderFiltersThreatIntelIndicatorType[];

  /**
   * The value of a threat intelligence indicator. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#threatIntelIndicatorValue
   */
  readonly threatIntelIndicatorValue?: InsightSpecInitProviderFiltersThreatIntelIndicatorValue[];

  /**
   * A finding's title. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#title
   */
  readonly title?: InsightSpecInitProviderFiltersTitle[];

  /**
   * A finding type in the format of namespace/category/classifier that classifies a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#type
   */
  readonly type?: InsightSpecInitProviderFiltersType[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#updatedAt
   */
  readonly updatedAt?: InsightSpecInitProviderFiltersUpdatedAt[];

  /**
   * A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#userDefinedValues
   */
  readonly userDefinedValues?: InsightSpecInitProviderFiltersUserDefinedValues[];

  /**
   * The veracity of a finding. See String Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#verificationState
   */
  readonly verificationState?: InsightSpecInitProviderFiltersVerificationState[];

  /**
   * The status of the investigation into a finding. See Workflow Status Filter below for more details.
   *
   * @schema InsightSpecInitProviderFilters#workflowStatus
   */
  readonly workflowStatus?: InsightSpecInitProviderFiltersWorkflowStatus[];

}

/**
 * Converts an object of type 'InsightSpecInitProviderFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFilters(obj: InsightSpecInitProviderFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId?.map(y => toJson_InsightSpecInitProviderFiltersAwsAccountId(y)),
    'companyName': obj.companyName?.map(y => toJson_InsightSpecInitProviderFiltersCompanyName(y)),
    'complianceStatus': obj.complianceStatus?.map(y => toJson_InsightSpecInitProviderFiltersComplianceStatus(y)),
    'confidence': obj.confidence?.map(y => toJson_InsightSpecInitProviderFiltersConfidence(y)),
    'createdAt': obj.createdAt?.map(y => toJson_InsightSpecInitProviderFiltersCreatedAt(y)),
    'criticality': obj.criticality?.map(y => toJson_InsightSpecInitProviderFiltersCriticality(y)),
    'description': obj.description?.map(y => toJson_InsightSpecInitProviderFiltersDescription(y)),
    'findingProviderFieldsConfidence': obj.findingProviderFieldsConfidence?.map(y => toJson_InsightSpecInitProviderFiltersFindingProviderFieldsConfidence(y)),
    'findingProviderFieldsCriticality': obj.findingProviderFieldsCriticality?.map(y => toJson_InsightSpecInitProviderFiltersFindingProviderFieldsCriticality(y)),
    'findingProviderFieldsRelatedFindingsId': obj.findingProviderFieldsRelatedFindingsId?.map(y => toJson_InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsId(y)),
    'findingProviderFieldsRelatedFindingsProductArn': obj.findingProviderFieldsRelatedFindingsProductArn?.map(y => toJson_InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsProductArn(y)),
    'findingProviderFieldsSeverityLabel': obj.findingProviderFieldsSeverityLabel?.map(y => toJson_InsightSpecInitProviderFiltersFindingProviderFieldsSeverityLabel(y)),
    'findingProviderFieldsSeverityOriginal': obj.findingProviderFieldsSeverityOriginal?.map(y => toJson_InsightSpecInitProviderFiltersFindingProviderFieldsSeverityOriginal(y)),
    'findingProviderFieldsTypes': obj.findingProviderFieldsTypes?.map(y => toJson_InsightSpecInitProviderFiltersFindingProviderFieldsTypes(y)),
    'firstObservedAt': obj.firstObservedAt?.map(y => toJson_InsightSpecInitProviderFiltersFirstObservedAt(y)),
    'generatorId': obj.generatorId?.map(y => toJson_InsightSpecInitProviderFiltersGeneratorId(y)),
    'id': obj.id?.map(y => toJson_InsightSpecInitProviderFiltersId(y)),
    'keyword': obj.keyword?.map(y => toJson_InsightSpecInitProviderFiltersKeyword(y)),
    'lastObservedAt': obj.lastObservedAt?.map(y => toJson_InsightSpecInitProviderFiltersLastObservedAt(y)),
    'malwareName': obj.malwareName?.map(y => toJson_InsightSpecInitProviderFiltersMalwareName(y)),
    'malwarePath': obj.malwarePath?.map(y => toJson_InsightSpecInitProviderFiltersMalwarePath(y)),
    'malwareState': obj.malwareState?.map(y => toJson_InsightSpecInitProviderFiltersMalwareState(y)),
    'malwareType': obj.malwareType?.map(y => toJson_InsightSpecInitProviderFiltersMalwareType(y)),
    'networkDestinationDomain': obj.networkDestinationDomain?.map(y => toJson_InsightSpecInitProviderFiltersNetworkDestinationDomain(y)),
    'networkDestinationIpv4': obj.networkDestinationIpv4?.map(y => toJson_InsightSpecInitProviderFiltersNetworkDestinationIpv4(y)),
    'networkDestinationIpv6': obj.networkDestinationIpv6?.map(y => toJson_InsightSpecInitProviderFiltersNetworkDestinationIpv6(y)),
    'networkDestinationPort': obj.networkDestinationPort?.map(y => toJson_InsightSpecInitProviderFiltersNetworkDestinationPort(y)),
    'networkDirection': obj.networkDirection?.map(y => toJson_InsightSpecInitProviderFiltersNetworkDirection(y)),
    'networkProtocol': obj.networkProtocol?.map(y => toJson_InsightSpecInitProviderFiltersNetworkProtocol(y)),
    'networkSourceDomain': obj.networkSourceDomain?.map(y => toJson_InsightSpecInitProviderFiltersNetworkSourceDomain(y)),
    'networkSourceIpv4': obj.networkSourceIpv4?.map(y => toJson_InsightSpecInitProviderFiltersNetworkSourceIpv4(y)),
    'networkSourceIpv6': obj.networkSourceIpv6?.map(y => toJson_InsightSpecInitProviderFiltersNetworkSourceIpv6(y)),
    'networkSourceMac': obj.networkSourceMac?.map(y => toJson_InsightSpecInitProviderFiltersNetworkSourceMac(y)),
    'networkSourcePort': obj.networkSourcePort?.map(y => toJson_InsightSpecInitProviderFiltersNetworkSourcePort(y)),
    'noteText': obj.noteText?.map(y => toJson_InsightSpecInitProviderFiltersNoteText(y)),
    'noteUpdatedAt': obj.noteUpdatedAt?.map(y => toJson_InsightSpecInitProviderFiltersNoteUpdatedAt(y)),
    'noteUpdatedBy': obj.noteUpdatedBy?.map(y => toJson_InsightSpecInitProviderFiltersNoteUpdatedBy(y)),
    'processLaunchedAt': obj.processLaunchedAt?.map(y => toJson_InsightSpecInitProviderFiltersProcessLaunchedAt(y)),
    'processName': obj.processName?.map(y => toJson_InsightSpecInitProviderFiltersProcessName(y)),
    'processParentPid': obj.processParentPid?.map(y => toJson_InsightSpecInitProviderFiltersProcessParentPid(y)),
    'processPath': obj.processPath?.map(y => toJson_InsightSpecInitProviderFiltersProcessPath(y)),
    'processPid': obj.processPid?.map(y => toJson_InsightSpecInitProviderFiltersProcessPid(y)),
    'processTerminatedAt': obj.processTerminatedAt?.map(y => toJson_InsightSpecInitProviderFiltersProcessTerminatedAt(y)),
    'productArn': obj.productArn?.map(y => toJson_InsightSpecInitProviderFiltersProductArn(y)),
    'productFields': obj.productFields?.map(y => toJson_InsightSpecInitProviderFiltersProductFields(y)),
    'productName': obj.productName?.map(y => toJson_InsightSpecInitProviderFiltersProductName(y)),
    'recommendationText': obj.recommendationText?.map(y => toJson_InsightSpecInitProviderFiltersRecommendationText(y)),
    'recordState': obj.recordState?.map(y => toJson_InsightSpecInitProviderFiltersRecordState(y)),
    'relatedFindingsId': obj.relatedFindingsId?.map(y => toJson_InsightSpecInitProviderFiltersRelatedFindingsId(y)),
    'relatedFindingsProductArn': obj.relatedFindingsProductArn?.map(y => toJson_InsightSpecInitProviderFiltersRelatedFindingsProductArn(y)),
    'resourceAwsEc2InstanceIamInstanceProfileArn': obj.resourceAwsEc2InstanceIamInstanceProfileArn?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn(y)),
    'resourceAwsEc2InstanceImageId': obj.resourceAwsEc2InstanceImageId?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceImageId(y)),
    'resourceAwsEc2InstanceIpv4Addresses': obj.resourceAwsEc2InstanceIpv4Addresses?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv4Addresses(y)),
    'resourceAwsEc2InstanceIpv6Addresses': obj.resourceAwsEc2InstanceIpv6Addresses?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv6Addresses(y)),
    'resourceAwsEc2InstanceKeyName': obj.resourceAwsEc2InstanceKeyName?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceKeyName(y)),
    'resourceAwsEc2InstanceLaunchedAt': obj.resourceAwsEc2InstanceLaunchedAt?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAt(y)),
    'resourceAwsEc2InstanceSubnetId': obj.resourceAwsEc2InstanceSubnetId?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceSubnetId(y)),
    'resourceAwsEc2InstanceType': obj.resourceAwsEc2InstanceType?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceType(y)),
    'resourceAwsEc2InstanceVpcId': obj.resourceAwsEc2InstanceVpcId?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceVpcId(y)),
    'resourceAwsIamAccessKeyCreatedAt': obj.resourceAwsIamAccessKeyCreatedAt?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAt(y)),
    'resourceAwsIamAccessKeyStatus': obj.resourceAwsIamAccessKeyStatus?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsIamAccessKeyStatus(y)),
    'resourceAwsIamAccessKeyUserName': obj.resourceAwsIamAccessKeyUserName?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsIamAccessKeyUserName(y)),
    'resourceAwsS3BucketOwnerId': obj.resourceAwsS3BucketOwnerId?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerId(y)),
    'resourceAwsS3BucketOwnerName': obj.resourceAwsS3BucketOwnerName?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerName(y)),
    'resourceContainerImageId': obj.resourceContainerImageId?.map(y => toJson_InsightSpecInitProviderFiltersResourceContainerImageId(y)),
    'resourceContainerImageName': obj.resourceContainerImageName?.map(y => toJson_InsightSpecInitProviderFiltersResourceContainerImageName(y)),
    'resourceContainerLaunchedAt': obj.resourceContainerLaunchedAt?.map(y => toJson_InsightSpecInitProviderFiltersResourceContainerLaunchedAt(y)),
    'resourceContainerName': obj.resourceContainerName?.map(y => toJson_InsightSpecInitProviderFiltersResourceContainerName(y)),
    'resourceDetailsOther': obj.resourceDetailsOther?.map(y => toJson_InsightSpecInitProviderFiltersResourceDetailsOther(y)),
    'resourceId': obj.resourceId?.map(y => toJson_InsightSpecInitProviderFiltersResourceId(y)),
    'resourcePartition': obj.resourcePartition?.map(y => toJson_InsightSpecInitProviderFiltersResourcePartition(y)),
    'resourceRegion': obj.resourceRegion?.map(y => toJson_InsightSpecInitProviderFiltersResourceRegion(y)),
    'resourceTags': obj.resourceTags?.map(y => toJson_InsightSpecInitProviderFiltersResourceTags(y)),
    'resourceType': obj.resourceType?.map(y => toJson_InsightSpecInitProviderFiltersResourceType(y)),
    'severityLabel': obj.severityLabel?.map(y => toJson_InsightSpecInitProviderFiltersSeverityLabel(y)),
    'sourceUrl': obj.sourceUrl?.map(y => toJson_InsightSpecInitProviderFiltersSourceUrl(y)),
    'threatIntelIndicatorCategory': obj.threatIntelIndicatorCategory?.map(y => toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorCategory(y)),
    'threatIntelIndicatorLastObservedAt': obj.threatIntelIndicatorLastObservedAt?.map(y => toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAt(y)),
    'threatIntelIndicatorSource': obj.threatIntelIndicatorSource?.map(y => toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorSource(y)),
    'threatIntelIndicatorSourceUrl': obj.threatIntelIndicatorSourceUrl?.map(y => toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorSourceUrl(y)),
    'threatIntelIndicatorType': obj.threatIntelIndicatorType?.map(y => toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorType(y)),
    'threatIntelIndicatorValue': obj.threatIntelIndicatorValue?.map(y => toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorValue(y)),
    'title': obj.title?.map(y => toJson_InsightSpecInitProviderFiltersTitle(y)),
    'type': obj.type?.map(y => toJson_InsightSpecInitProviderFiltersType(y)),
    'updatedAt': obj.updatedAt?.map(y => toJson_InsightSpecInitProviderFiltersUpdatedAt(y)),
    'userDefinedValues': obj.userDefinedValues?.map(y => toJson_InsightSpecInitProviderFiltersUserDefinedValues(y)),
    'verificationState': obj.verificationState?.map(y => toJson_InsightSpecInitProviderFiltersVerificationState(y)),
    'workflowStatus': obj.workflowStatus?.map(y => toJson_InsightSpecInitProviderFiltersWorkflowStatus(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InsightSpecProviderConfigRefPolicy
 */
export interface InsightSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InsightSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InsightSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InsightSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InsightSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InsightSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecProviderConfigRefPolicy(obj: InsightSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InsightSpecPublishConnectionDetailsToConfigRef
 */
export interface InsightSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InsightSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InsightSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InsightSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InsightSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecPublishConnectionDetailsToConfigRef(obj: InsightSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InsightSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InsightSpecPublishConnectionDetailsToMetadata
 */
export interface InsightSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InsightSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InsightSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InsightSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InsightSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecPublishConnectionDetailsToMetadata(obj: InsightSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersAwsAccountId
 */
export interface InsightSpecForProviderFiltersAwsAccountId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersAwsAccountId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersAwsAccountId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersAwsAccountId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersAwsAccountId(obj: InsightSpecForProviderFiltersAwsAccountId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersCompanyName
 */
export interface InsightSpecForProviderFiltersCompanyName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersCompanyName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersCompanyName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersCompanyName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersCompanyName(obj: InsightSpecForProviderFiltersCompanyName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersComplianceStatus
 */
export interface InsightSpecForProviderFiltersComplianceStatus {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersComplianceStatus#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersComplianceStatus#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersComplianceStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersComplianceStatus(obj: InsightSpecForProviderFiltersComplianceStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersConfidence
 */
export interface InsightSpecForProviderFiltersConfidence {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersConfidence#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersConfidence#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersConfidence#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersConfidence' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersConfidence(obj: InsightSpecForProviderFiltersConfidence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersCreatedAt
 */
export interface InsightSpecForProviderFiltersCreatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersCreatedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersCreatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersCreatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersCreatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersCreatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersCreatedAt(obj: InsightSpecForProviderFiltersCreatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersCreatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersCriticality
 */
export interface InsightSpecForProviderFiltersCriticality {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersCriticality#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersCriticality#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersCriticality#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersCriticality' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersCriticality(obj: InsightSpecForProviderFiltersCriticality | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersDescription
 */
export interface InsightSpecForProviderFiltersDescription {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersDescription#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersDescription#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersDescription' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersDescription(obj: InsightSpecForProviderFiltersDescription | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsConfidence
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsConfidence {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsConfidence#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsConfidence#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsConfidence#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsConfidence' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsConfidence(obj: InsightSpecForProviderFiltersFindingProviderFieldsConfidence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsCriticality
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsCriticality {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsCriticality#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsCriticality#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsCriticality#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsCriticality' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsCriticality(obj: InsightSpecForProviderFiltersFindingProviderFieldsCriticality | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId(obj: InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn(obj: InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel(obj: InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal(obj: InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsTypes
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsTypes {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsTypes#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsTypes#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsTypes(obj: InsightSpecForProviderFiltersFindingProviderFieldsTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFirstObservedAt
 */
export interface InsightSpecForProviderFiltersFirstObservedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersFirstObservedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersFirstObservedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersFirstObservedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersFirstObservedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFirstObservedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFirstObservedAt(obj: InsightSpecForProviderFiltersFirstObservedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersFirstObservedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersGeneratorId
 */
export interface InsightSpecForProviderFiltersGeneratorId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersGeneratorId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersGeneratorId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersGeneratorId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersGeneratorId(obj: InsightSpecForProviderFiltersGeneratorId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersId
 */
export interface InsightSpecForProviderFiltersId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersId(obj: InsightSpecForProviderFiltersId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersKeyword
 */
export interface InsightSpecForProviderFiltersKeyword {
  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersKeyword#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersKeyword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersKeyword(obj: InsightSpecForProviderFiltersKeyword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersLastObservedAt
 */
export interface InsightSpecForProviderFiltersLastObservedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersLastObservedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersLastObservedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersLastObservedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersLastObservedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersLastObservedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersLastObservedAt(obj: InsightSpecForProviderFiltersLastObservedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersLastObservedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersMalwareName
 */
export interface InsightSpecForProviderFiltersMalwareName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersMalwareName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersMalwareName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersMalwareName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersMalwareName(obj: InsightSpecForProviderFiltersMalwareName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersMalwarePath
 */
export interface InsightSpecForProviderFiltersMalwarePath {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersMalwarePath#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersMalwarePath#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersMalwarePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersMalwarePath(obj: InsightSpecForProviderFiltersMalwarePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersMalwareState
 */
export interface InsightSpecForProviderFiltersMalwareState {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersMalwareState#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersMalwareState#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersMalwareState' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersMalwareState(obj: InsightSpecForProviderFiltersMalwareState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersMalwareType
 */
export interface InsightSpecForProviderFiltersMalwareType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersMalwareType#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersMalwareType#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersMalwareType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersMalwareType(obj: InsightSpecForProviderFiltersMalwareType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkDestinationDomain
 */
export interface InsightSpecForProviderFiltersNetworkDestinationDomain {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationDomain#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationDomain#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkDestinationDomain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkDestinationDomain(obj: InsightSpecForProviderFiltersNetworkDestinationDomain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkDestinationIpv4
 */
export interface InsightSpecForProviderFiltersNetworkDestinationIpv4 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationIpv4#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkDestinationIpv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkDestinationIpv4(obj: InsightSpecForProviderFiltersNetworkDestinationIpv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkDestinationIpv6
 */
export interface InsightSpecForProviderFiltersNetworkDestinationIpv6 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationIpv6#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkDestinationIpv6' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkDestinationIpv6(obj: InsightSpecForProviderFiltersNetworkDestinationIpv6 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkDestinationPort
 */
export interface InsightSpecForProviderFiltersNetworkDestinationPort {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationPort#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationPort#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationPort#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkDestinationPort(obj: InsightSpecForProviderFiltersNetworkDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkDirection
 */
export interface InsightSpecForProviderFiltersNetworkDirection {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNetworkDirection#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNetworkDirection#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkDirection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkDirection(obj: InsightSpecForProviderFiltersNetworkDirection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkProtocol
 */
export interface InsightSpecForProviderFiltersNetworkProtocol {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNetworkProtocol#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNetworkProtocol#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkProtocol' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkProtocol(obj: InsightSpecForProviderFiltersNetworkProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkSourceDomain
 */
export interface InsightSpecForProviderFiltersNetworkSourceDomain {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceDomain#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceDomain#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkSourceDomain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkSourceDomain(obj: InsightSpecForProviderFiltersNetworkSourceDomain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkSourceIpv4
 */
export interface InsightSpecForProviderFiltersNetworkSourceIpv4 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceIpv4#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkSourceIpv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkSourceIpv4(obj: InsightSpecForProviderFiltersNetworkSourceIpv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkSourceIpv6
 */
export interface InsightSpecForProviderFiltersNetworkSourceIpv6 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceIpv6#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkSourceIpv6' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkSourceIpv6(obj: InsightSpecForProviderFiltersNetworkSourceIpv6 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkSourceMac
 */
export interface InsightSpecForProviderFiltersNetworkSourceMac {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceMac#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceMac#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkSourceMac' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkSourceMac(obj: InsightSpecForProviderFiltersNetworkSourceMac | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkSourcePort
 */
export interface InsightSpecForProviderFiltersNetworkSourcePort {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourcePort#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourcePort#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourcePort#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkSourcePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkSourcePort(obj: InsightSpecForProviderFiltersNetworkSourcePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNoteText
 */
export interface InsightSpecForProviderFiltersNoteText {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNoteText#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNoteText#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNoteText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNoteText(obj: InsightSpecForProviderFiltersNoteText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNoteUpdatedAt
 */
export interface InsightSpecForProviderFiltersNoteUpdatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersNoteUpdatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNoteUpdatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNoteUpdatedAt(obj: InsightSpecForProviderFiltersNoteUpdatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersNoteUpdatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNoteUpdatedBy
 */
export interface InsightSpecForProviderFiltersNoteUpdatedBy {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedBy#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedBy#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNoteUpdatedBy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNoteUpdatedBy(obj: InsightSpecForProviderFiltersNoteUpdatedBy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessLaunchedAt
 */
export interface InsightSpecForProviderFiltersProcessLaunchedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersProcessLaunchedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersProcessLaunchedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersProcessLaunchedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersProcessLaunchedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessLaunchedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessLaunchedAt(obj: InsightSpecForProviderFiltersProcessLaunchedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersProcessLaunchedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessName
 */
export interface InsightSpecForProviderFiltersProcessName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersProcessName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProcessName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessName(obj: InsightSpecForProviderFiltersProcessName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessParentPid
 */
export interface InsightSpecForProviderFiltersProcessParentPid {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessParentPid#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessParentPid#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessParentPid#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessParentPid' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessParentPid(obj: InsightSpecForProviderFiltersProcessParentPid | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessPath
 */
export interface InsightSpecForProviderFiltersProcessPath {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersProcessPath#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProcessPath#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessPath(obj: InsightSpecForProviderFiltersProcessPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessPid
 */
export interface InsightSpecForProviderFiltersProcessPid {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessPid#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessPid#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessPid#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessPid' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessPid(obj: InsightSpecForProviderFiltersProcessPid | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessTerminatedAt
 */
export interface InsightSpecForProviderFiltersProcessTerminatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersProcessTerminatedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersProcessTerminatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersProcessTerminatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersProcessTerminatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessTerminatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessTerminatedAt(obj: InsightSpecForProviderFiltersProcessTerminatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersProcessTerminatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProductArn
 */
export interface InsightSpecForProviderFiltersProductArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersProductArn#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProductArn#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProductArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProductArn(obj: InsightSpecForProviderFiltersProductArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProductFields
 */
export interface InsightSpecForProviderFiltersProductFields {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersProductFields#comparison
   */
  readonly comparison?: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecForProviderFiltersProductFields#key
   */
  readonly key?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProductFields#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProductFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProductFields(obj: InsightSpecForProviderFiltersProductFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProductName
 */
export interface InsightSpecForProviderFiltersProductName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersProductName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProductName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProductName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProductName(obj: InsightSpecForProviderFiltersProductName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersRecommendationText
 */
export interface InsightSpecForProviderFiltersRecommendationText {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersRecommendationText#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersRecommendationText#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersRecommendationText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersRecommendationText(obj: InsightSpecForProviderFiltersRecommendationText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersRecordState
 */
export interface InsightSpecForProviderFiltersRecordState {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersRecordState#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersRecordState#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersRecordState' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersRecordState(obj: InsightSpecForProviderFiltersRecordState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersRelatedFindingsId
 */
export interface InsightSpecForProviderFiltersRelatedFindingsId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersRelatedFindingsId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersRelatedFindingsId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersRelatedFindingsId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersRelatedFindingsId(obj: InsightSpecForProviderFiltersRelatedFindingsId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersRelatedFindingsProductArn
 */
export interface InsightSpecForProviderFiltersRelatedFindingsProductArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersRelatedFindingsProductArn#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersRelatedFindingsProductArn#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersRelatedFindingsProductArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersRelatedFindingsProductArn(obj: InsightSpecForProviderFiltersRelatedFindingsProductArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceType
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceType#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceType#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceType(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt
 */
export interface InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt(obj: InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus
 */
export interface InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus(obj: InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName
 */
export interface InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName(obj: InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId
 */
export interface InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId(obj: InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName
 */
export interface InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName(obj: InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceContainerImageId
 */
export interface InsightSpecForProviderFiltersResourceContainerImageId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerImageId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerImageId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceContainerImageId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceContainerImageId(obj: InsightSpecForProviderFiltersResourceContainerImageId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceContainerImageName
 */
export interface InsightSpecForProviderFiltersResourceContainerImageName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerImageName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerImageName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceContainerImageName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceContainerImageName(obj: InsightSpecForProviderFiltersResourceContainerImageName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAt
 */
export interface InsightSpecForProviderFiltersResourceContainerLaunchedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceContainerLaunchedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceContainerLaunchedAt(obj: InsightSpecForProviderFiltersResourceContainerLaunchedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceContainerName
 */
export interface InsightSpecForProviderFiltersResourceContainerName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceContainerName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceContainerName(obj: InsightSpecForProviderFiltersResourceContainerName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceDetailsOther
 */
export interface InsightSpecForProviderFiltersResourceDetailsOther {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceDetailsOther#comparison
   */
  readonly comparison?: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecForProviderFiltersResourceDetailsOther#key
   */
  readonly key?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceDetailsOther#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceDetailsOther' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceDetailsOther(obj: InsightSpecForProviderFiltersResourceDetailsOther | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceId
 */
export interface InsightSpecForProviderFiltersResourceId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceId(obj: InsightSpecForProviderFiltersResourceId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourcePartition
 */
export interface InsightSpecForProviderFiltersResourcePartition {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourcePartition#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourcePartition#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourcePartition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourcePartition(obj: InsightSpecForProviderFiltersResourcePartition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceRegion
 */
export interface InsightSpecForProviderFiltersResourceRegion {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceRegion#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceRegion#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceRegion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceRegion(obj: InsightSpecForProviderFiltersResourceRegion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceTags
 */
export interface InsightSpecForProviderFiltersResourceTags {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceTags#comparison
   */
  readonly comparison?: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecForProviderFiltersResourceTags#key
   */
  readonly key?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceTags(obj: InsightSpecForProviderFiltersResourceTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceType
 */
export interface InsightSpecForProviderFiltersResourceType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceType#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceType#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceType(obj: InsightSpecForProviderFiltersResourceType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersSeverityLabel
 */
export interface InsightSpecForProviderFiltersSeverityLabel {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersSeverityLabel#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersSeverityLabel#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersSeverityLabel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersSeverityLabel(obj: InsightSpecForProviderFiltersSeverityLabel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersSourceUrl
 */
export interface InsightSpecForProviderFiltersSourceUrl {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersSourceUrl#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersSourceUrl#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersSourceUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersSourceUrl(obj: InsightSpecForProviderFiltersSourceUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorCategory
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorCategory {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorCategory#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorCategory#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorCategory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorCategory(obj: InsightSpecForProviderFiltersThreatIntelIndicatorCategory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt(obj: InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSource
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorSource {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSource#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSource#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorSource(obj: InsightSpecForProviderFiltersThreatIntelIndicatorSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl(obj: InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorType
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorType#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorType#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorType(obj: InsightSpecForProviderFiltersThreatIntelIndicatorType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorValue
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorValue {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorValue#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorValue#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorValue(obj: InsightSpecForProviderFiltersThreatIntelIndicatorValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersTitle
 */
export interface InsightSpecForProviderFiltersTitle {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersTitle#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersTitle#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersTitle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersTitle(obj: InsightSpecForProviderFiltersTitle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersType
 */
export interface InsightSpecForProviderFiltersType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersType#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersType#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersType(obj: InsightSpecForProviderFiltersType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersUpdatedAt
 */
export interface InsightSpecForProviderFiltersUpdatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersUpdatedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersUpdatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersUpdatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersUpdatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersUpdatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersUpdatedAt(obj: InsightSpecForProviderFiltersUpdatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersUpdatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersUserDefinedValues
 */
export interface InsightSpecForProviderFiltersUserDefinedValues {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersUserDefinedValues#comparison
   */
  readonly comparison?: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecForProviderFiltersUserDefinedValues#key
   */
  readonly key?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersUserDefinedValues#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersUserDefinedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersUserDefinedValues(obj: InsightSpecForProviderFiltersUserDefinedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersVerificationState
 */
export interface InsightSpecForProviderFiltersVerificationState {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersVerificationState#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersVerificationState#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersVerificationState' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersVerificationState(obj: InsightSpecForProviderFiltersVerificationState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersWorkflowStatus
 */
export interface InsightSpecForProviderFiltersWorkflowStatus {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersWorkflowStatus#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersWorkflowStatus#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersWorkflowStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersWorkflowStatus(obj: InsightSpecForProviderFiltersWorkflowStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersAwsAccountId
 */
export interface InsightSpecInitProviderFiltersAwsAccountId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersAwsAccountId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersAwsAccountId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersAwsAccountId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersAwsAccountId(obj: InsightSpecInitProviderFiltersAwsAccountId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersCompanyName
 */
export interface InsightSpecInitProviderFiltersCompanyName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersCompanyName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersCompanyName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersCompanyName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersCompanyName(obj: InsightSpecInitProviderFiltersCompanyName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersComplianceStatus
 */
export interface InsightSpecInitProviderFiltersComplianceStatus {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersComplianceStatus#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersComplianceStatus#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersComplianceStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersComplianceStatus(obj: InsightSpecInitProviderFiltersComplianceStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersConfidence
 */
export interface InsightSpecInitProviderFiltersConfidence {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersConfidence#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersConfidence#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersConfidence#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersConfidence' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersConfidence(obj: InsightSpecInitProviderFiltersConfidence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersCreatedAt
 */
export interface InsightSpecInitProviderFiltersCreatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersCreatedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersCreatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersCreatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersCreatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersCreatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersCreatedAt(obj: InsightSpecInitProviderFiltersCreatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersCreatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersCriticality
 */
export interface InsightSpecInitProviderFiltersCriticality {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersCriticality#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersCriticality#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersCriticality#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersCriticality' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersCriticality(obj: InsightSpecInitProviderFiltersCriticality | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersDescription
 */
export interface InsightSpecInitProviderFiltersDescription {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersDescription#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersDescription#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersDescription' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersDescription(obj: InsightSpecInitProviderFiltersDescription | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersFindingProviderFieldsConfidence
 */
export interface InsightSpecInitProviderFiltersFindingProviderFieldsConfidence {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsConfidence#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsConfidence#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsConfidence#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersFindingProviderFieldsConfidence' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersFindingProviderFieldsConfidence(obj: InsightSpecInitProviderFiltersFindingProviderFieldsConfidence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersFindingProviderFieldsCriticality
 */
export interface InsightSpecInitProviderFiltersFindingProviderFieldsCriticality {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsCriticality#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsCriticality#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsCriticality#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersFindingProviderFieldsCriticality' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersFindingProviderFieldsCriticality(obj: InsightSpecInitProviderFiltersFindingProviderFieldsCriticality | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsId
 */
export interface InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsId(obj: InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsProductArn
 */
export interface InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsProductArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsProductArn#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsProductArn#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsProductArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsProductArn(obj: InsightSpecInitProviderFiltersFindingProviderFieldsRelatedFindingsProductArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersFindingProviderFieldsSeverityLabel
 */
export interface InsightSpecInitProviderFiltersFindingProviderFieldsSeverityLabel {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsSeverityLabel#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsSeverityLabel#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersFindingProviderFieldsSeverityLabel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersFindingProviderFieldsSeverityLabel(obj: InsightSpecInitProviderFiltersFindingProviderFieldsSeverityLabel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersFindingProviderFieldsSeverityOriginal
 */
export interface InsightSpecInitProviderFiltersFindingProviderFieldsSeverityOriginal {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsSeverityOriginal#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsSeverityOriginal#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersFindingProviderFieldsSeverityOriginal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersFindingProviderFieldsSeverityOriginal(obj: InsightSpecInitProviderFiltersFindingProviderFieldsSeverityOriginal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersFindingProviderFieldsTypes
 */
export interface InsightSpecInitProviderFiltersFindingProviderFieldsTypes {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsTypes#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersFindingProviderFieldsTypes#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersFindingProviderFieldsTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersFindingProviderFieldsTypes(obj: InsightSpecInitProviderFiltersFindingProviderFieldsTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersFirstObservedAt
 */
export interface InsightSpecInitProviderFiltersFirstObservedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersFirstObservedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersFirstObservedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersFirstObservedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersFirstObservedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersFirstObservedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersFirstObservedAt(obj: InsightSpecInitProviderFiltersFirstObservedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersFirstObservedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersGeneratorId
 */
export interface InsightSpecInitProviderFiltersGeneratorId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersGeneratorId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersGeneratorId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersGeneratorId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersGeneratorId(obj: InsightSpecInitProviderFiltersGeneratorId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersId
 */
export interface InsightSpecInitProviderFiltersId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersId(obj: InsightSpecInitProviderFiltersId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersKeyword
 */
export interface InsightSpecInitProviderFiltersKeyword {
  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersKeyword#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersKeyword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersKeyword(obj: InsightSpecInitProviderFiltersKeyword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersLastObservedAt
 */
export interface InsightSpecInitProviderFiltersLastObservedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersLastObservedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersLastObservedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersLastObservedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersLastObservedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersLastObservedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersLastObservedAt(obj: InsightSpecInitProviderFiltersLastObservedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersLastObservedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersMalwareName
 */
export interface InsightSpecInitProviderFiltersMalwareName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersMalwareName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersMalwareName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersMalwareName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersMalwareName(obj: InsightSpecInitProviderFiltersMalwareName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersMalwarePath
 */
export interface InsightSpecInitProviderFiltersMalwarePath {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersMalwarePath#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersMalwarePath#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersMalwarePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersMalwarePath(obj: InsightSpecInitProviderFiltersMalwarePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersMalwareState
 */
export interface InsightSpecInitProviderFiltersMalwareState {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersMalwareState#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersMalwareState#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersMalwareState' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersMalwareState(obj: InsightSpecInitProviderFiltersMalwareState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersMalwareType
 */
export interface InsightSpecInitProviderFiltersMalwareType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersMalwareType#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersMalwareType#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersMalwareType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersMalwareType(obj: InsightSpecInitProviderFiltersMalwareType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkDestinationDomain
 */
export interface InsightSpecInitProviderFiltersNetworkDestinationDomain {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersNetworkDestinationDomain#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersNetworkDestinationDomain#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkDestinationDomain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkDestinationDomain(obj: InsightSpecInitProviderFiltersNetworkDestinationDomain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkDestinationIpv4
 */
export interface InsightSpecInitProviderFiltersNetworkDestinationIpv4 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecInitProviderFiltersNetworkDestinationIpv4#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkDestinationIpv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkDestinationIpv4(obj: InsightSpecInitProviderFiltersNetworkDestinationIpv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkDestinationIpv6
 */
export interface InsightSpecInitProviderFiltersNetworkDestinationIpv6 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecInitProviderFiltersNetworkDestinationIpv6#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkDestinationIpv6' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkDestinationIpv6(obj: InsightSpecInitProviderFiltersNetworkDestinationIpv6 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkDestinationPort
 */
export interface InsightSpecInitProviderFiltersNetworkDestinationPort {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersNetworkDestinationPort#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersNetworkDestinationPort#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersNetworkDestinationPort#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkDestinationPort(obj: InsightSpecInitProviderFiltersNetworkDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkDirection
 */
export interface InsightSpecInitProviderFiltersNetworkDirection {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersNetworkDirection#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersNetworkDirection#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkDirection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkDirection(obj: InsightSpecInitProviderFiltersNetworkDirection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkProtocol
 */
export interface InsightSpecInitProviderFiltersNetworkProtocol {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersNetworkProtocol#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersNetworkProtocol#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkProtocol' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkProtocol(obj: InsightSpecInitProviderFiltersNetworkProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkSourceDomain
 */
export interface InsightSpecInitProviderFiltersNetworkSourceDomain {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersNetworkSourceDomain#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersNetworkSourceDomain#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkSourceDomain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkSourceDomain(obj: InsightSpecInitProviderFiltersNetworkSourceDomain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkSourceIpv4
 */
export interface InsightSpecInitProviderFiltersNetworkSourceIpv4 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecInitProviderFiltersNetworkSourceIpv4#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkSourceIpv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkSourceIpv4(obj: InsightSpecInitProviderFiltersNetworkSourceIpv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkSourceIpv6
 */
export interface InsightSpecInitProviderFiltersNetworkSourceIpv6 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecInitProviderFiltersNetworkSourceIpv6#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkSourceIpv6' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkSourceIpv6(obj: InsightSpecInitProviderFiltersNetworkSourceIpv6 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkSourceMac
 */
export interface InsightSpecInitProviderFiltersNetworkSourceMac {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersNetworkSourceMac#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersNetworkSourceMac#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkSourceMac' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkSourceMac(obj: InsightSpecInitProviderFiltersNetworkSourceMac | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNetworkSourcePort
 */
export interface InsightSpecInitProviderFiltersNetworkSourcePort {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersNetworkSourcePort#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersNetworkSourcePort#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersNetworkSourcePort#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNetworkSourcePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNetworkSourcePort(obj: InsightSpecInitProviderFiltersNetworkSourcePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNoteText
 */
export interface InsightSpecInitProviderFiltersNoteText {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersNoteText#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersNoteText#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNoteText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNoteText(obj: InsightSpecInitProviderFiltersNoteText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNoteUpdatedAt
 */
export interface InsightSpecInitProviderFiltersNoteUpdatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersNoteUpdatedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersNoteUpdatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersNoteUpdatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersNoteUpdatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNoteUpdatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNoteUpdatedAt(obj: InsightSpecInitProviderFiltersNoteUpdatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersNoteUpdatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNoteUpdatedBy
 */
export interface InsightSpecInitProviderFiltersNoteUpdatedBy {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersNoteUpdatedBy#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersNoteUpdatedBy#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNoteUpdatedBy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNoteUpdatedBy(obj: InsightSpecInitProviderFiltersNoteUpdatedBy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProcessLaunchedAt
 */
export interface InsightSpecInitProviderFiltersProcessLaunchedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersProcessLaunchedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersProcessLaunchedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersProcessLaunchedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersProcessLaunchedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProcessLaunchedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProcessLaunchedAt(obj: InsightSpecInitProviderFiltersProcessLaunchedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersProcessLaunchedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProcessName
 */
export interface InsightSpecInitProviderFiltersProcessName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersProcessName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersProcessName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProcessName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProcessName(obj: InsightSpecInitProviderFiltersProcessName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProcessParentPid
 */
export interface InsightSpecInitProviderFiltersProcessParentPid {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersProcessParentPid#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersProcessParentPid#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersProcessParentPid#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProcessParentPid' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProcessParentPid(obj: InsightSpecInitProviderFiltersProcessParentPid | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProcessPath
 */
export interface InsightSpecInitProviderFiltersProcessPath {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersProcessPath#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersProcessPath#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProcessPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProcessPath(obj: InsightSpecInitProviderFiltersProcessPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProcessPid
 */
export interface InsightSpecInitProviderFiltersProcessPid {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersProcessPid#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersProcessPid#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecInitProviderFiltersProcessPid#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProcessPid' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProcessPid(obj: InsightSpecInitProviderFiltersProcessPid | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProcessTerminatedAt
 */
export interface InsightSpecInitProviderFiltersProcessTerminatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersProcessTerminatedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersProcessTerminatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersProcessTerminatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersProcessTerminatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProcessTerminatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProcessTerminatedAt(obj: InsightSpecInitProviderFiltersProcessTerminatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersProcessTerminatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProductArn
 */
export interface InsightSpecInitProviderFiltersProductArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersProductArn#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersProductArn#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProductArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProductArn(obj: InsightSpecInitProviderFiltersProductArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProductFields
 */
export interface InsightSpecInitProviderFiltersProductFields {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersProductFields#comparison
   */
  readonly comparison?: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecInitProviderFiltersProductFields#key
   */
  readonly key?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersProductFields#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProductFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProductFields(obj: InsightSpecInitProviderFiltersProductFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProductName
 */
export interface InsightSpecInitProviderFiltersProductName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersProductName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersProductName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProductName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProductName(obj: InsightSpecInitProviderFiltersProductName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersRecommendationText
 */
export interface InsightSpecInitProviderFiltersRecommendationText {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersRecommendationText#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersRecommendationText#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersRecommendationText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersRecommendationText(obj: InsightSpecInitProviderFiltersRecommendationText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersRecordState
 */
export interface InsightSpecInitProviderFiltersRecordState {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersRecordState#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersRecordState#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersRecordState' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersRecordState(obj: InsightSpecInitProviderFiltersRecordState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersRelatedFindingsId
 */
export interface InsightSpecInitProviderFiltersRelatedFindingsId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersRelatedFindingsId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersRelatedFindingsId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersRelatedFindingsId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersRelatedFindingsId(obj: InsightSpecInitProviderFiltersRelatedFindingsId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersRelatedFindingsProductArn
 */
export interface InsightSpecInitProviderFiltersRelatedFindingsProductArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersRelatedFindingsProductArn#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersRelatedFindingsProductArn#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersRelatedFindingsProductArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersRelatedFindingsProductArn(obj: InsightSpecInitProviderFiltersRelatedFindingsProductArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn
 */
export interface InsightSpecInitProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn(obj: InsightSpecInitProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceImageId
 */
export interface InsightSpecInitProviderFiltersResourceAwsEc2InstanceImageId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceImageId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceImageId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsEc2InstanceImageId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceImageId(obj: InsightSpecInitProviderFiltersResourceAwsEc2InstanceImageId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv4Addresses
 */
export interface InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv4Addresses {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv4Addresses#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv4Addresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv4Addresses(obj: InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv4Addresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv6Addresses
 */
export interface InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv6Addresses {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv6Addresses#cidr
   */
  readonly cidr?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv6Addresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv6Addresses(obj: InsightSpecInitProviderFiltersResourceAwsEc2InstanceIpv6Addresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceKeyName
 */
export interface InsightSpecInitProviderFiltersResourceAwsEc2InstanceKeyName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceKeyName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceKeyName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsEc2InstanceKeyName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceKeyName(obj: InsightSpecInitProviderFiltersResourceAwsEc2InstanceKeyName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAt
 */
export interface InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAt(obj: InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceSubnetId
 */
export interface InsightSpecInitProviderFiltersResourceAwsEc2InstanceSubnetId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceSubnetId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceSubnetId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsEc2InstanceSubnetId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceSubnetId(obj: InsightSpecInitProviderFiltersResourceAwsEc2InstanceSubnetId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceType
 */
export interface InsightSpecInitProviderFiltersResourceAwsEc2InstanceType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceType#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceType#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsEc2InstanceType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceType(obj: InsightSpecInitProviderFiltersResourceAwsEc2InstanceType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceVpcId
 */
export interface InsightSpecInitProviderFiltersResourceAwsEc2InstanceVpcId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceVpcId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceVpcId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsEc2InstanceVpcId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceVpcId(obj: InsightSpecInitProviderFiltersResourceAwsEc2InstanceVpcId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAt
 */
export interface InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAt(obj: InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyStatus
 */
export interface InsightSpecInitProviderFiltersResourceAwsIamAccessKeyStatus {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyStatus#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyStatus#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsIamAccessKeyStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsIamAccessKeyStatus(obj: InsightSpecInitProviderFiltersResourceAwsIamAccessKeyStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyUserName
 */
export interface InsightSpecInitProviderFiltersResourceAwsIamAccessKeyUserName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyUserName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyUserName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsIamAccessKeyUserName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsIamAccessKeyUserName(obj: InsightSpecInitProviderFiltersResourceAwsIamAccessKeyUserName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerId
 */
export interface InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerId(obj: InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerName
 */
export interface InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerName(obj: InsightSpecInitProviderFiltersResourceAwsS3BucketOwnerName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceContainerImageId
 */
export interface InsightSpecInitProviderFiltersResourceContainerImageId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerImageId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerImageId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceContainerImageId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceContainerImageId(obj: InsightSpecInitProviderFiltersResourceContainerImageId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceContainerImageName
 */
export interface InsightSpecInitProviderFiltersResourceContainerImageName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerImageName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerImageName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceContainerImageName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceContainerImageName(obj: InsightSpecInitProviderFiltersResourceContainerImageName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceContainerLaunchedAt
 */
export interface InsightSpecInitProviderFiltersResourceContainerLaunchedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerLaunchedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersResourceContainerLaunchedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerLaunchedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerLaunchedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceContainerLaunchedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceContainerLaunchedAt(obj: InsightSpecInitProviderFiltersResourceContainerLaunchedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersResourceContainerLaunchedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceContainerName
 */
export interface InsightSpecInitProviderFiltersResourceContainerName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerName#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerName#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceContainerName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceContainerName(obj: InsightSpecInitProviderFiltersResourceContainerName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceDetailsOther
 */
export interface InsightSpecInitProviderFiltersResourceDetailsOther {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceDetailsOther#comparison
   */
  readonly comparison?: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecInitProviderFiltersResourceDetailsOther#key
   */
  readonly key?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceDetailsOther#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceDetailsOther' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceDetailsOther(obj: InsightSpecInitProviderFiltersResourceDetailsOther | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceId
 */
export interface InsightSpecInitProviderFiltersResourceId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceId#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceId(obj: InsightSpecInitProviderFiltersResourceId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourcePartition
 */
export interface InsightSpecInitProviderFiltersResourcePartition {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourcePartition#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourcePartition#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourcePartition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourcePartition(obj: InsightSpecInitProviderFiltersResourcePartition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceRegion
 */
export interface InsightSpecInitProviderFiltersResourceRegion {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceRegion#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceRegion#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceRegion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceRegion(obj: InsightSpecInitProviderFiltersResourceRegion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceTags
 */
export interface InsightSpecInitProviderFiltersResourceTags {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceTags#comparison
   */
  readonly comparison?: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecInitProviderFiltersResourceTags#key
   */
  readonly key?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceTags(obj: InsightSpecInitProviderFiltersResourceTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceType
 */
export interface InsightSpecInitProviderFiltersResourceType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersResourceType#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceType#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceType(obj: InsightSpecInitProviderFiltersResourceType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersSeverityLabel
 */
export interface InsightSpecInitProviderFiltersSeverityLabel {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersSeverityLabel#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersSeverityLabel#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersSeverityLabel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersSeverityLabel(obj: InsightSpecInitProviderFiltersSeverityLabel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersSourceUrl
 */
export interface InsightSpecInitProviderFiltersSourceUrl {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersSourceUrl#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersSourceUrl#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersSourceUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersSourceUrl(obj: InsightSpecInitProviderFiltersSourceUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorCategory
 */
export interface InsightSpecInitProviderFiltersThreatIntelIndicatorCategory {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorCategory#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorCategory#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersThreatIntelIndicatorCategory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorCategory(obj: InsightSpecInitProviderFiltersThreatIntelIndicatorCategory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAt
 */
export interface InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAt(obj: InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorSource
 */
export interface InsightSpecInitProviderFiltersThreatIntelIndicatorSource {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorSource#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorSource#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersThreatIntelIndicatorSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorSource(obj: InsightSpecInitProviderFiltersThreatIntelIndicatorSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorSourceUrl
 */
export interface InsightSpecInitProviderFiltersThreatIntelIndicatorSourceUrl {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorSourceUrl#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorSourceUrl#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersThreatIntelIndicatorSourceUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorSourceUrl(obj: InsightSpecInitProviderFiltersThreatIntelIndicatorSourceUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorType
 */
export interface InsightSpecInitProviderFiltersThreatIntelIndicatorType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorType#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorType#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersThreatIntelIndicatorType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorType(obj: InsightSpecInitProviderFiltersThreatIntelIndicatorType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorValue
 */
export interface InsightSpecInitProviderFiltersThreatIntelIndicatorValue {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorValue#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorValue#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersThreatIntelIndicatorValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorValue(obj: InsightSpecInitProviderFiltersThreatIntelIndicatorValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersTitle
 */
export interface InsightSpecInitProviderFiltersTitle {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersTitle#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersTitle#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersTitle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersTitle(obj: InsightSpecInitProviderFiltersTitle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersType
 */
export interface InsightSpecInitProviderFiltersType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersType#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersType#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersType(obj: InsightSpecInitProviderFiltersType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersUpdatedAt
 */
export interface InsightSpecInitProviderFiltersUpdatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecInitProviderFiltersUpdatedAt#dateRange
   */
  readonly dateRange?: InsightSpecInitProviderFiltersUpdatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersUpdatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecInitProviderFiltersUpdatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersUpdatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersUpdatedAt(obj: InsightSpecInitProviderFiltersUpdatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecInitProviderFiltersUpdatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersUserDefinedValues
 */
export interface InsightSpecInitProviderFiltersUserDefinedValues {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersUserDefinedValues#comparison
   */
  readonly comparison?: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecInitProviderFiltersUserDefinedValues#key
   */
  readonly key?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersUserDefinedValues#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersUserDefinedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersUserDefinedValues(obj: InsightSpecInitProviderFiltersUserDefinedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersVerificationState
 */
export interface InsightSpecInitProviderFiltersVerificationState {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersVerificationState#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersVerificationState#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersVerificationState' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersVerificationState(obj: InsightSpecInitProviderFiltersVerificationState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersWorkflowStatus
 */
export interface InsightSpecInitProviderFiltersWorkflowStatus {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecInitProviderFiltersWorkflowStatus#comparison
   */
  readonly comparison?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersWorkflowStatus#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersWorkflowStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersWorkflowStatus(obj: InsightSpecInitProviderFiltersWorkflowStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InsightSpecProviderConfigRefPolicyResolution
 */
export enum InsightSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InsightSpecProviderConfigRefPolicyResolve
 */
export enum InsightSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InsightSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InsightSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InsightSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InsightSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InsightSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InsightSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InsightSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecPublishConnectionDetailsToConfigRefPolicy(obj: InsightSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersCreatedAtDateRange
 */
export interface InsightSpecForProviderFiltersCreatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersCreatedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersCreatedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersCreatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersCreatedAtDateRange(obj: InsightSpecForProviderFiltersCreatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFirstObservedAtDateRange
 */
export interface InsightSpecForProviderFiltersFirstObservedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersFirstObservedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFirstObservedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFirstObservedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFirstObservedAtDateRange(obj: InsightSpecForProviderFiltersFirstObservedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersLastObservedAtDateRange
 */
export interface InsightSpecForProviderFiltersLastObservedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersLastObservedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersLastObservedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersLastObservedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersLastObservedAtDateRange(obj: InsightSpecForProviderFiltersLastObservedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNoteUpdatedAtDateRange
 */
export interface InsightSpecForProviderFiltersNoteUpdatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNoteUpdatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNoteUpdatedAtDateRange(obj: InsightSpecForProviderFiltersNoteUpdatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessLaunchedAtDateRange
 */
export interface InsightSpecForProviderFiltersProcessLaunchedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersProcessLaunchedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProcessLaunchedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessLaunchedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessLaunchedAtDateRange(obj: InsightSpecForProviderFiltersProcessLaunchedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessTerminatedAtDateRange
 */
export interface InsightSpecForProviderFiltersProcessTerminatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersProcessTerminatedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProcessTerminatedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessTerminatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessTerminatedAtDateRange(obj: InsightSpecForProviderFiltersProcessTerminatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange
 */
export interface InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange(obj: InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange
 */
export interface InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange(obj: InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange(obj: InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersUpdatedAtDateRange
 */
export interface InsightSpecForProviderFiltersUpdatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersUpdatedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersUpdatedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersUpdatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersUpdatedAtDateRange(obj: InsightSpecForProviderFiltersUpdatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersCreatedAtDateRange
 */
export interface InsightSpecInitProviderFiltersCreatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersCreatedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersCreatedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersCreatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersCreatedAtDateRange(obj: InsightSpecInitProviderFiltersCreatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersFirstObservedAtDateRange
 */
export interface InsightSpecInitProviderFiltersFirstObservedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersFirstObservedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersFirstObservedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersFirstObservedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersFirstObservedAtDateRange(obj: InsightSpecInitProviderFiltersFirstObservedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersLastObservedAtDateRange
 */
export interface InsightSpecInitProviderFiltersLastObservedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersLastObservedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersLastObservedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersLastObservedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersLastObservedAtDateRange(obj: InsightSpecInitProviderFiltersLastObservedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersNoteUpdatedAtDateRange
 */
export interface InsightSpecInitProviderFiltersNoteUpdatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersNoteUpdatedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersNoteUpdatedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersNoteUpdatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersNoteUpdatedAtDateRange(obj: InsightSpecInitProviderFiltersNoteUpdatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProcessLaunchedAtDateRange
 */
export interface InsightSpecInitProviderFiltersProcessLaunchedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersProcessLaunchedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersProcessLaunchedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProcessLaunchedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProcessLaunchedAtDateRange(obj: InsightSpecInitProviderFiltersProcessLaunchedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersProcessTerminatedAtDateRange
 */
export interface InsightSpecInitProviderFiltersProcessTerminatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersProcessTerminatedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersProcessTerminatedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersProcessTerminatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersProcessTerminatedAtDateRange(obj: InsightSpecInitProviderFiltersProcessTerminatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange
 */
export interface InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange(obj: InsightSpecInitProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange
 */
export interface InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange(obj: InsightSpecInitProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersResourceContainerLaunchedAtDateRange
 */
export interface InsightSpecInitProviderFiltersResourceContainerLaunchedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerLaunchedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersResourceContainerLaunchedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersResourceContainerLaunchedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersResourceContainerLaunchedAtDateRange(obj: InsightSpecInitProviderFiltersResourceContainerLaunchedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAtDateRange
 */
export interface InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAtDateRange(obj: InsightSpecInitProviderFiltersThreatIntelIndicatorLastObservedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecInitProviderFiltersUpdatedAtDateRange
 */
export interface InsightSpecInitProviderFiltersUpdatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecInitProviderFiltersUpdatedAtDateRange#unit
   */
  readonly unit?: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecInitProviderFiltersUpdatedAtDateRange#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'InsightSpecInitProviderFiltersUpdatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecInitProviderFiltersUpdatedAtDateRange(obj: InsightSpecInitProviderFiltersUpdatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InsightSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InsightSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InsightSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InsightSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InviteAccepter is the Schema for the InviteAccepters API. Accepts a Security Hub invitation.
 *
 * @schema InviteAccepter
 */
export class InviteAccepter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InviteAccepter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'InviteAccepter',
  }

  /**
   * Renders a Kubernetes manifest for "InviteAccepter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InviteAccepterProps): any {
    return {
      ...InviteAccepter.GVK,
      ...toJson_InviteAccepterProps(props),
    };
  }

  /**
   * Defines a "InviteAccepter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InviteAccepterProps) {
    super(scope, id, {
      ...InviteAccepter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InviteAccepter.GVK,
      ...toJson_InviteAccepterProps(resolved),
    };
  }
}

/**
 * InviteAccepter is the Schema for the InviteAccepters API. Accepts a Security Hub invitation.
 *
 * @schema InviteAccepter
 */
export interface InviteAccepterProps {
  /**
   * @schema InviteAccepter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InviteAccepterSpec defines the desired state of InviteAccepter
   *
   * @schema InviteAccepter#spec
   */
  readonly spec: InviteAccepterSpec;

}

/**
 * Converts an object of type 'InviteAccepterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterProps(obj: InviteAccepterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InviteAccepterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InviteAccepterSpec defines the desired state of InviteAccepter
 *
 * @schema InviteAccepterSpec
 */
export interface InviteAccepterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InviteAccepterSpec#deletionPolicy
   */
  readonly deletionPolicy?: InviteAccepterSpecDeletionPolicy;

  /**
   * @schema InviteAccepterSpec#forProvider
   */
  readonly forProvider: InviteAccepterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InviteAccepterSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InviteAccepterSpec#managementPolicies
   */
  readonly managementPolicies?: InviteAccepterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InviteAccepterSpec#providerConfigRef
   */
  readonly providerConfigRef?: InviteAccepterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InviteAccepterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InviteAccepterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InviteAccepterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InviteAccepterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InviteAccepterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpec(obj: InviteAccepterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InviteAccepterSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InviteAccepterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InviteAccepterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InviteAccepterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InviteAccepterSpecDeletionPolicy
 */
export enum InviteAccepterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InviteAccepterSpecForProvider
 */
export interface InviteAccepterSpecForProvider {
  /**
   * The account ID of the master Security Hub account whose invitation you're accepting.
   *
   * @schema InviteAccepterSpecForProvider#masterId
   */
  readonly masterId?: string;

  /**
   * Reference to a Member in securityhub to populate masterId.
   *
   * @schema InviteAccepterSpecForProvider#masterIdRef
   */
  readonly masterIdRef?: InviteAccepterSpecForProviderMasterIdRef;

  /**
   * Selector for a Member in securityhub to populate masterId.
   *
   * @schema InviteAccepterSpecForProvider#masterIdSelector
   */
  readonly masterIdSelector?: InviteAccepterSpecForProviderMasterIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InviteAccepterSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'InviteAccepterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecForProvider(obj: InviteAccepterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'masterId': obj.masterId,
    'masterIdRef': toJson_InviteAccepterSpecForProviderMasterIdRef(obj.masterIdRef),
    'masterIdSelector': toJson_InviteAccepterSpecForProviderMasterIdSelector(obj.masterIdSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InviteAccepterSpecManagementPolicies
 */
export enum InviteAccepterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InviteAccepterSpecProviderConfigRef
 */
export interface InviteAccepterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InviteAccepterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InviteAccepterSpecProviderConfigRef#policy
   */
  readonly policy?: InviteAccepterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InviteAccepterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecProviderConfigRef(obj: InviteAccepterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InviteAccepterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsTo
 */
export interface InviteAccepterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InviteAccepterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InviteAccepterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InviteAccepterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecPublishConnectionDetailsTo(obj: InviteAccepterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InviteAccepterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InviteAccepterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InviteAccepterSpecWriteConnectionSecretToRef
 */
export interface InviteAccepterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InviteAccepterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InviteAccepterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InviteAccepterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecWriteConnectionSecretToRef(obj: InviteAccepterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Member in securityhub to populate masterId.
 *
 * @schema InviteAccepterSpecForProviderMasterIdRef
 */
export interface InviteAccepterSpecForProviderMasterIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InviteAccepterSpecForProviderMasterIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InviteAccepterSpecForProviderMasterIdRef#policy
   */
  readonly policy?: InviteAccepterSpecForProviderMasterIdRefPolicy;

}

/**
 * Converts an object of type 'InviteAccepterSpecForProviderMasterIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecForProviderMasterIdRef(obj: InviteAccepterSpecForProviderMasterIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InviteAccepterSpecForProviderMasterIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Member in securityhub to populate masterId.
 *
 * @schema InviteAccepterSpecForProviderMasterIdSelector
 */
export interface InviteAccepterSpecForProviderMasterIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InviteAccepterSpecForProviderMasterIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InviteAccepterSpecForProviderMasterIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InviteAccepterSpecForProviderMasterIdSelector#policy
   */
  readonly policy?: InviteAccepterSpecForProviderMasterIdSelectorPolicy;

}

/**
 * Converts an object of type 'InviteAccepterSpecForProviderMasterIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecForProviderMasterIdSelector(obj: InviteAccepterSpecForProviderMasterIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InviteAccepterSpecForProviderMasterIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InviteAccepterSpecProviderConfigRefPolicy
 */
export interface InviteAccepterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InviteAccepterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InviteAccepterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InviteAccepterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InviteAccepterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InviteAccepterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecProviderConfigRefPolicy(obj: InviteAccepterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRef
 */
export interface InviteAccepterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InviteAccepterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecPublishConnectionDetailsToConfigRef(obj: InviteAccepterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsToMetadata
 */
export interface InviteAccepterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InviteAccepterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecPublishConnectionDetailsToMetadata(obj: InviteAccepterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InviteAccepterSpecForProviderMasterIdRefPolicy
 */
export interface InviteAccepterSpecForProviderMasterIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InviteAccepterSpecForProviderMasterIdRefPolicy#resolution
   */
  readonly resolution?: InviteAccepterSpecForProviderMasterIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InviteAccepterSpecForProviderMasterIdRefPolicy#resolve
   */
  readonly resolve?: InviteAccepterSpecForProviderMasterIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InviteAccepterSpecForProviderMasterIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecForProviderMasterIdRefPolicy(obj: InviteAccepterSpecForProviderMasterIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InviteAccepterSpecForProviderMasterIdSelectorPolicy
 */
export interface InviteAccepterSpecForProviderMasterIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InviteAccepterSpecForProviderMasterIdSelectorPolicy#resolution
   */
  readonly resolution?: InviteAccepterSpecForProviderMasterIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InviteAccepterSpecForProviderMasterIdSelectorPolicy#resolve
   */
  readonly resolve?: InviteAccepterSpecForProviderMasterIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InviteAccepterSpecForProviderMasterIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecForProviderMasterIdSelectorPolicy(obj: InviteAccepterSpecForProviderMasterIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InviteAccepterSpecProviderConfigRefPolicyResolution
 */
export enum InviteAccepterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InviteAccepterSpecProviderConfigRefPolicyResolve
 */
export enum InviteAccepterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj: InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InviteAccepterSpecForProviderMasterIdRefPolicyResolution
 */
export enum InviteAccepterSpecForProviderMasterIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InviteAccepterSpecForProviderMasterIdRefPolicyResolve
 */
export enum InviteAccepterSpecForProviderMasterIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InviteAccepterSpecForProviderMasterIdSelectorPolicyResolution
 */
export enum InviteAccepterSpecForProviderMasterIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InviteAccepterSpecForProviderMasterIdSelectorPolicyResolve
 */
export enum InviteAccepterSpecForProviderMasterIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Member is the Schema for the Members API. Provides a Security Hub member resource.
 *
 * @schema Member
 */
export class Member extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Member"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'Member',
  }

  /**
   * Renders a Kubernetes manifest for "Member".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MemberProps): any {
    return {
      ...Member.GVK,
      ...toJson_MemberProps(props),
    };
  }

  /**
   * Defines a "Member" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MemberProps) {
    super(scope, id, {
      ...Member.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Member.GVK,
      ...toJson_MemberProps(resolved),
    };
  }
}

/**
 * Member is the Schema for the Members API. Provides a Security Hub member resource.
 *
 * @schema Member
 */
export interface MemberProps {
  /**
   * @schema Member#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MemberSpec defines the desired state of Member
   *
   * @schema Member#spec
   */
  readonly spec: MemberSpec;

}

/**
 * Converts an object of type 'MemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberProps(obj: MemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MemberSpec defines the desired state of Member
 *
 * @schema MemberSpec
 */
export interface MemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: MemberSpecDeletionPolicy;

  /**
   * @schema MemberSpec#forProvider
   */
  readonly forProvider: MemberSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema MemberSpec#initProvider
   */
  readonly initProvider?: MemberSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema MemberSpec#managementPolicies
   */
  readonly managementPolicies?: MemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: MemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpec(obj: MemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_MemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_MemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_MemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MemberSpecDeletionPolicy
 */
export enum MemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MemberSpecForProvider
 */
export interface MemberSpecForProvider {
  /**
   * The ID of the member AWS account.
   *
   * @schema MemberSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * The email of the member AWS account.
   *
   * @schema MemberSpecForProvider#email
   */
  readonly email?: string;

  /**
   * Boolean whether to invite the account to Security Hub as a member. Defaults to false.
   *
   * @default false.
   * @schema MemberSpecForProvider#invite
   */
  readonly invite?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MemberSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'MemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProvider(obj: MemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'email': obj.email,
    'invite': obj.invite,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema MemberSpecInitProvider
 */
export interface MemberSpecInitProvider {
  /**
   * The ID of the member AWS account.
   *
   * @schema MemberSpecInitProvider#accountId
   */
  readonly accountId?: string;

  /**
   * The email of the member AWS account.
   *
   * @schema MemberSpecInitProvider#email
   */
  readonly email?: string;

  /**
   * Boolean whether to invite the account to Security Hub as a member. Defaults to false.
   *
   * @default false.
   * @schema MemberSpecInitProvider#invite
   */
  readonly invite?: boolean;

}

/**
 * Converts an object of type 'MemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecInitProvider(obj: MemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'email': obj.email,
    'invite': obj.invite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema MemberSpecManagementPolicies
 */
export enum MemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MemberSpecProviderConfigRef
 */
export interface MemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecProviderConfigRef#policy
   */
  readonly policy?: MemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderConfigRef(obj: MemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MemberSpecPublishConnectionDetailsTo
 */
export interface MemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsTo(obj: MemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MemberSpecWriteConnectionSecretToRef
 */
export interface MemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecWriteConnectionSecretToRef(obj: MemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecProviderConfigRefPolicy
 */
export interface MemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderConfigRefPolicy(obj: MemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRef
 */
export interface MemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToConfigRef(obj: MemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MemberSpecPublishConnectionDetailsToMetadata
 */
export interface MemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToMetadata(obj: MemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecProviderConfigRefPolicyResolution
 */
export enum MemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecProviderConfigRefPolicyResolve
 */
export enum MemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: MemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProductSubscription is the Schema for the ProductSubscriptions API. Subscribes to a Security Hub product.
 *
 * @schema ProductSubscription
 */
export class ProductSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProductSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'ProductSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "ProductSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProductSubscriptionProps): any {
    return {
      ...ProductSubscription.GVK,
      ...toJson_ProductSubscriptionProps(props),
    };
  }

  /**
   * Defines a "ProductSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProductSubscriptionProps) {
    super(scope, id, {
      ...ProductSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProductSubscription.GVK,
      ...toJson_ProductSubscriptionProps(resolved),
    };
  }
}

/**
 * ProductSubscription is the Schema for the ProductSubscriptions API. Subscribes to a Security Hub product.
 *
 * @schema ProductSubscription
 */
export interface ProductSubscriptionProps {
  /**
   * @schema ProductSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProductSubscriptionSpec defines the desired state of ProductSubscription
   *
   * @schema ProductSubscription#spec
   */
  readonly spec: ProductSubscriptionSpec;

}

/**
 * Converts an object of type 'ProductSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionProps(obj: ProductSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProductSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProductSubscriptionSpec defines the desired state of ProductSubscription
 *
 * @schema ProductSubscriptionSpec
 */
export interface ProductSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProductSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProductSubscriptionSpecDeletionPolicy;

  /**
   * @schema ProductSubscriptionSpec#forProvider
   */
  readonly forProvider: ProductSubscriptionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProductSubscriptionSpec#initProvider
   */
  readonly initProvider?: ProductSubscriptionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProductSubscriptionSpec#managementPolicies
   */
  readonly managementPolicies?: ProductSubscriptionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProductSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProductSubscriptionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProductSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProductSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProductSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProductSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProductSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpec(obj: ProductSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProductSubscriptionSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProductSubscriptionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProductSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProductSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProductSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProductSubscriptionSpecDeletionPolicy
 */
export enum ProductSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProductSubscriptionSpecForProvider
 */
export interface ProductSubscriptionSpecForProvider {
  /**
   * The ARN of the product that generates findings that you want to import into Security Hub - see below.
   *
   * @schema ProductSubscriptionSpecForProvider#productArn
   */
  readonly productArn?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProductSubscriptionSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecForProvider(obj: ProductSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'productArn': obj.productArn,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProductSubscriptionSpecInitProvider
 */
export interface ProductSubscriptionSpecInitProvider {
  /**
   * The ARN of the product that generates findings that you want to import into Security Hub - see below.
   *
   * @schema ProductSubscriptionSpecInitProvider#productArn
   */
  readonly productArn?: string;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecInitProvider(obj: ProductSubscriptionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'productArn': obj.productArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProductSubscriptionSpecManagementPolicies
 */
export enum ProductSubscriptionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProductSubscriptionSpecProviderConfigRef
 */
export interface ProductSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: ProductSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecProviderConfigRef(obj: ProductSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsTo
 */
export interface ProductSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProductSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProductSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecPublishConnectionDetailsTo(obj: ProductSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProductSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProductSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProductSubscriptionSpecWriteConnectionSecretToRef
 */
export interface ProductSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProductSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProductSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecWriteConnectionSecretToRef(obj: ProductSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProductSubscriptionSpecProviderConfigRefPolicy
 */
export interface ProductSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProductSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProductSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecProviderConfigRefPolicy(obj: ProductSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface ProductSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: ProductSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface ProductSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecPublishConnectionDetailsToMetadata(obj: ProductSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum ProductSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum ProductSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StandardsSubscription is the Schema for the StandardsSubscriptions API. Subscribes to a Security Hub standard.
 *
 * @schema StandardsSubscription
 */
export class StandardsSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StandardsSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'StandardsSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "StandardsSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StandardsSubscriptionProps): any {
    return {
      ...StandardsSubscription.GVK,
      ...toJson_StandardsSubscriptionProps(props),
    };
  }

  /**
   * Defines a "StandardsSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StandardsSubscriptionProps) {
    super(scope, id, {
      ...StandardsSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StandardsSubscription.GVK,
      ...toJson_StandardsSubscriptionProps(resolved),
    };
  }
}

/**
 * StandardsSubscription is the Schema for the StandardsSubscriptions API. Subscribes to a Security Hub standard.
 *
 * @schema StandardsSubscription
 */
export interface StandardsSubscriptionProps {
  /**
   * @schema StandardsSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StandardsSubscriptionSpec defines the desired state of StandardsSubscription
   *
   * @schema StandardsSubscription#spec
   */
  readonly spec: StandardsSubscriptionSpec;

}

/**
 * Converts an object of type 'StandardsSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionProps(obj: StandardsSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StandardsSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StandardsSubscriptionSpec defines the desired state of StandardsSubscription
 *
 * @schema StandardsSubscriptionSpec
 */
export interface StandardsSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StandardsSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: StandardsSubscriptionSpecDeletionPolicy;

  /**
   * @schema StandardsSubscriptionSpec#forProvider
   */
  readonly forProvider: StandardsSubscriptionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema StandardsSubscriptionSpec#initProvider
   */
  readonly initProvider?: StandardsSubscriptionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StandardsSubscriptionSpec#managementPolicies
   */
  readonly managementPolicies?: StandardsSubscriptionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StandardsSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: StandardsSubscriptionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StandardsSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StandardsSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StandardsSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StandardsSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpec(obj: StandardsSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StandardsSubscriptionSpecForProvider(obj.forProvider),
    'initProvider': toJson_StandardsSubscriptionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StandardsSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StandardsSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StandardsSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StandardsSubscriptionSpecDeletionPolicy
 */
export enum StandardsSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StandardsSubscriptionSpecForProvider
 */
export interface StandardsSubscriptionSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StandardsSubscriptionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of a standard - see below.
   *
   * @schema StandardsSubscriptionSpecForProvider#standardsArn
   */
  readonly standardsArn?: string;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecForProvider(obj: StandardsSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'standardsArn': obj.standardsArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema StandardsSubscriptionSpecInitProvider
 */
export interface StandardsSubscriptionSpecInitProvider {
  /**
   * The ARN of a standard - see below.
   *
   * @schema StandardsSubscriptionSpecInitProvider#standardsArn
   */
  readonly standardsArn?: string;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecInitProvider(obj: StandardsSubscriptionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'standardsArn': obj.standardsArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema StandardsSubscriptionSpecManagementPolicies
 */
export enum StandardsSubscriptionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StandardsSubscriptionSpecProviderConfigRef
 */
export interface StandardsSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StandardsSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StandardsSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: StandardsSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecProviderConfigRef(obj: StandardsSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StandardsSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsTo
 */
export interface StandardsSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StandardsSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecPublishConnectionDetailsTo(obj: StandardsSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StandardsSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StandardsSubscriptionSpecWriteConnectionSecretToRef
 */
export interface StandardsSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StandardsSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StandardsSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecWriteConnectionSecretToRef(obj: StandardsSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StandardsSubscriptionSpecProviderConfigRefPolicy
 */
export interface StandardsSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StandardsSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StandardsSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StandardsSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StandardsSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecProviderConfigRefPolicy(obj: StandardsSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface StandardsSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecPublishConnectionDetailsToMetadata(obj: StandardsSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StandardsSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum StandardsSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StandardsSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum StandardsSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

