// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Account is the Schema for the Accounts API. Enables Security Hub for an AWS account.
 *
 * @schema Account
 */
export class Account extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Account"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'Account',
  }

  /**
   * Renders a Kubernetes manifest for "Account".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccountProps): any {
    return {
      ...Account.GVK,
      ...toJson_AccountProps(props),
    };
  }

  /**
   * Defines a "Account" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccountProps) {
    super(scope, id, {
      ...Account.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Account.GVK,
      ...toJson_AccountProps(resolved),
    };
  }
}

/**
 * Account is the Schema for the Accounts API. Enables Security Hub for an AWS account.
 *
 * @schema Account
 */
export interface AccountProps {
  /**
   * @schema Account#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccountSpec defines the desired state of Account
   *
   * @schema Account#spec
   */
  readonly spec: AccountSpec;

}

/**
 * Converts an object of type 'AccountProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountProps(obj: AccountProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccountSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccountSpec defines the desired state of Account
 *
 * @schema AccountSpec
 */
export interface AccountSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AccountSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccountSpecDeletionPolicy;

  /**
   * @schema AccountSpec#forProvider
   */
  readonly forProvider: AccountSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccountSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccountSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AccountSpec#providerRef
   */
  readonly providerRef?: AccountSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccountSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccountSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccountSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccountSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccountSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpec(obj: AccountSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccountSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AccountSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AccountSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AccountSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccountSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AccountSpecDeletionPolicy
 */
export enum AccountSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccountSpecForProvider
 */
export interface AccountSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccountSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AccountSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecForProvider(obj: AccountSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccountSpecProviderConfigRef
 */
export interface AccountSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecProviderConfigRef#policy
   */
  readonly policy?: AccountSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderConfigRef(obj: AccountSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AccountSpecProviderRef
 */
export interface AccountSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecProviderRef#policy
   */
  readonly policy?: AccountSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderRef(obj: AccountSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccountSpecPublishConnectionDetailsTo
 */
export interface AccountSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccountSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccountSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsTo(obj: AccountSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccountSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccountSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccountSpecWriteConnectionSecretToRef
 */
export interface AccountSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccountSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccountSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccountSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecWriteConnectionSecretToRef(obj: AccountSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSpecProviderConfigRefPolicy
 */
export interface AccountSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderConfigRefPolicy(obj: AccountSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSpecProviderRefPolicy
 */
export interface AccountSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AccountSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AccountSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderRefPolicy(obj: AccountSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRef
 */
export interface AccountSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccountSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToConfigRef(obj: AccountSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccountSpecPublishConnectionDetailsToMetadata
 */
export interface AccountSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToMetadata(obj: AccountSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecProviderConfigRefPolicyResolution
 */
export enum AccountSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecProviderConfigRefPolicyResolve
 */
export enum AccountSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecProviderRefPolicyResolution
 */
export enum AccountSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecProviderRefPolicyResolve
 */
export enum AccountSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccountSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccountSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ActionTarget is the Schema for the ActionTargets API. Creates Security Hub custom action.
 *
 * @schema ActionTarget
 */
export class ActionTarget extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ActionTarget"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'ActionTarget',
  }

  /**
   * Renders a Kubernetes manifest for "ActionTarget".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ActionTargetProps): any {
    return {
      ...ActionTarget.GVK,
      ...toJson_ActionTargetProps(props),
    };
  }

  /**
   * Defines a "ActionTarget" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ActionTargetProps) {
    super(scope, id, {
      ...ActionTarget.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ActionTarget.GVK,
      ...toJson_ActionTargetProps(resolved),
    };
  }
}

/**
 * ActionTarget is the Schema for the ActionTargets API. Creates Security Hub custom action.
 *
 * @schema ActionTarget
 */
export interface ActionTargetProps {
  /**
   * @schema ActionTarget#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ActionTargetSpec defines the desired state of ActionTarget
   *
   * @schema ActionTarget#spec
   */
  readonly spec: ActionTargetSpec;

}

/**
 * Converts an object of type 'ActionTargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetProps(obj: ActionTargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ActionTargetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionTargetSpec defines the desired state of ActionTarget
 *
 * @schema ActionTargetSpec
 */
export interface ActionTargetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ActionTargetSpec#deletionPolicy
   */
  readonly deletionPolicy?: ActionTargetSpecDeletionPolicy;

  /**
   * @schema ActionTargetSpec#forProvider
   */
  readonly forProvider: ActionTargetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ActionTargetSpec#providerConfigRef
   */
  readonly providerConfigRef?: ActionTargetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ActionTargetSpec#providerRef
   */
  readonly providerRef?: ActionTargetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ActionTargetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ActionTargetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ActionTargetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ActionTargetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ActionTargetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpec(obj: ActionTargetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ActionTargetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ActionTargetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ActionTargetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ActionTargetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ActionTargetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ActionTargetSpecDeletionPolicy
 */
export enum ActionTargetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ActionTargetSpecForProvider
 */
export interface ActionTargetSpecForProvider {
  /**
   * The name of the custom action target.
   *
   * @schema ActionTargetSpecForProvider#description
   */
  readonly description: string;

  /**
   * The description for the custom action target.
   *
   * @schema ActionTargetSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ActionTargetSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ActionTargetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecForProvider(obj: ActionTargetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ActionTargetSpecProviderConfigRef
 */
export interface ActionTargetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActionTargetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActionTargetSpecProviderConfigRef#policy
   */
  readonly policy?: ActionTargetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ActionTargetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecProviderConfigRef(obj: ActionTargetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActionTargetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ActionTargetSpecProviderRef
 */
export interface ActionTargetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActionTargetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActionTargetSpecProviderRef#policy
   */
  readonly policy?: ActionTargetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ActionTargetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecProviderRef(obj: ActionTargetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActionTargetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsTo
 */
export interface ActionTargetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ActionTargetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ActionTargetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ActionTargetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecPublishConnectionDetailsTo(obj: ActionTargetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ActionTargetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ActionTargetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ActionTargetSpecWriteConnectionSecretToRef
 */
export interface ActionTargetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ActionTargetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ActionTargetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ActionTargetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecWriteConnectionSecretToRef(obj: ActionTargetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ActionTargetSpecProviderConfigRefPolicy
 */
export interface ActionTargetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActionTargetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ActionTargetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActionTargetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ActionTargetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ActionTargetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecProviderConfigRefPolicy(obj: ActionTargetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ActionTargetSpecProviderRefPolicy
 */
export interface ActionTargetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActionTargetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ActionTargetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActionTargetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ActionTargetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ActionTargetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecProviderRefPolicy(obj: ActionTargetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsToConfigRef
 */
export interface ActionTargetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ActionTargetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecPublishConnectionDetailsToConfigRef(obj: ActionTargetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsToMetadata
 */
export interface ActionTargetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ActionTargetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecPublishConnectionDetailsToMetadata(obj: ActionTargetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActionTargetSpecProviderConfigRefPolicyResolution
 */
export enum ActionTargetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActionTargetSpecProviderConfigRefPolicyResolve
 */
export enum ActionTargetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActionTargetSpecProviderRefPolicyResolution
 */
export enum ActionTargetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActionTargetSpecProviderRefPolicyResolve
 */
export enum ActionTargetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj: ActionTargetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ActionTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FindingAggregator is the Schema for the FindingAggregators API. Manages a Security Hub finding aggregator
 *
 * @schema FindingAggregator
 */
export class FindingAggregator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FindingAggregator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'FindingAggregator',
  }

  /**
   * Renders a Kubernetes manifest for "FindingAggregator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FindingAggregatorProps): any {
    return {
      ...FindingAggregator.GVK,
      ...toJson_FindingAggregatorProps(props),
    };
  }

  /**
   * Defines a "FindingAggregator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FindingAggregatorProps) {
    super(scope, id, {
      ...FindingAggregator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FindingAggregator.GVK,
      ...toJson_FindingAggregatorProps(resolved),
    };
  }
}

/**
 * FindingAggregator is the Schema for the FindingAggregators API. Manages a Security Hub finding aggregator
 *
 * @schema FindingAggregator
 */
export interface FindingAggregatorProps {
  /**
   * @schema FindingAggregator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FindingAggregatorSpec defines the desired state of FindingAggregator
   *
   * @schema FindingAggregator#spec
   */
  readonly spec: FindingAggregatorSpec;

}

/**
 * Converts an object of type 'FindingAggregatorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorProps(obj: FindingAggregatorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FindingAggregatorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FindingAggregatorSpec defines the desired state of FindingAggregator
 *
 * @schema FindingAggregatorSpec
 */
export interface FindingAggregatorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema FindingAggregatorSpec#deletionPolicy
   */
  readonly deletionPolicy?: FindingAggregatorSpecDeletionPolicy;

  /**
   * @schema FindingAggregatorSpec#forProvider
   */
  readonly forProvider: FindingAggregatorSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FindingAggregatorSpec#providerConfigRef
   */
  readonly providerConfigRef?: FindingAggregatorSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FindingAggregatorSpec#providerRef
   */
  readonly providerRef?: FindingAggregatorSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FindingAggregatorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FindingAggregatorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FindingAggregatorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FindingAggregatorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FindingAggregatorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpec(obj: FindingAggregatorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FindingAggregatorSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_FindingAggregatorSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FindingAggregatorSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FindingAggregatorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FindingAggregatorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema FindingAggregatorSpecDeletionPolicy
 */
export enum FindingAggregatorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FindingAggregatorSpecForProvider
 */
export interface FindingAggregatorSpecForProvider {
  /**
   * Indicates whether to aggregate findings from all of the available Regions or from a specified list. The options are ALL_REGIONS, ALL_REGIONS_EXCEPT_SPECIFIED or SPECIFIED_REGIONS. When ALL_REGIONS or ALL_REGIONS_EXCEPT_SPECIFIED are used, Security Hub will automatically aggregate findings from new Regions as Security Hub supports them and you opt into them.
   *
   * @schema FindingAggregatorSpecForProvider#linkingMode
   */
  readonly linkingMode: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FindingAggregatorSpecForProvider#region
   */
  readonly region: string;

  /**
   * List of regions to include or exclude
   *
   * @schema FindingAggregatorSpecForProvider#specifiedRegions
   */
  readonly specifiedRegions?: string[];

}

/**
 * Converts an object of type 'FindingAggregatorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecForProvider(obj: FindingAggregatorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linkingMode': obj.linkingMode,
    'region': obj.region,
    'specifiedRegions': obj.specifiedRegions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FindingAggregatorSpecProviderConfigRef
 */
export interface FindingAggregatorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FindingAggregatorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FindingAggregatorSpecProviderConfigRef#policy
   */
  readonly policy?: FindingAggregatorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FindingAggregatorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecProviderConfigRef(obj: FindingAggregatorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FindingAggregatorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FindingAggregatorSpecProviderRef
 */
export interface FindingAggregatorSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FindingAggregatorSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FindingAggregatorSpecProviderRef#policy
   */
  readonly policy?: FindingAggregatorSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FindingAggregatorSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecProviderRef(obj: FindingAggregatorSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FindingAggregatorSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsTo
 */
export interface FindingAggregatorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FindingAggregatorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FindingAggregatorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FindingAggregatorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecPublishConnectionDetailsTo(obj: FindingAggregatorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FindingAggregatorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FindingAggregatorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FindingAggregatorSpecWriteConnectionSecretToRef
 */
export interface FindingAggregatorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FindingAggregatorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FindingAggregatorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FindingAggregatorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecWriteConnectionSecretToRef(obj: FindingAggregatorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FindingAggregatorSpecProviderConfigRefPolicy
 */
export interface FindingAggregatorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FindingAggregatorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FindingAggregatorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FindingAggregatorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FindingAggregatorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FindingAggregatorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecProviderConfigRefPolicy(obj: FindingAggregatorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FindingAggregatorSpecProviderRefPolicy
 */
export interface FindingAggregatorSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FindingAggregatorSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FindingAggregatorSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FindingAggregatorSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FindingAggregatorSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FindingAggregatorSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecProviderRefPolicy(obj: FindingAggregatorSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRef
 */
export interface FindingAggregatorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FindingAggregatorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecPublishConnectionDetailsToConfigRef(obj: FindingAggregatorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsToMetadata
 */
export interface FindingAggregatorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FindingAggregatorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecPublishConnectionDetailsToMetadata(obj: FindingAggregatorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FindingAggregatorSpecProviderConfigRefPolicyResolution
 */
export enum FindingAggregatorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FindingAggregatorSpecProviderConfigRefPolicyResolve
 */
export enum FindingAggregatorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FindingAggregatorSpecProviderRefPolicyResolution
 */
export enum FindingAggregatorSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FindingAggregatorSpecProviderRefPolicyResolve
 */
export enum FindingAggregatorSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy(obj: FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FindingAggregatorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Insight is the Schema for the Insights API. Provides a Security Hub custom insight resource.
 *
 * @schema Insight
 */
export class Insight extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Insight"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'Insight',
  }

  /**
   * Renders a Kubernetes manifest for "Insight".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InsightProps): any {
    return {
      ...Insight.GVK,
      ...toJson_InsightProps(props),
    };
  }

  /**
   * Defines a "Insight" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InsightProps) {
    super(scope, id, {
      ...Insight.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Insight.GVK,
      ...toJson_InsightProps(resolved),
    };
  }
}

/**
 * Insight is the Schema for the Insights API. Provides a Security Hub custom insight resource.
 *
 * @schema Insight
 */
export interface InsightProps {
  /**
   * @schema Insight#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InsightSpec defines the desired state of Insight
   *
   * @schema Insight#spec
   */
  readonly spec: InsightSpec;

}

/**
 * Converts an object of type 'InsightProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightProps(obj: InsightProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InsightSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InsightSpec defines the desired state of Insight
 *
 * @schema InsightSpec
 */
export interface InsightSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema InsightSpec#deletionPolicy
   */
  readonly deletionPolicy?: InsightSpecDeletionPolicy;

  /**
   * @schema InsightSpec#forProvider
   */
  readonly forProvider: InsightSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InsightSpec#providerConfigRef
   */
  readonly providerConfigRef?: InsightSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InsightSpec#providerRef
   */
  readonly providerRef?: InsightSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InsightSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InsightSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InsightSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InsightSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InsightSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpec(obj: InsightSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InsightSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_InsightSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InsightSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InsightSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InsightSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema InsightSpecDeletionPolicy
 */
export enum InsightSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InsightSpecForProvider
 */
export interface InsightSpecForProvider {
  /**
   * A configuration block including one or more (up to 10 distinct) attributes used to filter the findings included in the insight. The insight only includes findings that match criteria defined in the filters. See filters below for more details.
   *
   * @schema InsightSpecForProvider#filters
   */
  readonly filters: InsightSpecForProviderFilters[];

  /**
   * The attribute used to group the findings for the insight e.g., if an insight is grouped by ResourceId, then the insight produces a list of resource identifiers.
   *
   * @schema InsightSpecForProvider#groupByAttribute
   */
  readonly groupByAttribute: string;

  /**
   * The name of the custom insight.
   *
   * @schema InsightSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InsightSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'InsightSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProvider(obj: InsightSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filters': obj.filters?.map(y => toJson_InsightSpecForProviderFilters(y)),
    'groupByAttribute': obj.groupByAttribute,
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InsightSpecProviderConfigRef
 */
export interface InsightSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InsightSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InsightSpecProviderConfigRef#policy
   */
  readonly policy?: InsightSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InsightSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecProviderConfigRef(obj: InsightSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InsightSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InsightSpecProviderRef
 */
export interface InsightSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InsightSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InsightSpecProviderRef#policy
   */
  readonly policy?: InsightSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InsightSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecProviderRef(obj: InsightSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InsightSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InsightSpecPublishConnectionDetailsTo
 */
export interface InsightSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InsightSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InsightSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InsightSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InsightSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InsightSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InsightSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecPublishConnectionDetailsTo(obj: InsightSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InsightSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InsightSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InsightSpecWriteConnectionSecretToRef
 */
export interface InsightSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InsightSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InsightSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InsightSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecWriteConnectionSecretToRef(obj: InsightSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFilters
 */
export interface InsightSpecForProviderFilters {
  /**
   * AWS account ID that a finding is generated in. See String_Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#awsAccountId
   */
  readonly awsAccountId?: InsightSpecForProviderFiltersAwsAccountId[];

  /**
   * The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#companyName
   */
  readonly companyName?: InsightSpecForProviderFiltersCompanyName[];

  /**
   * Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#complianceStatus
   */
  readonly complianceStatus?: InsightSpecForProviderFiltersComplianceStatus[];

  /**
   * A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#confidence
   */
  readonly confidence?: InsightSpecForProviderFiltersConfidence[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#createdAt
   */
  readonly createdAt?: InsightSpecForProviderFiltersCreatedAt[];

  /**
   * The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#criticality
   */
  readonly criticality?: InsightSpecForProviderFiltersCriticality[];

  /**
   * A finding's description. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#description
   */
  readonly description?: InsightSpecForProviderFiltersDescription[];

  /**
   * The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsConfidence
   */
  readonly findingProviderFieldsConfidence?: InsightSpecForProviderFiltersFindingProviderFieldsConfidence[];

  /**
   * The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsCriticality
   */
  readonly findingProviderFieldsCriticality?: InsightSpecForProviderFiltersFindingProviderFieldsCriticality[];

  /**
   * The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsRelatedFindingsId
   */
  readonly findingProviderFieldsRelatedFindingsId?: InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId[];

  /**
   * The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsRelatedFindingsProductArn
   */
  readonly findingProviderFieldsRelatedFindingsProductArn?: InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn[];

  /**
   * The finding provider value for the severity label. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsSeverityLabel
   */
  readonly findingProviderFieldsSeverityLabel?: InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel[];

  /**
   * The finding provider's original value for the severity. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsSeverityOriginal
   */
  readonly findingProviderFieldsSeverityOriginal?: InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal[];

  /**
   * One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values include: Software and Configuration Checks, TTPs, Effects, Unusual Behaviors, and Sensitive Data Identifications. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#findingProviderFieldsTypes
   */
  readonly findingProviderFieldsTypes?: InsightSpecForProviderFiltersFindingProviderFieldsTypes[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#firstObservedAt
   */
  readonly firstObservedAt?: InsightSpecForProviderFiltersFirstObservedAt[];

  /**
   * The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#generatorId
   */
  readonly generatorId?: InsightSpecForProviderFiltersGeneratorId[];

  /**
   * The security findings provider-specific identifier for a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#id
   */
  readonly id?: InsightSpecForProviderFiltersId[];

  /**
   * A keyword for a finding. See Keyword Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#keyword
   */
  readonly keyword?: InsightSpecForProviderFiltersKeyword[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#lastObservedAt
   */
  readonly lastObservedAt?: InsightSpecForProviderFiltersLastObservedAt[];

  /**
   * The name of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#malwareName
   */
  readonly malwareName?: InsightSpecForProviderFiltersMalwareName[];

  /**
   * The filesystem path of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#malwarePath
   */
  readonly malwarePath?: InsightSpecForProviderFiltersMalwarePath[];

  /**
   * The state of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#malwareState
   */
  readonly malwareState?: InsightSpecForProviderFiltersMalwareState[];

  /**
   * The type of the malware that was observed. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#malwareType
   */
  readonly malwareType?: InsightSpecForProviderFiltersMalwareType[];

  /**
   * The destination domain of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkDestinationDomain
   */
  readonly networkDestinationDomain?: InsightSpecForProviderFiltersNetworkDestinationDomain[];

  /**
   * The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkDestinationIpv4
   */
  readonly networkDestinationIpv4?: InsightSpecForProviderFiltersNetworkDestinationIpv4[];

  /**
   * The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkDestinationIpv6
   */
  readonly networkDestinationIpv6?: InsightSpecForProviderFiltersNetworkDestinationIpv6[];

  /**
   * The destination port of network-related information about a finding. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkDestinationPort
   */
  readonly networkDestinationPort?: InsightSpecForProviderFiltersNetworkDestinationPort[];

  /**
   * Indicates the direction of network traffic associated with a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkDirection
   */
  readonly networkDirection?: InsightSpecForProviderFiltersNetworkDirection[];

  /**
   * The protocol of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkProtocol
   */
  readonly networkProtocol?: InsightSpecForProviderFiltersNetworkProtocol[];

  /**
   * The source domain of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkSourceDomain
   */
  readonly networkSourceDomain?: InsightSpecForProviderFiltersNetworkSourceDomain[];

  /**
   * The source IPv4 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkSourceIpv4
   */
  readonly networkSourceIpv4?: InsightSpecForProviderFiltersNetworkSourceIpv4[];

  /**
   * The source IPv6 address of network-related information about a finding. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkSourceIpv6
   */
  readonly networkSourceIpv6?: InsightSpecForProviderFiltersNetworkSourceIpv6[];

  /**
   * The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkSourceMac
   */
  readonly networkSourceMac?: InsightSpecForProviderFiltersNetworkSourceMac[];

  /**
   * The source port of network-related information about a finding. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#networkSourcePort
   */
  readonly networkSourcePort?: InsightSpecForProviderFiltersNetworkSourcePort[];

  /**
   * The text of a note. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#noteText
   */
  readonly noteText?: InsightSpecForProviderFiltersNoteText[];

  /**
   * The timestamp of when the note was updated. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#noteUpdatedAt
   */
  readonly noteUpdatedAt?: InsightSpecForProviderFiltersNoteUpdatedAt[];

  /**
   * The principal that created a note. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#noteUpdatedBy
   */
  readonly noteUpdatedBy?: InsightSpecForProviderFiltersNoteUpdatedBy[];

  /**
   * The date/time that the process was launched. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processLaunchedAt
   */
  readonly processLaunchedAt?: InsightSpecForProviderFiltersProcessLaunchedAt[];

  /**
   * The name of the process. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processName
   */
  readonly processName?: InsightSpecForProviderFiltersProcessName[];

  /**
   * The parent process ID. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processParentPid
   */
  readonly processParentPid?: InsightSpecForProviderFiltersProcessParentPid[];

  /**
   * The path to the process executable. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processPath
   */
  readonly processPath?: InsightSpecForProviderFiltersProcessPath[];

  /**
   * The process ID. See Number Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processPid
   */
  readonly processPid?: InsightSpecForProviderFiltersProcessPid[];

  /**
   * The date/time that the process was terminated. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#processTerminatedAt
   */
  readonly processTerminatedAt?: InsightSpecForProviderFiltersProcessTerminatedAt[];

  /**
   * The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#productArn
   */
  readonly productArn?: InsightSpecForProviderFiltersProductArn[];

  /**
   * A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. See Map Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#productFields
   */
  readonly productFields?: InsightSpecForProviderFiltersProductFields[];

  /**
   * The name of the solution (product) that generates findings. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#productName
   */
  readonly productName?: InsightSpecForProviderFiltersProductName[];

  /**
   * The recommendation of what to do about the issue described in a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#recommendationText
   */
  readonly recommendationText?: InsightSpecForProviderFiltersRecommendationText[];

  /**
   * The updated record state for the finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#recordState
   */
  readonly recordState?: InsightSpecForProviderFiltersRecordState[];

  /**
   * The solution-generated identifier for a related finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#relatedFindingsId
   */
  readonly relatedFindingsId?: InsightSpecForProviderFiltersRelatedFindingsId[];

  /**
   * The ARN of the solution that generated a related finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#relatedFindingsProductArn
   */
  readonly relatedFindingsProductArn?: InsightSpecForProviderFiltersRelatedFindingsProductArn[];

  /**
   * The IAM profile ARN of the instance. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceIamInstanceProfileArn
   */
  readonly resourceAwsEc2InstanceIamInstanceProfileArn?: InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn[];

  /**
   * The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceImageId
   */
  readonly resourceAwsEc2InstanceImageId?: InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId[];

  /**
   * The IPv4 addresses associated with the instance. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceIpv4Addresses
   */
  readonly resourceAwsEc2InstanceIpv4Addresses?: InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses[];

  /**
   * The IPv6 addresses associated with the instance. See Ip Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceIpv6Addresses
   */
  readonly resourceAwsEc2InstanceIpv6Addresses?: InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses[];

  /**
   * The key name associated with the instance. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceKeyName
   */
  readonly resourceAwsEc2InstanceKeyName?: InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName[];

  /**
   * The date and time the instance was launched. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceLaunchedAt
   */
  readonly resourceAwsEc2InstanceLaunchedAt?: InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt[];

  /**
   * The identifier of the subnet that the instance was launched in. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceSubnetId
   */
  readonly resourceAwsEc2InstanceSubnetId?: InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId[];

  /**
   * The instance type of the instance. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceType
   */
  readonly resourceAwsEc2InstanceType?: InsightSpecForProviderFiltersResourceAwsEc2InstanceType[];

  /**
   * The identifier of the VPC that the instance was launched in. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsEc2InstanceVpcId
   */
  readonly resourceAwsEc2InstanceVpcId?: InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId[];

  /**
   * The creation date/time of the IAM access key related to a finding. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsIamAccessKeyCreatedAt
   */
  readonly resourceAwsIamAccessKeyCreatedAt?: InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt[];

  /**
   * The status of the IAM access key related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsIamAccessKeyStatus
   */
  readonly resourceAwsIamAccessKeyStatus?: InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus[];

  /**
   * The user associated with the IAM access key related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsIamAccessKeyUserName
   */
  readonly resourceAwsIamAccessKeyUserName?: InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName[];

  /**
   * The canonical user ID of the owner of the S3 bucket. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsS3BucketOwnerId
   */
  readonly resourceAwsS3BucketOwnerId?: InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId[];

  /**
   * The display name of the owner of the S3 bucket. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceAwsS3BucketOwnerName
   */
  readonly resourceAwsS3BucketOwnerName?: InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName[];

  /**
   * The identifier of the image related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceContainerImageId
   */
  readonly resourceContainerImageId?: InsightSpecForProviderFiltersResourceContainerImageId[];

  /**
   * The name of the image related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceContainerImageName
   */
  readonly resourceContainerImageName?: InsightSpecForProviderFiltersResourceContainerImageName[];

  /**
   * The date/time that the container was started. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceContainerLaunchedAt
   */
  readonly resourceContainerLaunchedAt?: InsightSpecForProviderFiltersResourceContainerLaunchedAt[];

  /**
   * The name of the container related to a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceContainerName
   */
  readonly resourceContainerName?: InsightSpecForProviderFiltersResourceContainerName[];

  /**
   * The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceDetailsOther
   */
  readonly resourceDetailsOther?: InsightSpecForProviderFiltersResourceDetailsOther[];

  /**
   * The canonical identifier for the given resource type. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceId
   */
  readonly resourceId?: InsightSpecForProviderFiltersResourceId[];

  /**
   * The canonical AWS partition name that the Region is assigned to. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourcePartition
   */
  readonly resourcePartition?: InsightSpecForProviderFiltersResourcePartition[];

  /**
   * The canonical AWS external Region name where this resource is located. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceRegion
   */
  readonly resourceRegion?: InsightSpecForProviderFiltersResourceRegion[];

  /**
   * A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceTags
   */
  readonly resourceTags?: InsightSpecForProviderFiltersResourceTags[];

  /**
   * Specifies the type of the resource that details are provided for. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#resourceType
   */
  readonly resourceType?: InsightSpecForProviderFiltersResourceType[];

  /**
   * The label of a finding's severity. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#severityLabel
   */
  readonly severityLabel?: InsightSpecForProviderFiltersSeverityLabel[];

  /**
   * A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#sourceUrl
   */
  readonly sourceUrl?: InsightSpecForProviderFiltersSourceUrl[];

  /**
   * The category of a threat intelligence indicator. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorCategory
   */
  readonly threatIntelIndicatorCategory?: InsightSpecForProviderFiltersThreatIntelIndicatorCategory[];

  /**
   * The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorLastObservedAt
   */
  readonly threatIntelIndicatorLastObservedAt?: InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt[];

  /**
   * The source of the threat intelligence. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorSource
   */
  readonly threatIntelIndicatorSource?: InsightSpecForProviderFiltersThreatIntelIndicatorSource[];

  /**
   * The URL for more details from the source of the threat intelligence. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorSourceUrl
   */
  readonly threatIntelIndicatorSourceUrl?: InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl[];

  /**
   * The type of a threat intelligence indicator. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorType
   */
  readonly threatIntelIndicatorType?: InsightSpecForProviderFiltersThreatIntelIndicatorType[];

  /**
   * The value of a threat intelligence indicator. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#threatIntelIndicatorValue
   */
  readonly threatIntelIndicatorValue?: InsightSpecForProviderFiltersThreatIntelIndicatorValue[];

  /**
   * A finding's title. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#title
   */
  readonly title?: InsightSpecForProviderFiltersTitle[];

  /**
   * A finding type in the format of namespace/category/classifier that classifies a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#type
   */
  readonly type?: InsightSpecForProviderFiltersType[];

  /**
   * An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#updatedAt
   */
  readonly updatedAt?: InsightSpecForProviderFiltersUpdatedAt[];

  /**
   * A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#userDefinedValues
   */
  readonly userDefinedValues?: InsightSpecForProviderFiltersUserDefinedValues[];

  /**
   * The veracity of a finding. See String Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#verificationState
   */
  readonly verificationState?: InsightSpecForProviderFiltersVerificationState[];

  /**
   * The status of the investigation into a finding. See Workflow Status Filter below for more details.
   *
   * @schema InsightSpecForProviderFilters#workflowStatus
   */
  readonly workflowStatus?: InsightSpecForProviderFiltersWorkflowStatus[];

}

/**
 * Converts an object of type 'InsightSpecForProviderFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFilters(obj: InsightSpecForProviderFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAccountId': obj.awsAccountId?.map(y => toJson_InsightSpecForProviderFiltersAwsAccountId(y)),
    'companyName': obj.companyName?.map(y => toJson_InsightSpecForProviderFiltersCompanyName(y)),
    'complianceStatus': obj.complianceStatus?.map(y => toJson_InsightSpecForProviderFiltersComplianceStatus(y)),
    'confidence': obj.confidence?.map(y => toJson_InsightSpecForProviderFiltersConfidence(y)),
    'createdAt': obj.createdAt?.map(y => toJson_InsightSpecForProviderFiltersCreatedAt(y)),
    'criticality': obj.criticality?.map(y => toJson_InsightSpecForProviderFiltersCriticality(y)),
    'description': obj.description?.map(y => toJson_InsightSpecForProviderFiltersDescription(y)),
    'findingProviderFieldsConfidence': obj.findingProviderFieldsConfidence?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsConfidence(y)),
    'findingProviderFieldsCriticality': obj.findingProviderFieldsCriticality?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsCriticality(y)),
    'findingProviderFieldsRelatedFindingsId': obj.findingProviderFieldsRelatedFindingsId?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId(y)),
    'findingProviderFieldsRelatedFindingsProductArn': obj.findingProviderFieldsRelatedFindingsProductArn?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn(y)),
    'findingProviderFieldsSeverityLabel': obj.findingProviderFieldsSeverityLabel?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel(y)),
    'findingProviderFieldsSeverityOriginal': obj.findingProviderFieldsSeverityOriginal?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal(y)),
    'findingProviderFieldsTypes': obj.findingProviderFieldsTypes?.map(y => toJson_InsightSpecForProviderFiltersFindingProviderFieldsTypes(y)),
    'firstObservedAt': obj.firstObservedAt?.map(y => toJson_InsightSpecForProviderFiltersFirstObservedAt(y)),
    'generatorId': obj.generatorId?.map(y => toJson_InsightSpecForProviderFiltersGeneratorId(y)),
    'id': obj.id?.map(y => toJson_InsightSpecForProviderFiltersId(y)),
    'keyword': obj.keyword?.map(y => toJson_InsightSpecForProviderFiltersKeyword(y)),
    'lastObservedAt': obj.lastObservedAt?.map(y => toJson_InsightSpecForProviderFiltersLastObservedAt(y)),
    'malwareName': obj.malwareName?.map(y => toJson_InsightSpecForProviderFiltersMalwareName(y)),
    'malwarePath': obj.malwarePath?.map(y => toJson_InsightSpecForProviderFiltersMalwarePath(y)),
    'malwareState': obj.malwareState?.map(y => toJson_InsightSpecForProviderFiltersMalwareState(y)),
    'malwareType': obj.malwareType?.map(y => toJson_InsightSpecForProviderFiltersMalwareType(y)),
    'networkDestinationDomain': obj.networkDestinationDomain?.map(y => toJson_InsightSpecForProviderFiltersNetworkDestinationDomain(y)),
    'networkDestinationIpv4': obj.networkDestinationIpv4?.map(y => toJson_InsightSpecForProviderFiltersNetworkDestinationIpv4(y)),
    'networkDestinationIpv6': obj.networkDestinationIpv6?.map(y => toJson_InsightSpecForProviderFiltersNetworkDestinationIpv6(y)),
    'networkDestinationPort': obj.networkDestinationPort?.map(y => toJson_InsightSpecForProviderFiltersNetworkDestinationPort(y)),
    'networkDirection': obj.networkDirection?.map(y => toJson_InsightSpecForProviderFiltersNetworkDirection(y)),
    'networkProtocol': obj.networkProtocol?.map(y => toJson_InsightSpecForProviderFiltersNetworkProtocol(y)),
    'networkSourceDomain': obj.networkSourceDomain?.map(y => toJson_InsightSpecForProviderFiltersNetworkSourceDomain(y)),
    'networkSourceIpv4': obj.networkSourceIpv4?.map(y => toJson_InsightSpecForProviderFiltersNetworkSourceIpv4(y)),
    'networkSourceIpv6': obj.networkSourceIpv6?.map(y => toJson_InsightSpecForProviderFiltersNetworkSourceIpv6(y)),
    'networkSourceMac': obj.networkSourceMac?.map(y => toJson_InsightSpecForProviderFiltersNetworkSourceMac(y)),
    'networkSourcePort': obj.networkSourcePort?.map(y => toJson_InsightSpecForProviderFiltersNetworkSourcePort(y)),
    'noteText': obj.noteText?.map(y => toJson_InsightSpecForProviderFiltersNoteText(y)),
    'noteUpdatedAt': obj.noteUpdatedAt?.map(y => toJson_InsightSpecForProviderFiltersNoteUpdatedAt(y)),
    'noteUpdatedBy': obj.noteUpdatedBy?.map(y => toJson_InsightSpecForProviderFiltersNoteUpdatedBy(y)),
    'processLaunchedAt': obj.processLaunchedAt?.map(y => toJson_InsightSpecForProviderFiltersProcessLaunchedAt(y)),
    'processName': obj.processName?.map(y => toJson_InsightSpecForProviderFiltersProcessName(y)),
    'processParentPid': obj.processParentPid?.map(y => toJson_InsightSpecForProviderFiltersProcessParentPid(y)),
    'processPath': obj.processPath?.map(y => toJson_InsightSpecForProviderFiltersProcessPath(y)),
    'processPid': obj.processPid?.map(y => toJson_InsightSpecForProviderFiltersProcessPid(y)),
    'processTerminatedAt': obj.processTerminatedAt?.map(y => toJson_InsightSpecForProviderFiltersProcessTerminatedAt(y)),
    'productArn': obj.productArn?.map(y => toJson_InsightSpecForProviderFiltersProductArn(y)),
    'productFields': obj.productFields?.map(y => toJson_InsightSpecForProviderFiltersProductFields(y)),
    'productName': obj.productName?.map(y => toJson_InsightSpecForProviderFiltersProductName(y)),
    'recommendationText': obj.recommendationText?.map(y => toJson_InsightSpecForProviderFiltersRecommendationText(y)),
    'recordState': obj.recordState?.map(y => toJson_InsightSpecForProviderFiltersRecordState(y)),
    'relatedFindingsId': obj.relatedFindingsId?.map(y => toJson_InsightSpecForProviderFiltersRelatedFindingsId(y)),
    'relatedFindingsProductArn': obj.relatedFindingsProductArn?.map(y => toJson_InsightSpecForProviderFiltersRelatedFindingsProductArn(y)),
    'resourceAwsEc2InstanceIamInstanceProfileArn': obj.resourceAwsEc2InstanceIamInstanceProfileArn?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn(y)),
    'resourceAwsEc2InstanceImageId': obj.resourceAwsEc2InstanceImageId?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId(y)),
    'resourceAwsEc2InstanceIpv4Addresses': obj.resourceAwsEc2InstanceIpv4Addresses?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses(y)),
    'resourceAwsEc2InstanceIpv6Addresses': obj.resourceAwsEc2InstanceIpv6Addresses?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses(y)),
    'resourceAwsEc2InstanceKeyName': obj.resourceAwsEc2InstanceKeyName?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName(y)),
    'resourceAwsEc2InstanceLaunchedAt': obj.resourceAwsEc2InstanceLaunchedAt?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt(y)),
    'resourceAwsEc2InstanceSubnetId': obj.resourceAwsEc2InstanceSubnetId?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId(y)),
    'resourceAwsEc2InstanceType': obj.resourceAwsEc2InstanceType?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceType(y)),
    'resourceAwsEc2InstanceVpcId': obj.resourceAwsEc2InstanceVpcId?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId(y)),
    'resourceAwsIamAccessKeyCreatedAt': obj.resourceAwsIamAccessKeyCreatedAt?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt(y)),
    'resourceAwsIamAccessKeyStatus': obj.resourceAwsIamAccessKeyStatus?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus(y)),
    'resourceAwsIamAccessKeyUserName': obj.resourceAwsIamAccessKeyUserName?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName(y)),
    'resourceAwsS3BucketOwnerId': obj.resourceAwsS3BucketOwnerId?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId(y)),
    'resourceAwsS3BucketOwnerName': obj.resourceAwsS3BucketOwnerName?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName(y)),
    'resourceContainerImageId': obj.resourceContainerImageId?.map(y => toJson_InsightSpecForProviderFiltersResourceContainerImageId(y)),
    'resourceContainerImageName': obj.resourceContainerImageName?.map(y => toJson_InsightSpecForProviderFiltersResourceContainerImageName(y)),
    'resourceContainerLaunchedAt': obj.resourceContainerLaunchedAt?.map(y => toJson_InsightSpecForProviderFiltersResourceContainerLaunchedAt(y)),
    'resourceContainerName': obj.resourceContainerName?.map(y => toJson_InsightSpecForProviderFiltersResourceContainerName(y)),
    'resourceDetailsOther': obj.resourceDetailsOther?.map(y => toJson_InsightSpecForProviderFiltersResourceDetailsOther(y)),
    'resourceId': obj.resourceId?.map(y => toJson_InsightSpecForProviderFiltersResourceId(y)),
    'resourcePartition': obj.resourcePartition?.map(y => toJson_InsightSpecForProviderFiltersResourcePartition(y)),
    'resourceRegion': obj.resourceRegion?.map(y => toJson_InsightSpecForProviderFiltersResourceRegion(y)),
    'resourceTags': obj.resourceTags?.map(y => toJson_InsightSpecForProviderFiltersResourceTags(y)),
    'resourceType': obj.resourceType?.map(y => toJson_InsightSpecForProviderFiltersResourceType(y)),
    'severityLabel': obj.severityLabel?.map(y => toJson_InsightSpecForProviderFiltersSeverityLabel(y)),
    'sourceUrl': obj.sourceUrl?.map(y => toJson_InsightSpecForProviderFiltersSourceUrl(y)),
    'threatIntelIndicatorCategory': obj.threatIntelIndicatorCategory?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorCategory(y)),
    'threatIntelIndicatorLastObservedAt': obj.threatIntelIndicatorLastObservedAt?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt(y)),
    'threatIntelIndicatorSource': obj.threatIntelIndicatorSource?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorSource(y)),
    'threatIntelIndicatorSourceUrl': obj.threatIntelIndicatorSourceUrl?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl(y)),
    'threatIntelIndicatorType': obj.threatIntelIndicatorType?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorType(y)),
    'threatIntelIndicatorValue': obj.threatIntelIndicatorValue?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorValue(y)),
    'title': obj.title?.map(y => toJson_InsightSpecForProviderFiltersTitle(y)),
    'type': obj.type?.map(y => toJson_InsightSpecForProviderFiltersType(y)),
    'updatedAt': obj.updatedAt?.map(y => toJson_InsightSpecForProviderFiltersUpdatedAt(y)),
    'userDefinedValues': obj.userDefinedValues?.map(y => toJson_InsightSpecForProviderFiltersUserDefinedValues(y)),
    'verificationState': obj.verificationState?.map(y => toJson_InsightSpecForProviderFiltersVerificationState(y)),
    'workflowStatus': obj.workflowStatus?.map(y => toJson_InsightSpecForProviderFiltersWorkflowStatus(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InsightSpecProviderConfigRefPolicy
 */
export interface InsightSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InsightSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InsightSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InsightSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InsightSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InsightSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecProviderConfigRefPolicy(obj: InsightSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InsightSpecProviderRefPolicy
 */
export interface InsightSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InsightSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InsightSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InsightSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InsightSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InsightSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecProviderRefPolicy(obj: InsightSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InsightSpecPublishConnectionDetailsToConfigRef
 */
export interface InsightSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InsightSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InsightSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InsightSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InsightSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecPublishConnectionDetailsToConfigRef(obj: InsightSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InsightSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InsightSpecPublishConnectionDetailsToMetadata
 */
export interface InsightSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InsightSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InsightSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InsightSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InsightSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecPublishConnectionDetailsToMetadata(obj: InsightSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersAwsAccountId
 */
export interface InsightSpecForProviderFiltersAwsAccountId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersAwsAccountId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersAwsAccountId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersAwsAccountId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersAwsAccountId(obj: InsightSpecForProviderFiltersAwsAccountId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersCompanyName
 */
export interface InsightSpecForProviderFiltersCompanyName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersCompanyName#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersCompanyName#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersCompanyName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersCompanyName(obj: InsightSpecForProviderFiltersCompanyName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersComplianceStatus
 */
export interface InsightSpecForProviderFiltersComplianceStatus {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersComplianceStatus#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersComplianceStatus#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersComplianceStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersComplianceStatus(obj: InsightSpecForProviderFiltersComplianceStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersConfidence
 */
export interface InsightSpecForProviderFiltersConfidence {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersConfidence#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersConfidence#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersConfidence#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersConfidence' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersConfidence(obj: InsightSpecForProviderFiltersConfidence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersCreatedAt
 */
export interface InsightSpecForProviderFiltersCreatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersCreatedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersCreatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersCreatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersCreatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersCreatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersCreatedAt(obj: InsightSpecForProviderFiltersCreatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersCreatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersCriticality
 */
export interface InsightSpecForProviderFiltersCriticality {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersCriticality#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersCriticality#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersCriticality#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersCriticality' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersCriticality(obj: InsightSpecForProviderFiltersCriticality | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersDescription
 */
export interface InsightSpecForProviderFiltersDescription {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersDescription#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersDescription#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersDescription' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersDescription(obj: InsightSpecForProviderFiltersDescription | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsConfidence
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsConfidence {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsConfidence#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsConfidence#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsConfidence#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsConfidence' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsConfidence(obj: InsightSpecForProviderFiltersFindingProviderFieldsConfidence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsCriticality
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsCriticality {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsCriticality#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsCriticality#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsCriticality#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsCriticality' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsCriticality(obj: InsightSpecForProviderFiltersFindingProviderFieldsCriticality | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId(obj: InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn(obj: InsightSpecForProviderFiltersFindingProviderFieldsRelatedFindingsProductArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel(obj: InsightSpecForProviderFiltersFindingProviderFieldsSeverityLabel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal(obj: InsightSpecForProviderFiltersFindingProviderFieldsSeverityOriginal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFindingProviderFieldsTypes
 */
export interface InsightSpecForProviderFiltersFindingProviderFieldsTypes {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsTypes#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFindingProviderFieldsTypes#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFindingProviderFieldsTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFindingProviderFieldsTypes(obj: InsightSpecForProviderFiltersFindingProviderFieldsTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFirstObservedAt
 */
export interface InsightSpecForProviderFiltersFirstObservedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersFirstObservedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersFirstObservedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersFirstObservedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersFirstObservedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFirstObservedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFirstObservedAt(obj: InsightSpecForProviderFiltersFirstObservedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersFirstObservedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersGeneratorId
 */
export interface InsightSpecForProviderFiltersGeneratorId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersGeneratorId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersGeneratorId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersGeneratorId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersGeneratorId(obj: InsightSpecForProviderFiltersGeneratorId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersId
 */
export interface InsightSpecForProviderFiltersId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersId(obj: InsightSpecForProviderFiltersId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersKeyword
 */
export interface InsightSpecForProviderFiltersKeyword {
  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersKeyword#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersKeyword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersKeyword(obj: InsightSpecForProviderFiltersKeyword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersLastObservedAt
 */
export interface InsightSpecForProviderFiltersLastObservedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersLastObservedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersLastObservedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersLastObservedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersLastObservedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersLastObservedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersLastObservedAt(obj: InsightSpecForProviderFiltersLastObservedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersLastObservedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersMalwareName
 */
export interface InsightSpecForProviderFiltersMalwareName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersMalwareName#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersMalwareName#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersMalwareName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersMalwareName(obj: InsightSpecForProviderFiltersMalwareName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersMalwarePath
 */
export interface InsightSpecForProviderFiltersMalwarePath {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersMalwarePath#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersMalwarePath#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersMalwarePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersMalwarePath(obj: InsightSpecForProviderFiltersMalwarePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersMalwareState
 */
export interface InsightSpecForProviderFiltersMalwareState {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersMalwareState#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersMalwareState#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersMalwareState' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersMalwareState(obj: InsightSpecForProviderFiltersMalwareState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersMalwareType
 */
export interface InsightSpecForProviderFiltersMalwareType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersMalwareType#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersMalwareType#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersMalwareType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersMalwareType(obj: InsightSpecForProviderFiltersMalwareType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkDestinationDomain
 */
export interface InsightSpecForProviderFiltersNetworkDestinationDomain {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationDomain#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationDomain#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkDestinationDomain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkDestinationDomain(obj: InsightSpecForProviderFiltersNetworkDestinationDomain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkDestinationIpv4
 */
export interface InsightSpecForProviderFiltersNetworkDestinationIpv4 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationIpv4#cidr
   */
  readonly cidr: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkDestinationIpv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkDestinationIpv4(obj: InsightSpecForProviderFiltersNetworkDestinationIpv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkDestinationIpv6
 */
export interface InsightSpecForProviderFiltersNetworkDestinationIpv6 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationIpv6#cidr
   */
  readonly cidr: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkDestinationIpv6' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkDestinationIpv6(obj: InsightSpecForProviderFiltersNetworkDestinationIpv6 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkDestinationPort
 */
export interface InsightSpecForProviderFiltersNetworkDestinationPort {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationPort#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationPort#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkDestinationPort#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkDestinationPort(obj: InsightSpecForProviderFiltersNetworkDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkDirection
 */
export interface InsightSpecForProviderFiltersNetworkDirection {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNetworkDirection#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNetworkDirection#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkDirection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkDirection(obj: InsightSpecForProviderFiltersNetworkDirection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkProtocol
 */
export interface InsightSpecForProviderFiltersNetworkProtocol {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNetworkProtocol#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNetworkProtocol#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkProtocol' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkProtocol(obj: InsightSpecForProviderFiltersNetworkProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkSourceDomain
 */
export interface InsightSpecForProviderFiltersNetworkSourceDomain {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceDomain#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceDomain#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkSourceDomain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkSourceDomain(obj: InsightSpecForProviderFiltersNetworkSourceDomain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkSourceIpv4
 */
export interface InsightSpecForProviderFiltersNetworkSourceIpv4 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceIpv4#cidr
   */
  readonly cidr: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkSourceIpv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkSourceIpv4(obj: InsightSpecForProviderFiltersNetworkSourceIpv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkSourceIpv6
 */
export interface InsightSpecForProviderFiltersNetworkSourceIpv6 {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceIpv6#cidr
   */
  readonly cidr: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkSourceIpv6' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkSourceIpv6(obj: InsightSpecForProviderFiltersNetworkSourceIpv6 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkSourceMac
 */
export interface InsightSpecForProviderFiltersNetworkSourceMac {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceMac#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourceMac#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkSourceMac' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkSourceMac(obj: InsightSpecForProviderFiltersNetworkSourceMac | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNetworkSourcePort
 */
export interface InsightSpecForProviderFiltersNetworkSourcePort {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourcePort#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourcePort#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersNetworkSourcePort#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNetworkSourcePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNetworkSourcePort(obj: InsightSpecForProviderFiltersNetworkSourcePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNoteText
 */
export interface InsightSpecForProviderFiltersNoteText {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNoteText#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNoteText#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNoteText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNoteText(obj: InsightSpecForProviderFiltersNoteText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNoteUpdatedAt
 */
export interface InsightSpecForProviderFiltersNoteUpdatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersNoteUpdatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNoteUpdatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNoteUpdatedAt(obj: InsightSpecForProviderFiltersNoteUpdatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersNoteUpdatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNoteUpdatedBy
 */
export interface InsightSpecForProviderFiltersNoteUpdatedBy {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedBy#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedBy#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNoteUpdatedBy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNoteUpdatedBy(obj: InsightSpecForProviderFiltersNoteUpdatedBy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessLaunchedAt
 */
export interface InsightSpecForProviderFiltersProcessLaunchedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersProcessLaunchedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersProcessLaunchedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersProcessLaunchedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersProcessLaunchedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessLaunchedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessLaunchedAt(obj: InsightSpecForProviderFiltersProcessLaunchedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersProcessLaunchedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessName
 */
export interface InsightSpecForProviderFiltersProcessName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersProcessName#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProcessName#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessName(obj: InsightSpecForProviderFiltersProcessName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessParentPid
 */
export interface InsightSpecForProviderFiltersProcessParentPid {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessParentPid#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessParentPid#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessParentPid#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessParentPid' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessParentPid(obj: InsightSpecForProviderFiltersProcessParentPid | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessPath
 */
export interface InsightSpecForProviderFiltersProcessPath {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersProcessPath#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProcessPath#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessPath(obj: InsightSpecForProviderFiltersProcessPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessPid
 */
export interface InsightSpecForProviderFiltersProcessPid {
  /**
   * The equal-to condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessPid#eq
   */
  readonly eq?: string;

  /**
   * The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessPid#gte
   */
  readonly gte?: string;

  /**
   * The less-than-equal condition to be applied to a single field when querying for findings, provided as a String.
   *
   * @schema InsightSpecForProviderFiltersProcessPid#lte
   */
  readonly lte?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessPid' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessPid(obj: InsightSpecForProviderFiltersProcessPid | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eq': obj.eq,
    'gte': obj.gte,
    'lte': obj.lte,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessTerminatedAt
 */
export interface InsightSpecForProviderFiltersProcessTerminatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersProcessTerminatedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersProcessTerminatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersProcessTerminatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersProcessTerminatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessTerminatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessTerminatedAt(obj: InsightSpecForProviderFiltersProcessTerminatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersProcessTerminatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProductArn
 */
export interface InsightSpecForProviderFiltersProductArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersProductArn#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProductArn#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProductArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProductArn(obj: InsightSpecForProviderFiltersProductArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProductFields
 */
export interface InsightSpecForProviderFiltersProductFields {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersProductFields#comparison
   */
  readonly comparison: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecForProviderFiltersProductFields#key
   */
  readonly key: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProductFields#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProductFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProductFields(obj: InsightSpecForProviderFiltersProductFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProductName
 */
export interface InsightSpecForProviderFiltersProductName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersProductName#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProductName#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProductName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProductName(obj: InsightSpecForProviderFiltersProductName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersRecommendationText
 */
export interface InsightSpecForProviderFiltersRecommendationText {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersRecommendationText#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersRecommendationText#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersRecommendationText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersRecommendationText(obj: InsightSpecForProviderFiltersRecommendationText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersRecordState
 */
export interface InsightSpecForProviderFiltersRecordState {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersRecordState#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersRecordState#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersRecordState' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersRecordState(obj: InsightSpecForProviderFiltersRecordState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersRelatedFindingsId
 */
export interface InsightSpecForProviderFiltersRelatedFindingsId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersRelatedFindingsId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersRelatedFindingsId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersRelatedFindingsId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersRelatedFindingsId(obj: InsightSpecForProviderFiltersRelatedFindingsId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersRelatedFindingsProductArn
 */
export interface InsightSpecForProviderFiltersRelatedFindingsProductArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersRelatedFindingsProductArn#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersRelatedFindingsProductArn#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersRelatedFindingsProductArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersRelatedFindingsProductArn(obj: InsightSpecForProviderFiltersRelatedFindingsProductArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceIamInstanceProfileArn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceImageId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses#cidr
   */
  readonly cidr: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv4Addresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses {
  /**
   * A finding's CIDR value.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses#cidr
   */
  readonly cidr: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceIpv6Addresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceKeyName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceSubnetId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceType
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceType#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceType#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceType(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceVpcId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt
 */
export interface InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt(obj: InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus
 */
export interface InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus(obj: InsightSpecForProviderFiltersResourceAwsIamAccessKeyStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName
 */
export interface InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName(obj: InsightSpecForProviderFiltersResourceAwsIamAccessKeyUserName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId
 */
export interface InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId(obj: InsightSpecForProviderFiltersResourceAwsS3BucketOwnerId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName
 */
export interface InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName(obj: InsightSpecForProviderFiltersResourceAwsS3BucketOwnerName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceContainerImageId
 */
export interface InsightSpecForProviderFiltersResourceContainerImageId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerImageId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerImageId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceContainerImageId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceContainerImageId(obj: InsightSpecForProviderFiltersResourceContainerImageId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceContainerImageName
 */
export interface InsightSpecForProviderFiltersResourceContainerImageName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerImageName#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerImageName#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceContainerImageName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceContainerImageName(obj: InsightSpecForProviderFiltersResourceContainerImageName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAt
 */
export interface InsightSpecForProviderFiltersResourceContainerLaunchedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceContainerLaunchedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceContainerLaunchedAt(obj: InsightSpecForProviderFiltersResourceContainerLaunchedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceContainerName
 */
export interface InsightSpecForProviderFiltersResourceContainerName {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerName#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerName#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceContainerName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceContainerName(obj: InsightSpecForProviderFiltersResourceContainerName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceDetailsOther
 */
export interface InsightSpecForProviderFiltersResourceDetailsOther {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceDetailsOther#comparison
   */
  readonly comparison: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecForProviderFiltersResourceDetailsOther#key
   */
  readonly key: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceDetailsOther#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceDetailsOther' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceDetailsOther(obj: InsightSpecForProviderFiltersResourceDetailsOther | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceId
 */
export interface InsightSpecForProviderFiltersResourceId {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceId#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceId#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceId(obj: InsightSpecForProviderFiltersResourceId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourcePartition
 */
export interface InsightSpecForProviderFiltersResourcePartition {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourcePartition#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourcePartition#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourcePartition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourcePartition(obj: InsightSpecForProviderFiltersResourcePartition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceRegion
 */
export interface InsightSpecForProviderFiltersResourceRegion {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceRegion#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceRegion#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceRegion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceRegion(obj: InsightSpecForProviderFiltersResourceRegion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceTags
 */
export interface InsightSpecForProviderFiltersResourceTags {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceTags#comparison
   */
  readonly comparison: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecForProviderFiltersResourceTags#key
   */
  readonly key: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceTags(obj: InsightSpecForProviderFiltersResourceTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceType
 */
export interface InsightSpecForProviderFiltersResourceType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersResourceType#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceType#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceType(obj: InsightSpecForProviderFiltersResourceType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersSeverityLabel
 */
export interface InsightSpecForProviderFiltersSeverityLabel {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersSeverityLabel#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersSeverityLabel#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersSeverityLabel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersSeverityLabel(obj: InsightSpecForProviderFiltersSeverityLabel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersSourceUrl
 */
export interface InsightSpecForProviderFiltersSourceUrl {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersSourceUrl#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersSourceUrl#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersSourceUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersSourceUrl(obj: InsightSpecForProviderFiltersSourceUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorCategory
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorCategory {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorCategory#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorCategory#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorCategory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorCategory(obj: InsightSpecForProviderFiltersThreatIntelIndicatorCategory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt(obj: InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSource
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorSource {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSource#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSource#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorSource(obj: InsightSpecForProviderFiltersThreatIntelIndicatorSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl(obj: InsightSpecForProviderFiltersThreatIntelIndicatorSourceUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorType
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorType#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorType#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorType(obj: InsightSpecForProviderFiltersThreatIntelIndicatorType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorValue
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorValue {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorValue#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorValue#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorValue(obj: InsightSpecForProviderFiltersThreatIntelIndicatorValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersTitle
 */
export interface InsightSpecForProviderFiltersTitle {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersTitle#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersTitle#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersTitle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersTitle(obj: InsightSpecForProviderFiltersTitle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersType
 */
export interface InsightSpecForProviderFiltersType {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersType#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersType#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersType(obj: InsightSpecForProviderFiltersType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersUpdatedAt
 */
export interface InsightSpecForProviderFiltersUpdatedAt {
  /**
   * A configuration block of the date range for the date filter. See date_range below for more details.
   *
   * @schema InsightSpecForProviderFiltersUpdatedAt#dateRange
   */
  readonly dateRange?: InsightSpecForProviderFiltersUpdatedAtDateRange[];

  /**
   * An end date for the date filter. Required with start if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersUpdatedAt#end
   */
  readonly end?: string;

  /**
   * A start date for the date filter. Required with end if date_range is not specified.
   *
   * @schema InsightSpecForProviderFiltersUpdatedAt#start
   */
  readonly start?: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersUpdatedAt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersUpdatedAt(obj: InsightSpecForProviderFiltersUpdatedAt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateRange': obj.dateRange?.map(y => toJson_InsightSpecForProviderFiltersUpdatedAtDateRange(y)),
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersUserDefinedValues
 */
export interface InsightSpecForProviderFiltersUserDefinedValues {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersUserDefinedValues#comparison
   */
  readonly comparison: string;

  /**
   * The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
   *
   * @schema InsightSpecForProviderFiltersUserDefinedValues#key
   */
  readonly key: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersUserDefinedValues#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersUserDefinedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersUserDefinedValues(obj: InsightSpecForProviderFiltersUserDefinedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersVerificationState
 */
export interface InsightSpecForProviderFiltersVerificationState {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersVerificationState#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersVerificationState#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersVerificationState' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersVerificationState(obj: InsightSpecForProviderFiltersVerificationState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersWorkflowStatus
 */
export interface InsightSpecForProviderFiltersWorkflowStatus {
  /**
   * The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS.
   *
   * @schema InsightSpecForProviderFiltersWorkflowStatus#comparison
   */
  readonly comparison: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersWorkflowStatus#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersWorkflowStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersWorkflowStatus(obj: InsightSpecForProviderFiltersWorkflowStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparison': obj.comparison,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InsightSpecProviderConfigRefPolicyResolution
 */
export enum InsightSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InsightSpecProviderConfigRefPolicyResolve
 */
export enum InsightSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InsightSpecProviderRefPolicyResolution
 */
export enum InsightSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InsightSpecProviderRefPolicyResolve
 */
export enum InsightSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InsightSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InsightSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InsightSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InsightSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InsightSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InsightSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InsightSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecPublishConnectionDetailsToConfigRefPolicy(obj: InsightSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersCreatedAtDateRange
 */
export interface InsightSpecForProviderFiltersCreatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersCreatedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersCreatedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersCreatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersCreatedAtDateRange(obj: InsightSpecForProviderFiltersCreatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersFirstObservedAtDateRange
 */
export interface InsightSpecForProviderFiltersFirstObservedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersFirstObservedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersFirstObservedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersFirstObservedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersFirstObservedAtDateRange(obj: InsightSpecForProviderFiltersFirstObservedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersLastObservedAtDateRange
 */
export interface InsightSpecForProviderFiltersLastObservedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersLastObservedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersLastObservedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersLastObservedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersLastObservedAtDateRange(obj: InsightSpecForProviderFiltersLastObservedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersNoteUpdatedAtDateRange
 */
export interface InsightSpecForProviderFiltersNoteUpdatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersNoteUpdatedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersNoteUpdatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersNoteUpdatedAtDateRange(obj: InsightSpecForProviderFiltersNoteUpdatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessLaunchedAtDateRange
 */
export interface InsightSpecForProviderFiltersProcessLaunchedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersProcessLaunchedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProcessLaunchedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessLaunchedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessLaunchedAtDateRange(obj: InsightSpecForProviderFiltersProcessLaunchedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersProcessTerminatedAtDateRange
 */
export interface InsightSpecForProviderFiltersProcessTerminatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersProcessTerminatedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersProcessTerminatedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersProcessTerminatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersProcessTerminatedAtDateRange(obj: InsightSpecForProviderFiltersProcessTerminatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange
 */
export interface InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange(obj: InsightSpecForProviderFiltersResourceAwsEc2InstanceLaunchedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange
 */
export interface InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange(obj: InsightSpecForProviderFiltersResourceAwsIamAccessKeyCreatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange
 */
export interface InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange(obj: InsightSpecForProviderFiltersResourceContainerLaunchedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange
 */
export interface InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange(obj: InsightSpecForProviderFiltersThreatIntelIndicatorLastObservedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InsightSpecForProviderFiltersUpdatedAtDateRange
 */
export interface InsightSpecForProviderFiltersUpdatedAtDateRange {
  /**
   * A date range unit for the date filter. Valid values: DAYS.
   *
   * @schema InsightSpecForProviderFiltersUpdatedAtDateRange#unit
   */
  readonly unit: string;

  /**
   * A value for the keyword.
   *
   * @schema InsightSpecForProviderFiltersUpdatedAtDateRange#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'InsightSpecForProviderFiltersUpdatedAtDateRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InsightSpecForProviderFiltersUpdatedAtDateRange(obj: InsightSpecForProviderFiltersUpdatedAtDateRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InsightSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InsightSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InsightSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InsightSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InviteAccepter is the Schema for the InviteAccepters API. Accepts a Security Hub invitation.
 *
 * @schema InviteAccepter
 */
export class InviteAccepter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InviteAccepter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'InviteAccepter',
  }

  /**
   * Renders a Kubernetes manifest for "InviteAccepter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InviteAccepterProps): any {
    return {
      ...InviteAccepter.GVK,
      ...toJson_InviteAccepterProps(props),
    };
  }

  /**
   * Defines a "InviteAccepter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InviteAccepterProps) {
    super(scope, id, {
      ...InviteAccepter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InviteAccepter.GVK,
      ...toJson_InviteAccepterProps(resolved),
    };
  }
}

/**
 * InviteAccepter is the Schema for the InviteAccepters API. Accepts a Security Hub invitation.
 *
 * @schema InviteAccepter
 */
export interface InviteAccepterProps {
  /**
   * @schema InviteAccepter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InviteAccepterSpec defines the desired state of InviteAccepter
   *
   * @schema InviteAccepter#spec
   */
  readonly spec: InviteAccepterSpec;

}

/**
 * Converts an object of type 'InviteAccepterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterProps(obj: InviteAccepterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InviteAccepterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InviteAccepterSpec defines the desired state of InviteAccepter
 *
 * @schema InviteAccepterSpec
 */
export interface InviteAccepterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema InviteAccepterSpec#deletionPolicy
   */
  readonly deletionPolicy?: InviteAccepterSpecDeletionPolicy;

  /**
   * @schema InviteAccepterSpec#forProvider
   */
  readonly forProvider: InviteAccepterSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InviteAccepterSpec#providerConfigRef
   */
  readonly providerConfigRef?: InviteAccepterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InviteAccepterSpec#providerRef
   */
  readonly providerRef?: InviteAccepterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InviteAccepterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InviteAccepterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InviteAccepterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InviteAccepterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InviteAccepterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpec(obj: InviteAccepterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InviteAccepterSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_InviteAccepterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InviteAccepterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InviteAccepterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InviteAccepterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema InviteAccepterSpecDeletionPolicy
 */
export enum InviteAccepterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InviteAccepterSpecForProvider
 */
export interface InviteAccepterSpecForProvider {
  /**
   * The account ID of the master Security Hub account whose invitation you're accepting.
   *
   * @schema InviteAccepterSpecForProvider#masterId
   */
  readonly masterId?: string;

  /**
   * Reference to a Member in securityhub to populate masterId.
   *
   * @schema InviteAccepterSpecForProvider#masterIdRef
   */
  readonly masterIdRef?: InviteAccepterSpecForProviderMasterIdRef;

  /**
   * Selector for a Member in securityhub to populate masterId.
   *
   * @schema InviteAccepterSpecForProvider#masterIdSelector
   */
  readonly masterIdSelector?: InviteAccepterSpecForProviderMasterIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InviteAccepterSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'InviteAccepterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecForProvider(obj: InviteAccepterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'masterId': obj.masterId,
    'masterIdRef': toJson_InviteAccepterSpecForProviderMasterIdRef(obj.masterIdRef),
    'masterIdSelector': toJson_InviteAccepterSpecForProviderMasterIdSelector(obj.masterIdSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InviteAccepterSpecProviderConfigRef
 */
export interface InviteAccepterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InviteAccepterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InviteAccepterSpecProviderConfigRef#policy
   */
  readonly policy?: InviteAccepterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InviteAccepterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecProviderConfigRef(obj: InviteAccepterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InviteAccepterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InviteAccepterSpecProviderRef
 */
export interface InviteAccepterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InviteAccepterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InviteAccepterSpecProviderRef#policy
   */
  readonly policy?: InviteAccepterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InviteAccepterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecProviderRef(obj: InviteAccepterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InviteAccepterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsTo
 */
export interface InviteAccepterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InviteAccepterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InviteAccepterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InviteAccepterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecPublishConnectionDetailsTo(obj: InviteAccepterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InviteAccepterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InviteAccepterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InviteAccepterSpecWriteConnectionSecretToRef
 */
export interface InviteAccepterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InviteAccepterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InviteAccepterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InviteAccepterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecWriteConnectionSecretToRef(obj: InviteAccepterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Member in securityhub to populate masterId.
 *
 * @schema InviteAccepterSpecForProviderMasterIdRef
 */
export interface InviteAccepterSpecForProviderMasterIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InviteAccepterSpecForProviderMasterIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InviteAccepterSpecForProviderMasterIdRef#policy
   */
  readonly policy?: InviteAccepterSpecForProviderMasterIdRefPolicy;

}

/**
 * Converts an object of type 'InviteAccepterSpecForProviderMasterIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecForProviderMasterIdRef(obj: InviteAccepterSpecForProviderMasterIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InviteAccepterSpecForProviderMasterIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Member in securityhub to populate masterId.
 *
 * @schema InviteAccepterSpecForProviderMasterIdSelector
 */
export interface InviteAccepterSpecForProviderMasterIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InviteAccepterSpecForProviderMasterIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InviteAccepterSpecForProviderMasterIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InviteAccepterSpecForProviderMasterIdSelector#policy
   */
  readonly policy?: InviteAccepterSpecForProviderMasterIdSelectorPolicy;

}

/**
 * Converts an object of type 'InviteAccepterSpecForProviderMasterIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecForProviderMasterIdSelector(obj: InviteAccepterSpecForProviderMasterIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InviteAccepterSpecForProviderMasterIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InviteAccepterSpecProviderConfigRefPolicy
 */
export interface InviteAccepterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InviteAccepterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InviteAccepterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InviteAccepterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InviteAccepterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InviteAccepterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecProviderConfigRefPolicy(obj: InviteAccepterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InviteAccepterSpecProviderRefPolicy
 */
export interface InviteAccepterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InviteAccepterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InviteAccepterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InviteAccepterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InviteAccepterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InviteAccepterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecProviderRefPolicy(obj: InviteAccepterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRef
 */
export interface InviteAccepterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InviteAccepterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecPublishConnectionDetailsToConfigRef(obj: InviteAccepterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsToMetadata
 */
export interface InviteAccepterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InviteAccepterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecPublishConnectionDetailsToMetadata(obj: InviteAccepterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InviteAccepterSpecForProviderMasterIdRefPolicy
 */
export interface InviteAccepterSpecForProviderMasterIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InviteAccepterSpecForProviderMasterIdRefPolicy#resolution
   */
  readonly resolution?: InviteAccepterSpecForProviderMasterIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InviteAccepterSpecForProviderMasterIdRefPolicy#resolve
   */
  readonly resolve?: InviteAccepterSpecForProviderMasterIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InviteAccepterSpecForProviderMasterIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecForProviderMasterIdRefPolicy(obj: InviteAccepterSpecForProviderMasterIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InviteAccepterSpecForProviderMasterIdSelectorPolicy
 */
export interface InviteAccepterSpecForProviderMasterIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InviteAccepterSpecForProviderMasterIdSelectorPolicy#resolution
   */
  readonly resolution?: InviteAccepterSpecForProviderMasterIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InviteAccepterSpecForProviderMasterIdSelectorPolicy#resolve
   */
  readonly resolve?: InviteAccepterSpecForProviderMasterIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InviteAccepterSpecForProviderMasterIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecForProviderMasterIdSelectorPolicy(obj: InviteAccepterSpecForProviderMasterIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InviteAccepterSpecProviderConfigRefPolicyResolution
 */
export enum InviteAccepterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InviteAccepterSpecProviderConfigRefPolicyResolve
 */
export enum InviteAccepterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InviteAccepterSpecProviderRefPolicyResolution
 */
export enum InviteAccepterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InviteAccepterSpecProviderRefPolicyResolve
 */
export enum InviteAccepterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj: InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InviteAccepterSpecForProviderMasterIdRefPolicyResolution
 */
export enum InviteAccepterSpecForProviderMasterIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InviteAccepterSpecForProviderMasterIdRefPolicyResolve
 */
export enum InviteAccepterSpecForProviderMasterIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InviteAccepterSpecForProviderMasterIdSelectorPolicyResolution
 */
export enum InviteAccepterSpecForProviderMasterIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InviteAccepterSpecForProviderMasterIdSelectorPolicyResolve
 */
export enum InviteAccepterSpecForProviderMasterIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InviteAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Member is the Schema for the Members API. Provides a Security Hub member resource.
 *
 * @schema Member
 */
export class Member extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Member"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'Member',
  }

  /**
   * Renders a Kubernetes manifest for "Member".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MemberProps): any {
    return {
      ...Member.GVK,
      ...toJson_MemberProps(props),
    };
  }

  /**
   * Defines a "Member" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MemberProps) {
    super(scope, id, {
      ...Member.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Member.GVK,
      ...toJson_MemberProps(resolved),
    };
  }
}

/**
 * Member is the Schema for the Members API. Provides a Security Hub member resource.
 *
 * @schema Member
 */
export interface MemberProps {
  /**
   * @schema Member#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MemberSpec defines the desired state of Member
   *
   * @schema Member#spec
   */
  readonly spec: MemberSpec;

}

/**
 * Converts an object of type 'MemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberProps(obj: MemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MemberSpec defines the desired state of Member
 *
 * @schema MemberSpec
 */
export interface MemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema MemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: MemberSpecDeletionPolicy;

  /**
   * @schema MemberSpec#forProvider
   */
  readonly forProvider: MemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: MemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MemberSpec#providerRef
   */
  readonly providerRef?: MemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpec(obj: MemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_MemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema MemberSpecDeletionPolicy
 */
export enum MemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MemberSpecForProvider
 */
export interface MemberSpecForProvider {
  /**
   * The ID of the member AWS account.
   *
   * @schema MemberSpecForProvider#accountId
   */
  readonly accountId: string;

  /**
   * The email of the member AWS account.
   *
   * @schema MemberSpecForProvider#email
   */
  readonly email: string;

  /**
   * Boolean whether to invite the account to Security Hub as a member. Defaults to false.
   *
   * @default false.
   * @schema MemberSpecForProvider#invite
   */
  readonly invite?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MemberSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'MemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProvider(obj: MemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'email': obj.email,
    'invite': obj.invite,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MemberSpecProviderConfigRef
 */
export interface MemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecProviderConfigRef#policy
   */
  readonly policy?: MemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderConfigRef(obj: MemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MemberSpecProviderRef
 */
export interface MemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecProviderRef#policy
   */
  readonly policy?: MemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderRef(obj: MemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MemberSpecPublishConnectionDetailsTo
 */
export interface MemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsTo(obj: MemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MemberSpecWriteConnectionSecretToRef
 */
export interface MemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecWriteConnectionSecretToRef(obj: MemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecProviderConfigRefPolicy
 */
export interface MemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderConfigRefPolicy(obj: MemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecProviderRefPolicy
 */
export interface MemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderRefPolicy(obj: MemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRef
 */
export interface MemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToConfigRef(obj: MemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MemberSpecPublishConnectionDetailsToMetadata
 */
export interface MemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToMetadata(obj: MemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecProviderConfigRefPolicyResolution
 */
export enum MemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecProviderConfigRefPolicyResolve
 */
export enum MemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecProviderRefPolicyResolution
 */
export enum MemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecProviderRefPolicyResolve
 */
export enum MemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: MemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProductSubscription is the Schema for the ProductSubscriptions API. Subscribes to a Security Hub product.
 *
 * @schema ProductSubscription
 */
export class ProductSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProductSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'ProductSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "ProductSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProductSubscriptionProps): any {
    return {
      ...ProductSubscription.GVK,
      ...toJson_ProductSubscriptionProps(props),
    };
  }

  /**
   * Defines a "ProductSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProductSubscriptionProps) {
    super(scope, id, {
      ...ProductSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProductSubscription.GVK,
      ...toJson_ProductSubscriptionProps(resolved),
    };
  }
}

/**
 * ProductSubscription is the Schema for the ProductSubscriptions API. Subscribes to a Security Hub product.
 *
 * @schema ProductSubscription
 */
export interface ProductSubscriptionProps {
  /**
   * @schema ProductSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProductSubscriptionSpec defines the desired state of ProductSubscription
   *
   * @schema ProductSubscription#spec
   */
  readonly spec: ProductSubscriptionSpec;

}

/**
 * Converts an object of type 'ProductSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionProps(obj: ProductSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProductSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProductSubscriptionSpec defines the desired state of ProductSubscription
 *
 * @schema ProductSubscriptionSpec
 */
export interface ProductSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ProductSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProductSubscriptionSpecDeletionPolicy;

  /**
   * @schema ProductSubscriptionSpec#forProvider
   */
  readonly forProvider: ProductSubscriptionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProductSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProductSubscriptionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ProductSubscriptionSpec#providerRef
   */
  readonly providerRef?: ProductSubscriptionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProductSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProductSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProductSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProductSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProductSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpec(obj: ProductSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProductSubscriptionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ProductSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ProductSubscriptionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ProductSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProductSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ProductSubscriptionSpecDeletionPolicy
 */
export enum ProductSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProductSubscriptionSpecForProvider
 */
export interface ProductSubscriptionSpecForProvider {
  /**
   * The ARN of the product that generates findings that you want to import into Security Hub - see below.
   *
   * @schema ProductSubscriptionSpecForProvider#productArn
   */
  readonly productArn: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProductSubscriptionSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecForProvider(obj: ProductSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'productArn': obj.productArn,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProductSubscriptionSpecProviderConfigRef
 */
export interface ProductSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: ProductSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecProviderConfigRef(obj: ProductSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ProductSubscriptionSpecProviderRef
 */
export interface ProductSubscriptionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductSubscriptionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductSubscriptionSpecProviderRef#policy
   */
  readonly policy?: ProductSubscriptionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecProviderRef(obj: ProductSubscriptionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductSubscriptionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsTo
 */
export interface ProductSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProductSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProductSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecPublishConnectionDetailsTo(obj: ProductSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProductSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProductSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProductSubscriptionSpecWriteConnectionSecretToRef
 */
export interface ProductSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProductSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProductSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecWriteConnectionSecretToRef(obj: ProductSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProductSubscriptionSpecProviderConfigRefPolicy
 */
export interface ProductSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProductSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProductSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecProviderConfigRefPolicy(obj: ProductSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProductSubscriptionSpecProviderRefPolicy
 */
export interface ProductSubscriptionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductSubscriptionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ProductSubscriptionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductSubscriptionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ProductSubscriptionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecProviderRefPolicy(obj: ProductSubscriptionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface ProductSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: ProductSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface ProductSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecPublishConnectionDetailsToMetadata(obj: ProductSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum ProductSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum ProductSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductSubscriptionSpecProviderRefPolicyResolution
 */
export enum ProductSubscriptionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductSubscriptionSpecProviderRefPolicyResolve
 */
export enum ProductSubscriptionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProductSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StandardsSubscription is the Schema for the StandardsSubscriptions API. Subscribes to a Security Hub standard.
 *
 * @schema StandardsSubscription
 */
export class StandardsSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StandardsSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'StandardsSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "StandardsSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StandardsSubscriptionProps): any {
    return {
      ...StandardsSubscription.GVK,
      ...toJson_StandardsSubscriptionProps(props),
    };
  }

  /**
   * Defines a "StandardsSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StandardsSubscriptionProps) {
    super(scope, id, {
      ...StandardsSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StandardsSubscription.GVK,
      ...toJson_StandardsSubscriptionProps(resolved),
    };
  }
}

/**
 * StandardsSubscription is the Schema for the StandardsSubscriptions API. Subscribes to a Security Hub standard.
 *
 * @schema StandardsSubscription
 */
export interface StandardsSubscriptionProps {
  /**
   * @schema StandardsSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StandardsSubscriptionSpec defines the desired state of StandardsSubscription
   *
   * @schema StandardsSubscription#spec
   */
  readonly spec: StandardsSubscriptionSpec;

}

/**
 * Converts an object of type 'StandardsSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionProps(obj: StandardsSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StandardsSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StandardsSubscriptionSpec defines the desired state of StandardsSubscription
 *
 * @schema StandardsSubscriptionSpec
 */
export interface StandardsSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema StandardsSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: StandardsSubscriptionSpecDeletionPolicy;

  /**
   * @schema StandardsSubscriptionSpec#forProvider
   */
  readonly forProvider: StandardsSubscriptionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StandardsSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: StandardsSubscriptionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StandardsSubscriptionSpec#providerRef
   */
  readonly providerRef?: StandardsSubscriptionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StandardsSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StandardsSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StandardsSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StandardsSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpec(obj: StandardsSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StandardsSubscriptionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_StandardsSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StandardsSubscriptionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StandardsSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StandardsSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema StandardsSubscriptionSpecDeletionPolicy
 */
export enum StandardsSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StandardsSubscriptionSpecForProvider
 */
export interface StandardsSubscriptionSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StandardsSubscriptionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of a standard - see below.
   *
   * @schema StandardsSubscriptionSpecForProvider#standardsArn
   */
  readonly standardsArn: string;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecForProvider(obj: StandardsSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'standardsArn': obj.standardsArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StandardsSubscriptionSpecProviderConfigRef
 */
export interface StandardsSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StandardsSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StandardsSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: StandardsSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecProviderConfigRef(obj: StandardsSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StandardsSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StandardsSubscriptionSpecProviderRef
 */
export interface StandardsSubscriptionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StandardsSubscriptionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StandardsSubscriptionSpecProviderRef#policy
   */
  readonly policy?: StandardsSubscriptionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecProviderRef(obj: StandardsSubscriptionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StandardsSubscriptionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsTo
 */
export interface StandardsSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StandardsSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecPublishConnectionDetailsTo(obj: StandardsSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StandardsSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StandardsSubscriptionSpecWriteConnectionSecretToRef
 */
export interface StandardsSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StandardsSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StandardsSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecWriteConnectionSecretToRef(obj: StandardsSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StandardsSubscriptionSpecProviderConfigRefPolicy
 */
export interface StandardsSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StandardsSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StandardsSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StandardsSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StandardsSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecProviderConfigRefPolicy(obj: StandardsSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StandardsSubscriptionSpecProviderRefPolicy
 */
export interface StandardsSubscriptionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StandardsSubscriptionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StandardsSubscriptionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StandardsSubscriptionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StandardsSubscriptionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecProviderRefPolicy(obj: StandardsSubscriptionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface StandardsSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecPublishConnectionDetailsToMetadata(obj: StandardsSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StandardsSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum StandardsSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StandardsSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum StandardsSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StandardsSubscriptionSpecProviderRefPolicyResolution
 */
export enum StandardsSubscriptionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StandardsSubscriptionSpecProviderRefPolicyResolve
 */
export enum StandardsSubscriptionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StandardsSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

