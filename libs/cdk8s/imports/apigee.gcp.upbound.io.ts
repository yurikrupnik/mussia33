// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Envgroup is the Schema for the Envgroups API. An
 *
 * @schema Envgroup
 */
export class Envgroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Envgroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigee.gcp.upbound.io/v1beta1',
    kind: 'Envgroup',
  }

  /**
   * Renders a Kubernetes manifest for "Envgroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvgroupProps): any {
    return {
      ...Envgroup.GVK,
      ...toJson_EnvgroupProps(props),
    };
  }

  /**
   * Defines a "Envgroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvgroupProps) {
    super(scope, id, {
      ...Envgroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Envgroup.GVK,
      ...toJson_EnvgroupProps(resolved),
    };
  }
}

/**
 * Envgroup is the Schema for the Envgroups API. An
 *
 * @schema Envgroup
 */
export interface EnvgroupProps {
  /**
   * @schema Envgroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EnvgroupSpec defines the desired state of Envgroup
   *
   * @schema Envgroup#spec
   */
  readonly spec: EnvgroupSpec;

}

/**
 * Converts an object of type 'EnvgroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupProps(obj: EnvgroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvgroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvgroupSpec defines the desired state of Envgroup
 *
 * @schema EnvgroupSpec
 */
export interface EnvgroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EnvgroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: EnvgroupSpecDeletionPolicy;

  /**
   * @schema EnvgroupSpec#forProvider
   */
  readonly forProvider: EnvgroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EnvgroupSpec#managementPolicy
   */
  readonly managementPolicy?: EnvgroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EnvgroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: EnvgroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EnvgroupSpec#providerRef
   */
  readonly providerRef?: EnvgroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EnvgroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EnvgroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EnvgroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EnvgroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EnvgroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpec(obj: EnvgroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EnvgroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EnvgroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EnvgroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EnvgroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EnvgroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EnvgroupSpecDeletionPolicy
 */
export enum EnvgroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EnvgroupSpecForProvider
 */
export interface EnvgroupSpecForProvider {
  /**
   * Hostnames of the environment group.
   *
   * @schema EnvgroupSpecForProvider#hostnames
   */
  readonly hostnames?: string[];

  /**
   * The Apigee Organization associated with the Apigee environment group, in the format organizations/{{org_name}}.
   *
   * @schema EnvgroupSpecForProvider#orgId
   */
  readonly orgId?: string;

  /**
   * Reference to a Organization in apigee to populate orgId.
   *
   * @schema EnvgroupSpecForProvider#orgIdRef
   */
  readonly orgIdRef?: EnvgroupSpecForProviderOrgIdRef;

  /**
   * Selector for a Organization in apigee to populate orgId.
   *
   * @schema EnvgroupSpecForProvider#orgIdSelector
   */
  readonly orgIdSelector?: EnvgroupSpecForProviderOrgIdSelector;

}

/**
 * Converts an object of type 'EnvgroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecForProvider(obj: EnvgroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'orgId': obj.orgId,
    'orgIdRef': toJson_EnvgroupSpecForProviderOrgIdRef(obj.orgIdRef),
    'orgIdSelector': toJson_EnvgroupSpecForProviderOrgIdSelector(obj.orgIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EnvgroupSpecManagementPolicy
 */
export enum EnvgroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EnvgroupSpecProviderConfigRef
 */
export interface EnvgroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvgroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvgroupSpecProviderConfigRef#policy
   */
  readonly policy?: EnvgroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvgroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecProviderConfigRef(obj: EnvgroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvgroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EnvgroupSpecProviderRef
 */
export interface EnvgroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvgroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvgroupSpecProviderRef#policy
   */
  readonly policy?: EnvgroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EnvgroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecProviderRef(obj: EnvgroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvgroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EnvgroupSpecPublishConnectionDetailsTo
 */
export interface EnvgroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EnvgroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EnvgroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EnvgroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EnvgroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EnvgroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EnvgroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecPublishConnectionDetailsTo(obj: EnvgroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EnvgroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EnvgroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EnvgroupSpecWriteConnectionSecretToRef
 */
export interface EnvgroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EnvgroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EnvgroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EnvgroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecWriteConnectionSecretToRef(obj: EnvgroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Organization in apigee to populate orgId.
 *
 * @schema EnvgroupSpecForProviderOrgIdRef
 */
export interface EnvgroupSpecForProviderOrgIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvgroupSpecForProviderOrgIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvgroupSpecForProviderOrgIdRef#policy
   */
  readonly policy?: EnvgroupSpecForProviderOrgIdRefPolicy;

}

/**
 * Converts an object of type 'EnvgroupSpecForProviderOrgIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecForProviderOrgIdRef(obj: EnvgroupSpecForProviderOrgIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvgroupSpecForProviderOrgIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Organization in apigee to populate orgId.
 *
 * @schema EnvgroupSpecForProviderOrgIdSelector
 */
export interface EnvgroupSpecForProviderOrgIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvgroupSpecForProviderOrgIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvgroupSpecForProviderOrgIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvgroupSpecForProviderOrgIdSelector#policy
   */
  readonly policy?: EnvgroupSpecForProviderOrgIdSelectorPolicy;

}

/**
 * Converts an object of type 'EnvgroupSpecForProviderOrgIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecForProviderOrgIdSelector(obj: EnvgroupSpecForProviderOrgIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvgroupSpecForProviderOrgIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvgroupSpecProviderConfigRefPolicy
 */
export interface EnvgroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvgroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EnvgroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvgroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EnvgroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvgroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecProviderConfigRefPolicy(obj: EnvgroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvgroupSpecProviderRefPolicy
 */
export interface EnvgroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvgroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EnvgroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvgroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EnvgroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvgroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecProviderRefPolicy(obj: EnvgroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EnvgroupSpecPublishConnectionDetailsToConfigRef
 */
export interface EnvgroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvgroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvgroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EnvgroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvgroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecPublishConnectionDetailsToConfigRef(obj: EnvgroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvgroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EnvgroupSpecPublishConnectionDetailsToMetadata
 */
export interface EnvgroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvgroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvgroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EnvgroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EnvgroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecPublishConnectionDetailsToMetadata(obj: EnvgroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvgroupSpecForProviderOrgIdRefPolicy
 */
export interface EnvgroupSpecForProviderOrgIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvgroupSpecForProviderOrgIdRefPolicy#resolution
   */
  readonly resolution?: EnvgroupSpecForProviderOrgIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvgroupSpecForProviderOrgIdRefPolicy#resolve
   */
  readonly resolve?: EnvgroupSpecForProviderOrgIdRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvgroupSpecForProviderOrgIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecForProviderOrgIdRefPolicy(obj: EnvgroupSpecForProviderOrgIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvgroupSpecForProviderOrgIdSelectorPolicy
 */
export interface EnvgroupSpecForProviderOrgIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvgroupSpecForProviderOrgIdSelectorPolicy#resolution
   */
  readonly resolution?: EnvgroupSpecForProviderOrgIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvgroupSpecForProviderOrgIdSelectorPolicy#resolve
   */
  readonly resolve?: EnvgroupSpecForProviderOrgIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvgroupSpecForProviderOrgIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecForProviderOrgIdSelectorPolicy(obj: EnvgroupSpecForProviderOrgIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvgroupSpecProviderConfigRefPolicyResolution
 */
export enum EnvgroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvgroupSpecProviderConfigRefPolicyResolve
 */
export enum EnvgroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvgroupSpecProviderRefPolicyResolution
 */
export enum EnvgroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvgroupSpecProviderRefPolicyResolve
 */
export enum EnvgroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvgroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EnvgroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvgroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EnvgroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvgroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EnvgroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvgroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvgroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: EnvgroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvgroupSpecForProviderOrgIdRefPolicyResolution
 */
export enum EnvgroupSpecForProviderOrgIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvgroupSpecForProviderOrgIdRefPolicyResolve
 */
export enum EnvgroupSpecForProviderOrgIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvgroupSpecForProviderOrgIdSelectorPolicyResolution
 */
export enum EnvgroupSpecForProviderOrgIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvgroupSpecForProviderOrgIdSelectorPolicyResolve
 */
export enum EnvgroupSpecForProviderOrgIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvgroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EnvgroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvgroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EnvgroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Environment is the Schema for the Environments API. An
 *
 * @schema Environment
 */
export class Environment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Environment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigee.gcp.upbound.io/v1beta1',
    kind: 'Environment',
  }

  /**
   * Renders a Kubernetes manifest for "Environment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvironmentProps): any {
    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(props),
    };
  }

  /**
   * Defines a "Environment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvironmentProps) {
    super(scope, id, {
      ...Environment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(resolved),
    };
  }
}

/**
 * Environment is the Schema for the Environments API. An
 *
 * @schema Environment
 */
export interface EnvironmentProps {
  /**
   * @schema Environment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EnvironmentSpec defines the desired state of Environment
   *
   * @schema Environment#spec
   */
  readonly spec: EnvironmentSpec;

}

/**
 * Converts an object of type 'EnvironmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentProps(obj: EnvironmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvironmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentSpec defines the desired state of Environment
 *
 * @schema EnvironmentSpec
 */
export interface EnvironmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EnvironmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: EnvironmentSpecDeletionPolicy;

  /**
   * @schema EnvironmentSpec#forProvider
   */
  readonly forProvider: EnvironmentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EnvironmentSpec#managementPolicy
   */
  readonly managementPolicy?: EnvironmentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EnvironmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: EnvironmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EnvironmentSpec#providerRef
   */
  readonly providerRef?: EnvironmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EnvironmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EnvironmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EnvironmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EnvironmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EnvironmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpec(obj: EnvironmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EnvironmentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EnvironmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EnvironmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EnvironmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EnvironmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EnvironmentSpecDeletionPolicy
 */
export enum EnvironmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EnvironmentSpecForProvider
 */
export interface EnvironmentSpecForProvider {
  /**
   * Optional. API Proxy type supported by the environment. The type can be set when creating the Environment and cannot be changed. Possible values are: API_PROXY_TYPE_UNSPECIFIED, PROGRAMMABLE, CONFIGURABLE.
   *
   * @schema EnvironmentSpecForProvider#apiProxyType
   */
  readonly apiProxyType?: string;

  /**
   * Optional. Deployment type supported by the environment. The deployment type can be set when creating the environment and cannot be changed. When you enable archive deployment, you will be prevented from performing a subset of actions within the environment, including: Managing the deployment of API proxy or shared flow revisions; Creating, updating, or deleting resource files; Creating, updating, or deleting target servers. Possible values are: DEPLOYMENT_TYPE_UNSPECIFIED, PROXY, ARCHIVE.
   *
   * @schema EnvironmentSpecForProvider#deploymentType
   */
  readonly deploymentType?: string;

  /**
   * Description of the environment.
   *
   * @schema EnvironmentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Display name of the environment.
   *
   * @schema EnvironmentSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * NodeConfig for setting the min/max number of nodes associated with the environment. Structure is documented below.
   *
   * @schema EnvironmentSpecForProvider#nodeConfig
   */
  readonly nodeConfig?: EnvironmentSpecForProviderNodeConfig[];

  /**
   * The Apigee Organization associated with the Apigee environment, in the format organizations/{{org_name}}.
   *
   * @schema EnvironmentSpecForProvider#orgId
   */
  readonly orgId?: string;

  /**
   * Reference to a Organization in apigee to populate orgId.
   *
   * @schema EnvironmentSpecForProvider#orgIdRef
   */
  readonly orgIdRef?: EnvironmentSpecForProviderOrgIdRef;

  /**
   * Selector for a Organization in apigee to populate orgId.
   *
   * @schema EnvironmentSpecForProvider#orgIdSelector
   */
  readonly orgIdSelector?: EnvironmentSpecForProviderOrgIdSelector;

}

/**
 * Converts an object of type 'EnvironmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProvider(obj: EnvironmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiProxyType': obj.apiProxyType,
    'deploymentType': obj.deploymentType,
    'description': obj.description,
    'displayName': obj.displayName,
    'nodeConfig': obj.nodeConfig?.map(y => toJson_EnvironmentSpecForProviderNodeConfig(y)),
    'orgId': obj.orgId,
    'orgIdRef': toJson_EnvironmentSpecForProviderOrgIdRef(obj.orgIdRef),
    'orgIdSelector': toJson_EnvironmentSpecForProviderOrgIdSelector(obj.orgIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EnvironmentSpecManagementPolicy
 */
export enum EnvironmentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EnvironmentSpecProviderConfigRef
 */
export interface EnvironmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderConfigRef#policy
   */
  readonly policy?: EnvironmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRef(obj: EnvironmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EnvironmentSpecProviderRef
 */
export interface EnvironmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderRef#policy
   */
  readonly policy?: EnvironmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderRef(obj: EnvironmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsTo
 */
export interface EnvironmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EnvironmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EnvironmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsTo(obj: EnvironmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EnvironmentSpecWriteConnectionSecretToRef
 */
export interface EnvironmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EnvironmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecWriteConnectionSecretToRef(obj: EnvironmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderNodeConfig
 */
export interface EnvironmentSpecForProviderNodeConfig {
  /**
   * The maximum total number of gateway nodes that the is reserved for all instances that has the specified environment. If not specified, the default is determined by the recommended maximum number of nodes for that gateway.
   *
   * @schema EnvironmentSpecForProviderNodeConfig#maxNodeCount
   */
  readonly maxNodeCount?: string;

  /**
   * The minimum total number of gateway nodes that the is reserved for all instances that has the specified environment. If not specified, the default is determined by the recommended minimum number of nodes for that gateway.
   *
   * @schema EnvironmentSpecForProviderNodeConfig#minNodeCount
   */
  readonly minNodeCount?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderNodeConfig(obj: EnvironmentSpecForProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxNodeCount': obj.maxNodeCount,
    'minNodeCount': obj.minNodeCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Organization in apigee to populate orgId.
 *
 * @schema EnvironmentSpecForProviderOrgIdRef
 */
export interface EnvironmentSpecForProviderOrgIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderOrgIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderOrgIdRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderOrgIdRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderOrgIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderOrgIdRef(obj: EnvironmentSpecForProviderOrgIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderOrgIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Organization in apigee to populate orgId.
 *
 * @schema EnvironmentSpecForProviderOrgIdSelector
 */
export interface EnvironmentSpecForProviderOrgIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderOrgIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderOrgIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderOrgIdSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderOrgIdSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderOrgIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderOrgIdSelector(obj: EnvironmentSpecForProviderOrgIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderOrgIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicy
 */
export interface EnvironmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRefPolicy(obj: EnvironmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderRefPolicy
 */
export interface EnvironmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderRefPolicy(obj: EnvironmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj: EnvironmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToMetadata
 */
export interface EnvironmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj: EnvironmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderOrgIdRefPolicy
 */
export interface EnvironmentSpecForProviderOrgIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderOrgIdRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderOrgIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderOrgIdRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderOrgIdRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderOrgIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderOrgIdRefPolicy(obj: EnvironmentSpecForProviderOrgIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderOrgIdSelectorPolicy
 */
export interface EnvironmentSpecForProviderOrgIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderOrgIdSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderOrgIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderOrgIdSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderOrgIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderOrgIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderOrgIdSelectorPolicy(obj: EnvironmentSpecForProviderOrgIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolution
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolve
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderRefPolicyResolution
 */
export enum EnvironmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderRefPolicyResolve
 */
export enum EnvironmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderOrgIdRefPolicyResolution
 */
export enum EnvironmentSpecForProviderOrgIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderOrgIdRefPolicyResolve
 */
export enum EnvironmentSpecForProviderOrgIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderOrgIdSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderOrgIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderOrgIdSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderOrgIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EnvironmentIAMMember is the Schema for the EnvironmentIAMMembers API. <no value>
 *
 * @schema EnvironmentIAMMember
 */
export class EnvironmentIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EnvironmentIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigee.gcp.upbound.io/v1beta1',
    kind: 'EnvironmentIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "EnvironmentIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvironmentIamMemberProps): any {
    return {
      ...EnvironmentIamMember.GVK,
      ...toJson_EnvironmentIamMemberProps(props),
    };
  }

  /**
   * Defines a "EnvironmentIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvironmentIamMemberProps) {
    super(scope, id, {
      ...EnvironmentIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EnvironmentIamMember.GVK,
      ...toJson_EnvironmentIamMemberProps(resolved),
    };
  }
}

/**
 * EnvironmentIAMMember is the Schema for the EnvironmentIAMMembers API. <no value>
 *
 * @schema EnvironmentIAMMember
 */
export interface EnvironmentIamMemberProps {
  /**
   * @schema EnvironmentIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EnvironmentIAMMemberSpec defines the desired state of EnvironmentIAMMember
   *
   * @schema EnvironmentIAMMember#spec
   */
  readonly spec: EnvironmentIamMemberSpec;

}

/**
 * Converts an object of type 'EnvironmentIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberProps(obj: EnvironmentIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvironmentIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentIAMMemberSpec defines the desired state of EnvironmentIAMMember
 *
 * @schema EnvironmentIamMemberSpec
 */
export interface EnvironmentIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EnvironmentIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: EnvironmentIamMemberSpecDeletionPolicy;

  /**
   * @schema EnvironmentIamMemberSpec#forProvider
   */
  readonly forProvider: EnvironmentIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EnvironmentIamMemberSpec#managementPolicy
   */
  readonly managementPolicy?: EnvironmentIamMemberSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EnvironmentIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: EnvironmentIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EnvironmentIamMemberSpec#providerRef
   */
  readonly providerRef?: EnvironmentIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EnvironmentIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EnvironmentIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EnvironmentIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EnvironmentIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpec(obj: EnvironmentIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EnvironmentIamMemberSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EnvironmentIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EnvironmentIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EnvironmentIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EnvironmentIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EnvironmentIamMemberSpecDeletionPolicy
 */
export enum EnvironmentIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EnvironmentIamMemberSpecForProvider
 */
export interface EnvironmentIamMemberSpecForProvider {
  /**
   * @schema EnvironmentIamMemberSpecForProvider#condition
   */
  readonly condition?: EnvironmentIamMemberSpecForProviderCondition[];

  /**
   * @schema EnvironmentIamMemberSpecForProvider#envId
   */
  readonly envId?: string;

  /**
   * @schema EnvironmentIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema EnvironmentIamMemberSpecForProvider#orgId
   */
  readonly orgId?: string;

  /**
   * @schema EnvironmentIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecForProvider(obj: EnvironmentIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_EnvironmentIamMemberSpecForProviderCondition(y)),
    'envId': obj.envId,
    'member': obj.member,
    'orgId': obj.orgId,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EnvironmentIamMemberSpecManagementPolicy
 */
export enum EnvironmentIamMemberSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EnvironmentIamMemberSpecProviderConfigRef
 */
export interface EnvironmentIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: EnvironmentIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecProviderConfigRef(obj: EnvironmentIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EnvironmentIamMemberSpecProviderRef
 */
export interface EnvironmentIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentIamMemberSpecProviderRef#policy
   */
  readonly policy?: EnvironmentIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecProviderRef(obj: EnvironmentIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EnvironmentIamMemberSpecPublishConnectionDetailsTo
 */
export interface EnvironmentIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EnvironmentIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EnvironmentIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EnvironmentIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EnvironmentIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecPublishConnectionDetailsTo(obj: EnvironmentIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EnvironmentIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EnvironmentIamMemberSpecWriteConnectionSecretToRef
 */
export interface EnvironmentIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EnvironmentIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EnvironmentIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecWriteConnectionSecretToRef(obj: EnvironmentIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentIamMemberSpecForProviderCondition
 */
export interface EnvironmentIamMemberSpecForProviderCondition {
  /**
   * @schema EnvironmentIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema EnvironmentIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema EnvironmentIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecForProviderCondition(obj: EnvironmentIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentIamMemberSpecProviderConfigRefPolicy
 */
export interface EnvironmentIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecProviderConfigRefPolicy(obj: EnvironmentIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentIamMemberSpecProviderRefPolicy
 */
export interface EnvironmentIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EnvironmentIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EnvironmentIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecProviderRefPolicy(obj: EnvironmentIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRef(obj: EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface EnvironmentIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecPublishConnectionDetailsToMetadata(obj: EnvironmentIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum EnvironmentIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum EnvironmentIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentIamMemberSpecProviderRefPolicyResolution
 */
export enum EnvironmentIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentIamMemberSpecProviderRefPolicyResolve
 */
export enum EnvironmentIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EnvironmentIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Instance is the Schema for the Instances API. An
 *
 * @schema Instance
 */
export class Instance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Instance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigee.gcp.upbound.io/v1beta1',
    kind: 'Instance',
  }

  /**
   * Renders a Kubernetes manifest for "Instance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProps): any {
    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(props),
    };
  }

  /**
   * Defines a "Instance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProps) {
    super(scope, id, {
      ...Instance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(resolved),
    };
  }
}

/**
 * Instance is the Schema for the Instances API. An
 *
 * @schema Instance
 */
export interface InstanceProps {
  /**
   * @schema Instance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceSpec defines the desired state of Instance
   *
   * @schema Instance#spec
   */
  readonly spec: InstanceSpec;

}

/**
 * Converts an object of type 'InstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProps(obj: InstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSpec defines the desired state of Instance
 *
 * @schema InstanceSpec
 */
export interface InstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceSpecDeletionPolicy;

  /**
   * @schema InstanceSpec#forProvider
   */
  readonly forProvider: InstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#managementPolicy
   */
  readonly managementPolicy?: InstanceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InstanceSpec#providerRef
   */
  readonly providerRef?: InstanceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpec(obj: InstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_InstanceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InstanceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecDeletionPolicy
 */
export enum InstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceSpecForProvider
 */
export interface InstanceSpecForProvider {
  /**
   * Optional. Customer accept list represents the list of projects (id/number) on customer side that can privately connect to the service attachment. It is an optional field which the customers can provide during the instance creation. By default, the customer project associated with the Apigee organization will be included to the list.
   *
   * @schema InstanceSpecForProvider#consumerAcceptList
   */
  readonly consumerAcceptList?: string[];

  /**
   * Description of the instance.
   *
   * @schema InstanceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Customer Managed Encryption Key (CMEK) used for disk and volume encryption. Required for Apigee paid subscriptions only. Use the following format: projects/([^/]+)/locations/([^/]+)/keyRings/([^/]+)/cryptoKeys/([^/]+)
   *
   * @schema InstanceSpecForProvider#diskEncryptionKeyName
   */
  readonly diskEncryptionKeyName?: string;

  /**
   * Reference to a CryptoKey in kms to populate diskEncryptionKeyName.
   *
   * @schema InstanceSpecForProvider#diskEncryptionKeyNameRef
   */
  readonly diskEncryptionKeyNameRef?: InstanceSpecForProviderDiskEncryptionKeyNameRef;

  /**
   * Selector for a CryptoKey in kms to populate diskEncryptionKeyName.
   *
   * @schema InstanceSpecForProvider#diskEncryptionKeyNameSelector
   */
  readonly diskEncryptionKeyNameSelector?: InstanceSpecForProviderDiskEncryptionKeyNameSelector;

  /**
   * Display name of the instance.
   *
   * @schema InstanceSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * IP range represents the customer-provided CIDR block of length 22 that will be used for the Apigee instance creation. This optional range, if provided, should be freely available as part of larger named range the customer has allocated to the Service Networking peering. If this is not provided, Apigee will automatically request for any available /22 CIDR block from Service Networking. The customer should use this CIDR block for configuring their firewall needs to allow traffic from Apigee. Input format: "a.b.c.d/22"
   *
   * @schema InstanceSpecForProvider#ipRange
   */
  readonly ipRange?: string;

  /**
   * Required. Compute Engine location where the instance resides.
   *
   * @schema InstanceSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The Apigee Organization associated with the Apigee instance, in the format organizations/{{org_name}}.
   *
   * @schema InstanceSpecForProvider#orgId
   */
  readonly orgId?: string;

  /**
   * Reference to a Organization in apigee to populate orgId.
   *
   * @schema InstanceSpecForProvider#orgIdRef
   */
  readonly orgIdRef?: InstanceSpecForProviderOrgIdRef;

  /**
   * Selector for a Organization in apigee to populate orgId.
   *
   * @schema InstanceSpecForProvider#orgIdSelector
   */
  readonly orgIdSelector?: InstanceSpecForProviderOrgIdSelector;

  /**
   * The size of the CIDR block range that will be reserved by the instance. For valid values, see CidrRange on the documentation.
   *
   * @schema InstanceSpecForProvider#peeringCidrRange
   */
  readonly peeringCidrRange?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProvider(obj: InstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumerAcceptList': obj.consumerAcceptList?.map(y => y),
    'description': obj.description,
    'diskEncryptionKeyName': obj.diskEncryptionKeyName,
    'diskEncryptionKeyNameRef': toJson_InstanceSpecForProviderDiskEncryptionKeyNameRef(obj.diskEncryptionKeyNameRef),
    'diskEncryptionKeyNameSelector': toJson_InstanceSpecForProviderDiskEncryptionKeyNameSelector(obj.diskEncryptionKeyNameSelector),
    'displayName': obj.displayName,
    'ipRange': obj.ipRange,
    'location': obj.location,
    'orgId': obj.orgId,
    'orgIdRef': toJson_InstanceSpecForProviderOrgIdRef(obj.orgIdRef),
    'orgIdSelector': toJson_InstanceSpecForProviderOrgIdSelector(obj.orgIdSelector),
    'peeringCidrRange': obj.peeringCidrRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecManagementPolicy
 */
export enum InstanceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceSpecProviderConfigRef
 */
export interface InstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRef(obj: InstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InstanceSpecProviderRef
 */
export interface InstanceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderRef#policy
   */
  readonly policy?: InstanceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderRef(obj: InstanceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceSpecPublishConnectionDetailsTo
 */
export interface InstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsTo(obj: InstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceSpecWriteConnectionSecretToRef
 */
export interface InstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecWriteConnectionSecretToRef(obj: InstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate diskEncryptionKeyName.
 *
 * @schema InstanceSpecForProviderDiskEncryptionKeyNameRef
 */
export interface InstanceSpecForProviderDiskEncryptionKeyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderDiskEncryptionKeyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderDiskEncryptionKeyNameRef#policy
   */
  readonly policy?: InstanceSpecForProviderDiskEncryptionKeyNameRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDiskEncryptionKeyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDiskEncryptionKeyNameRef(obj: InstanceSpecForProviderDiskEncryptionKeyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderDiskEncryptionKeyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate diskEncryptionKeyName.
 *
 * @schema InstanceSpecForProviderDiskEncryptionKeyNameSelector
 */
export interface InstanceSpecForProviderDiskEncryptionKeyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderDiskEncryptionKeyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderDiskEncryptionKeyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderDiskEncryptionKeyNameSelector#policy
   */
  readonly policy?: InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDiskEncryptionKeyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDiskEncryptionKeyNameSelector(obj: InstanceSpecForProviderDiskEncryptionKeyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Organization in apigee to populate orgId.
 *
 * @schema InstanceSpecForProviderOrgIdRef
 */
export interface InstanceSpecForProviderOrgIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderOrgIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderOrgIdRef#policy
   */
  readonly policy?: InstanceSpecForProviderOrgIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderOrgIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderOrgIdRef(obj: InstanceSpecForProviderOrgIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderOrgIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Organization in apigee to populate orgId.
 *
 * @schema InstanceSpecForProviderOrgIdSelector
 */
export interface InstanceSpecForProviderOrgIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderOrgIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderOrgIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderOrgIdSelector#policy
   */
  readonly policy?: InstanceSpecForProviderOrgIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderOrgIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderOrgIdSelector(obj: InstanceSpecForProviderOrgIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderOrgIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderConfigRefPolicy
 */
export interface InstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRefPolicy(obj: InstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderRefPolicy
 */
export interface InstanceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderRefPolicy(obj: InstanceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj: InstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj: InstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderDiskEncryptionKeyNameRefPolicy
 */
export interface InstanceSpecForProviderDiskEncryptionKeyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderDiskEncryptionKeyNameRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderDiskEncryptionKeyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderDiskEncryptionKeyNameRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderDiskEncryptionKeyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDiskEncryptionKeyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDiskEncryptionKeyNameRefPolicy(obj: InstanceSpecForProviderDiskEncryptionKeyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicy
 */
export interface InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicy(obj: InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderOrgIdRefPolicy
 */
export interface InstanceSpecForProviderOrgIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderOrgIdRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderOrgIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderOrgIdRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderOrgIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderOrgIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderOrgIdRefPolicy(obj: InstanceSpecForProviderOrgIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderOrgIdSelectorPolicy
 */
export interface InstanceSpecForProviderOrgIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderOrgIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderOrgIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderOrgIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderOrgIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderOrgIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderOrgIdSelectorPolicy(obj: InstanceSpecForProviderOrgIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolution
 */
export enum InstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolve
 */
export enum InstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderRefPolicyResolution
 */
export enum InstanceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderRefPolicyResolve
 */
export enum InstanceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderDiskEncryptionKeyNameRefPolicyResolution
 */
export enum InstanceSpecForProviderDiskEncryptionKeyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderDiskEncryptionKeyNameRefPolicyResolve
 */
export enum InstanceSpecForProviderDiskEncryptionKeyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicyResolution
 */
export enum InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicyResolve
 */
export enum InstanceSpecForProviderDiskEncryptionKeyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderOrgIdRefPolicyResolution
 */
export enum InstanceSpecForProviderOrgIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderOrgIdRefPolicyResolve
 */
export enum InstanceSpecForProviderOrgIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderOrgIdSelectorPolicyResolution
 */
export enum InstanceSpecForProviderOrgIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderOrgIdSelectorPolicyResolve
 */
export enum InstanceSpecForProviderOrgIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * NATAddress is the Schema for the NATAddresss API. Apigee NAT (network address translation) address.
 *
 * @schema NATAddress
 */
export class NatAddress extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NATAddress"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigee.gcp.upbound.io/v1beta1',
    kind: 'NATAddress',
  }

  /**
   * Renders a Kubernetes manifest for "NATAddress".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NatAddressProps): any {
    return {
      ...NatAddress.GVK,
      ...toJson_NatAddressProps(props),
    };
  }

  /**
   * Defines a "NATAddress" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NatAddressProps) {
    super(scope, id, {
      ...NatAddress.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NatAddress.GVK,
      ...toJson_NatAddressProps(resolved),
    };
  }
}

/**
 * NATAddress is the Schema for the NATAddresss API. Apigee NAT (network address translation) address.
 *
 * @schema NATAddress
 */
export interface NatAddressProps {
  /**
   * @schema NATAddress#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NATAddressSpec defines the desired state of NATAddress
   *
   * @schema NATAddress#spec
   */
  readonly spec: NatAddressSpec;

}

/**
 * Converts an object of type 'NatAddressProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressProps(obj: NatAddressProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NatAddressSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NATAddressSpec defines the desired state of NATAddress
 *
 * @schema NatAddressSpec
 */
export interface NatAddressSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NatAddressSpec#deletionPolicy
   */
  readonly deletionPolicy?: NatAddressSpecDeletionPolicy;

  /**
   * @schema NatAddressSpec#forProvider
   */
  readonly forProvider: NatAddressSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NatAddressSpec#managementPolicy
   */
  readonly managementPolicy?: NatAddressSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NatAddressSpec#providerConfigRef
   */
  readonly providerConfigRef?: NatAddressSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema NatAddressSpec#providerRef
   */
  readonly providerRef?: NatAddressSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NatAddressSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NatAddressSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NatAddressSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NatAddressSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NatAddressSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpec(obj: NatAddressSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NatAddressSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_NatAddressSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_NatAddressSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_NatAddressSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NatAddressSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NatAddressSpecDeletionPolicy
 */
export enum NatAddressSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NatAddressSpecForProvider
 */
export interface NatAddressSpecForProvider {
  /**
   * The Apigee instance associated with the Apigee environment, in the format organizations/{{org_name}}/instances/{{instance_name}}.
   *
   * @schema NatAddressSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in apigee to populate instanceId.
   *
   * @schema NatAddressSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: NatAddressSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in apigee to populate instanceId.
   *
   * @schema NatAddressSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: NatAddressSpecForProviderInstanceIdSelector;

}

/**
 * Converts an object of type 'NatAddressSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecForProvider(obj: NatAddressSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_NatAddressSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_NatAddressSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NatAddressSpecManagementPolicy
 */
export enum NatAddressSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NatAddressSpecProviderConfigRef
 */
export interface NatAddressSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NatAddressSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NatAddressSpecProviderConfigRef#policy
   */
  readonly policy?: NatAddressSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NatAddressSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecProviderConfigRef(obj: NatAddressSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NatAddressSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema NatAddressSpecProviderRef
 */
export interface NatAddressSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema NatAddressSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NatAddressSpecProviderRef#policy
   */
  readonly policy?: NatAddressSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'NatAddressSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecProviderRef(obj: NatAddressSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NatAddressSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NatAddressSpecPublishConnectionDetailsTo
 */
export interface NatAddressSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NatAddressSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NatAddressSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NatAddressSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NatAddressSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NatAddressSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NatAddressSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecPublishConnectionDetailsTo(obj: NatAddressSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NatAddressSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NatAddressSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NatAddressSpecWriteConnectionSecretToRef
 */
export interface NatAddressSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NatAddressSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NatAddressSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NatAddressSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecWriteConnectionSecretToRef(obj: NatAddressSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in apigee to populate instanceId.
 *
 * @schema NatAddressSpecForProviderInstanceIdRef
 */
export interface NatAddressSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema NatAddressSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NatAddressSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: NatAddressSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'NatAddressSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecForProviderInstanceIdRef(obj: NatAddressSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NatAddressSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in apigee to populate instanceId.
 *
 * @schema NatAddressSpecForProviderInstanceIdSelector
 */
export interface NatAddressSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NatAddressSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NatAddressSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NatAddressSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: NatAddressSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'NatAddressSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecForProviderInstanceIdSelector(obj: NatAddressSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NatAddressSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NatAddressSpecProviderConfigRefPolicy
 */
export interface NatAddressSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatAddressSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NatAddressSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatAddressSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NatAddressSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NatAddressSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecProviderConfigRefPolicy(obj: NatAddressSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NatAddressSpecProviderRefPolicy
 */
export interface NatAddressSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatAddressSpecProviderRefPolicy#resolution
   */
  readonly resolution?: NatAddressSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatAddressSpecProviderRefPolicy#resolve
   */
  readonly resolve?: NatAddressSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'NatAddressSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecProviderRefPolicy(obj: NatAddressSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NatAddressSpecPublishConnectionDetailsToConfigRef
 */
export interface NatAddressSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NatAddressSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NatAddressSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NatAddressSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NatAddressSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecPublishConnectionDetailsToConfigRef(obj: NatAddressSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NatAddressSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NatAddressSpecPublishConnectionDetailsToMetadata
 */
export interface NatAddressSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NatAddressSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NatAddressSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NatAddressSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NatAddressSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecPublishConnectionDetailsToMetadata(obj: NatAddressSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NatAddressSpecForProviderInstanceIdRefPolicy
 */
export interface NatAddressSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatAddressSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: NatAddressSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatAddressSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: NatAddressSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'NatAddressSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecForProviderInstanceIdRefPolicy(obj: NatAddressSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NatAddressSpecForProviderInstanceIdSelectorPolicy
 */
export interface NatAddressSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatAddressSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: NatAddressSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatAddressSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: NatAddressSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NatAddressSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecForProviderInstanceIdSelectorPolicy(obj: NatAddressSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatAddressSpecProviderConfigRefPolicyResolution
 */
export enum NatAddressSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatAddressSpecProviderConfigRefPolicyResolve
 */
export enum NatAddressSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatAddressSpecProviderRefPolicyResolution
 */
export enum NatAddressSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatAddressSpecProviderRefPolicyResolve
 */
export enum NatAddressSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NatAddressSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NatAddressSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NatAddressSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NatAddressSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NatAddressSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NatAddressSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NatAddressSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NatAddressSpecPublishConnectionDetailsToConfigRefPolicy(obj: NatAddressSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatAddressSpecForProviderInstanceIdRefPolicyResolution
 */
export enum NatAddressSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatAddressSpecForProviderInstanceIdRefPolicyResolve
 */
export enum NatAddressSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatAddressSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum NatAddressSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatAddressSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum NatAddressSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NatAddressSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NatAddressSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NatAddressSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NatAddressSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Organization is the Schema for the Organizations API. An
 *
 * @schema Organization
 */
export class Organization extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Organization"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigee.gcp.upbound.io/v1beta1',
    kind: 'Organization',
  }

  /**
   * Renders a Kubernetes manifest for "Organization".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OrganizationProps): any {
    return {
      ...Organization.GVK,
      ...toJson_OrganizationProps(props),
    };
  }

  /**
   * Defines a "Organization" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OrganizationProps) {
    super(scope, id, {
      ...Organization.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Organization.GVK,
      ...toJson_OrganizationProps(resolved),
    };
  }
}

/**
 * Organization is the Schema for the Organizations API. An
 *
 * @schema Organization
 */
export interface OrganizationProps {
  /**
   * @schema Organization#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OrganizationSpec defines the desired state of Organization
   *
   * @schema Organization#spec
   */
  readonly spec: OrganizationSpec;

}

/**
 * Converts an object of type 'OrganizationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationProps(obj: OrganizationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OrganizationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrganizationSpec defines the desired state of Organization
 *
 * @schema OrganizationSpec
 */
export interface OrganizationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OrganizationSpec#deletionPolicy
   */
  readonly deletionPolicy?: OrganizationSpecDeletionPolicy;

  /**
   * @schema OrganizationSpec#forProvider
   */
  readonly forProvider: OrganizationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OrganizationSpec#managementPolicy
   */
  readonly managementPolicy?: OrganizationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OrganizationSpec#providerConfigRef
   */
  readonly providerConfigRef?: OrganizationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema OrganizationSpec#providerRef
   */
  readonly providerRef?: OrganizationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OrganizationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OrganizationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OrganizationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OrganizationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OrganizationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpec(obj: OrganizationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OrganizationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_OrganizationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_OrganizationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_OrganizationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OrganizationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OrganizationSpecDeletionPolicy
 */
export enum OrganizationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OrganizationSpecForProvider
 */
export interface OrganizationSpecForProvider {
  /**
   * Primary GCP region for analytics data storage. For valid values, see Create an Apigee organization.
   *
   * @schema OrganizationSpecForProvider#analyticsRegion
   */
  readonly analyticsRegion?: string;

  /**
   * Compute Engine network used for Service Networking to be peered with Apigee runtime instances. See Getting started with the Service Networking API. Valid only when RuntimeType is set to CLOUD. The value can be updated only when there are no runtime instances. For example: "default".
   *
   * @schema OrganizationSpecForProvider#authorizedNetwork
   */
  readonly authorizedNetwork?: string;

  /**
   * Reference to a Network in compute to populate authorizedNetwork.
   *
   * @schema OrganizationSpecForProvider#authorizedNetworkRef
   */
  readonly authorizedNetworkRef?: OrganizationSpecForProviderAuthorizedNetworkRef;

  /**
   * Selector for a Network in compute to populate authorizedNetwork.
   *
   * @schema OrganizationSpecForProvider#authorizedNetworkSelector
   */
  readonly authorizedNetworkSelector?: OrganizationSpecForProviderAuthorizedNetworkSelector;

  /**
   * Billing type of the Apigee organization. See Apigee pricing.
   *
   * @schema OrganizationSpecForProvider#billingType
   */
  readonly billingType?: string;

  /**
   * Description of the Apigee organization.
   *
   * @schema OrganizationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The display name of the Apigee organization.
   *
   * @schema OrganizationSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The project ID associated with the Apigee organization.
   *
   * @schema OrganizationSpecForProvider#projectId
   */
  readonly projectId?: string;

  /**
   * Properties defined in the Apigee organization profile. Structure is documented below.
   *
   * @schema OrganizationSpecForProvider#properties
   */
  readonly properties?: OrganizationSpecForProviderProperties[];

  /**
   * Optional. This setting is applicable only for organizations that are soft-deleted (i.e., BillingType is not EVALUATION). It controls how long Organization data will be retained after the initial delete operation completes. During this period, the Organization may be restored to its last known state. After this period, the Organization will no longer be able to be restored. Default value is DELETION_RETENTION_UNSPECIFIED. Possible values are: DELETION_RETENTION_UNSPECIFIED, MINIMUM.
   *
   * @schema OrganizationSpecForProvider#retention
   */
  readonly retention?: string;

  /**
   * Cloud KMS key name used for encrypting the data that is stored and replicated across runtime instances. Update is not allowed after the organization is created. If not specified, a Google-Managed encryption key will be used. Valid only when RuntimeType is CLOUD. For example: projects/foo/locations/us/keyRings/bar/cryptoKeys/baz.
   *
   * @schema OrganizationSpecForProvider#runtimeDatabaseEncryptionKeyName
   */
  readonly runtimeDatabaseEncryptionKeyName?: string;

  /**
   * Reference to a CryptoKey in kms to populate runtimeDatabaseEncryptionKeyName.
   *
   * @schema OrganizationSpecForProvider#runtimeDatabaseEncryptionKeyNameRef
   */
  readonly runtimeDatabaseEncryptionKeyNameRef?: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRef;

  /**
   * Selector for a CryptoKey in kms to populate runtimeDatabaseEncryptionKeyName.
   *
   * @schema OrganizationSpecForProvider#runtimeDatabaseEncryptionKeyNameSelector
   */
  readonly runtimeDatabaseEncryptionKeyNameSelector?: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelector;

  /**
   * Runtime type of the Apigee organization based on the Apigee subscription purchased. Default value is CLOUD. Possible values are: CLOUD, HYBRID.
   *
   * @schema OrganizationSpecForProvider#runtimeType
   */
  readonly runtimeType?: string;

}

/**
 * Converts an object of type 'OrganizationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProvider(obj: OrganizationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'analyticsRegion': obj.analyticsRegion,
    'authorizedNetwork': obj.authorizedNetwork,
    'authorizedNetworkRef': toJson_OrganizationSpecForProviderAuthorizedNetworkRef(obj.authorizedNetworkRef),
    'authorizedNetworkSelector': toJson_OrganizationSpecForProviderAuthorizedNetworkSelector(obj.authorizedNetworkSelector),
    'billingType': obj.billingType,
    'description': obj.description,
    'displayName': obj.displayName,
    'projectId': obj.projectId,
    'properties': obj.properties?.map(y => toJson_OrganizationSpecForProviderProperties(y)),
    'retention': obj.retention,
    'runtimeDatabaseEncryptionKeyName': obj.runtimeDatabaseEncryptionKeyName,
    'runtimeDatabaseEncryptionKeyNameRef': toJson_OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRef(obj.runtimeDatabaseEncryptionKeyNameRef),
    'runtimeDatabaseEncryptionKeyNameSelector': toJson_OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelector(obj.runtimeDatabaseEncryptionKeyNameSelector),
    'runtimeType': obj.runtimeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OrganizationSpecManagementPolicy
 */
export enum OrganizationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OrganizationSpecProviderConfigRef
 */
export interface OrganizationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationSpecProviderConfigRef#policy
   */
  readonly policy?: OrganizationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecProviderConfigRef(obj: OrganizationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema OrganizationSpecProviderRef
 */
export interface OrganizationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationSpecProviderRef#policy
   */
  readonly policy?: OrganizationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'OrganizationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecProviderRef(obj: OrganizationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OrganizationSpecPublishConnectionDetailsTo
 */
export interface OrganizationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OrganizationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OrganizationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OrganizationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OrganizationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OrganizationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OrganizationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecPublishConnectionDetailsTo(obj: OrganizationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OrganizationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OrganizationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OrganizationSpecWriteConnectionSecretToRef
 */
export interface OrganizationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OrganizationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OrganizationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OrganizationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecWriteConnectionSecretToRef(obj: OrganizationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate authorizedNetwork.
 *
 * @schema OrganizationSpecForProviderAuthorizedNetworkRef
 */
export interface OrganizationSpecForProviderAuthorizedNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationSpecForProviderAuthorizedNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationSpecForProviderAuthorizedNetworkRef#policy
   */
  readonly policy?: OrganizationSpecForProviderAuthorizedNetworkRefPolicy;

}

/**
 * Converts an object of type 'OrganizationSpecForProviderAuthorizedNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProviderAuthorizedNetworkRef(obj: OrganizationSpecForProviderAuthorizedNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationSpecForProviderAuthorizedNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate authorizedNetwork.
 *
 * @schema OrganizationSpecForProviderAuthorizedNetworkSelector
 */
export interface OrganizationSpecForProviderAuthorizedNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema OrganizationSpecForProviderAuthorizedNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema OrganizationSpecForProviderAuthorizedNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema OrganizationSpecForProviderAuthorizedNetworkSelector#policy
   */
  readonly policy?: OrganizationSpecForProviderAuthorizedNetworkSelectorPolicy;

}

/**
 * Converts an object of type 'OrganizationSpecForProviderAuthorizedNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProviderAuthorizedNetworkSelector(obj: OrganizationSpecForProviderAuthorizedNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_OrganizationSpecForProviderAuthorizedNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OrganizationSpecForProviderProperties
 */
export interface OrganizationSpecForProviderProperties {
  /**
   * List of all properties in the object. Structure is documented below.
   *
   * @schema OrganizationSpecForProviderProperties#property
   */
  readonly property?: OrganizationSpecForProviderPropertiesProperty[];

}

/**
 * Converts an object of type 'OrganizationSpecForProviderProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProviderProperties(obj: OrganizationSpecForProviderProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'property': obj.property?.map(y => toJson_OrganizationSpecForProviderPropertiesProperty(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate runtimeDatabaseEncryptionKeyName.
 *
 * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRef
 */
export interface OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRef#policy
   */
  readonly policy?: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicy;

}

/**
 * Converts an object of type 'OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRef(obj: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate runtimeDatabaseEncryptionKeyName.
 *
 * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelector
 */
export interface OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelector#policy
   */
  readonly policy?: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicy;

}

/**
 * Converts an object of type 'OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelector(obj: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationSpecProviderConfigRefPolicy
 */
export interface OrganizationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecProviderConfigRefPolicy(obj: OrganizationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationSpecProviderRefPolicy
 */
export interface OrganizationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: OrganizationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: OrganizationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecProviderRefPolicy(obj: OrganizationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OrganizationSpecPublishConnectionDetailsToConfigRef
 */
export interface OrganizationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OrganizationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecPublishConnectionDetailsToConfigRef(obj: OrganizationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OrganizationSpecPublishConnectionDetailsToMetadata
 */
export interface OrganizationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OrganizationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecPublishConnectionDetailsToMetadata(obj: OrganizationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationSpecForProviderAuthorizedNetworkRefPolicy
 */
export interface OrganizationSpecForProviderAuthorizedNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationSpecForProviderAuthorizedNetworkRefPolicy#resolution
   */
  readonly resolution?: OrganizationSpecForProviderAuthorizedNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationSpecForProviderAuthorizedNetworkRefPolicy#resolve
   */
  readonly resolve?: OrganizationSpecForProviderAuthorizedNetworkRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationSpecForProviderAuthorizedNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProviderAuthorizedNetworkRefPolicy(obj: OrganizationSpecForProviderAuthorizedNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema OrganizationSpecForProviderAuthorizedNetworkSelectorPolicy
 */
export interface OrganizationSpecForProviderAuthorizedNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationSpecForProviderAuthorizedNetworkSelectorPolicy#resolution
   */
  readonly resolution?: OrganizationSpecForProviderAuthorizedNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationSpecForProviderAuthorizedNetworkSelectorPolicy#resolve
   */
  readonly resolve?: OrganizationSpecForProviderAuthorizedNetworkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationSpecForProviderAuthorizedNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProviderAuthorizedNetworkSelectorPolicy(obj: OrganizationSpecForProviderAuthorizedNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OrganizationSpecForProviderPropertiesProperty
 */
export interface OrganizationSpecForProviderPropertiesProperty {
  /**
   * Name of the property.
   *
   * @schema OrganizationSpecForProviderPropertiesProperty#name
   */
  readonly name?: string;

  /**
   * Value of the property.
   *
   * @schema OrganizationSpecForProviderPropertiesProperty#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'OrganizationSpecForProviderPropertiesProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProviderPropertiesProperty(obj: OrganizationSpecForProviderPropertiesProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicy
 */
export interface OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicy#resolution
   */
  readonly resolution?: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicy#resolve
   */
  readonly resolve?: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicy(obj: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicy
 */
export interface OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicy#resolution
   */
  readonly resolution?: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicy#resolve
   */
  readonly resolve?: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicy(obj: OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationSpecProviderConfigRefPolicyResolution
 */
export enum OrganizationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationSpecProviderConfigRefPolicyResolve
 */
export enum OrganizationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationSpecProviderRefPolicyResolution
 */
export enum OrganizationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationSpecProviderRefPolicyResolve
 */
export enum OrganizationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OrganizationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OrganizationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationSpecPublishConnectionDetailsToConfigRefPolicy(obj: OrganizationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationSpecForProviderAuthorizedNetworkRefPolicyResolution
 */
export enum OrganizationSpecForProviderAuthorizedNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationSpecForProviderAuthorizedNetworkRefPolicyResolve
 */
export enum OrganizationSpecForProviderAuthorizedNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationSpecForProviderAuthorizedNetworkSelectorPolicyResolution
 */
export enum OrganizationSpecForProviderAuthorizedNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationSpecForProviderAuthorizedNetworkSelectorPolicyResolve
 */
export enum OrganizationSpecForProviderAuthorizedNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicyResolution
 */
export enum OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicyResolve
 */
export enum OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicyResolution
 */
export enum OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicyResolve
 */
export enum OrganizationSpecForProviderRuntimeDatabaseEncryptionKeyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OrganizationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

