// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LicenseAssociation is the Schema for the LicenseAssociations API. Provides an Amazon Managed Grafana workspace license association resource.
 *
 * @schema LicenseAssociation
 */
export class LicenseAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LicenseAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'grafana.aws.upbound.io/v1beta1',
    kind: 'LicenseAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "LicenseAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LicenseAssociationProps): any {
    return {
      ...LicenseAssociation.GVK,
      ...toJson_LicenseAssociationProps(props),
    };
  }

  /**
   * Defines a "LicenseAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LicenseAssociationProps) {
    super(scope, id, {
      ...LicenseAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LicenseAssociation.GVK,
      ...toJson_LicenseAssociationProps(resolved),
    };
  }
}

/**
 * LicenseAssociation is the Schema for the LicenseAssociations API. Provides an Amazon Managed Grafana workspace license association resource.
 *
 * @schema LicenseAssociation
 */
export interface LicenseAssociationProps {
  /**
   * @schema LicenseAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LicenseAssociationSpec defines the desired state of LicenseAssociation
   *
   * @schema LicenseAssociation#spec
   */
  readonly spec: LicenseAssociationSpec;

}

/**
 * Converts an object of type 'LicenseAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationProps(obj: LicenseAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LicenseAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LicenseAssociationSpec defines the desired state of LicenseAssociation
 *
 * @schema LicenseAssociationSpec
 */
export interface LicenseAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LicenseAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: LicenseAssociationSpecDeletionPolicy;

  /**
   * @schema LicenseAssociationSpec#forProvider
   */
  readonly forProvider: LicenseAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema LicenseAssociationSpec#initProvider
   */
  readonly initProvider?: LicenseAssociationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LicenseAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: LicenseAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LicenseAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: LicenseAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LicenseAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LicenseAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LicenseAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LicenseAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LicenseAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpec(obj: LicenseAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LicenseAssociationSpecForProvider(obj.forProvider),
    'initProvider': toJson_LicenseAssociationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LicenseAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LicenseAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LicenseAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LicenseAssociationSpecDeletionPolicy
 */
export enum LicenseAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LicenseAssociationSpecForProvider
 */
export interface LicenseAssociationSpecForProvider {
  /**
   * The type of license for the workspace license association. Valid values are ENTERPRISE and ENTERPRISE_FREE_TRIAL.
   *
   * @schema LicenseAssociationSpecForProvider#licenseType
   */
  readonly licenseType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LicenseAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The workspace id.
   *
   * @schema LicenseAssociationSpecForProvider#workspaceId
   */
  readonly workspaceId?: string;

  /**
   * Reference to a Workspace in grafana to populate workspaceId.
   *
   * @schema LicenseAssociationSpecForProvider#workspaceIdRef
   */
  readonly workspaceIdRef?: LicenseAssociationSpecForProviderWorkspaceIdRef;

  /**
   * Selector for a Workspace in grafana to populate workspaceId.
   *
   * @schema LicenseAssociationSpecForProvider#workspaceIdSelector
   */
  readonly workspaceIdSelector?: LicenseAssociationSpecForProviderWorkspaceIdSelector;

}

/**
 * Converts an object of type 'LicenseAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecForProvider(obj: LicenseAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'licenseType': obj.licenseType,
    'region': obj.region,
    'workspaceId': obj.workspaceId,
    'workspaceIdRef': toJson_LicenseAssociationSpecForProviderWorkspaceIdRef(obj.workspaceIdRef),
    'workspaceIdSelector': toJson_LicenseAssociationSpecForProviderWorkspaceIdSelector(obj.workspaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema LicenseAssociationSpecInitProvider
 */
export interface LicenseAssociationSpecInitProvider {
  /**
   * The type of license for the workspace license association. Valid values are ENTERPRISE and ENTERPRISE_FREE_TRIAL.
   *
   * @schema LicenseAssociationSpecInitProvider#licenseType
   */
  readonly licenseType?: string;

}

/**
 * Converts an object of type 'LicenseAssociationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecInitProvider(obj: LicenseAssociationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'licenseType': obj.licenseType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LicenseAssociationSpecManagementPolicies
 */
export enum LicenseAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LicenseAssociationSpecProviderConfigRef
 */
export interface LicenseAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LicenseAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LicenseAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: LicenseAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LicenseAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecProviderConfigRef(obj: LicenseAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LicenseAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LicenseAssociationSpecPublishConnectionDetailsTo
 */
export interface LicenseAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LicenseAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LicenseAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LicenseAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LicenseAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LicenseAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LicenseAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecPublishConnectionDetailsTo(obj: LicenseAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LicenseAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LicenseAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LicenseAssociationSpecWriteConnectionSecretToRef
 */
export interface LicenseAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LicenseAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LicenseAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LicenseAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecWriteConnectionSecretToRef(obj: LicenseAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workspace in grafana to populate workspaceId.
 *
 * @schema LicenseAssociationSpecForProviderWorkspaceIdRef
 */
export interface LicenseAssociationSpecForProviderWorkspaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LicenseAssociationSpecForProviderWorkspaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LicenseAssociationSpecForProviderWorkspaceIdRef#policy
   */
  readonly policy?: LicenseAssociationSpecForProviderWorkspaceIdRefPolicy;

}

/**
 * Converts an object of type 'LicenseAssociationSpecForProviderWorkspaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecForProviderWorkspaceIdRef(obj: LicenseAssociationSpecForProviderWorkspaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LicenseAssociationSpecForProviderWorkspaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workspace in grafana to populate workspaceId.
 *
 * @schema LicenseAssociationSpecForProviderWorkspaceIdSelector
 */
export interface LicenseAssociationSpecForProviderWorkspaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LicenseAssociationSpecForProviderWorkspaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LicenseAssociationSpecForProviderWorkspaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LicenseAssociationSpecForProviderWorkspaceIdSelector#policy
   */
  readonly policy?: LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'LicenseAssociationSpecForProviderWorkspaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecForProviderWorkspaceIdSelector(obj: LicenseAssociationSpecForProviderWorkspaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LicenseAssociationSpecProviderConfigRefPolicy
 */
export interface LicenseAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LicenseAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LicenseAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LicenseAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LicenseAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LicenseAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecProviderConfigRefPolicy(obj: LicenseAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LicenseAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface LicenseAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LicenseAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LicenseAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LicenseAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecPublishConnectionDetailsToConfigRef(obj: LicenseAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LicenseAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface LicenseAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LicenseAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LicenseAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LicenseAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LicenseAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecPublishConnectionDetailsToMetadata(obj: LicenseAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LicenseAssociationSpecForProviderWorkspaceIdRefPolicy
 */
export interface LicenseAssociationSpecForProviderWorkspaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LicenseAssociationSpecForProviderWorkspaceIdRefPolicy#resolution
   */
  readonly resolution?: LicenseAssociationSpecForProviderWorkspaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LicenseAssociationSpecForProviderWorkspaceIdRefPolicy#resolve
   */
  readonly resolve?: LicenseAssociationSpecForProviderWorkspaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LicenseAssociationSpecForProviderWorkspaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecForProviderWorkspaceIdRefPolicy(obj: LicenseAssociationSpecForProviderWorkspaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicy
 */
export interface LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicy#resolution
   */
  readonly resolution?: LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicy#resolve
   */
  readonly resolve?: LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicy(obj: LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LicenseAssociationSpecProviderConfigRefPolicyResolution
 */
export enum LicenseAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LicenseAssociationSpecProviderConfigRefPolicyResolve
 */
export enum LicenseAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LicenseAssociationSpecForProviderWorkspaceIdRefPolicyResolution
 */
export enum LicenseAssociationSpecForProviderWorkspaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LicenseAssociationSpecForProviderWorkspaceIdRefPolicyResolve
 */
export enum LicenseAssociationSpecForProviderWorkspaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicyResolution
 */
export enum LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicyResolve
 */
export enum LicenseAssociationSpecForProviderWorkspaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LicenseAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RoleAssociation is the Schema for the RoleAssociations API. Provides an Amazon Managed Grafana workspace role association resource.
 *
 * @schema RoleAssociation
 */
export class RoleAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RoleAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'grafana.aws.upbound.io/v1beta1',
    kind: 'RoleAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "RoleAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RoleAssociationProps): any {
    return {
      ...RoleAssociation.GVK,
      ...toJson_RoleAssociationProps(props),
    };
  }

  /**
   * Defines a "RoleAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RoleAssociationProps) {
    super(scope, id, {
      ...RoleAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RoleAssociation.GVK,
      ...toJson_RoleAssociationProps(resolved),
    };
  }
}

/**
 * RoleAssociation is the Schema for the RoleAssociations API. Provides an Amazon Managed Grafana workspace role association resource.
 *
 * @schema RoleAssociation
 */
export interface RoleAssociationProps {
  /**
   * @schema RoleAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RoleAssociationSpec defines the desired state of RoleAssociation
   *
   * @schema RoleAssociation#spec
   */
  readonly spec: RoleAssociationSpec;

}

/**
 * Converts an object of type 'RoleAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationProps(obj: RoleAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RoleAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleAssociationSpec defines the desired state of RoleAssociation
 *
 * @schema RoleAssociationSpec
 */
export interface RoleAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RoleAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: RoleAssociationSpecDeletionPolicy;

  /**
   * @schema RoleAssociationSpec#forProvider
   */
  readonly forProvider: RoleAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RoleAssociationSpec#initProvider
   */
  readonly initProvider?: RoleAssociationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RoleAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: RoleAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RoleAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: RoleAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RoleAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RoleAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RoleAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RoleAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RoleAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpec(obj: RoleAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RoleAssociationSpecForProvider(obj.forProvider),
    'initProvider': toJson_RoleAssociationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RoleAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RoleAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RoleAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RoleAssociationSpecDeletionPolicy
 */
export enum RoleAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RoleAssociationSpecForProvider
 */
export interface RoleAssociationSpecForProvider {
  /**
   * The AWS SSO group ids to be assigned the role given in role.
   *
   * @schema RoleAssociationSpecForProvider#groupIds
   */
  readonly groupIds?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RoleAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The grafana role. Valid values can be found here.
   *
   * @schema RoleAssociationSpecForProvider#role
   */
  readonly role?: string;

  /**
   * The AWS SSO user ids to be assigned the role given in role.
   *
   * @schema RoleAssociationSpecForProvider#userIds
   */
  readonly userIds?: string[];

  /**
   * The workspace id.
   *
   * @schema RoleAssociationSpecForProvider#workspaceId
   */
  readonly workspaceId?: string;

  /**
   * Reference to a Workspace to populate workspaceId.
   *
   * @schema RoleAssociationSpecForProvider#workspaceIdRef
   */
  readonly workspaceIdRef?: RoleAssociationSpecForProviderWorkspaceIdRef;

  /**
   * Selector for a Workspace to populate workspaceId.
   *
   * @schema RoleAssociationSpecForProvider#workspaceIdSelector
   */
  readonly workspaceIdSelector?: RoleAssociationSpecForProviderWorkspaceIdSelector;

}

/**
 * Converts an object of type 'RoleAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecForProvider(obj: RoleAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIds': obj.groupIds?.map(y => y),
    'region': obj.region,
    'role': obj.role,
    'userIds': obj.userIds?.map(y => y),
    'workspaceId': obj.workspaceId,
    'workspaceIdRef': toJson_RoleAssociationSpecForProviderWorkspaceIdRef(obj.workspaceIdRef),
    'workspaceIdSelector': toJson_RoleAssociationSpecForProviderWorkspaceIdSelector(obj.workspaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RoleAssociationSpecInitProvider
 */
export interface RoleAssociationSpecInitProvider {
  /**
   * The AWS SSO group ids to be assigned the role given in role.
   *
   * @schema RoleAssociationSpecInitProvider#groupIds
   */
  readonly groupIds?: string[];

  /**
   * The grafana role. Valid values can be found here.
   *
   * @schema RoleAssociationSpecInitProvider#role
   */
  readonly role?: string;

  /**
   * The AWS SSO user ids to be assigned the role given in role.
   *
   * @schema RoleAssociationSpecInitProvider#userIds
   */
  readonly userIds?: string[];

}

/**
 * Converts an object of type 'RoleAssociationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecInitProvider(obj: RoleAssociationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIds': obj.groupIds?.map(y => y),
    'role': obj.role,
    'userIds': obj.userIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RoleAssociationSpecManagementPolicies
 */
export enum RoleAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RoleAssociationSpecProviderConfigRef
 */
export interface RoleAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoleAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoleAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: RoleAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RoleAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecProviderConfigRef(obj: RoleAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoleAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RoleAssociationSpecPublishConnectionDetailsTo
 */
export interface RoleAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RoleAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RoleAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RoleAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RoleAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RoleAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RoleAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecPublishConnectionDetailsTo(obj: RoleAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RoleAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RoleAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RoleAssociationSpecWriteConnectionSecretToRef
 */
export interface RoleAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RoleAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RoleAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RoleAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecWriteConnectionSecretToRef(obj: RoleAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workspace to populate workspaceId.
 *
 * @schema RoleAssociationSpecForProviderWorkspaceIdRef
 */
export interface RoleAssociationSpecForProviderWorkspaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoleAssociationSpecForProviderWorkspaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoleAssociationSpecForProviderWorkspaceIdRef#policy
   */
  readonly policy?: RoleAssociationSpecForProviderWorkspaceIdRefPolicy;

}

/**
 * Converts an object of type 'RoleAssociationSpecForProviderWorkspaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecForProviderWorkspaceIdRef(obj: RoleAssociationSpecForProviderWorkspaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoleAssociationSpecForProviderWorkspaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workspace to populate workspaceId.
 *
 * @schema RoleAssociationSpecForProviderWorkspaceIdSelector
 */
export interface RoleAssociationSpecForProviderWorkspaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RoleAssociationSpecForProviderWorkspaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RoleAssociationSpecForProviderWorkspaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RoleAssociationSpecForProviderWorkspaceIdSelector#policy
   */
  readonly policy?: RoleAssociationSpecForProviderWorkspaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'RoleAssociationSpecForProviderWorkspaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecForProviderWorkspaceIdSelector(obj: RoleAssociationSpecForProviderWorkspaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RoleAssociationSpecForProviderWorkspaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoleAssociationSpecProviderConfigRefPolicy
 */
export interface RoleAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoleAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RoleAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoleAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RoleAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RoleAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecProviderConfigRefPolicy(obj: RoleAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RoleAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface RoleAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoleAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoleAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RoleAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecPublishConnectionDetailsToConfigRef(obj: RoleAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RoleAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface RoleAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RoleAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RoleAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RoleAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RoleAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecPublishConnectionDetailsToMetadata(obj: RoleAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoleAssociationSpecForProviderWorkspaceIdRefPolicy
 */
export interface RoleAssociationSpecForProviderWorkspaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoleAssociationSpecForProviderWorkspaceIdRefPolicy#resolution
   */
  readonly resolution?: RoleAssociationSpecForProviderWorkspaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoleAssociationSpecForProviderWorkspaceIdRefPolicy#resolve
   */
  readonly resolve?: RoleAssociationSpecForProviderWorkspaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RoleAssociationSpecForProviderWorkspaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecForProviderWorkspaceIdRefPolicy(obj: RoleAssociationSpecForProviderWorkspaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RoleAssociationSpecForProviderWorkspaceIdSelectorPolicy
 */
export interface RoleAssociationSpecForProviderWorkspaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoleAssociationSpecForProviderWorkspaceIdSelectorPolicy#resolution
   */
  readonly resolution?: RoleAssociationSpecForProviderWorkspaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoleAssociationSpecForProviderWorkspaceIdSelectorPolicy#resolve
   */
  readonly resolve?: RoleAssociationSpecForProviderWorkspaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RoleAssociationSpecForProviderWorkspaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecForProviderWorkspaceIdSelectorPolicy(obj: RoleAssociationSpecForProviderWorkspaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoleAssociationSpecProviderConfigRefPolicyResolution
 */
export enum RoleAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoleAssociationSpecProviderConfigRefPolicyResolve
 */
export enum RoleAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoleAssociationSpecForProviderWorkspaceIdRefPolicyResolution
 */
export enum RoleAssociationSpecForProviderWorkspaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoleAssociationSpecForProviderWorkspaceIdRefPolicyResolve
 */
export enum RoleAssociationSpecForProviderWorkspaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoleAssociationSpecForProviderWorkspaceIdSelectorPolicyResolution
 */
export enum RoleAssociationSpecForProviderWorkspaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoleAssociationSpecForProviderWorkspaceIdSelectorPolicyResolve
 */
export enum RoleAssociationSpecForProviderWorkspaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Workspace is the Schema for the Workspaces API. Provides an Amazon Managed Grafana workspace resource.
 *
 * @schema Workspace
 */
export class Workspace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Workspace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'grafana.aws.upbound.io/v1beta1',
    kind: 'Workspace',
  }

  /**
   * Renders a Kubernetes manifest for "Workspace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkspaceProps): any {
    return {
      ...Workspace.GVK,
      ...toJson_WorkspaceProps(props),
    };
  }

  /**
   * Defines a "Workspace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkspaceProps) {
    super(scope, id, {
      ...Workspace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Workspace.GVK,
      ...toJson_WorkspaceProps(resolved),
    };
  }
}

/**
 * Workspace is the Schema for the Workspaces API. Provides an Amazon Managed Grafana workspace resource.
 *
 * @schema Workspace
 */
export interface WorkspaceProps {
  /**
   * @schema Workspace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkspaceSpec defines the desired state of Workspace
   *
   * @schema Workspace#spec
   */
  readonly spec: WorkspaceSpec;

}

/**
 * Converts an object of type 'WorkspaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceProps(obj: WorkspaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkspaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkspaceSpec defines the desired state of Workspace
 *
 * @schema WorkspaceSpec
 */
export interface WorkspaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkspaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkspaceSpecDeletionPolicy;

  /**
   * @schema WorkspaceSpec#forProvider
   */
  readonly forProvider: WorkspaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema WorkspaceSpec#initProvider
   */
  readonly initProvider?: WorkspaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkspaceSpec#managementPolicies
   */
  readonly managementPolicies?: WorkspaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkspaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkspaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkspaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkspaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkspaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkspaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkspaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpec(obj: WorkspaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkspaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_WorkspaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkspaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkspaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkspaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkspaceSpecDeletionPolicy
 */
export enum WorkspaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkspaceSpecForProvider
 */
export interface WorkspaceSpecForProvider {
  /**
   * The type of account access for the workspace. Valid values are CURRENT_ACCOUNT and ORGANIZATION. If ORGANIZATION is specified, then organizational_units must also be present.
   *
   * @schema WorkspaceSpecForProvider#accountAccessType
   */
  readonly accountAccessType?: string;

  /**
   * The authentication providers for the workspace. Valid values are AWS_SSO, SAML, or both.
   *
   * @schema WorkspaceSpecForProvider#authenticationProviders
   */
  readonly authenticationProviders?: string[];

  /**
   * The configuration string for the workspace that you create. For more information about the format and configuration options available, see Working in your Grafana workspace.
   *
   * @schema WorkspaceSpecForProvider#configuration
   */
  readonly configuration?: string;

  /**
   * The data sources for the workspace. Valid values are AMAZON_OPENSEARCH_SERVICE, ATHENA, CLOUDWATCH, PROMETHEUS, REDSHIFT, SITEWISE, TIMESTREAM, XRAY
   *
   * @schema WorkspaceSpecForProvider#dataSources
   */
  readonly dataSources?: string[];

  /**
   * The workspace description.
   *
   * @schema WorkspaceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies the version of Grafana to support in the new workspace. Supported values are 8.4 and 9.4. If not specified, defaults to 8.4. Upgrading the workspace version isn't supported, however it's possible to copy content from the old version to the new one using AWS official migration tool.
   *
   * @schema WorkspaceSpecForProvider#grafanaVersion
   */
  readonly grafanaVersion?: string;

  /**
   * The Grafana workspace name.
   *
   * @schema WorkspaceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Configuration for network access to your workspace.See Network Access Control below.
   *
   * @schema WorkspaceSpecForProvider#networkAccessControl
   */
  readonly networkAccessControl?: WorkspaceSpecForProviderNetworkAccessControl[];

  /**
   * The notification destinations. If a data source is specified here, Amazon Managed Grafana will create IAM roles and permissions needed to use these destinations. Must be set to SNS.
   *
   * @schema WorkspaceSpecForProvider#notificationDestinations
   */
  readonly notificationDestinations?: string[];

  /**
   * The role name that the workspace uses to access resources through Amazon Organizations.
   *
   * @schema WorkspaceSpecForProvider#organizationRoleName
   */
  readonly organizationRoleName?: string;

  /**
   * The Amazon Organizations organizational units that the workspace is authorized to use data sources from.
   *
   * @schema WorkspaceSpecForProvider#organizationalUnits
   */
  readonly organizationalUnits?: string[];

  /**
   * The permission type of the workspace. If SERVICE_MANAGED is specified, the IAM roles and IAM policy attachments are generated automatically. If CUSTOMER_MANAGED is specified, the IAM roles and IAM policy attachments will not be created.
   *
   * @schema WorkspaceSpecForProvider#permissionType
   */
  readonly permissionType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkspaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The IAM role ARN that the workspace assumes.
   *
   * @schema WorkspaceSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema WorkspaceSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: WorkspaceSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema WorkspaceSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: WorkspaceSpecForProviderRoleArnSelector;

  /**
   * The AWS CloudFormation stack set name that provisions IAM roles to be used by the workspace.
   *
   * @schema WorkspaceSpecForProvider#stackSetName
   */
  readonly stackSetName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkspaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The configuration settings for an Amazon VPC that contains data sources for your Grafana workspace to connect to. See VPC Configuration below.
   *
   * @schema WorkspaceSpecForProvider#vpcConfiguration
   */
  readonly vpcConfiguration?: WorkspaceSpecForProviderVpcConfiguration[];

}

/**
 * Converts an object of type 'WorkspaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProvider(obj: WorkspaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountAccessType': obj.accountAccessType,
    'authenticationProviders': obj.authenticationProviders?.map(y => y),
    'configuration': obj.configuration,
    'dataSources': obj.dataSources?.map(y => y),
    'description': obj.description,
    'grafanaVersion': obj.grafanaVersion,
    'name': obj.name,
    'networkAccessControl': obj.networkAccessControl?.map(y => toJson_WorkspaceSpecForProviderNetworkAccessControl(y)),
    'notificationDestinations': obj.notificationDestinations?.map(y => y),
    'organizationRoleName': obj.organizationRoleName,
    'organizationalUnits': obj.organizationalUnits?.map(y => y),
    'permissionType': obj.permissionType,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_WorkspaceSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_WorkspaceSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'stackSetName': obj.stackSetName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcConfiguration': obj.vpcConfiguration?.map(y => toJson_WorkspaceSpecForProviderVpcConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema WorkspaceSpecInitProvider
 */
export interface WorkspaceSpecInitProvider {
  /**
   * The type of account access for the workspace. Valid values are CURRENT_ACCOUNT and ORGANIZATION. If ORGANIZATION is specified, then organizational_units must also be present.
   *
   * @schema WorkspaceSpecInitProvider#accountAccessType
   */
  readonly accountAccessType?: string;

  /**
   * The authentication providers for the workspace. Valid values are AWS_SSO, SAML, or both.
   *
   * @schema WorkspaceSpecInitProvider#authenticationProviders
   */
  readonly authenticationProviders?: string[];

  /**
   * The configuration string for the workspace that you create. For more information about the format and configuration options available, see Working in your Grafana workspace.
   *
   * @schema WorkspaceSpecInitProvider#configuration
   */
  readonly configuration?: string;

  /**
   * The data sources for the workspace. Valid values are AMAZON_OPENSEARCH_SERVICE, ATHENA, CLOUDWATCH, PROMETHEUS, REDSHIFT, SITEWISE, TIMESTREAM, XRAY
   *
   * @schema WorkspaceSpecInitProvider#dataSources
   */
  readonly dataSources?: string[];

  /**
   * The workspace description.
   *
   * @schema WorkspaceSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Specifies the version of Grafana to support in the new workspace. Supported values are 8.4 and 9.4. If not specified, defaults to 8.4. Upgrading the workspace version isn't supported, however it's possible to copy content from the old version to the new one using AWS official migration tool.
   *
   * @schema WorkspaceSpecInitProvider#grafanaVersion
   */
  readonly grafanaVersion?: string;

  /**
   * The Grafana workspace name.
   *
   * @schema WorkspaceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Configuration for network access to your workspace.See Network Access Control below.
   *
   * @schema WorkspaceSpecInitProvider#networkAccessControl
   */
  readonly networkAccessControl?: WorkspaceSpecInitProviderNetworkAccessControl[];

  /**
   * The notification destinations. If a data source is specified here, Amazon Managed Grafana will create IAM roles and permissions needed to use these destinations. Must be set to SNS.
   *
   * @schema WorkspaceSpecInitProvider#notificationDestinations
   */
  readonly notificationDestinations?: string[];

  /**
   * The role name that the workspace uses to access resources through Amazon Organizations.
   *
   * @schema WorkspaceSpecInitProvider#organizationRoleName
   */
  readonly organizationRoleName?: string;

  /**
   * The Amazon Organizations organizational units that the workspace is authorized to use data sources from.
   *
   * @schema WorkspaceSpecInitProvider#organizationalUnits
   */
  readonly organizationalUnits?: string[];

  /**
   * The permission type of the workspace. If SERVICE_MANAGED is specified, the IAM roles and IAM policy attachments are generated automatically. If CUSTOMER_MANAGED is specified, the IAM roles and IAM policy attachments will not be created.
   *
   * @schema WorkspaceSpecInitProvider#permissionType
   */
  readonly permissionType?: string;

  /**
   * The AWS CloudFormation stack set name that provisions IAM roles to be used by the workspace.
   *
   * @schema WorkspaceSpecInitProvider#stackSetName
   */
  readonly stackSetName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkspaceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The configuration settings for an Amazon VPC that contains data sources for your Grafana workspace to connect to. See VPC Configuration below.
   *
   * @schema WorkspaceSpecInitProvider#vpcConfiguration
   */
  readonly vpcConfiguration?: WorkspaceSpecInitProviderVpcConfiguration[];

}

/**
 * Converts an object of type 'WorkspaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecInitProvider(obj: WorkspaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountAccessType': obj.accountAccessType,
    'authenticationProviders': obj.authenticationProviders?.map(y => y),
    'configuration': obj.configuration,
    'dataSources': obj.dataSources?.map(y => y),
    'description': obj.description,
    'grafanaVersion': obj.grafanaVersion,
    'name': obj.name,
    'networkAccessControl': obj.networkAccessControl?.map(y => toJson_WorkspaceSpecInitProviderNetworkAccessControl(y)),
    'notificationDestinations': obj.notificationDestinations?.map(y => y),
    'organizationRoleName': obj.organizationRoleName,
    'organizationalUnits': obj.organizationalUnits?.map(y => y),
    'permissionType': obj.permissionType,
    'stackSetName': obj.stackSetName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcConfiguration': obj.vpcConfiguration?.map(y => toJson_WorkspaceSpecInitProviderVpcConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkspaceSpecManagementPolicies
 */
export enum WorkspaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkspaceSpecProviderConfigRef
 */
export interface WorkspaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSpecProviderConfigRef#policy
   */
  readonly policy?: WorkspaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecProviderConfigRef(obj: WorkspaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsTo
 */
export interface WorkspaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkspaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkspaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsTo(obj: WorkspaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkspaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkspaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkspaceSpecWriteConnectionSecretToRef
 */
export interface WorkspaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkspaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkspaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkspaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecWriteConnectionSecretToRef(obj: WorkspaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkspaceSpecForProviderNetworkAccessControl
 */
export interface WorkspaceSpecForProviderNetworkAccessControl {
  /**
   * - An array of prefix list IDs.
   *
   * @schema WorkspaceSpecForProviderNetworkAccessControl#prefixListIds
   */
  readonly prefixListIds?: string[];

  /**
   * - An array of Amazon VPC endpoint IDs for the workspace. The only VPC endpoints that can be specified here are interface VPC endpoints for Grafana workspaces (using the com.amazonaws.[region].grafana-workspace service endpoint). Other VPC endpoints will be ignored.
   *
   * @schema WorkspaceSpecForProviderNetworkAccessControl#vpceIds
   */
  readonly vpceIds?: string[];

}

/**
 * Converts an object of type 'WorkspaceSpecForProviderNetworkAccessControl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProviderNetworkAccessControl(obj: WorkspaceSpecForProviderNetworkAccessControl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefixListIds': obj.prefixListIds?.map(y => y),
    'vpceIds': obj.vpceIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema WorkspaceSpecForProviderRoleArnRef
 */
export interface WorkspaceSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSpecForProviderRoleArnRef#policy
   */
  readonly policy?: WorkspaceSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProviderRoleArnRef(obj: WorkspaceSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema WorkspaceSpecForProviderRoleArnSelector
 */
export interface WorkspaceSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkspaceSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkspaceSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkspaceSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: WorkspaceSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProviderRoleArnSelector(obj: WorkspaceSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkspaceSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkspaceSpecForProviderVpcConfiguration
 */
export interface WorkspaceSpecForProviderVpcConfiguration {
  /**
   * - The list of Amazon EC2 security group IDs attached to the Amazon VPC for your Grafana workspace to connect.
   *
   * @schema WorkspaceSpecForProviderVpcConfiguration#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * - The list of Amazon EC2 subnet IDs created in the Amazon VPC for your Grafana workspace to connect.
   *
   * @schema WorkspaceSpecForProviderVpcConfiguration#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'WorkspaceSpecForProviderVpcConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProviderVpcConfiguration(obj: WorkspaceSpecForProviderVpcConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkspaceSpecInitProviderNetworkAccessControl
 */
export interface WorkspaceSpecInitProviderNetworkAccessControl {
  /**
   * - An array of prefix list IDs.
   *
   * @schema WorkspaceSpecInitProviderNetworkAccessControl#prefixListIds
   */
  readonly prefixListIds?: string[];

  /**
   * - An array of Amazon VPC endpoint IDs for the workspace. The only VPC endpoints that can be specified here are interface VPC endpoints for Grafana workspaces (using the com.amazonaws.[region].grafana-workspace service endpoint). Other VPC endpoints will be ignored.
   *
   * @schema WorkspaceSpecInitProviderNetworkAccessControl#vpceIds
   */
  readonly vpceIds?: string[];

}

/**
 * Converts an object of type 'WorkspaceSpecInitProviderNetworkAccessControl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecInitProviderNetworkAccessControl(obj: WorkspaceSpecInitProviderNetworkAccessControl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefixListIds': obj.prefixListIds?.map(y => y),
    'vpceIds': obj.vpceIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkspaceSpecInitProviderVpcConfiguration
 */
export interface WorkspaceSpecInitProviderVpcConfiguration {
  /**
   * - The list of Amazon EC2 security group IDs attached to the Amazon VPC for your Grafana workspace to connect.
   *
   * @schema WorkspaceSpecInitProviderVpcConfiguration#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * - The list of Amazon EC2 subnet IDs created in the Amazon VPC for your Grafana workspace to connect.
   *
   * @schema WorkspaceSpecInitProviderVpcConfiguration#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'WorkspaceSpecInitProviderVpcConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecInitProviderVpcConfiguration(obj: WorkspaceSpecInitProviderVpcConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicy
 */
export interface WorkspaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecProviderConfigRefPolicy(obj: WorkspaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkspaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToConfigRef(obj: WorkspaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToMetadata
 */
export interface WorkspaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToMetadata(obj: WorkspaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSpecForProviderRoleArnRefPolicy
 */
export interface WorkspaceSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProviderRoleArnRefPolicy(obj: WorkspaceSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkspaceSpecForProviderRoleArnSelectorPolicy
 */
export interface WorkspaceSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProviderRoleArnSelectorPolicy(obj: WorkspaceSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicyResolution
 */
export enum WorkspaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicyResolve
 */
export enum WorkspaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecForProviderRoleArnRefPolicyResolution
 */
export enum WorkspaceSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecForProviderRoleArnRefPolicyResolve
 */
export enum WorkspaceSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum WorkspaceSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum WorkspaceSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * WorkspaceAPIKey is the Schema for the WorkspaceAPIKeys API. Creates a Grafana API key for the workspace. This key can be used to authenticate requests sent to the workspace's HTTP API.
 *
 * @schema WorkspaceAPIKey
 */
export class WorkspaceApiKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkspaceAPIKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'grafana.aws.upbound.io/v1beta1',
    kind: 'WorkspaceAPIKey',
  }

  /**
   * Renders a Kubernetes manifest for "WorkspaceAPIKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkspaceApiKeyProps): any {
    return {
      ...WorkspaceApiKey.GVK,
      ...toJson_WorkspaceApiKeyProps(props),
    };
  }

  /**
   * Defines a "WorkspaceAPIKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkspaceApiKeyProps) {
    super(scope, id, {
      ...WorkspaceApiKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkspaceApiKey.GVK,
      ...toJson_WorkspaceApiKeyProps(resolved),
    };
  }
}

/**
 * WorkspaceAPIKey is the Schema for the WorkspaceAPIKeys API. Creates a Grafana API key for the workspace. This key can be used to authenticate requests sent to the workspace's HTTP API.
 *
 * @schema WorkspaceAPIKey
 */
export interface WorkspaceApiKeyProps {
  /**
   * @schema WorkspaceAPIKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkspaceAPIKeySpec defines the desired state of WorkspaceAPIKey
   *
   * @schema WorkspaceAPIKey#spec
   */
  readonly spec: WorkspaceApiKeySpec;

}

/**
 * Converts an object of type 'WorkspaceApiKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeyProps(obj: WorkspaceApiKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkspaceApiKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkspaceAPIKeySpec defines the desired state of WorkspaceAPIKey
 *
 * @schema WorkspaceApiKeySpec
 */
export interface WorkspaceApiKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkspaceApiKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkspaceApiKeySpecDeletionPolicy;

  /**
   * @schema WorkspaceApiKeySpec#forProvider
   */
  readonly forProvider: WorkspaceApiKeySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema WorkspaceApiKeySpec#initProvider
   */
  readonly initProvider?: WorkspaceApiKeySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkspaceApiKeySpec#managementPolicies
   */
  readonly managementPolicies?: WorkspaceApiKeySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkspaceApiKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkspaceApiKeySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkspaceApiKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkspaceApiKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkspaceApiKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkspaceApiKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpec(obj: WorkspaceApiKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkspaceApiKeySpecForProvider(obj.forProvider),
    'initProvider': toJson_WorkspaceApiKeySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkspaceApiKeySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkspaceApiKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkspaceApiKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkspaceApiKeySpecDeletionPolicy
 */
export enum WorkspaceApiKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkspaceApiKeySpecForProvider
 */
export interface WorkspaceApiKeySpecForProvider {
  /**
   * Specifies the name of the API key. Key names must be unique to the workspace.
   *
   * @schema WorkspaceApiKeySpecForProvider#keyName
   */
  readonly keyName?: string;

  /**
   * Specifies the permission level of the API key. Valid values are VIEWER, EDITOR, or ADMIN.
   *
   * @schema WorkspaceApiKeySpecForProvider#keyRole
   */
  readonly keyRole?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkspaceApiKeySpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the time in seconds until the API key expires. Keys can be valid for up to 30 days.
   *
   * @schema WorkspaceApiKeySpecForProvider#secondsToLive
   */
  readonly secondsToLive?: number;

  /**
   * The ID of the workspace that the API key is valid for.
   *
   * @schema WorkspaceApiKeySpecForProvider#workspaceId
   */
  readonly workspaceId?: string;

  /**
   * Reference to a Workspace in grafana to populate workspaceId.
   *
   * @schema WorkspaceApiKeySpecForProvider#workspaceIdRef
   */
  readonly workspaceIdRef?: WorkspaceApiKeySpecForProviderWorkspaceIdRef;

  /**
   * Selector for a Workspace in grafana to populate workspaceId.
   *
   * @schema WorkspaceApiKeySpecForProvider#workspaceIdSelector
   */
  readonly workspaceIdSelector?: WorkspaceApiKeySpecForProviderWorkspaceIdSelector;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecForProvider(obj: WorkspaceApiKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'keyRole': obj.keyRole,
    'region': obj.region,
    'secondsToLive': obj.secondsToLive,
    'workspaceId': obj.workspaceId,
    'workspaceIdRef': toJson_WorkspaceApiKeySpecForProviderWorkspaceIdRef(obj.workspaceIdRef),
    'workspaceIdSelector': toJson_WorkspaceApiKeySpecForProviderWorkspaceIdSelector(obj.workspaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema WorkspaceApiKeySpecInitProvider
 */
export interface WorkspaceApiKeySpecInitProvider {
  /**
   * Specifies the name of the API key. Key names must be unique to the workspace.
   *
   * @schema WorkspaceApiKeySpecInitProvider#keyName
   */
  readonly keyName?: string;

  /**
   * Specifies the permission level of the API key. Valid values are VIEWER, EDITOR, or ADMIN.
   *
   * @schema WorkspaceApiKeySpecInitProvider#keyRole
   */
  readonly keyRole?: string;

  /**
   * Specifies the time in seconds until the API key expires. Keys can be valid for up to 30 days.
   *
   * @schema WorkspaceApiKeySpecInitProvider#secondsToLive
   */
  readonly secondsToLive?: number;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecInitProvider(obj: WorkspaceApiKeySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'keyRole': obj.keyRole,
    'secondsToLive': obj.secondsToLive,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkspaceApiKeySpecManagementPolicies
 */
export enum WorkspaceApiKeySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkspaceApiKeySpecProviderConfigRef
 */
export interface WorkspaceApiKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceApiKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceApiKeySpecProviderConfigRef#policy
   */
  readonly policy?: WorkspaceApiKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecProviderConfigRef(obj: WorkspaceApiKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceApiKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkspaceApiKeySpecPublishConnectionDetailsTo
 */
export interface WorkspaceApiKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkspaceApiKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkspaceApiKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkspaceApiKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkspaceApiKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkspaceApiKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecPublishConnectionDetailsTo(obj: WorkspaceApiKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkspaceApiKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkspaceApiKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkspaceApiKeySpecWriteConnectionSecretToRef
 */
export interface WorkspaceApiKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkspaceApiKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkspaceApiKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecWriteConnectionSecretToRef(obj: WorkspaceApiKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workspace in grafana to populate workspaceId.
 *
 * @schema WorkspaceApiKeySpecForProviderWorkspaceIdRef
 */
export interface WorkspaceApiKeySpecForProviderWorkspaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceApiKeySpecForProviderWorkspaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceApiKeySpecForProviderWorkspaceIdRef#policy
   */
  readonly policy?: WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecForProviderWorkspaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecForProviderWorkspaceIdRef(obj: WorkspaceApiKeySpecForProviderWorkspaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workspace in grafana to populate workspaceId.
 *
 * @schema WorkspaceApiKeySpecForProviderWorkspaceIdSelector
 */
export interface WorkspaceApiKeySpecForProviderWorkspaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkspaceApiKeySpecForProviderWorkspaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkspaceApiKeySpecForProviderWorkspaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkspaceApiKeySpecForProviderWorkspaceIdSelector#policy
   */
  readonly policy?: WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecForProviderWorkspaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecForProviderWorkspaceIdSelector(obj: WorkspaceApiKeySpecForProviderWorkspaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkspaceApiKeySpecProviderConfigRefPolicy
 */
export interface WorkspaceApiKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceApiKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceApiKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceApiKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceApiKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecProviderConfigRefPolicy(obj: WorkspaceApiKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkspaceApiKeySpecPublishConnectionDetailsToConfigRef
 */
export interface WorkspaceApiKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceApiKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceApiKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecPublishConnectionDetailsToConfigRef(obj: WorkspaceApiKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkspaceApiKeySpecPublishConnectionDetailsToMetadata
 */
export interface WorkspaceApiKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceApiKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceApiKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkspaceApiKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecPublishConnectionDetailsToMetadata(obj: WorkspaceApiKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicy
 */
export interface WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicy#resolution
   */
  readonly resolution?: WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicy#resolve
   */
  readonly resolve?: WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicy(obj: WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicy
 */
export interface WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicy#resolution
   */
  readonly resolution?: WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicy#resolve
   */
  readonly resolve?: WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicy(obj: WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceApiKeySpecProviderConfigRefPolicyResolution
 */
export enum WorkspaceApiKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceApiKeySpecProviderConfigRefPolicyResolve
 */
export enum WorkspaceApiKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicyResolution
 */
export enum WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicyResolve
 */
export enum WorkspaceApiKeySpecForProviderWorkspaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicyResolution
 */
export enum WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicyResolve
 */
export enum WorkspaceApiKeySpecForProviderWorkspaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkspaceApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * WorkspaceSAMLConfiguration is the Schema for the WorkspaceSAMLConfigurations API. Provides an Amazon Managed Grafana workspace SAML configuration resource.
 *
 * @schema WorkspaceSAMLConfiguration
 */
export class WorkspaceSamlConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkspaceSAMLConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'grafana.aws.upbound.io/v1beta1',
    kind: 'WorkspaceSAMLConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "WorkspaceSAMLConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkspaceSamlConfigurationProps): any {
    return {
      ...WorkspaceSamlConfiguration.GVK,
      ...toJson_WorkspaceSamlConfigurationProps(props),
    };
  }

  /**
   * Defines a "WorkspaceSAMLConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkspaceSamlConfigurationProps) {
    super(scope, id, {
      ...WorkspaceSamlConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkspaceSamlConfiguration.GVK,
      ...toJson_WorkspaceSamlConfigurationProps(resolved),
    };
  }
}

/**
 * WorkspaceSAMLConfiguration is the Schema for the WorkspaceSAMLConfigurations API. Provides an Amazon Managed Grafana workspace SAML configuration resource.
 *
 * @schema WorkspaceSAMLConfiguration
 */
export interface WorkspaceSamlConfigurationProps {
  /**
   * @schema WorkspaceSAMLConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkspaceSAMLConfigurationSpec defines the desired state of WorkspaceSAMLConfiguration
   *
   * @schema WorkspaceSAMLConfiguration#spec
   */
  readonly spec: WorkspaceSamlConfigurationSpec;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationProps(obj: WorkspaceSamlConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkspaceSamlConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkspaceSAMLConfigurationSpec defines the desired state of WorkspaceSAMLConfiguration
 *
 * @schema WorkspaceSamlConfigurationSpec
 */
export interface WorkspaceSamlConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkspaceSamlConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkspaceSamlConfigurationSpecDeletionPolicy;

  /**
   * @schema WorkspaceSamlConfigurationSpec#forProvider
   */
  readonly forProvider: WorkspaceSamlConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema WorkspaceSamlConfigurationSpec#initProvider
   */
  readonly initProvider?: WorkspaceSamlConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkspaceSamlConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: WorkspaceSamlConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkspaceSamlConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkspaceSamlConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkspaceSamlConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkspaceSamlConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkspaceSamlConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkspaceSamlConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpec(obj: WorkspaceSamlConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkspaceSamlConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_WorkspaceSamlConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkspaceSamlConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkspaceSamlConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkspaceSamlConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkspaceSamlConfigurationSpecDeletionPolicy
 */
export enum WorkspaceSamlConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkspaceSamlConfigurationSpecForProvider
 */
export interface WorkspaceSamlConfigurationSpecForProvider {
  /**
   * The admin role values.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#adminRoleValues
   */
  readonly adminRoleValues?: string[];

  /**
   * The allowed organizations.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#allowedOrganizations
   */
  readonly allowedOrganizations?: string[];

  /**
   * The editor role values.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#editorRoleValues
   */
  readonly editorRoleValues?: string[];

  /**
   * The email assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#emailAssertion
   */
  readonly emailAssertion?: string;

  /**
   * The groups assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#groupsAssertion
   */
  readonly groupsAssertion?: string;

  /**
   * The IDP Metadata URL. Note that either idp_metadata_url or idp_metadata_xml (but not both) must be specified.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#idpMetadataUrl
   */
  readonly idpMetadataUrl?: string;

  /**
   * The IDP Metadata XML. Note that either idp_metadata_url or idp_metadata_xml (but not both) must be specified.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#idpMetadataXml
   */
  readonly idpMetadataXml?: string;

  /**
   * The login assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#loginAssertion
   */
  readonly loginAssertion?: string;

  /**
   * The login validity duration.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#loginValidityDuration
   */
  readonly loginValidityDuration?: number;

  /**
   * The name assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#nameAssertion
   */
  readonly nameAssertion?: string;

  /**
   * The org assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#orgAssertion
   */
  readonly orgAssertion?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The role assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#roleAssertion
   */
  readonly roleAssertion?: string;

  /**
   * The workspace id.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#workspaceId
   */
  readonly workspaceId?: string;

  /**
   * Reference to a Workspace to populate workspaceId.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#workspaceIdRef
   */
  readonly workspaceIdRef?: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRef;

  /**
   * Selector for a Workspace to populate workspaceId.
   *
   * @schema WorkspaceSamlConfigurationSpecForProvider#workspaceIdSelector
   */
  readonly workspaceIdSelector?: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelector;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecForProvider(obj: WorkspaceSamlConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminRoleValues': obj.adminRoleValues?.map(y => y),
    'allowedOrganizations': obj.allowedOrganizations?.map(y => y),
    'editorRoleValues': obj.editorRoleValues?.map(y => y),
    'emailAssertion': obj.emailAssertion,
    'groupsAssertion': obj.groupsAssertion,
    'idpMetadataUrl': obj.idpMetadataUrl,
    'idpMetadataXml': obj.idpMetadataXml,
    'loginAssertion': obj.loginAssertion,
    'loginValidityDuration': obj.loginValidityDuration,
    'nameAssertion': obj.nameAssertion,
    'orgAssertion': obj.orgAssertion,
    'region': obj.region,
    'roleAssertion': obj.roleAssertion,
    'workspaceId': obj.workspaceId,
    'workspaceIdRef': toJson_WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRef(obj.workspaceIdRef),
    'workspaceIdSelector': toJson_WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelector(obj.workspaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema WorkspaceSamlConfigurationSpecInitProvider
 */
export interface WorkspaceSamlConfigurationSpecInitProvider {
  /**
   * The admin role values.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#adminRoleValues
   */
  readonly adminRoleValues?: string[];

  /**
   * The allowed organizations.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#allowedOrganizations
   */
  readonly allowedOrganizations?: string[];

  /**
   * The editor role values.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#editorRoleValues
   */
  readonly editorRoleValues?: string[];

  /**
   * The email assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#emailAssertion
   */
  readonly emailAssertion?: string;

  /**
   * The groups assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#groupsAssertion
   */
  readonly groupsAssertion?: string;

  /**
   * The IDP Metadata URL. Note that either idp_metadata_url or idp_metadata_xml (but not both) must be specified.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#idpMetadataUrl
   */
  readonly idpMetadataUrl?: string;

  /**
   * The IDP Metadata XML. Note that either idp_metadata_url or idp_metadata_xml (but not both) must be specified.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#idpMetadataXml
   */
  readonly idpMetadataXml?: string;

  /**
   * The login assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#loginAssertion
   */
  readonly loginAssertion?: string;

  /**
   * The login validity duration.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#loginValidityDuration
   */
  readonly loginValidityDuration?: number;

  /**
   * The name assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#nameAssertion
   */
  readonly nameAssertion?: string;

  /**
   * The org assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#orgAssertion
   */
  readonly orgAssertion?: string;

  /**
   * The role assertion.
   *
   * @schema WorkspaceSamlConfigurationSpecInitProvider#roleAssertion
   */
  readonly roleAssertion?: string;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecInitProvider(obj: WorkspaceSamlConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminRoleValues': obj.adminRoleValues?.map(y => y),
    'allowedOrganizations': obj.allowedOrganizations?.map(y => y),
    'editorRoleValues': obj.editorRoleValues?.map(y => y),
    'emailAssertion': obj.emailAssertion,
    'groupsAssertion': obj.groupsAssertion,
    'idpMetadataUrl': obj.idpMetadataUrl,
    'idpMetadataXml': obj.idpMetadataXml,
    'loginAssertion': obj.loginAssertion,
    'loginValidityDuration': obj.loginValidityDuration,
    'nameAssertion': obj.nameAssertion,
    'orgAssertion': obj.orgAssertion,
    'roleAssertion': obj.roleAssertion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkspaceSamlConfigurationSpecManagementPolicies
 */
export enum WorkspaceSamlConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkspaceSamlConfigurationSpecProviderConfigRef
 */
export interface WorkspaceSamlConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSamlConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSamlConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: WorkspaceSamlConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecProviderConfigRef(obj: WorkspaceSamlConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSamlConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsTo
 */
export interface WorkspaceSamlConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkspaceSamlConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecPublishConnectionDetailsTo(obj: WorkspaceSamlConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkspaceSamlConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkspaceSamlConfigurationSpecWriteConnectionSecretToRef
 */
export interface WorkspaceSamlConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkspaceSamlConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkspaceSamlConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecWriteConnectionSecretToRef(obj: WorkspaceSamlConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workspace to populate workspaceId.
 *
 * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRef
 */
export interface WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRef#policy
   */
  readonly policy?: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRef(obj: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workspace to populate workspaceId.
 *
 * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelector
 */
export interface WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelector#policy
   */
  readonly policy?: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelector(obj: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSamlConfigurationSpecProviderConfigRefPolicy
 */
export interface WorkspaceSamlConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSamlConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSamlConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSamlConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSamlConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecProviderConfigRefPolicy(obj: WorkspaceSamlConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRef(obj: WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface WorkspaceSamlConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecPublishConnectionDetailsToMetadata(obj: WorkspaceSamlConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicy
 */
export interface WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicy(obj: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicy
 */
export interface WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicy#resolution
   */
  readonly resolution?: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicy#resolve
   */
  readonly resolve?: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicy(obj: WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSamlConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum WorkspaceSamlConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSamlConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum WorkspaceSamlConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicyResolution
 */
export enum WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicyResolve
 */
export enum WorkspaceSamlConfigurationSpecForProviderWorkspaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicyResolution
 */
export enum WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicyResolve
 */
export enum WorkspaceSamlConfigurationSpecForProviderWorkspaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkspaceSamlConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

