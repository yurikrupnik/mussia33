// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CloneSet is the Schema for the clonesets API
 *
 * @schema CloneSet
 */
export class CloneSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CloneSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apps.kruise.io/v1alpha1',
    kind: 'CloneSet',
  }

  /**
   * Renders a Kubernetes manifest for "CloneSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CloneSetProps = {}): any {
    return {
      ...CloneSet.GVK,
      ...toJson_CloneSetProps(props),
    };
  }

  /**
   * Defines a "CloneSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CloneSetProps = {}) {
    super(scope, id, {
      ...CloneSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CloneSet.GVK,
      ...toJson_CloneSetProps(resolved),
    };
  }
}

/**
 * CloneSet is the Schema for the clonesets API
 *
 * @schema CloneSet
 */
export interface CloneSetProps {
  /**
   * @schema CloneSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CloneSetSpec defines the desired state of CloneSet
   *
   * @schema CloneSet#spec
   */
  readonly spec?: CloneSetSpec;

}

/**
 * Converts an object of type 'CloneSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetProps(obj: CloneSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CloneSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CloneSetSpec defines the desired state of CloneSet
 *
 * @schema CloneSetSpec
 */
export interface CloneSetSpec {
  /**
   * Lifecycle defines the lifecycle hooks for Pods pre-delete, in-place update.
   *
   * @schema CloneSetSpec#lifecycle
   */
  readonly lifecycle?: CloneSetSpecLifecycle;

  /**
   * Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
   *
   * @default 0 (pod will be considered available as soon as it is ready)
   * @schema CloneSetSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * Replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template. If unspecified, defaults to 1.
   *
   * @schema CloneSetSpec#replicas
   */
  readonly replicas?: number;

  /**
   * RevisionHistoryLimit is the maximum number of revisions that will be maintained in the CloneSet's revision history. The revision history consists of all revisions not represented by a currently applied CloneSetSpec version. The default value is 10.
   *
   * @schema CloneSetSpec#revisionHistoryLimit
   */
  readonly revisionHistoryLimit?: number;

  /**
   * ScaleStrategy indicates the ScaleStrategy that will be employed to create and delete Pods in the CloneSet.
   *
   * @schema CloneSetSpec#scaleStrategy
   */
  readonly scaleStrategy?: CloneSetSpecScaleStrategy;

  /**
   * Selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
   *
   * @schema CloneSetSpec#selector
   */
  readonly selector: CloneSetSpecSelector;

  /**
   * Template describes the pods that will be created.
   *
   * @schema CloneSetSpec#template
   */
  readonly template: any;

  /**
   * UpdateStrategy indicates the UpdateStrategy that will be employed to update Pods in the CloneSet when a revision is made to Template.
   *
   * @schema CloneSetSpec#updateStrategy
   */
  readonly updateStrategy?: CloneSetSpecUpdateStrategy;

  /**
   * VolumeClaimTemplates is a list of claims that pods are allowed to reference. Note that PVC will be deleted when its pod has been deleted.
   *
   * @schema CloneSetSpec#volumeClaimTemplates
   */
  readonly volumeClaimTemplates?: any;

}

/**
 * Converts an object of type 'CloneSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpec(obj: CloneSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lifecycle': toJson_CloneSetSpecLifecycle(obj.lifecycle),
    'minReadySeconds': obj.minReadySeconds,
    'replicas': obj.replicas,
    'revisionHistoryLimit': obj.revisionHistoryLimit,
    'scaleStrategy': toJson_CloneSetSpecScaleStrategy(obj.scaleStrategy),
    'selector': toJson_CloneSetSpecSelector(obj.selector),
    'template': obj.template,
    'updateStrategy': toJson_CloneSetSpecUpdateStrategy(obj.updateStrategy),
    'volumeClaimTemplates': obj.volumeClaimTemplates,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Lifecycle defines the lifecycle hooks for Pods pre-delete, in-place update.
 *
 * @schema CloneSetSpecLifecycle
 */
export interface CloneSetSpecLifecycle {
  /**
   * InPlaceUpdate is the hook before Pod to update and after Pod has been updated.
   *
   * @schema CloneSetSpecLifecycle#inPlaceUpdate
   */
  readonly inPlaceUpdate?: CloneSetSpecLifecycleInPlaceUpdate;

  /**
   * PreDelete is the hook before Pod to be deleted.
   *
   * @schema CloneSetSpecLifecycle#preDelete
   */
  readonly preDelete?: CloneSetSpecLifecyclePreDelete;

}

/**
 * Converts an object of type 'CloneSetSpecLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecLifecycle(obj: CloneSetSpecLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inPlaceUpdate': toJson_CloneSetSpecLifecycleInPlaceUpdate(obj.inPlaceUpdate),
    'preDelete': toJson_CloneSetSpecLifecyclePreDelete(obj.preDelete),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScaleStrategy indicates the ScaleStrategy that will be employed to create and delete Pods in the CloneSet.
 *
 * @schema CloneSetSpecScaleStrategy
 */
export interface CloneSetSpecScaleStrategy {
  /**
   * The maximum number of pods that can be unavailable for scaled pods. This field can control the changes rate of replicas for CloneSet so as to minimize the impact for users' service. The scale will fail if the number of unavailable pods were greater than this MaxUnavailable at scaling up. MaxUnavailable works only when scaling up.
   *
   * @schema CloneSetSpecScaleStrategy#maxUnavailable
   */
  readonly maxUnavailable?: CloneSetSpecScaleStrategyMaxUnavailable;

  /**
   * PodsToDelete is the names of Pod should be deleted. Note that this list will be truncated for non-existing pod names.
   *
   * @schema CloneSetSpecScaleStrategy#podsToDelete
   */
  readonly podsToDelete?: string[];

}

/**
 * Converts an object of type 'CloneSetSpecScaleStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecScaleStrategy(obj: CloneSetSpecScaleStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'podsToDelete': obj.podsToDelete?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
 *
 * @schema CloneSetSpecSelector
 */
export interface CloneSetSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CloneSetSpecSelector#matchExpressions
   */
  readonly matchExpressions?: CloneSetSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CloneSetSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CloneSetSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecSelector(obj: CloneSetSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CloneSetSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpdateStrategy indicates the UpdateStrategy that will be employed to update Pods in the CloneSet when a revision is made to Template.
 *
 * @schema CloneSetSpecUpdateStrategy
 */
export interface CloneSetSpecUpdateStrategy {
  /**
   * InPlaceUpdateStrategy contains strategies for in-place update.
   *
   * @schema CloneSetSpecUpdateStrategy#inPlaceUpdateStrategy
   */
  readonly inPlaceUpdateStrategy?: CloneSetSpecUpdateStrategyInPlaceUpdateStrategy;

  /**
   * The maximum number of pods that can be scheduled above the desired replicas during update or specified delete. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.
   *
   * @default 0.
   * @schema CloneSetSpecUpdateStrategy#maxSurge
   */
  readonly maxSurge?: CloneSetSpecUpdateStrategyMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during update or scale. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge > 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.
   *
   * @default 20%.
   * @schema CloneSetSpecUpdateStrategy#maxUnavailable
   */
  readonly maxUnavailable?: CloneSetSpecUpdateStrategyMaxUnavailable;

  /**
   * Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.
   *
   * @schema CloneSetSpecUpdateStrategy#partition
   */
  readonly partition?: CloneSetSpecUpdateStrategyPartition;

  /**
   * Paused indicates that the CloneSet is paused. Default value is false
   *
   * @schema CloneSetSpecUpdateStrategy#paused
   */
  readonly paused?: boolean;

  /**
   * Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.
   *
   * @schema CloneSetSpecUpdateStrategy#priorityStrategy
   */
  readonly priorityStrategy?: CloneSetSpecUpdateStrategyPriorityStrategy;

  /**
   * ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.
   *
   * @schema CloneSetSpecUpdateStrategy#scatterStrategy
   */
  readonly scatterStrategy?: CloneSetSpecUpdateStrategyScatterStrategy[];

  /**
   * Type indicates the type of the CloneSetUpdateStrategy. Default is ReCreate.
   *
   * @default ReCreate.
   * @schema CloneSetSpecUpdateStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CloneSetSpecUpdateStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecUpdateStrategy(obj: CloneSetSpecUpdateStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inPlaceUpdateStrategy': toJson_CloneSetSpecUpdateStrategyInPlaceUpdateStrategy(obj.inPlaceUpdateStrategy),
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
    'partition': obj.partition?.value,
    'paused': obj.paused,
    'priorityStrategy': toJson_CloneSetSpecUpdateStrategyPriorityStrategy(obj.priorityStrategy),
    'scatterStrategy': obj.scatterStrategy?.map(y => toJson_CloneSetSpecUpdateStrategyScatterStrategy(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InPlaceUpdate is the hook before Pod to update and after Pod has been updated.
 *
 * @schema CloneSetSpecLifecycleInPlaceUpdate
 */
export interface CloneSetSpecLifecycleInPlaceUpdate {
  /**
   * @schema CloneSetSpecLifecycleInPlaceUpdate#finalizersHandler
   */
  readonly finalizersHandler?: string[];

  /**
   * @schema CloneSetSpecLifecycleInPlaceUpdate#labelsHandler
   */
  readonly labelsHandler?: { [key: string]: string };

}

/**
 * Converts an object of type 'CloneSetSpecLifecycleInPlaceUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecLifecycleInPlaceUpdate(obj: CloneSetSpecLifecycleInPlaceUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'finalizersHandler': obj.finalizersHandler?.map(y => y),
    'labelsHandler': ((obj.labelsHandler) === undefined) ? undefined : (Object.entries(obj.labelsHandler).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreDelete is the hook before Pod to be deleted.
 *
 * @schema CloneSetSpecLifecyclePreDelete
 */
export interface CloneSetSpecLifecyclePreDelete {
  /**
   * @schema CloneSetSpecLifecyclePreDelete#finalizersHandler
   */
  readonly finalizersHandler?: string[];

  /**
   * @schema CloneSetSpecLifecyclePreDelete#labelsHandler
   */
  readonly labelsHandler?: { [key: string]: string };

}

/**
 * Converts an object of type 'CloneSetSpecLifecyclePreDelete' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecLifecyclePreDelete(obj: CloneSetSpecLifecyclePreDelete | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'finalizersHandler': obj.finalizersHandler?.map(y => y),
    'labelsHandler': ((obj.labelsHandler) === undefined) ? undefined : (Object.entries(obj.labelsHandler).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The maximum number of pods that can be unavailable for scaled pods. This field can control the changes rate of replicas for CloneSet so as to minimize the impact for users' service. The scale will fail if the number of unavailable pods were greater than this MaxUnavailable at scaling up. MaxUnavailable works only when scaling up.
 *
 * @schema CloneSetSpecScaleStrategyMaxUnavailable
 */
export class CloneSetSpecScaleStrategyMaxUnavailable {
  public static fromNumber(value: number): CloneSetSpecScaleStrategyMaxUnavailable {
    return new CloneSetSpecScaleStrategyMaxUnavailable(value);
  }
  public static fromString(value: string): CloneSetSpecScaleStrategyMaxUnavailable {
    return new CloneSetSpecScaleStrategyMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CloneSetSpecSelectorMatchExpressions
 */
export interface CloneSetSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CloneSetSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CloneSetSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CloneSetSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CloneSetSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecSelectorMatchExpressions(obj: CloneSetSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InPlaceUpdateStrategy contains strategies for in-place update.
 *
 * @schema CloneSetSpecUpdateStrategyInPlaceUpdateStrategy
 */
export interface CloneSetSpecUpdateStrategyInPlaceUpdateStrategy {
  /**
   * GracePeriodSeconds is the timespan between set Pod status to not-ready and update images in Pod spec when in-place update a Pod.
   *
   * @schema CloneSetSpecUpdateStrategyInPlaceUpdateStrategy#gracePeriodSeconds
   */
  readonly gracePeriodSeconds?: number;

}

/**
 * Converts an object of type 'CloneSetSpecUpdateStrategyInPlaceUpdateStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecUpdateStrategyInPlaceUpdateStrategy(obj: CloneSetSpecUpdateStrategyInPlaceUpdateStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gracePeriodSeconds': obj.gracePeriodSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The maximum number of pods that can be scheduled above the desired replicas during update or specified delete. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.
 *
 * @default 0.
 * @schema CloneSetSpecUpdateStrategyMaxSurge
 */
export class CloneSetSpecUpdateStrategyMaxSurge {
  public static fromNumber(value: number): CloneSetSpecUpdateStrategyMaxSurge {
    return new CloneSetSpecUpdateStrategyMaxSurge(value);
  }
  public static fromString(value: string): CloneSetSpecUpdateStrategyMaxSurge {
    return new CloneSetSpecUpdateStrategyMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during update or scale. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge > 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.
 *
 * @default 20%.
 * @schema CloneSetSpecUpdateStrategyMaxUnavailable
 */
export class CloneSetSpecUpdateStrategyMaxUnavailable {
  public static fromNumber(value: number): CloneSetSpecUpdateStrategyMaxUnavailable {
    return new CloneSetSpecUpdateStrategyMaxUnavailable(value);
  }
  public static fromString(value: string): CloneSetSpecUpdateStrategyMaxUnavailable {
    return new CloneSetSpecUpdateStrategyMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.
 *
 * @schema CloneSetSpecUpdateStrategyPartition
 */
export class CloneSetSpecUpdateStrategyPartition {
  public static fromNumber(value: number): CloneSetSpecUpdateStrategyPartition {
    return new CloneSetSpecUpdateStrategyPartition(value);
  }
  public static fromString(value: string): CloneSetSpecUpdateStrategyPartition {
    return new CloneSetSpecUpdateStrategyPartition(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.
 *
 * @schema CloneSetSpecUpdateStrategyPriorityStrategy
 */
export interface CloneSetSpecUpdateStrategyPriorityStrategy {
  /**
   * Order priority terms, pods will be sorted by the value of orderedKey. For example: ``` orderPriority: - orderedKey: key1 - orderedKey: key2 ``` First, all pods which have key1 in labels will be sorted by the value of key1. Then, the left pods which have no key1 but have key2 in labels will be sorted by the value of key2 and put behind those pods have key1.
   *
   * @schema CloneSetSpecUpdateStrategyPriorityStrategy#orderPriority
   */
  readonly orderPriority?: CloneSetSpecUpdateStrategyPriorityStrategyOrderPriority[];

  /**
   * Weight priority terms, pods will be sorted by the sum of all terms weight.
   *
   * @schema CloneSetSpecUpdateStrategyPriorityStrategy#weightPriority
   */
  readonly weightPriority?: CloneSetSpecUpdateStrategyPriorityStrategyWeightPriority[];

}

/**
 * Converts an object of type 'CloneSetSpecUpdateStrategyPriorityStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecUpdateStrategyPriorityStrategy(obj: CloneSetSpecUpdateStrategyPriorityStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'orderPriority': obj.orderPriority?.map(y => toJson_CloneSetSpecUpdateStrategyPriorityStrategyOrderPriority(y)),
    'weightPriority': obj.weightPriority?.map(y => toJson_CloneSetSpecUpdateStrategyPriorityStrategyWeightPriority(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CloneSetSpecUpdateStrategyScatterStrategy
 */
export interface CloneSetSpecUpdateStrategyScatterStrategy {
  /**
   * @schema CloneSetSpecUpdateStrategyScatterStrategy#key
   */
  readonly key: string;

  /**
   * @schema CloneSetSpecUpdateStrategyScatterStrategy#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CloneSetSpecUpdateStrategyScatterStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecUpdateStrategyScatterStrategy(obj: CloneSetSpecUpdateStrategyScatterStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpdatePriorityOrder defines order priority.
 *
 * @schema CloneSetSpecUpdateStrategyPriorityStrategyOrderPriority
 */
export interface CloneSetSpecUpdateStrategyPriorityStrategyOrderPriority {
  /**
   * Calculate priority by value of this key. Values of this key, will be sorted by GetInt(val). GetInt method will find the last int in value, such as getting 5 in value '5', getting 10 in value 'sts-10'.
   *
   * @schema CloneSetSpecUpdateStrategyPriorityStrategyOrderPriority#orderedKey
   */
  readonly orderedKey: string;

}

/**
 * Converts an object of type 'CloneSetSpecUpdateStrategyPriorityStrategyOrderPriority' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecUpdateStrategyPriorityStrategyOrderPriority(obj: CloneSetSpecUpdateStrategyPriorityStrategyOrderPriority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'orderedKey': obj.orderedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpdatePriorityWeightTerm defines weight priority.
 *
 * @schema CloneSetSpecUpdateStrategyPriorityStrategyWeightPriority
 */
export interface CloneSetSpecUpdateStrategyPriorityStrategyWeightPriority {
  /**
   * MatchSelector is used to select by pod's labels.
   *
   * @schema CloneSetSpecUpdateStrategyPriorityStrategyWeightPriority#matchSelector
   */
  readonly matchSelector: CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelector;

  /**
   * Weight associated with matching the corresponding matchExpressions, in the range 1-100.
   *
   * @schema CloneSetSpecUpdateStrategyPriorityStrategyWeightPriority#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'CloneSetSpecUpdateStrategyPriorityStrategyWeightPriority' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecUpdateStrategyPriorityStrategyWeightPriority(obj: CloneSetSpecUpdateStrategyPriorityStrategyWeightPriority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchSelector': toJson_CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelector(obj.matchSelector),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MatchSelector is used to select by pod's labels.
 *
 * @schema CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelector
 */
export interface CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelector#matchExpressions
   */
  readonly matchExpressions?: CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelector(obj: CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelectorMatchExpressions
 */
export interface CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelectorMatchExpressions(obj: CloneSetSpecUpdateStrategyPriorityStrategyWeightPriorityMatchSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

