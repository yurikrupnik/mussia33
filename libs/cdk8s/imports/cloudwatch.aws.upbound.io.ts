// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CompositeAlarm is the Schema for the CompositeAlarms API. Provides a CloudWatch Composite Alarm resource.
 *
 * @schema CompositeAlarm
 */
export class CompositeAlarm extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CompositeAlarm"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatch.aws.upbound.io/v1beta1',
    kind: 'CompositeAlarm',
  }

  /**
   * Renders a Kubernetes manifest for "CompositeAlarm".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CompositeAlarmProps): any {
    return {
      ...CompositeAlarm.GVK,
      ...toJson_CompositeAlarmProps(props),
    };
  }

  /**
   * Defines a "CompositeAlarm" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CompositeAlarmProps) {
    super(scope, id, {
      ...CompositeAlarm.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CompositeAlarm.GVK,
      ...toJson_CompositeAlarmProps(resolved),
    };
  }
}

/**
 * CompositeAlarm is the Schema for the CompositeAlarms API. Provides a CloudWatch Composite Alarm resource.
 *
 * @schema CompositeAlarm
 */
export interface CompositeAlarmProps {
  /**
   * @schema CompositeAlarm#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CompositeAlarmSpec defines the desired state of CompositeAlarm
   *
   * @schema CompositeAlarm#spec
   */
  readonly spec: CompositeAlarmSpec;

}

/**
 * Converts an object of type 'CompositeAlarmProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmProps(obj: CompositeAlarmProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CompositeAlarmSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CompositeAlarmSpec defines the desired state of CompositeAlarm
 *
 * @schema CompositeAlarmSpec
 */
export interface CompositeAlarmSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CompositeAlarmSpec#deletionPolicy
   */
  readonly deletionPolicy?: CompositeAlarmSpecDeletionPolicy;

  /**
   * @schema CompositeAlarmSpec#forProvider
   */
  readonly forProvider: CompositeAlarmSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CompositeAlarmSpec#initProvider
   */
  readonly initProvider?: CompositeAlarmSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CompositeAlarmSpec#managementPolicies
   */
  readonly managementPolicies?: CompositeAlarmSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CompositeAlarmSpec#providerConfigRef
   */
  readonly providerConfigRef?: CompositeAlarmSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CompositeAlarmSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CompositeAlarmSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CompositeAlarmSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CompositeAlarmSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CompositeAlarmSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpec(obj: CompositeAlarmSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CompositeAlarmSpecForProvider(obj.forProvider),
    'initProvider': toJson_CompositeAlarmSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CompositeAlarmSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CompositeAlarmSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CompositeAlarmSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CompositeAlarmSpecDeletionPolicy
 */
export enum CompositeAlarmSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CompositeAlarmSpecForProvider
 */
export interface CompositeAlarmSpecForProvider {
  /**
   * Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. Defaults to true.
   *
   * @default true.
   * @schema CompositeAlarmSpecForProvider#actionsEnabled
   */
  readonly actionsEnabled?: boolean;

  /**
   * The set of actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an ARN. Up to 5 actions are allowed.
   *
   * @schema CompositeAlarmSpecForProvider#alarmActions
   */
  readonly alarmActions?: string[];

  /**
   * References to Topic in sns to populate alarmActions.
   *
   * @schema CompositeAlarmSpecForProvider#alarmActionsRefs
   */
  readonly alarmActionsRefs?: CompositeAlarmSpecForProviderAlarmActionsRefs[];

  /**
   * Selector for a list of Topic in sns to populate alarmActions.
   *
   * @schema CompositeAlarmSpecForProvider#alarmActionsSelector
   */
  readonly alarmActionsSelector?: CompositeAlarmSpecForProviderAlarmActionsSelector;

  /**
   * The description for the composite alarm.
   *
   * @schema CompositeAlarmSpecForProvider#alarmDescription
   */
  readonly alarmDescription?: string;

  /**
   * An expression that specifies which other alarms are to be evaluated to determine this composite alarm's state. For syntax, see Creating a Composite Alarm. The maximum length is 10240 characters.
   *
   * @schema CompositeAlarmSpecForProvider#alarmRule
   */
  readonly alarmRule?: string;

  /**
   * The set of actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an ARN. Up to 5 actions are allowed.
   *
   * @schema CompositeAlarmSpecForProvider#insufficientDataActions
   */
  readonly insufficientDataActions?: string[];

  /**
   * The set of actions to execute when this alarm transitions to an OK state from any other state. Each action is specified as an ARN. Up to 5 actions are allowed.
   *
   * @schema CompositeAlarmSpecForProvider#okActions
   */
  readonly okActions?: string[];

  /**
   * References to Topic in sns to populate okActions.
   *
   * @schema CompositeAlarmSpecForProvider#okActionsRefs
   */
  readonly okActionsRefs?: CompositeAlarmSpecForProviderOkActionsRefs[];

  /**
   * Selector for a list of Topic in sns to populate okActions.
   *
   * @schema CompositeAlarmSpecForProvider#okActionsSelector
   */
  readonly okActionsSelector?: CompositeAlarmSpecForProviderOkActionsSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CompositeAlarmSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema CompositeAlarmSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CompositeAlarmSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecForProvider(obj: CompositeAlarmSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionsEnabled': obj.actionsEnabled,
    'alarmActions': obj.alarmActions?.map(y => y),
    'alarmActionsRefs': obj.alarmActionsRefs?.map(y => toJson_CompositeAlarmSpecForProviderAlarmActionsRefs(y)),
    'alarmActionsSelector': toJson_CompositeAlarmSpecForProviderAlarmActionsSelector(obj.alarmActionsSelector),
    'alarmDescription': obj.alarmDescription,
    'alarmRule': obj.alarmRule,
    'insufficientDataActions': obj.insufficientDataActions?.map(y => y),
    'okActions': obj.okActions?.map(y => y),
    'okActionsRefs': obj.okActionsRefs?.map(y => toJson_CompositeAlarmSpecForProviderOkActionsRefs(y)),
    'okActionsSelector': toJson_CompositeAlarmSpecForProviderOkActionsSelector(obj.okActionsSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CompositeAlarmSpecInitProvider
 */
export interface CompositeAlarmSpecInitProvider {
  /**
   * Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. Defaults to true.
   *
   * @default true.
   * @schema CompositeAlarmSpecInitProvider#actionsEnabled
   */
  readonly actionsEnabled?: boolean;

  /**
   * The description for the composite alarm.
   *
   * @schema CompositeAlarmSpecInitProvider#alarmDescription
   */
  readonly alarmDescription?: string;

  /**
   * An expression that specifies which other alarms are to be evaluated to determine this composite alarm's state. For syntax, see Creating a Composite Alarm. The maximum length is 10240 characters.
   *
   * @schema CompositeAlarmSpecInitProvider#alarmRule
   */
  readonly alarmRule?: string;

  /**
   * The set of actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an ARN. Up to 5 actions are allowed.
   *
   * @schema CompositeAlarmSpecInitProvider#insufficientDataActions
   */
  readonly insufficientDataActions?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CompositeAlarmSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CompositeAlarmSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecInitProvider(obj: CompositeAlarmSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionsEnabled': obj.actionsEnabled,
    'alarmDescription': obj.alarmDescription,
    'alarmRule': obj.alarmRule,
    'insufficientDataActions': obj.insufficientDataActions?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CompositeAlarmSpecManagementPolicies
 */
export enum CompositeAlarmSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CompositeAlarmSpecProviderConfigRef
 */
export interface CompositeAlarmSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CompositeAlarmSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CompositeAlarmSpecProviderConfigRef#policy
   */
  readonly policy?: CompositeAlarmSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CompositeAlarmSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecProviderConfigRef(obj: CompositeAlarmSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CompositeAlarmSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CompositeAlarmSpecPublishConnectionDetailsTo
 */
export interface CompositeAlarmSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CompositeAlarmSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CompositeAlarmSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CompositeAlarmSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CompositeAlarmSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CompositeAlarmSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CompositeAlarmSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecPublishConnectionDetailsTo(obj: CompositeAlarmSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CompositeAlarmSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CompositeAlarmSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CompositeAlarmSpecWriteConnectionSecretToRef
 */
export interface CompositeAlarmSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CompositeAlarmSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CompositeAlarmSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CompositeAlarmSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecWriteConnectionSecretToRef(obj: CompositeAlarmSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema CompositeAlarmSpecForProviderAlarmActionsRefs
 */
export interface CompositeAlarmSpecForProviderAlarmActionsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema CompositeAlarmSpecForProviderAlarmActionsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CompositeAlarmSpecForProviderAlarmActionsRefs#policy
   */
  readonly policy?: CompositeAlarmSpecForProviderAlarmActionsRefsPolicy;

}

/**
 * Converts an object of type 'CompositeAlarmSpecForProviderAlarmActionsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecForProviderAlarmActionsRefs(obj: CompositeAlarmSpecForProviderAlarmActionsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CompositeAlarmSpecForProviderAlarmActionsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Topic in sns to populate alarmActions.
 *
 * @schema CompositeAlarmSpecForProviderAlarmActionsSelector
 */
export interface CompositeAlarmSpecForProviderAlarmActionsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CompositeAlarmSpecForProviderAlarmActionsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CompositeAlarmSpecForProviderAlarmActionsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CompositeAlarmSpecForProviderAlarmActionsSelector#policy
   */
  readonly policy?: CompositeAlarmSpecForProviderAlarmActionsSelectorPolicy;

}

/**
 * Converts an object of type 'CompositeAlarmSpecForProviderAlarmActionsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecForProviderAlarmActionsSelector(obj: CompositeAlarmSpecForProviderAlarmActionsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CompositeAlarmSpecForProviderAlarmActionsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema CompositeAlarmSpecForProviderOkActionsRefs
 */
export interface CompositeAlarmSpecForProviderOkActionsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema CompositeAlarmSpecForProviderOkActionsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CompositeAlarmSpecForProviderOkActionsRefs#policy
   */
  readonly policy?: CompositeAlarmSpecForProviderOkActionsRefsPolicy;

}

/**
 * Converts an object of type 'CompositeAlarmSpecForProviderOkActionsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecForProviderOkActionsRefs(obj: CompositeAlarmSpecForProviderOkActionsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CompositeAlarmSpecForProviderOkActionsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Topic in sns to populate okActions.
 *
 * @schema CompositeAlarmSpecForProviderOkActionsSelector
 */
export interface CompositeAlarmSpecForProviderOkActionsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CompositeAlarmSpecForProviderOkActionsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CompositeAlarmSpecForProviderOkActionsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CompositeAlarmSpecForProviderOkActionsSelector#policy
   */
  readonly policy?: CompositeAlarmSpecForProviderOkActionsSelectorPolicy;

}

/**
 * Converts an object of type 'CompositeAlarmSpecForProviderOkActionsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecForProviderOkActionsSelector(obj: CompositeAlarmSpecForProviderOkActionsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CompositeAlarmSpecForProviderOkActionsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CompositeAlarmSpecProviderConfigRefPolicy
 */
export interface CompositeAlarmSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CompositeAlarmSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CompositeAlarmSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CompositeAlarmSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CompositeAlarmSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CompositeAlarmSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecProviderConfigRefPolicy(obj: CompositeAlarmSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CompositeAlarmSpecPublishConnectionDetailsToConfigRef
 */
export interface CompositeAlarmSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CompositeAlarmSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CompositeAlarmSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CompositeAlarmSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecPublishConnectionDetailsToConfigRef(obj: CompositeAlarmSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CompositeAlarmSpecPublishConnectionDetailsToMetadata
 */
export interface CompositeAlarmSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CompositeAlarmSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CompositeAlarmSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CompositeAlarmSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CompositeAlarmSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecPublishConnectionDetailsToMetadata(obj: CompositeAlarmSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CompositeAlarmSpecForProviderAlarmActionsRefsPolicy
 */
export interface CompositeAlarmSpecForProviderAlarmActionsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CompositeAlarmSpecForProviderAlarmActionsRefsPolicy#resolution
   */
  readonly resolution?: CompositeAlarmSpecForProviderAlarmActionsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CompositeAlarmSpecForProviderAlarmActionsRefsPolicy#resolve
   */
  readonly resolve?: CompositeAlarmSpecForProviderAlarmActionsRefsPolicyResolve;

}

/**
 * Converts an object of type 'CompositeAlarmSpecForProviderAlarmActionsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecForProviderAlarmActionsRefsPolicy(obj: CompositeAlarmSpecForProviderAlarmActionsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CompositeAlarmSpecForProviderAlarmActionsSelectorPolicy
 */
export interface CompositeAlarmSpecForProviderAlarmActionsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CompositeAlarmSpecForProviderAlarmActionsSelectorPolicy#resolution
   */
  readonly resolution?: CompositeAlarmSpecForProviderAlarmActionsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CompositeAlarmSpecForProviderAlarmActionsSelectorPolicy#resolve
   */
  readonly resolve?: CompositeAlarmSpecForProviderAlarmActionsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CompositeAlarmSpecForProviderAlarmActionsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecForProviderAlarmActionsSelectorPolicy(obj: CompositeAlarmSpecForProviderAlarmActionsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CompositeAlarmSpecForProviderOkActionsRefsPolicy
 */
export interface CompositeAlarmSpecForProviderOkActionsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CompositeAlarmSpecForProviderOkActionsRefsPolicy#resolution
   */
  readonly resolution?: CompositeAlarmSpecForProviderOkActionsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CompositeAlarmSpecForProviderOkActionsRefsPolicy#resolve
   */
  readonly resolve?: CompositeAlarmSpecForProviderOkActionsRefsPolicyResolve;

}

/**
 * Converts an object of type 'CompositeAlarmSpecForProviderOkActionsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecForProviderOkActionsRefsPolicy(obj: CompositeAlarmSpecForProviderOkActionsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CompositeAlarmSpecForProviderOkActionsSelectorPolicy
 */
export interface CompositeAlarmSpecForProviderOkActionsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CompositeAlarmSpecForProviderOkActionsSelectorPolicy#resolution
   */
  readonly resolution?: CompositeAlarmSpecForProviderOkActionsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CompositeAlarmSpecForProviderOkActionsSelectorPolicy#resolve
   */
  readonly resolve?: CompositeAlarmSpecForProviderOkActionsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CompositeAlarmSpecForProviderOkActionsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecForProviderOkActionsSelectorPolicy(obj: CompositeAlarmSpecForProviderOkActionsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CompositeAlarmSpecProviderConfigRefPolicyResolution
 */
export enum CompositeAlarmSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CompositeAlarmSpecProviderConfigRefPolicyResolve
 */
export enum CompositeAlarmSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicy(obj: CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CompositeAlarmSpecForProviderAlarmActionsRefsPolicyResolution
 */
export enum CompositeAlarmSpecForProviderAlarmActionsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CompositeAlarmSpecForProviderAlarmActionsRefsPolicyResolve
 */
export enum CompositeAlarmSpecForProviderAlarmActionsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CompositeAlarmSpecForProviderAlarmActionsSelectorPolicyResolution
 */
export enum CompositeAlarmSpecForProviderAlarmActionsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CompositeAlarmSpecForProviderAlarmActionsSelectorPolicyResolve
 */
export enum CompositeAlarmSpecForProviderAlarmActionsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CompositeAlarmSpecForProviderOkActionsRefsPolicyResolution
 */
export enum CompositeAlarmSpecForProviderOkActionsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CompositeAlarmSpecForProviderOkActionsRefsPolicyResolve
 */
export enum CompositeAlarmSpecForProviderOkActionsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CompositeAlarmSpecForProviderOkActionsSelectorPolicyResolution
 */
export enum CompositeAlarmSpecForProviderOkActionsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CompositeAlarmSpecForProviderOkActionsSelectorPolicyResolve
 */
export enum CompositeAlarmSpecForProviderOkActionsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CompositeAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Dashboard is the Schema for the Dashboards API. Provides a CloudWatch Dashboard resource.
 *
 * @schema Dashboard
 */
export class Dashboard extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Dashboard"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatch.aws.upbound.io/v1beta1',
    kind: 'Dashboard',
  }

  /**
   * Renders a Kubernetes manifest for "Dashboard".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DashboardProps): any {
    return {
      ...Dashboard.GVK,
      ...toJson_DashboardProps(props),
    };
  }

  /**
   * Defines a "Dashboard" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DashboardProps) {
    super(scope, id, {
      ...Dashboard.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Dashboard.GVK,
      ...toJson_DashboardProps(resolved),
    };
  }
}

/**
 * Dashboard is the Schema for the Dashboards API. Provides a CloudWatch Dashboard resource.
 *
 * @schema Dashboard
 */
export interface DashboardProps {
  /**
   * @schema Dashboard#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DashboardSpec defines the desired state of Dashboard
   *
   * @schema Dashboard#spec
   */
  readonly spec: DashboardSpec;

}

/**
 * Converts an object of type 'DashboardProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardProps(obj: DashboardProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DashboardSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DashboardSpec defines the desired state of Dashboard
 *
 * @schema DashboardSpec
 */
export interface DashboardSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DashboardSpec#deletionPolicy
   */
  readonly deletionPolicy?: DashboardSpecDeletionPolicy;

  /**
   * @schema DashboardSpec#forProvider
   */
  readonly forProvider: DashboardSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DashboardSpec#initProvider
   */
  readonly initProvider?: DashboardSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DashboardSpec#managementPolicies
   */
  readonly managementPolicies?: DashboardSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DashboardSpec#providerConfigRef
   */
  readonly providerConfigRef?: DashboardSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DashboardSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DashboardSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DashboardSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DashboardSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DashboardSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpec(obj: DashboardSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DashboardSpecForProvider(obj.forProvider),
    'initProvider': toJson_DashboardSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DashboardSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DashboardSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DashboardSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DashboardSpecDeletionPolicy
 */
export enum DashboardSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DashboardSpecForProvider
 */
export interface DashboardSpecForProvider {
  /**
   * The detailed information about the dashboard, including what widgets are included and their location on the dashboard. You can read more about the body structure in the documentation.
   *
   * @schema DashboardSpecForProvider#dashboardBody
   */
  readonly dashboardBody?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DashboardSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DashboardSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecForProvider(obj: DashboardSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dashboardBody': obj.dashboardBody,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DashboardSpecInitProvider
 */
export interface DashboardSpecInitProvider {
  /**
   * The detailed information about the dashboard, including what widgets are included and their location on the dashboard. You can read more about the body structure in the documentation.
   *
   * @schema DashboardSpecInitProvider#dashboardBody
   */
  readonly dashboardBody?: string;

}

/**
 * Converts an object of type 'DashboardSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecInitProvider(obj: DashboardSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dashboardBody': obj.dashboardBody,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DashboardSpecManagementPolicies
 */
export enum DashboardSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DashboardSpecProviderConfigRef
 */
export interface DashboardSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DashboardSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DashboardSpecProviderConfigRef#policy
   */
  readonly policy?: DashboardSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DashboardSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecProviderConfigRef(obj: DashboardSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DashboardSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DashboardSpecPublishConnectionDetailsTo
 */
export interface DashboardSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DashboardSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DashboardSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DashboardSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DashboardSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DashboardSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DashboardSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecPublishConnectionDetailsTo(obj: DashboardSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DashboardSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DashboardSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DashboardSpecWriteConnectionSecretToRef
 */
export interface DashboardSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DashboardSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DashboardSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DashboardSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecWriteConnectionSecretToRef(obj: DashboardSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DashboardSpecProviderConfigRefPolicy
 */
export interface DashboardSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DashboardSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DashboardSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DashboardSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DashboardSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DashboardSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecProviderConfigRefPolicy(obj: DashboardSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DashboardSpecPublishConnectionDetailsToConfigRef
 */
export interface DashboardSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DashboardSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DashboardSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DashboardSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DashboardSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecPublishConnectionDetailsToConfigRef(obj: DashboardSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DashboardSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DashboardSpecPublishConnectionDetailsToMetadata
 */
export interface DashboardSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DashboardSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DashboardSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DashboardSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DashboardSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecPublishConnectionDetailsToMetadata(obj: DashboardSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DashboardSpecProviderConfigRefPolicyResolution
 */
export enum DashboardSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DashboardSpecProviderConfigRefPolicyResolve
 */
export enum DashboardSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DashboardSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DashboardSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DashboardSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DashboardSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DashboardSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecPublishConnectionDetailsToConfigRefPolicy(obj: DashboardSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MetricAlarm is the Schema for the MetricAlarms API. Provides a CloudWatch Metric Alarm resource.
 *
 * @schema MetricAlarm
 */
export class MetricAlarm extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MetricAlarm"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatch.aws.upbound.io/v1beta1',
    kind: 'MetricAlarm',
  }

  /**
   * Renders a Kubernetes manifest for "MetricAlarm".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MetricAlarmProps): any {
    return {
      ...MetricAlarm.GVK,
      ...toJson_MetricAlarmProps(props),
    };
  }

  /**
   * Defines a "MetricAlarm" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MetricAlarmProps) {
    super(scope, id, {
      ...MetricAlarm.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MetricAlarm.GVK,
      ...toJson_MetricAlarmProps(resolved),
    };
  }
}

/**
 * MetricAlarm is the Schema for the MetricAlarms API. Provides a CloudWatch Metric Alarm resource.
 *
 * @schema MetricAlarm
 */
export interface MetricAlarmProps {
  /**
   * @schema MetricAlarm#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MetricAlarmSpec defines the desired state of MetricAlarm
   *
   * @schema MetricAlarm#spec
   */
  readonly spec: MetricAlarmSpec;

}

/**
 * Converts an object of type 'MetricAlarmProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmProps(obj: MetricAlarmProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MetricAlarmSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetricAlarmSpec defines the desired state of MetricAlarm
 *
 * @schema MetricAlarmSpec
 */
export interface MetricAlarmSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MetricAlarmSpec#deletionPolicy
   */
  readonly deletionPolicy?: MetricAlarmSpecDeletionPolicy;

  /**
   * @schema MetricAlarmSpec#forProvider
   */
  readonly forProvider: MetricAlarmSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema MetricAlarmSpec#initProvider
   */
  readonly initProvider?: MetricAlarmSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema MetricAlarmSpec#managementPolicies
   */
  readonly managementPolicies?: MetricAlarmSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MetricAlarmSpec#providerConfigRef
   */
  readonly providerConfigRef?: MetricAlarmSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MetricAlarmSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MetricAlarmSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MetricAlarmSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MetricAlarmSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MetricAlarmSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpec(obj: MetricAlarmSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MetricAlarmSpecForProvider(obj.forProvider),
    'initProvider': toJson_MetricAlarmSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_MetricAlarmSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_MetricAlarmSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MetricAlarmSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MetricAlarmSpecDeletionPolicy
 */
export enum MetricAlarmSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MetricAlarmSpecForProvider
 */
export interface MetricAlarmSpecForProvider {
  /**
   * Indicates whether or not actions should be executed during any changes to the alarm's state. Defaults to true.
   *
   * @default true.
   * @schema MetricAlarmSpecForProvider#actionsEnabled
   */
  readonly actionsEnabled?: boolean;

  /**
   * The list of actions to execute when this alarm transitions into an ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).
   *
   * @schema MetricAlarmSpecForProvider#alarmActions
   */
  readonly alarmActions?: string[];

  /**
   * The description for the alarm.
   *
   * @schema MetricAlarmSpecForProvider#alarmDescription
   */
  readonly alarmDescription?: string;

  /**
   * The arithmetic operation to use when comparing the specified Statistic and Threshold. The specified Statistic value is used as the first operand. Either of the following is supported: GreaterThanOrEqualToThreshold, GreaterThanThreshold, LessThanThreshold, LessThanOrEqualToThreshold. Additionally, the values  LessThanLowerOrGreaterThanUpperThreshold, LessThanLowerThreshold, and GreaterThanUpperThreshold are used only for alarms based on anomaly detection models.
   *
   * @schema MetricAlarmSpecForProvider#comparisonOperator
   */
  readonly comparisonOperator?: string;

  /**
   * The number of datapoints that must be breaching to trigger the alarm.
   *
   * @schema MetricAlarmSpecForProvider#datapointsToAlarm
   */
  readonly datapointsToAlarm?: number;

  /**
   * The dimensions for the alarm's associated metric.  For the list of available dimensions see the AWS documentation here.
   *
   * @schema MetricAlarmSpecForProvider#dimensions
   */
  readonly dimensions?: { [key: string]: string };

  /**
   * Used only for alarms based on percentiles. If you specify ignore, the alarm state will not change during periods with too few data points to be statistically significant. If you specify evaluate or omit this parameter, the alarm will always be evaluated and possibly change state no matter how many data points are available. The following values are supported: ignore, and evaluate.
   *
   * @schema MetricAlarmSpecForProvider#evaluateLowSampleCountPercentiles
   */
  readonly evaluateLowSampleCountPercentiles?: string;

  /**
   * The number of periods over which data is compared to the specified threshold.
   *
   * @schema MetricAlarmSpecForProvider#evaluationPeriods
   */
  readonly evaluationPeriods?: number;

  /**
   * The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100.
   *
   * @schema MetricAlarmSpecForProvider#extendedStatistic
   */
  readonly extendedStatistic?: string;

  /**
   * The list of actions to execute when this alarm transitions into an INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).
   *
   * @schema MetricAlarmSpecForProvider#insufficientDataActions
   */
  readonly insufficientDataActions?: string[];

  /**
   * The name for the alarm's associated metric. See docs for supported metrics.
   *
   * @schema MetricAlarmSpecForProvider#metricName
   */
  readonly metricName?: string;

  /**
   * Enables you to create an alarm based on a metric math expression. You may specify at most 20.
   *
   * @schema MetricAlarmSpecForProvider#metricQuery
   */
  readonly metricQuery?: MetricAlarmSpecForProviderMetricQuery[];

  /**
   * The namespace for the alarm's associated metric. See docs for the list of namespaces. See docs for supported metrics.
   *
   * @schema MetricAlarmSpecForProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The list of actions to execute when this alarm transitions into an OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).
   *
   * @schema MetricAlarmSpecForProvider#okActions
   */
  readonly okActions?: string[];

  /**
   * The period in seconds over which the specified statistic is applied. Valid values are 10, 30, or any multiple of 60.
   *
   * @schema MetricAlarmSpecForProvider#period
   */
  readonly period?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MetricAlarmSpecForProvider#region
   */
  readonly region: string;

  /**
   * The statistic to apply to the alarm's associated metric. Either of the following is supported: SampleCount, Average, Sum, Minimum, Maximum
   *
   * @schema MetricAlarmSpecForProvider#statistic
   */
  readonly statistic?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema MetricAlarmSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The value against which the specified statistic is compared. This parameter is required for alarms based on static thresholds, but should not be used for alarms based on anomaly detection models.
   *
   * @schema MetricAlarmSpecForProvider#threshold
   */
  readonly threshold?: number;

  /**
   * If this is an alarm based on an anomaly detection model, make this value match the ID of the ANOMALY_DETECTION_BAND function.
   *
   * @schema MetricAlarmSpecForProvider#thresholdMetricId
   */
  readonly thresholdMetricId?: string;

  /**
   * Sets how this alarm is to handle missing data points. The following values are supported: missing, ignore, breaching and notBreaching. Defaults to missing.
   *
   * @default missing.
   * @schema MetricAlarmSpecForProvider#treatMissingData
   */
  readonly treatMissingData?: string;

  /**
   * The unit for the alarm's associated metric.
   *
   * @schema MetricAlarmSpecForProvider#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'MetricAlarmSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecForProvider(obj: MetricAlarmSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionsEnabled': obj.actionsEnabled,
    'alarmActions': obj.alarmActions?.map(y => y),
    'alarmDescription': obj.alarmDescription,
    'comparisonOperator': obj.comparisonOperator,
    'datapointsToAlarm': obj.datapointsToAlarm,
    'dimensions': ((obj.dimensions) === undefined) ? undefined : (Object.entries(obj.dimensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'evaluateLowSampleCountPercentiles': obj.evaluateLowSampleCountPercentiles,
    'evaluationPeriods': obj.evaluationPeriods,
    'extendedStatistic': obj.extendedStatistic,
    'insufficientDataActions': obj.insufficientDataActions?.map(y => y),
    'metricName': obj.metricName,
    'metricQuery': obj.metricQuery?.map(y => toJson_MetricAlarmSpecForProviderMetricQuery(y)),
    'namespace': obj.namespace,
    'okActions': obj.okActions?.map(y => y),
    'period': obj.period,
    'region': obj.region,
    'statistic': obj.statistic,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'threshold': obj.threshold,
    'thresholdMetricId': obj.thresholdMetricId,
    'treatMissingData': obj.treatMissingData,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema MetricAlarmSpecInitProvider
 */
export interface MetricAlarmSpecInitProvider {
  /**
   * Indicates whether or not actions should be executed during any changes to the alarm's state. Defaults to true.
   *
   * @default true.
   * @schema MetricAlarmSpecInitProvider#actionsEnabled
   */
  readonly actionsEnabled?: boolean;

  /**
   * The list of actions to execute when this alarm transitions into an ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).
   *
   * @schema MetricAlarmSpecInitProvider#alarmActions
   */
  readonly alarmActions?: string[];

  /**
   * The description for the alarm.
   *
   * @schema MetricAlarmSpecInitProvider#alarmDescription
   */
  readonly alarmDescription?: string;

  /**
   * The arithmetic operation to use when comparing the specified Statistic and Threshold. The specified Statistic value is used as the first operand. Either of the following is supported: GreaterThanOrEqualToThreshold, GreaterThanThreshold, LessThanThreshold, LessThanOrEqualToThreshold. Additionally, the values  LessThanLowerOrGreaterThanUpperThreshold, LessThanLowerThreshold, and GreaterThanUpperThreshold are used only for alarms based on anomaly detection models.
   *
   * @schema MetricAlarmSpecInitProvider#comparisonOperator
   */
  readonly comparisonOperator?: string;

  /**
   * The number of datapoints that must be breaching to trigger the alarm.
   *
   * @schema MetricAlarmSpecInitProvider#datapointsToAlarm
   */
  readonly datapointsToAlarm?: number;

  /**
   * The dimensions for the alarm's associated metric.  For the list of available dimensions see the AWS documentation here.
   *
   * @schema MetricAlarmSpecInitProvider#dimensions
   */
  readonly dimensions?: { [key: string]: string };

  /**
   * Used only for alarms based on percentiles. If you specify ignore, the alarm state will not change during periods with too few data points to be statistically significant. If you specify evaluate or omit this parameter, the alarm will always be evaluated and possibly change state no matter how many data points are available. The following values are supported: ignore, and evaluate.
   *
   * @schema MetricAlarmSpecInitProvider#evaluateLowSampleCountPercentiles
   */
  readonly evaluateLowSampleCountPercentiles?: string;

  /**
   * The number of periods over which data is compared to the specified threshold.
   *
   * @schema MetricAlarmSpecInitProvider#evaluationPeriods
   */
  readonly evaluationPeriods?: number;

  /**
   * The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100.
   *
   * @schema MetricAlarmSpecInitProvider#extendedStatistic
   */
  readonly extendedStatistic?: string;

  /**
   * The list of actions to execute when this alarm transitions into an INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).
   *
   * @schema MetricAlarmSpecInitProvider#insufficientDataActions
   */
  readonly insufficientDataActions?: string[];

  /**
   * The name for the alarm's associated metric. See docs for supported metrics.
   *
   * @schema MetricAlarmSpecInitProvider#metricName
   */
  readonly metricName?: string;

  /**
   * Enables you to create an alarm based on a metric math expression. You may specify at most 20.
   *
   * @schema MetricAlarmSpecInitProvider#metricQuery
   */
  readonly metricQuery?: MetricAlarmSpecInitProviderMetricQuery[];

  /**
   * The namespace for the alarm's associated metric. See docs for the list of namespaces. See docs for supported metrics.
   *
   * @schema MetricAlarmSpecInitProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The list of actions to execute when this alarm transitions into an OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).
   *
   * @schema MetricAlarmSpecInitProvider#okActions
   */
  readonly okActions?: string[];

  /**
   * The period in seconds over which the specified statistic is applied. Valid values are 10, 30, or any multiple of 60.
   *
   * @schema MetricAlarmSpecInitProvider#period
   */
  readonly period?: number;

  /**
   * The statistic to apply to the alarm's associated metric. Either of the following is supported: SampleCount, Average, Sum, Minimum, Maximum
   *
   * @schema MetricAlarmSpecInitProvider#statistic
   */
  readonly statistic?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema MetricAlarmSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The value against which the specified statistic is compared. This parameter is required for alarms based on static thresholds, but should not be used for alarms based on anomaly detection models.
   *
   * @schema MetricAlarmSpecInitProvider#threshold
   */
  readonly threshold?: number;

  /**
   * If this is an alarm based on an anomaly detection model, make this value match the ID of the ANOMALY_DETECTION_BAND function.
   *
   * @schema MetricAlarmSpecInitProvider#thresholdMetricId
   */
  readonly thresholdMetricId?: string;

  /**
   * Sets how this alarm is to handle missing data points. The following values are supported: missing, ignore, breaching and notBreaching. Defaults to missing.
   *
   * @default missing.
   * @schema MetricAlarmSpecInitProvider#treatMissingData
   */
  readonly treatMissingData?: string;

  /**
   * The unit for the alarm's associated metric.
   *
   * @schema MetricAlarmSpecInitProvider#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'MetricAlarmSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecInitProvider(obj: MetricAlarmSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionsEnabled': obj.actionsEnabled,
    'alarmActions': obj.alarmActions?.map(y => y),
    'alarmDescription': obj.alarmDescription,
    'comparisonOperator': obj.comparisonOperator,
    'datapointsToAlarm': obj.datapointsToAlarm,
    'dimensions': ((obj.dimensions) === undefined) ? undefined : (Object.entries(obj.dimensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'evaluateLowSampleCountPercentiles': obj.evaluateLowSampleCountPercentiles,
    'evaluationPeriods': obj.evaluationPeriods,
    'extendedStatistic': obj.extendedStatistic,
    'insufficientDataActions': obj.insufficientDataActions?.map(y => y),
    'metricName': obj.metricName,
    'metricQuery': obj.metricQuery?.map(y => toJson_MetricAlarmSpecInitProviderMetricQuery(y)),
    'namespace': obj.namespace,
    'okActions': obj.okActions?.map(y => y),
    'period': obj.period,
    'statistic': obj.statistic,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'threshold': obj.threshold,
    'thresholdMetricId': obj.thresholdMetricId,
    'treatMissingData': obj.treatMissingData,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema MetricAlarmSpecManagementPolicies
 */
export enum MetricAlarmSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MetricAlarmSpecProviderConfigRef
 */
export interface MetricAlarmSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricAlarmSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricAlarmSpecProviderConfigRef#policy
   */
  readonly policy?: MetricAlarmSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MetricAlarmSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecProviderConfigRef(obj: MetricAlarmSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricAlarmSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MetricAlarmSpecPublishConnectionDetailsTo
 */
export interface MetricAlarmSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MetricAlarmSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MetricAlarmSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MetricAlarmSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MetricAlarmSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MetricAlarmSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MetricAlarmSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecPublishConnectionDetailsTo(obj: MetricAlarmSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MetricAlarmSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MetricAlarmSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MetricAlarmSpecWriteConnectionSecretToRef
 */
export interface MetricAlarmSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MetricAlarmSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MetricAlarmSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MetricAlarmSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecWriteConnectionSecretToRef(obj: MetricAlarmSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricAlarmSpecForProviderMetricQuery
 */
export interface MetricAlarmSpecForProviderMetricQuery {
  /**
   * The ID of the account where the metrics are located, if this is a cross-account alarm.
   *
   * @schema MetricAlarmSpecForProviderMetricQuery#accountId
   */
  readonly accountId?: string;

  /**
   * The math expression to be performed on the returned data, if this object is performing a math expression. This expression can use the id of the other metrics to refer to those metrics, and can also use the id of other expressions to use the result of those expressions. For more information about metric math expressions, see Metric Math Syntax and Functions in the Amazon CloudWatch User Guide.
   *
   * @schema MetricAlarmSpecForProviderMetricQuery#expression
   */
  readonly expression?: string;

  /**
   * A short name used to tie this object to the results in the response. If you are performing math expressions on this set of data, this name represents that data and can serve as a variable in the mathematical expression. The valid characters are letters, numbers, and underscore. The first character must be a lowercase letter.
   *
   * @schema MetricAlarmSpecForProviderMetricQuery#id
   */
  readonly id?: string;

  /**
   * A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents.
   *
   * @schema MetricAlarmSpecForProviderMetricQuery#label
   */
  readonly label?: string;

  /**
   * The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data.
   *
   * @schema MetricAlarmSpecForProviderMetricQuery#metric
   */
  readonly metric?: MetricAlarmSpecForProviderMetricQueryMetric[];

  /**
   * Granularity in seconds of returned data points. For metrics with regular resolution, valid values are any multiple of 60. For high-resolution metrics, valid values are 1, 5, 10, 30, or any multiple of 60.
   *
   * @schema MetricAlarmSpecForProviderMetricQuery#period
   */
  readonly period?: number;

  /**
   * Specify exactly one metric_query to be true to use that metric_query result as the alarm.
   *
   * @schema MetricAlarmSpecForProviderMetricQuery#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'MetricAlarmSpecForProviderMetricQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecForProviderMetricQuery(obj: MetricAlarmSpecForProviderMetricQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metric': obj.metric?.map(y => toJson_MetricAlarmSpecForProviderMetricQueryMetric(y)),
    'period': obj.period,
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricAlarmSpecInitProviderMetricQuery
 */
export interface MetricAlarmSpecInitProviderMetricQuery {
  /**
   * The ID of the account where the metrics are located, if this is a cross-account alarm.
   *
   * @schema MetricAlarmSpecInitProviderMetricQuery#accountId
   */
  readonly accountId?: string;

  /**
   * The math expression to be performed on the returned data, if this object is performing a math expression. This expression can use the id of the other metrics to refer to those metrics, and can also use the id of other expressions to use the result of those expressions. For more information about metric math expressions, see Metric Math Syntax and Functions in the Amazon CloudWatch User Guide.
   *
   * @schema MetricAlarmSpecInitProviderMetricQuery#expression
   */
  readonly expression?: string;

  /**
   * A short name used to tie this object to the results in the response. If you are performing math expressions on this set of data, this name represents that data and can serve as a variable in the mathematical expression. The valid characters are letters, numbers, and underscore. The first character must be a lowercase letter.
   *
   * @schema MetricAlarmSpecInitProviderMetricQuery#id
   */
  readonly id?: string;

  /**
   * A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents.
   *
   * @schema MetricAlarmSpecInitProviderMetricQuery#label
   */
  readonly label?: string;

  /**
   * The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data.
   *
   * @schema MetricAlarmSpecInitProviderMetricQuery#metric
   */
  readonly metric?: MetricAlarmSpecInitProviderMetricQueryMetric[];

  /**
   * Granularity in seconds of returned data points. For metrics with regular resolution, valid values are any multiple of 60. For high-resolution metrics, valid values are 1, 5, 10, 30, or any multiple of 60.
   *
   * @schema MetricAlarmSpecInitProviderMetricQuery#period
   */
  readonly period?: number;

  /**
   * Specify exactly one metric_query to be true to use that metric_query result as the alarm.
   *
   * @schema MetricAlarmSpecInitProviderMetricQuery#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'MetricAlarmSpecInitProviderMetricQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecInitProviderMetricQuery(obj: MetricAlarmSpecInitProviderMetricQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metric': obj.metric?.map(y => toJson_MetricAlarmSpecInitProviderMetricQueryMetric(y)),
    'period': obj.period,
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricAlarmSpecProviderConfigRefPolicy
 */
export interface MetricAlarmSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricAlarmSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MetricAlarmSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricAlarmSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MetricAlarmSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricAlarmSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecProviderConfigRefPolicy(obj: MetricAlarmSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MetricAlarmSpecPublishConnectionDetailsToConfigRef
 */
export interface MetricAlarmSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricAlarmSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricAlarmSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MetricAlarmSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecPublishConnectionDetailsToConfigRef(obj: MetricAlarmSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MetricAlarmSpecPublishConnectionDetailsToMetadata
 */
export interface MetricAlarmSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MetricAlarmSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MetricAlarmSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MetricAlarmSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MetricAlarmSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecPublishConnectionDetailsToMetadata(obj: MetricAlarmSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricAlarmSpecForProviderMetricQueryMetric
 */
export interface MetricAlarmSpecForProviderMetricQueryMetric {
  /**
   * The dimensions for this metric.  For the list of available dimensions see the AWS documentation here.
   *
   * @schema MetricAlarmSpecForProviderMetricQueryMetric#dimensions
   */
  readonly dimensions?: { [key: string]: string };

  /**
   * The name for this metric. See docs for supported metrics.
   *
   * @schema MetricAlarmSpecForProviderMetricQueryMetric#metricName
   */
  readonly metricName?: string;

  /**
   * The namespace for this metric. See docs for the list of namespaces. See docs for supported metrics.
   *
   * @schema MetricAlarmSpecForProviderMetricQueryMetric#namespace
   */
  readonly namespace?: string;

  /**
   * Granularity in seconds of returned data points. For metrics with regular resolution, valid values are any multiple of 60. For high-resolution metrics, valid values are 1, 5, 10, 30, or any multiple of 60.
   *
   * @schema MetricAlarmSpecForProviderMetricQueryMetric#period
   */
  readonly period?: number;

  /**
   * The statistic to apply to this metric. See docs for supported statistics.
   *
   * @schema MetricAlarmSpecForProviderMetricQueryMetric#stat
   */
  readonly stat?: string;

  /**
   * The unit for this metric.
   *
   * @schema MetricAlarmSpecForProviderMetricQueryMetric#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'MetricAlarmSpecForProviderMetricQueryMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecForProviderMetricQueryMetric(obj: MetricAlarmSpecForProviderMetricQueryMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': ((obj.dimensions) === undefined) ? undefined : (Object.entries(obj.dimensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
    'period': obj.period,
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricAlarmSpecInitProviderMetricQueryMetric
 */
export interface MetricAlarmSpecInitProviderMetricQueryMetric {
  /**
   * The dimensions for this metric.  For the list of available dimensions see the AWS documentation here.
   *
   * @schema MetricAlarmSpecInitProviderMetricQueryMetric#dimensions
   */
  readonly dimensions?: { [key: string]: string };

  /**
   * The name for this metric. See docs for supported metrics.
   *
   * @schema MetricAlarmSpecInitProviderMetricQueryMetric#metricName
   */
  readonly metricName?: string;

  /**
   * The namespace for this metric. See docs for the list of namespaces. See docs for supported metrics.
   *
   * @schema MetricAlarmSpecInitProviderMetricQueryMetric#namespace
   */
  readonly namespace?: string;

  /**
   * Granularity in seconds of returned data points. For metrics with regular resolution, valid values are any multiple of 60. For high-resolution metrics, valid values are 1, 5, 10, 30, or any multiple of 60.
   *
   * @schema MetricAlarmSpecInitProviderMetricQueryMetric#period
   */
  readonly period?: number;

  /**
   * The statistic to apply to this metric. See docs for supported statistics.
   *
   * @schema MetricAlarmSpecInitProviderMetricQueryMetric#stat
   */
  readonly stat?: string;

  /**
   * The unit for this metric.
   *
   * @schema MetricAlarmSpecInitProviderMetricQueryMetric#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'MetricAlarmSpecInitProviderMetricQueryMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecInitProviderMetricQueryMetric(obj: MetricAlarmSpecInitProviderMetricQueryMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': ((obj.dimensions) === undefined) ? undefined : (Object.entries(obj.dimensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
    'period': obj.period,
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricAlarmSpecProviderConfigRefPolicyResolution
 */
export enum MetricAlarmSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricAlarmSpecProviderConfigRefPolicyResolve
 */
export enum MetricAlarmSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicy(obj: MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MetricAlarmSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MetricStream is the Schema for the MetricStreams API. Provides a CloudWatch Metric Stream resource.
 *
 * @schema MetricStream
 */
export class MetricStream extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MetricStream"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatch.aws.upbound.io/v1beta1',
    kind: 'MetricStream',
  }

  /**
   * Renders a Kubernetes manifest for "MetricStream".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MetricStreamProps): any {
    return {
      ...MetricStream.GVK,
      ...toJson_MetricStreamProps(props),
    };
  }

  /**
   * Defines a "MetricStream" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MetricStreamProps) {
    super(scope, id, {
      ...MetricStream.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MetricStream.GVK,
      ...toJson_MetricStreamProps(resolved),
    };
  }
}

/**
 * MetricStream is the Schema for the MetricStreams API. Provides a CloudWatch Metric Stream resource.
 *
 * @schema MetricStream
 */
export interface MetricStreamProps {
  /**
   * @schema MetricStream#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MetricStreamSpec defines the desired state of MetricStream
   *
   * @schema MetricStream#spec
   */
  readonly spec: MetricStreamSpec;

}

/**
 * Converts an object of type 'MetricStreamProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamProps(obj: MetricStreamProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MetricStreamSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetricStreamSpec defines the desired state of MetricStream
 *
 * @schema MetricStreamSpec
 */
export interface MetricStreamSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MetricStreamSpec#deletionPolicy
   */
  readonly deletionPolicy?: MetricStreamSpecDeletionPolicy;

  /**
   * @schema MetricStreamSpec#forProvider
   */
  readonly forProvider: MetricStreamSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema MetricStreamSpec#initProvider
   */
  readonly initProvider?: MetricStreamSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema MetricStreamSpec#managementPolicies
   */
  readonly managementPolicies?: MetricStreamSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MetricStreamSpec#providerConfigRef
   */
  readonly providerConfigRef?: MetricStreamSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MetricStreamSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MetricStreamSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MetricStreamSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MetricStreamSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MetricStreamSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpec(obj: MetricStreamSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MetricStreamSpecForProvider(obj.forProvider),
    'initProvider': toJson_MetricStreamSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_MetricStreamSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_MetricStreamSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MetricStreamSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MetricStreamSpecDeletionPolicy
 */
export enum MetricStreamSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MetricStreamSpecForProvider
 */
export interface MetricStreamSpecForProvider {
  /**
   * List of exclusive metric filters. If you specify this parameter, the stream sends metrics from all metric namespaces except for the namespaces and the conditional metric names that you specify here. If you don't specify metric names or provide empty metric names whole metric namespace is excluded. Conflicts with include_filter.
   *
   * @schema MetricStreamSpecForProvider#excludeFilter
   */
  readonly excludeFilter?: MetricStreamSpecForProviderExcludeFilter[];

  /**
   * ARN of the Amazon Kinesis Firehose delivery stream to use for this metric stream.
   *
   * @schema MetricStreamSpecForProvider#firehoseArn
   */
  readonly firehoseArn?: string;

  /**
   * Reference to a DeliveryStream in firehose to populate firehoseArn.
   *
   * @schema MetricStreamSpecForProvider#firehoseArnRef
   */
  readonly firehoseArnRef?: MetricStreamSpecForProviderFirehoseArnRef;

  /**
   * Selector for a DeliveryStream in firehose to populate firehoseArn.
   *
   * @schema MetricStreamSpecForProvider#firehoseArnSelector
   */
  readonly firehoseArnSelector?: MetricStreamSpecForProviderFirehoseArnSelector;

  /**
   * List of inclusive metric filters. If you specify this parameter, the stream sends only the conditional metric names from the metric namespaces that you specify here. If you don't specify metric names or provide empty metric names whole metric namespace is included. Conflicts with exclude_filter.
   *
   * @schema MetricStreamSpecForProvider#includeFilter
   */
  readonly includeFilter?: MetricStreamSpecForProviderIncludeFilter[];

  /**
   * account observability.
   *
   * @schema MetricStreamSpecForProvider#includeLinkedAccountsMetrics
   */
  readonly includeLinkedAccountsMetrics?: boolean;

  /**
   * Friendly name of the metric stream. Conflicts with name_prefix.
   *
   * @schema MetricStreamSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Output format for the stream. Possible values are json and opentelemetry0.7. For more information about output formats, see Metric streams output formats.
   *
   * @schema MetricStreamSpecForProvider#outputFormat
   */
  readonly outputFormat?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MetricStreamSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of the IAM role that this metric stream will use to access Amazon Kinesis Firehose resources. For more information about role permissions, see Trust between CloudWatch and Kinesis Data Firehose.
   *
   * @schema MetricStreamSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema MetricStreamSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: MetricStreamSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema MetricStreamSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: MetricStreamSpecForProviderRoleArnSelector;

  /**
   * For each entry in this array, you specify one or more metrics and the list of additional statistics to stream for those metrics. The additional statistics that you can stream depend on the stream's output_format. If the OutputFormat is json, you can stream any additional statistic that is supported by CloudWatch, listed in CloudWatch statistics definitions. If the OutputFormat is opentelemetry0.7, you can stream percentile statistics (p99 etc.). See details below.
   *
   * @schema MetricStreamSpecForProvider#statisticsConfiguration
   */
  readonly statisticsConfiguration?: MetricStreamSpecForProviderStatisticsConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema MetricStreamSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'MetricStreamSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProvider(obj: MetricStreamSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludeFilter': obj.excludeFilter?.map(y => toJson_MetricStreamSpecForProviderExcludeFilter(y)),
    'firehoseArn': obj.firehoseArn,
    'firehoseArnRef': toJson_MetricStreamSpecForProviderFirehoseArnRef(obj.firehoseArnRef),
    'firehoseArnSelector': toJson_MetricStreamSpecForProviderFirehoseArnSelector(obj.firehoseArnSelector),
    'includeFilter': obj.includeFilter?.map(y => toJson_MetricStreamSpecForProviderIncludeFilter(y)),
    'includeLinkedAccountsMetrics': obj.includeLinkedAccountsMetrics,
    'name': obj.name,
    'outputFormat': obj.outputFormat,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_MetricStreamSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_MetricStreamSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'statisticsConfiguration': obj.statisticsConfiguration?.map(y => toJson_MetricStreamSpecForProviderStatisticsConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema MetricStreamSpecInitProvider
 */
export interface MetricStreamSpecInitProvider {
  /**
   * List of exclusive metric filters. If you specify this parameter, the stream sends metrics from all metric namespaces except for the namespaces and the conditional metric names that you specify here. If you don't specify metric names or provide empty metric names whole metric namespace is excluded. Conflicts with include_filter.
   *
   * @schema MetricStreamSpecInitProvider#excludeFilter
   */
  readonly excludeFilter?: MetricStreamSpecInitProviderExcludeFilter[];

  /**
   * List of inclusive metric filters. If you specify this parameter, the stream sends only the conditional metric names from the metric namespaces that you specify here. If you don't specify metric names or provide empty metric names whole metric namespace is included. Conflicts with exclude_filter.
   *
   * @schema MetricStreamSpecInitProvider#includeFilter
   */
  readonly includeFilter?: MetricStreamSpecInitProviderIncludeFilter[];

  /**
   * account observability.
   *
   * @schema MetricStreamSpecInitProvider#includeLinkedAccountsMetrics
   */
  readonly includeLinkedAccountsMetrics?: boolean;

  /**
   * Friendly name of the metric stream. Conflicts with name_prefix.
   *
   * @schema MetricStreamSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Output format for the stream. Possible values are json and opentelemetry0.7. For more information about output formats, see Metric streams output formats.
   *
   * @schema MetricStreamSpecInitProvider#outputFormat
   */
  readonly outputFormat?: string;

  /**
   * For each entry in this array, you specify one or more metrics and the list of additional statistics to stream for those metrics. The additional statistics that you can stream depend on the stream's output_format. If the OutputFormat is json, you can stream any additional statistic that is supported by CloudWatch, listed in CloudWatch statistics definitions. If the OutputFormat is opentelemetry0.7, you can stream percentile statistics (p99 etc.). See details below.
   *
   * @schema MetricStreamSpecInitProvider#statisticsConfiguration
   */
  readonly statisticsConfiguration?: MetricStreamSpecInitProviderStatisticsConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema MetricStreamSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'MetricStreamSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecInitProvider(obj: MetricStreamSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludeFilter': obj.excludeFilter?.map(y => toJson_MetricStreamSpecInitProviderExcludeFilter(y)),
    'includeFilter': obj.includeFilter?.map(y => toJson_MetricStreamSpecInitProviderIncludeFilter(y)),
    'includeLinkedAccountsMetrics': obj.includeLinkedAccountsMetrics,
    'name': obj.name,
    'outputFormat': obj.outputFormat,
    'statisticsConfiguration': obj.statisticsConfiguration?.map(y => toJson_MetricStreamSpecInitProviderStatisticsConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema MetricStreamSpecManagementPolicies
 */
export enum MetricStreamSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MetricStreamSpecProviderConfigRef
 */
export interface MetricStreamSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricStreamSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricStreamSpecProviderConfigRef#policy
   */
  readonly policy?: MetricStreamSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MetricStreamSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecProviderConfigRef(obj: MetricStreamSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricStreamSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MetricStreamSpecPublishConnectionDetailsTo
 */
export interface MetricStreamSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MetricStreamSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MetricStreamSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MetricStreamSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MetricStreamSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MetricStreamSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MetricStreamSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecPublishConnectionDetailsTo(obj: MetricStreamSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MetricStreamSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MetricStreamSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MetricStreamSpecWriteConnectionSecretToRef
 */
export interface MetricStreamSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MetricStreamSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MetricStreamSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MetricStreamSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecWriteConnectionSecretToRef(obj: MetricStreamSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricStreamSpecForProviderExcludeFilter
 */
export interface MetricStreamSpecForProviderExcludeFilter {
  /**
   * An array that defines the metrics you want to exclude for this metric namespace
   *
   * @schema MetricStreamSpecForProviderExcludeFilter#metricNames
   */
  readonly metricNames?: string[];

  /**
   * Name of the metric namespace in the filter.
   *
   * @schema MetricStreamSpecForProviderExcludeFilter#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderExcludeFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderExcludeFilter(obj: MetricStreamSpecForProviderExcludeFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricNames': obj.metricNames?.map(y => y),
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DeliveryStream in firehose to populate firehoseArn.
 *
 * @schema MetricStreamSpecForProviderFirehoseArnRef
 */
export interface MetricStreamSpecForProviderFirehoseArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricStreamSpecForProviderFirehoseArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricStreamSpecForProviderFirehoseArnRef#policy
   */
  readonly policy?: MetricStreamSpecForProviderFirehoseArnRefPolicy;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderFirehoseArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderFirehoseArnRef(obj: MetricStreamSpecForProviderFirehoseArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricStreamSpecForProviderFirehoseArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DeliveryStream in firehose to populate firehoseArn.
 *
 * @schema MetricStreamSpecForProviderFirehoseArnSelector
 */
export interface MetricStreamSpecForProviderFirehoseArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MetricStreamSpecForProviderFirehoseArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MetricStreamSpecForProviderFirehoseArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MetricStreamSpecForProviderFirehoseArnSelector#policy
   */
  readonly policy?: MetricStreamSpecForProviderFirehoseArnSelectorPolicy;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderFirehoseArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderFirehoseArnSelector(obj: MetricStreamSpecForProviderFirehoseArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MetricStreamSpecForProviderFirehoseArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricStreamSpecForProviderIncludeFilter
 */
export interface MetricStreamSpecForProviderIncludeFilter {
  /**
   * An array that defines the metrics you want to include for this metric namespace
   *
   * @schema MetricStreamSpecForProviderIncludeFilter#metricNames
   */
  readonly metricNames?: string[];

  /**
   * Name of the metric namespace in the filter.
   *
   * @schema MetricStreamSpecForProviderIncludeFilter#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderIncludeFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderIncludeFilter(obj: MetricStreamSpecForProviderIncludeFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricNames': obj.metricNames?.map(y => y),
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema MetricStreamSpecForProviderRoleArnRef
 */
export interface MetricStreamSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricStreamSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricStreamSpecForProviderRoleArnRef#policy
   */
  readonly policy?: MetricStreamSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderRoleArnRef(obj: MetricStreamSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricStreamSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema MetricStreamSpecForProviderRoleArnSelector
 */
export interface MetricStreamSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MetricStreamSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MetricStreamSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MetricStreamSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: MetricStreamSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderRoleArnSelector(obj: MetricStreamSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MetricStreamSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricStreamSpecForProviderStatisticsConfiguration
 */
export interface MetricStreamSpecForProviderStatisticsConfiguration {
  /**
   * The additional statistics to stream for the metrics listed in include_metrics.
   *
   * @schema MetricStreamSpecForProviderStatisticsConfiguration#additionalStatistics
   */
  readonly additionalStatistics?: string[];

  /**
   * An array that defines the metrics that are to have additional statistics streamed. See details below.
   *
   * @schema MetricStreamSpecForProviderStatisticsConfiguration#includeMetric
   */
  readonly includeMetric?: MetricStreamSpecForProviderStatisticsConfigurationIncludeMetric[];

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderStatisticsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderStatisticsConfiguration(obj: MetricStreamSpecForProviderStatisticsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalStatistics': obj.additionalStatistics?.map(y => y),
    'includeMetric': obj.includeMetric?.map(y => toJson_MetricStreamSpecForProviderStatisticsConfigurationIncludeMetric(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricStreamSpecInitProviderExcludeFilter
 */
export interface MetricStreamSpecInitProviderExcludeFilter {
  /**
   * An array that defines the metrics you want to exclude for this metric namespace
   *
   * @schema MetricStreamSpecInitProviderExcludeFilter#metricNames
   */
  readonly metricNames?: string[];

  /**
   * Name of the metric namespace in the filter.
   *
   * @schema MetricStreamSpecInitProviderExcludeFilter#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MetricStreamSpecInitProviderExcludeFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecInitProviderExcludeFilter(obj: MetricStreamSpecInitProviderExcludeFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricNames': obj.metricNames?.map(y => y),
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricStreamSpecInitProviderIncludeFilter
 */
export interface MetricStreamSpecInitProviderIncludeFilter {
  /**
   * An array that defines the metrics you want to include for this metric namespace
   *
   * @schema MetricStreamSpecInitProviderIncludeFilter#metricNames
   */
  readonly metricNames?: string[];

  /**
   * Name of the metric namespace in the filter.
   *
   * @schema MetricStreamSpecInitProviderIncludeFilter#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MetricStreamSpecInitProviderIncludeFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecInitProviderIncludeFilter(obj: MetricStreamSpecInitProviderIncludeFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricNames': obj.metricNames?.map(y => y),
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricStreamSpecInitProviderStatisticsConfiguration
 */
export interface MetricStreamSpecInitProviderStatisticsConfiguration {
  /**
   * The additional statistics to stream for the metrics listed in include_metrics.
   *
   * @schema MetricStreamSpecInitProviderStatisticsConfiguration#additionalStatistics
   */
  readonly additionalStatistics?: string[];

  /**
   * An array that defines the metrics that are to have additional statistics streamed. See details below.
   *
   * @schema MetricStreamSpecInitProviderStatisticsConfiguration#includeMetric
   */
  readonly includeMetric?: MetricStreamSpecInitProviderStatisticsConfigurationIncludeMetric[];

}

/**
 * Converts an object of type 'MetricStreamSpecInitProviderStatisticsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecInitProviderStatisticsConfiguration(obj: MetricStreamSpecInitProviderStatisticsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalStatistics': obj.additionalStatistics?.map(y => y),
    'includeMetric': obj.includeMetric?.map(y => toJson_MetricStreamSpecInitProviderStatisticsConfigurationIncludeMetric(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricStreamSpecProviderConfigRefPolicy
 */
export interface MetricStreamSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricStreamSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MetricStreamSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricStreamSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MetricStreamSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricStreamSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecProviderConfigRefPolicy(obj: MetricStreamSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MetricStreamSpecPublishConnectionDetailsToConfigRef
 */
export interface MetricStreamSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricStreamSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricStreamSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MetricStreamSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MetricStreamSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecPublishConnectionDetailsToConfigRef(obj: MetricStreamSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricStreamSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MetricStreamSpecPublishConnectionDetailsToMetadata
 */
export interface MetricStreamSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MetricStreamSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MetricStreamSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MetricStreamSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MetricStreamSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecPublishConnectionDetailsToMetadata(obj: MetricStreamSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricStreamSpecForProviderFirehoseArnRefPolicy
 */
export interface MetricStreamSpecForProviderFirehoseArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricStreamSpecForProviderFirehoseArnRefPolicy#resolution
   */
  readonly resolution?: MetricStreamSpecForProviderFirehoseArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricStreamSpecForProviderFirehoseArnRefPolicy#resolve
   */
  readonly resolve?: MetricStreamSpecForProviderFirehoseArnRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderFirehoseArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderFirehoseArnRefPolicy(obj: MetricStreamSpecForProviderFirehoseArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MetricStreamSpecForProviderFirehoseArnSelectorPolicy
 */
export interface MetricStreamSpecForProviderFirehoseArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricStreamSpecForProviderFirehoseArnSelectorPolicy#resolution
   */
  readonly resolution?: MetricStreamSpecForProviderFirehoseArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricStreamSpecForProviderFirehoseArnSelectorPolicy#resolve
   */
  readonly resolve?: MetricStreamSpecForProviderFirehoseArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderFirehoseArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderFirehoseArnSelectorPolicy(obj: MetricStreamSpecForProviderFirehoseArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricStreamSpecForProviderRoleArnRefPolicy
 */
export interface MetricStreamSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricStreamSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: MetricStreamSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricStreamSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: MetricStreamSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderRoleArnRefPolicy(obj: MetricStreamSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MetricStreamSpecForProviderRoleArnSelectorPolicy
 */
export interface MetricStreamSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricStreamSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: MetricStreamSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricStreamSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: MetricStreamSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderRoleArnSelectorPolicy(obj: MetricStreamSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricStreamSpecForProviderStatisticsConfigurationIncludeMetric
 */
export interface MetricStreamSpecForProviderStatisticsConfigurationIncludeMetric {
  /**
   * The name of the metric.
   *
   * @schema MetricStreamSpecForProviderStatisticsConfigurationIncludeMetric#metricName
   */
  readonly metricName?: string;

  /**
   * The namespace of the metric.
   *
   * @schema MetricStreamSpecForProviderStatisticsConfigurationIncludeMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MetricStreamSpecForProviderStatisticsConfigurationIncludeMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecForProviderStatisticsConfigurationIncludeMetric(obj: MetricStreamSpecForProviderStatisticsConfigurationIncludeMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricStreamSpecInitProviderStatisticsConfigurationIncludeMetric
 */
export interface MetricStreamSpecInitProviderStatisticsConfigurationIncludeMetric {
  /**
   * The name of the metric.
   *
   * @schema MetricStreamSpecInitProviderStatisticsConfigurationIncludeMetric#metricName
   */
  readonly metricName?: string;

  /**
   * The namespace of the metric.
   *
   * @schema MetricStreamSpecInitProviderStatisticsConfigurationIncludeMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MetricStreamSpecInitProviderStatisticsConfigurationIncludeMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecInitProviderStatisticsConfigurationIncludeMetric(obj: MetricStreamSpecInitProviderStatisticsConfigurationIncludeMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricStreamSpecProviderConfigRefPolicyResolution
 */
export enum MetricStreamSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricStreamSpecProviderConfigRefPolicyResolve
 */
export enum MetricStreamSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MetricStreamSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MetricStreamSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricStreamSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MetricStreamSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricStreamSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MetricStreamSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricStreamSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricStreamSpecPublishConnectionDetailsToConfigRefPolicy(obj: MetricStreamSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricStreamSpecForProviderFirehoseArnRefPolicyResolution
 */
export enum MetricStreamSpecForProviderFirehoseArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricStreamSpecForProviderFirehoseArnRefPolicyResolve
 */
export enum MetricStreamSpecForProviderFirehoseArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricStreamSpecForProviderFirehoseArnSelectorPolicyResolution
 */
export enum MetricStreamSpecForProviderFirehoseArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricStreamSpecForProviderFirehoseArnSelectorPolicyResolve
 */
export enum MetricStreamSpecForProviderFirehoseArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricStreamSpecForProviderRoleArnRefPolicyResolution
 */
export enum MetricStreamSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricStreamSpecForProviderRoleArnRefPolicyResolve
 */
export enum MetricStreamSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricStreamSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum MetricStreamSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricStreamSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum MetricStreamSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricStreamSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MetricStreamSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricStreamSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MetricStreamSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

