// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DelegationSet is the Schema for the DelegationSets API. Provides a Route53 Delegation Set resource.
 *
 * @schema DelegationSet
 */
export class DelegationSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DelegationSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'DelegationSet',
  }

  /**
   * Renders a Kubernetes manifest for "DelegationSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DelegationSetProps): any {
    return {
      ...DelegationSet.GVK,
      ...toJson_DelegationSetProps(props),
    };
  }

  /**
   * Defines a "DelegationSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DelegationSetProps) {
    super(scope, id, {
      ...DelegationSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DelegationSet.GVK,
      ...toJson_DelegationSetProps(resolved),
    };
  }
}

/**
 * DelegationSet is the Schema for the DelegationSets API. Provides a Route53 Delegation Set resource.
 *
 * @schema DelegationSet
 */
export interface DelegationSetProps {
  /**
   * @schema DelegationSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DelegationSetSpec defines the desired state of DelegationSet
   *
   * @schema DelegationSet#spec
   */
  readonly spec: DelegationSetSpec;

}

/**
 * Converts an object of type 'DelegationSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetProps(obj: DelegationSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DelegationSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DelegationSetSpec defines the desired state of DelegationSet
 *
 * @schema DelegationSetSpec
 */
export interface DelegationSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DelegationSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: DelegationSetSpecDeletionPolicy;

  /**
   * @schema DelegationSetSpec#forProvider
   */
  readonly forProvider: DelegationSetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DelegationSetSpec#managementPolicy
   */
  readonly managementPolicy?: DelegationSetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DelegationSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: DelegationSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DelegationSetSpec#providerRef
   */
  readonly providerRef?: DelegationSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DelegationSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DelegationSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DelegationSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DelegationSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DelegationSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpec(obj: DelegationSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DelegationSetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DelegationSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DelegationSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DelegationSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DelegationSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DelegationSetSpecDeletionPolicy
 */
export enum DelegationSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DelegationSetSpecForProvider
 */
export interface DelegationSetSpecForProvider {
  /**
   * This is a reference name used in Caller Reference (helpful for identifying single delegation set amongst others)
   *
   * @schema DelegationSetSpecForProvider#referenceName
   */
  readonly referenceName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DelegationSetSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DelegationSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecForProvider(obj: DelegationSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'referenceName': obj.referenceName,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DelegationSetSpecManagementPolicy
 */
export enum DelegationSetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DelegationSetSpecProviderConfigRef
 */
export interface DelegationSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DelegationSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DelegationSetSpecProviderConfigRef#policy
   */
  readonly policy?: DelegationSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DelegationSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecProviderConfigRef(obj: DelegationSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DelegationSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DelegationSetSpecProviderRef
 */
export interface DelegationSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DelegationSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DelegationSetSpecProviderRef#policy
   */
  readonly policy?: DelegationSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DelegationSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecProviderRef(obj: DelegationSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DelegationSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsTo
 */
export interface DelegationSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DelegationSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DelegationSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DelegationSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecPublishConnectionDetailsTo(obj: DelegationSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DelegationSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DelegationSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DelegationSetSpecWriteConnectionSecretToRef
 */
export interface DelegationSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DelegationSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DelegationSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DelegationSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecWriteConnectionSecretToRef(obj: DelegationSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DelegationSetSpecProviderConfigRefPolicy
 */
export interface DelegationSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DelegationSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DelegationSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DelegationSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DelegationSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DelegationSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecProviderConfigRefPolicy(obj: DelegationSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DelegationSetSpecProviderRefPolicy
 */
export interface DelegationSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DelegationSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DelegationSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DelegationSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DelegationSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DelegationSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecProviderRefPolicy(obj: DelegationSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsToConfigRef
 */
export interface DelegationSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DelegationSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecPublishConnectionDetailsToConfigRef(obj: DelegationSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsToMetadata
 */
export interface DelegationSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DelegationSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecPublishConnectionDetailsToMetadata(obj: DelegationSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DelegationSetSpecProviderConfigRefPolicyResolution
 */
export enum DelegationSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DelegationSetSpecProviderConfigRefPolicyResolve
 */
export enum DelegationSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DelegationSetSpecProviderRefPolicyResolution
 */
export enum DelegationSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DelegationSetSpecProviderRefPolicyResolve
 */
export enum DelegationSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HealthCheck is the Schema for the HealthChecks API. Provides a Route53 health check.
 *
 * @schema HealthCheck
 */
export class HealthCheck extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HealthCheck"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'HealthCheck',
  }

  /**
   * Renders a Kubernetes manifest for "HealthCheck".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HealthCheckProps): any {
    return {
      ...HealthCheck.GVK,
      ...toJson_HealthCheckProps(props),
    };
  }

  /**
   * Defines a "HealthCheck" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HealthCheckProps) {
    super(scope, id, {
      ...HealthCheck.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HealthCheck.GVK,
      ...toJson_HealthCheckProps(resolved),
    };
  }
}

/**
 * HealthCheck is the Schema for the HealthChecks API. Provides a Route53 health check.
 *
 * @schema HealthCheck
 */
export interface HealthCheckProps {
  /**
   * @schema HealthCheck#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HealthCheckSpec defines the desired state of HealthCheck
   *
   * @schema HealthCheck#spec
   */
  readonly spec: HealthCheckSpec;

}

/**
 * Converts an object of type 'HealthCheckProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckProps(obj: HealthCheckProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HealthCheckSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HealthCheckSpec defines the desired state of HealthCheck
 *
 * @schema HealthCheckSpec
 */
export interface HealthCheckSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HealthCheckSpec#deletionPolicy
   */
  readonly deletionPolicy?: HealthCheckSpecDeletionPolicy;

  /**
   * @schema HealthCheckSpec#forProvider
   */
  readonly forProvider: HealthCheckSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HealthCheckSpec#managementPolicy
   */
  readonly managementPolicy?: HealthCheckSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HealthCheckSpec#providerConfigRef
   */
  readonly providerConfigRef?: HealthCheckSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema HealthCheckSpec#providerRef
   */
  readonly providerRef?: HealthCheckSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HealthCheckSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HealthCheckSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HealthCheckSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HealthCheckSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HealthCheckSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpec(obj: HealthCheckSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HealthCheckSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_HealthCheckSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_HealthCheckSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_HealthCheckSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HealthCheckSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HealthCheckSpecDeletionPolicy
 */
export enum HealthCheckSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HealthCheckSpecForProvider
 */
export interface HealthCheckSpecForProvider {
  /**
   * The minimum number of child health checks that must be healthy for Route 53 to consider the parent health check to be healthy. Valid values are integers between 0 and 256, inclusive
   *
   * @schema HealthCheckSpecForProvider#childHealthThreshold
   */
  readonly childHealthThreshold?: number;

  /**
   * For a specified parent health check, a list of HealthCheckId values for the associated child health checks.
   *
   * @schema HealthCheckSpecForProvider#childHealthchecks
   */
  readonly childHealthchecks?: string[];

  /**
   * The name of the CloudWatch alarm.
   *
   * @schema HealthCheckSpecForProvider#cloudwatchAlarmName
   */
  readonly cloudwatchAlarmName?: string;

  /**
   * Reference to a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
   *
   * @schema HealthCheckSpecForProvider#cloudwatchAlarmNameRef
   */
  readonly cloudwatchAlarmNameRef?: HealthCheckSpecForProviderCloudwatchAlarmNameRef;

  /**
   * Selector for a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
   *
   * @schema HealthCheckSpecForProvider#cloudwatchAlarmNameSelector
   */
  readonly cloudwatchAlarmNameSelector?: HealthCheckSpecForProviderCloudwatchAlarmNameSelector;

  /**
   * The CloudWatchRegion that the CloudWatch alarm was created in.
   *
   * @schema HealthCheckSpecForProvider#cloudwatchAlarmRegion
   */
  readonly cloudwatchAlarmRegion?: string;

  /**
   * A boolean value that stops Route 53 from performing health checks. When set to true, Route 53 will do the following depending on the type of health check:
   *
   * @schema HealthCheckSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * A boolean value that indicates whether Route53 should send the fqdn to the endpoint when performing the health check. This defaults to AWS' defaults: when the type is "HTTPS" enable_sni defaults to true, when type is anything else enable_sni defaults to false.
   *
   * @schema HealthCheckSpecForProvider#enableSni
   */
  readonly enableSni?: boolean;

  /**
   * The number of consecutive health checks that an endpoint must pass or fail.
   *
   * @schema HealthCheckSpecForProvider#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The fully qualified domain name of the endpoint to be checked.
   *
   * @schema HealthCheckSpecForProvider#fqdn
   */
  readonly fqdn?: string;

  /**
   * The status of the health check when CloudWatch has insufficient data about the state of associated alarm. Valid values are Healthy , Unhealthy and LastKnownStatus.
   *
   * @schema HealthCheckSpecForProvider#insufficientDataHealthStatus
   */
  readonly insufficientDataHealthStatus?: string;

  /**
   * A boolean value that indicates whether the status of health check should be inverted. For example, if a health check is healthy but Inverted is True , then Route 53 considers the health check to be unhealthy.
   *
   * @schema HealthCheckSpecForProvider#invertHealthcheck
   */
  readonly invertHealthcheck?: boolean;

  /**
   * The IP address of the endpoint to be checked.
   *
   * @schema HealthCheckSpecForProvider#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * A Boolean value that indicates whether you want Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint and to display CloudWatch latency graphs in the Route 53 console.
   *
   * @schema HealthCheckSpecForProvider#measureLatency
   */
  readonly measureLatency?: boolean;

  /**
   * The port of the endpoint to be checked.
   *
   * @schema HealthCheckSpecForProvider#port
   */
  readonly port?: number;

  /**
   * This is a reference name used in Caller Reference (helpful for identifying single health_check set amongst others)
   *
   * @schema HealthCheckSpecForProvider#referenceName
   */
  readonly referenceName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HealthCheckSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of AWS regions that you want Amazon Route 53 health checkers to check the specified endpoint from.
   *
   * @schema HealthCheckSpecForProvider#regions
   */
  readonly regions?: string[];

  /**
   * The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health-check request.
   *
   * @schema HealthCheckSpecForProvider#requestInterval
   */
  readonly requestInterval?: number;

  /**
   * The path that you want Amazon Route 53 to request when performing health checks.
   *
   * @schema HealthCheckSpecForProvider#resourcePath
   */
  readonly resourcePath?: string;

  /**
   * The Amazon Resource Name (ARN) for the Route 53 Application Recovery Controller routing control. This is used when health check type is RECOVERY_CONTROL
   *
   * @schema HealthCheckSpecForProvider#routingControlArn
   */
  readonly routingControlArn?: string;

  /**
   * String searched in the first 5120 bytes of the response body for check to be considered healthy. Only valid with HTTP_STR_MATCH and HTTPS_STR_MATCH.
   *
   * @schema HealthCheckSpecForProvider#searchString
   */
  readonly searchString?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HealthCheckSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The protocol to use when performing health checks. Valid values are HTTP, HTTPS, HTTP_STR_MATCH, HTTPS_STR_MATCH, TCP, CALCULATED, CLOUDWATCH_METRIC and RECOVERY_CONTROL.
   *
   * @schema HealthCheckSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HealthCheckSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecForProvider(obj: HealthCheckSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'childHealthThreshold': obj.childHealthThreshold,
    'childHealthchecks': obj.childHealthchecks?.map(y => y),
    'cloudwatchAlarmName': obj.cloudwatchAlarmName,
    'cloudwatchAlarmNameRef': toJson_HealthCheckSpecForProviderCloudwatchAlarmNameRef(obj.cloudwatchAlarmNameRef),
    'cloudwatchAlarmNameSelector': toJson_HealthCheckSpecForProviderCloudwatchAlarmNameSelector(obj.cloudwatchAlarmNameSelector),
    'cloudwatchAlarmRegion': obj.cloudwatchAlarmRegion,
    'disabled': obj.disabled,
    'enableSni': obj.enableSni,
    'failureThreshold': obj.failureThreshold,
    'fqdn': obj.fqdn,
    'insufficientDataHealthStatus': obj.insufficientDataHealthStatus,
    'invertHealthcheck': obj.invertHealthcheck,
    'ipAddress': obj.ipAddress,
    'measureLatency': obj.measureLatency,
    'port': obj.port,
    'referenceName': obj.referenceName,
    'region': obj.region,
    'regions': obj.regions?.map(y => y),
    'requestInterval': obj.requestInterval,
    'resourcePath': obj.resourcePath,
    'routingControlArn': obj.routingControlArn,
    'searchString': obj.searchString,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HealthCheckSpecManagementPolicy
 */
export enum HealthCheckSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HealthCheckSpecProviderConfigRef
 */
export interface HealthCheckSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HealthCheckSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HealthCheckSpecProviderConfigRef#policy
   */
  readonly policy?: HealthCheckSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecProviderConfigRef(obj: HealthCheckSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HealthCheckSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema HealthCheckSpecProviderRef
 */
export interface HealthCheckSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema HealthCheckSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HealthCheckSpecProviderRef#policy
   */
  readonly policy?: HealthCheckSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecProviderRef(obj: HealthCheckSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HealthCheckSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsTo
 */
export interface HealthCheckSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HealthCheckSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HealthCheckSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HealthCheckSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecPublishConnectionDetailsTo(obj: HealthCheckSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HealthCheckSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HealthCheckSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HealthCheckSpecWriteConnectionSecretToRef
 */
export interface HealthCheckSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HealthCheckSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HealthCheckSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HealthCheckSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecWriteConnectionSecretToRef(obj: HealthCheckSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRef
 */
export interface HealthCheckSpecForProviderCloudwatchAlarmNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRef#policy
   */
  readonly policy?: HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecForProviderCloudwatchAlarmNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecForProviderCloudwatchAlarmNameRef(obj: HealthCheckSpecForProviderCloudwatchAlarmNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelector
 */
export interface HealthCheckSpecForProviderCloudwatchAlarmNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelector#policy
   */
  readonly policy?: HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecForProviderCloudwatchAlarmNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecForProviderCloudwatchAlarmNameSelector(obj: HealthCheckSpecForProviderCloudwatchAlarmNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HealthCheckSpecProviderConfigRefPolicy
 */
export interface HealthCheckSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HealthCheckSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecProviderConfigRefPolicy(obj: HealthCheckSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HealthCheckSpecProviderRefPolicy
 */
export interface HealthCheckSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecProviderRefPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HealthCheckSpecProviderRefPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecProviderRefPolicy(obj: HealthCheckSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsToConfigRef
 */
export interface HealthCheckSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecPublishConnectionDetailsToConfigRef(obj: HealthCheckSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsToMetadata
 */
export interface HealthCheckSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HealthCheckSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecPublishConnectionDetailsToMetadata(obj: HealthCheckSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy
 */
export interface HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy(obj: HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy
 */
export interface HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy(obj: HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecProviderConfigRefPolicyResolution
 */
export enum HealthCheckSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HealthCheckSpecProviderConfigRefPolicyResolve
 */
export enum HealthCheckSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecProviderRefPolicyResolution
 */
export enum HealthCheckSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HealthCheckSpecProviderRefPolicyResolve
 */
export enum HealthCheckSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy(obj: HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolution
 */
export enum HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolve
 */
export enum HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolution
 */
export enum HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolve
 */
export enum HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HostedZoneDNSSEC is the Schema for the HostedZoneDNSSECs API. Manages Route 53 Hosted Zone DNSSEC
 *
 * @schema HostedZoneDNSSEC
 */
export class HostedZoneDnssec extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HostedZoneDNSSEC"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'HostedZoneDNSSEC',
  }

  /**
   * Renders a Kubernetes manifest for "HostedZoneDNSSEC".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HostedZoneDnssecProps): any {
    return {
      ...HostedZoneDnssec.GVK,
      ...toJson_HostedZoneDnssecProps(props),
    };
  }

  /**
   * Defines a "HostedZoneDNSSEC" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HostedZoneDnssecProps) {
    super(scope, id, {
      ...HostedZoneDnssec.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HostedZoneDnssec.GVK,
      ...toJson_HostedZoneDnssecProps(resolved),
    };
  }
}

/**
 * HostedZoneDNSSEC is the Schema for the HostedZoneDNSSECs API. Manages Route 53 Hosted Zone DNSSEC
 *
 * @schema HostedZoneDNSSEC
 */
export interface HostedZoneDnssecProps {
  /**
   * @schema HostedZoneDNSSEC#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HostedZoneDNSSECSpec defines the desired state of HostedZoneDNSSEC
   *
   * @schema HostedZoneDNSSEC#spec
   */
  readonly spec: HostedZoneDnssecSpec;

}

/**
 * Converts an object of type 'HostedZoneDnssecProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecProps(obj: HostedZoneDnssecProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HostedZoneDnssecSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostedZoneDNSSECSpec defines the desired state of HostedZoneDNSSEC
 *
 * @schema HostedZoneDnssecSpec
 */
export interface HostedZoneDnssecSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedZoneDnssecSpec#deletionPolicy
   */
  readonly deletionPolicy?: HostedZoneDnssecSpecDeletionPolicy;

  /**
   * @schema HostedZoneDnssecSpec#forProvider
   */
  readonly forProvider: HostedZoneDnssecSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedZoneDnssecSpec#managementPolicy
   */
  readonly managementPolicy?: HostedZoneDnssecSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HostedZoneDnssecSpec#providerConfigRef
   */
  readonly providerConfigRef?: HostedZoneDnssecSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema HostedZoneDnssecSpec#providerRef
   */
  readonly providerRef?: HostedZoneDnssecSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HostedZoneDnssecSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HostedZoneDnssecSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HostedZoneDnssecSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HostedZoneDnssecSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpec(obj: HostedZoneDnssecSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HostedZoneDnssecSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_HostedZoneDnssecSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_HostedZoneDnssecSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_HostedZoneDnssecSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HostedZoneDnssecSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedZoneDnssecSpecDeletionPolicy
 */
export enum HostedZoneDnssecSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HostedZoneDnssecSpecForProvider
 */
export interface HostedZoneDnssecSpecForProvider {
  /**
   * Identifier of the Route 53 Hosted Zone.
   *
   * @schema HostedZoneDnssecSpecForProvider#hostedZoneId
   */
  readonly hostedZoneId?: string;

  /**
   * Reference to a Zone to populate hostedZoneId.
   *
   * @schema HostedZoneDnssecSpecForProvider#hostedZoneIdRef
   */
  readonly hostedZoneIdRef?: HostedZoneDnssecSpecForProviderHostedZoneIdRef;

  /**
   * Selector for a Zone to populate hostedZoneId.
   *
   * @schema HostedZoneDnssecSpecForProvider#hostedZoneIdSelector
   */
  readonly hostedZoneIdSelector?: HostedZoneDnssecSpecForProviderHostedZoneIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HostedZoneDnssecSpecForProvider#region
   */
  readonly region: string;

  /**
   * Hosted Zone signing status. Valid values: SIGNING, NOT_SIGNING. Defaults to SIGNING.
   *
   * @default SIGNING.
   * @schema HostedZoneDnssecSpecForProvider#signingStatus
   */
  readonly signingStatus?: string;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecForProvider(obj: HostedZoneDnssecSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostedZoneId': obj.hostedZoneId,
    'hostedZoneIdRef': toJson_HostedZoneDnssecSpecForProviderHostedZoneIdRef(obj.hostedZoneIdRef),
    'hostedZoneIdSelector': toJson_HostedZoneDnssecSpecForProviderHostedZoneIdSelector(obj.hostedZoneIdSelector),
    'region': obj.region,
    'signingStatus': obj.signingStatus,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedZoneDnssecSpecManagementPolicy
 */
export enum HostedZoneDnssecSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HostedZoneDnssecSpecProviderConfigRef
 */
export interface HostedZoneDnssecSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedZoneDnssecSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedZoneDnssecSpecProviderConfigRef#policy
   */
  readonly policy?: HostedZoneDnssecSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecProviderConfigRef(obj: HostedZoneDnssecSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedZoneDnssecSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema HostedZoneDnssecSpecProviderRef
 */
export interface HostedZoneDnssecSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedZoneDnssecSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedZoneDnssecSpecProviderRef#policy
   */
  readonly policy?: HostedZoneDnssecSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecProviderRef(obj: HostedZoneDnssecSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedZoneDnssecSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsTo
 */
export interface HostedZoneDnssecSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HostedZoneDnssecSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecPublishConnectionDetailsTo(obj: HostedZoneDnssecSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HostedZoneDnssecSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HostedZoneDnssecSpecWriteConnectionSecretToRef
 */
export interface HostedZoneDnssecSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HostedZoneDnssecSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HostedZoneDnssecSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecWriteConnectionSecretToRef(obj: HostedZoneDnssecSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone to populate hostedZoneId.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRef
 */
export interface HostedZoneDnssecSpecForProviderHostedZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRef#policy
   */
  readonly policy?: HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecForProviderHostedZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecForProviderHostedZoneIdRef(obj: HostedZoneDnssecSpecForProviderHostedZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone to populate hostedZoneId.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelector
 */
export interface HostedZoneDnssecSpecForProviderHostedZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelector#policy
   */
  readonly policy?: HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecForProviderHostedZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecForProviderHostedZoneIdSelector(obj: HostedZoneDnssecSpecForProviderHostedZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedZoneDnssecSpecProviderConfigRefPolicy
 */
export interface HostedZoneDnssecSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecProviderConfigRefPolicy(obj: HostedZoneDnssecSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedZoneDnssecSpecProviderRefPolicy
 */
export interface HostedZoneDnssecSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecProviderRefPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecProviderRefPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecProviderRefPolicy(obj: HostedZoneDnssecSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef
 */
export interface HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef(obj: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsToMetadata
 */
export interface HostedZoneDnssecSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecPublishConnectionDetailsToMetadata(obj: HostedZoneDnssecSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy
 */
export interface HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy(obj: HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy
 */
export interface HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy(obj: HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecProviderConfigRefPolicyResolution
 */
export enum HostedZoneDnssecSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecProviderConfigRefPolicyResolve
 */
export enum HostedZoneDnssecSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecProviderRefPolicyResolution
 */
export enum HostedZoneDnssecSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecProviderRefPolicyResolve
 */
export enum HostedZoneDnssecSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy(obj: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolution
 */
export enum HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolve
 */
export enum HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolution
 */
export enum HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolve
 */
export enum HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Record is the Schema for the Records API. Provides a Route53 record resource.
 *
 * @schema Record
 */
export class Record extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Record"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'Record',
  }

  /**
   * Renders a Kubernetes manifest for "Record".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RecordProps): any {
    return {
      ...Record.GVK,
      ...toJson_RecordProps(props),
    };
  }

  /**
   * Defines a "Record" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RecordProps) {
    super(scope, id, {
      ...Record.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Record.GVK,
      ...toJson_RecordProps(resolved),
    };
  }
}

/**
 * Record is the Schema for the Records API. Provides a Route53 record resource.
 *
 * @schema Record
 */
export interface RecordProps {
  /**
   * @schema Record#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RecordSpec defines the desired state of Record
   *
   * @schema Record#spec
   */
  readonly spec: RecordSpec;

}

/**
 * Converts an object of type 'RecordProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordProps(obj: RecordProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RecordSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RecordSpec defines the desired state of Record
 *
 * @schema RecordSpec
 */
export interface RecordSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RecordSpec#deletionPolicy
   */
  readonly deletionPolicy?: RecordSpecDeletionPolicy;

  /**
   * @schema RecordSpec#forProvider
   */
  readonly forProvider: RecordSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RecordSpec#managementPolicy
   */
  readonly managementPolicy?: RecordSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RecordSpec#providerConfigRef
   */
  readonly providerConfigRef?: RecordSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RecordSpec#providerRef
   */
  readonly providerRef?: RecordSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RecordSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RecordSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RecordSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RecordSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RecordSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpec(obj: RecordSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RecordSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RecordSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RecordSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RecordSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RecordSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RecordSpecDeletionPolicy
 */
export enum RecordSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RecordSpecForProvider
 */
export interface RecordSpecForProvider {
  /**
   * An alias block. Conflicts with ttl & records. Documented below.
   *
   * @schema RecordSpecForProvider#alias
   */
  readonly alias?: RecordSpecForProviderAlias[];

  /**
   * false by default. This configuration is not recommended for most environments.
   *
   * @schema RecordSpecForProvider#allowOverwrite
   */
  readonly allowOverwrite?: boolean;

  /**
   * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#cidrRoutingPolicy
   */
  readonly cidrRoutingPolicy?: RecordSpecForProviderCidrRoutingPolicy[];

  /**
   * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#failoverRoutingPolicy
   */
  readonly failoverRoutingPolicy?: RecordSpecForProviderFailoverRoutingPolicy[];

  /**
   * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#geolocationRoutingPolicy
   */
  readonly geolocationRoutingPolicy?: RecordSpecForProviderGeolocationRoutingPolicy[];

  /**
   * The health check the record should be associated with.
   *
   * @schema RecordSpecForProvider#healthCheckId
   */
  readonly healthCheckId?: string;

  /**
   * Reference to a HealthCheck to populate healthCheckId.
   *
   * @schema RecordSpecForProvider#healthCheckIdRef
   */
  readonly healthCheckIdRef?: RecordSpecForProviderHealthCheckIdRef;

  /**
   * Selector for a HealthCheck to populate healthCheckId.
   *
   * @schema RecordSpecForProvider#healthCheckIdSelector
   */
  readonly healthCheckIdSelector?: RecordSpecForProviderHealthCheckIdSelector;

  /**
   * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#latencyRoutingPolicy
   */
  readonly latencyRoutingPolicy?: RecordSpecForProviderLatencyRoutingPolicy[];

  /**
   * Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
   *
   * @schema RecordSpecForProvider#multivalueAnswerRoutingPolicy
   */
  readonly multivalueAnswerRoutingPolicy?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A string list of records.g., "first255characters\"\"morecharacters").
   *
   * @schema RecordSpecForProvider#records
   */
  readonly records?: string[];

  /**
   * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency Region is the region you'd like your resource to be created in.
   *
   * @schema RecordSpecForProvider#region
   */
  readonly region: string;

  /**
   * Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
   *
   * @schema RecordSpecForProvider#setIdentifier
   */
  readonly setIdentifier?: string;

  /**
   * The TTL of the record.
   *
   * @schema RecordSpecForProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordSpecForProvider#type
   */
  readonly type?: string;

  /**
   * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#weightedRoutingPolicy
   */
  readonly weightedRoutingPolicy?: RecordSpecForProviderWeightedRoutingPolicy[];

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordSpecForProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone to populate zoneId.
   *
   * @schema RecordSpecForProvider#zoneIdRef
   */
  readonly zoneIdRef?: RecordSpecForProviderZoneIdRef;

  /**
   * Selector for a Zone to populate zoneId.
   *
   * @schema RecordSpecForProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: RecordSpecForProviderZoneIdSelector;

}

/**
 * Converts an object of type 'RecordSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProvider(obj: RecordSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias?.map(y => toJson_RecordSpecForProviderAlias(y)),
    'allowOverwrite': obj.allowOverwrite,
    'cidrRoutingPolicy': obj.cidrRoutingPolicy?.map(y => toJson_RecordSpecForProviderCidrRoutingPolicy(y)),
    'failoverRoutingPolicy': obj.failoverRoutingPolicy?.map(y => toJson_RecordSpecForProviderFailoverRoutingPolicy(y)),
    'geolocationRoutingPolicy': obj.geolocationRoutingPolicy?.map(y => toJson_RecordSpecForProviderGeolocationRoutingPolicy(y)),
    'healthCheckId': obj.healthCheckId,
    'healthCheckIdRef': toJson_RecordSpecForProviderHealthCheckIdRef(obj.healthCheckIdRef),
    'healthCheckIdSelector': toJson_RecordSpecForProviderHealthCheckIdSelector(obj.healthCheckIdSelector),
    'latencyRoutingPolicy': obj.latencyRoutingPolicy?.map(y => toJson_RecordSpecForProviderLatencyRoutingPolicy(y)),
    'multivalueAnswerRoutingPolicy': obj.multivalueAnswerRoutingPolicy,
    'name': obj.name,
    'records': obj.records?.map(y => y),
    'region': obj.region,
    'setIdentifier': obj.setIdentifier,
    'ttl': obj.ttl,
    'type': obj.type,
    'weightedRoutingPolicy': obj.weightedRoutingPolicy?.map(y => toJson_RecordSpecForProviderWeightedRoutingPolicy(y)),
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_RecordSpecForProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_RecordSpecForProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RecordSpecManagementPolicy
 */
export enum RecordSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RecordSpecProviderConfigRef
 */
export interface RecordSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecProviderConfigRef#policy
   */
  readonly policy?: RecordSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecProviderConfigRef(obj: RecordSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RecordSpecProviderRef
 */
export interface RecordSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecProviderRef#policy
   */
  readonly policy?: RecordSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecProviderRef(obj: RecordSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RecordSpecPublishConnectionDetailsTo
 */
export interface RecordSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RecordSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RecordSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RecordSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RecordSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RecordSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsTo(obj: RecordSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RecordSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RecordSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RecordSpecWriteConnectionSecretToRef
 */
export interface RecordSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RecordSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RecordSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RecordSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecWriteConnectionSecretToRef(obj: RecordSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderAlias
 */
export interface RecordSpecForProviderAlias {
  /**
   * Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
   *
   * @schema RecordSpecForProviderAlias#evaluateTargetHealth
   */
  readonly evaluateTargetHealth: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordSpecForProviderAlias#name
   */
  readonly name: string;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordSpecForProviderAlias#zoneId
   */
  readonly zoneId: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderAlias(obj: RecordSpecForProviderAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'evaluateTargetHealth': obj.evaluateTargetHealth,
    'name': obj.name,
    'zoneId': obj.zoneId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderCidrRoutingPolicy
 */
export interface RecordSpecForProviderCidrRoutingPolicy {
  /**
   * The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
   *
   * @schema RecordSpecForProviderCidrRoutingPolicy#collectionId
   */
  readonly collectionId: string;

  /**
   * The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
   *
   * @schema RecordSpecForProviderCidrRoutingPolicy#locationName
   */
  readonly locationName: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderCidrRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderCidrRoutingPolicy(obj: RecordSpecForProviderCidrRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectionId': obj.collectionId,
    'locationName': obj.locationName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderFailoverRoutingPolicy
 */
export interface RecordSpecForProviderFailoverRoutingPolicy {
  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordSpecForProviderFailoverRoutingPolicy#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderFailoverRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderFailoverRoutingPolicy(obj: RecordSpecForProviderFailoverRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderGeolocationRoutingPolicy
 */
export interface RecordSpecForProviderGeolocationRoutingPolicy {
  /**
   * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
   *
   * @schema RecordSpecForProviderGeolocationRoutingPolicy#continent
   */
  readonly continent?: string;

  /**
   * A two-character country code or * to indicate a default resource record set.
   *
   * @schema RecordSpecForProviderGeolocationRoutingPolicy#country
   */
  readonly country?: string;

  /**
   * A subdivision code for a country.
   *
   * @schema RecordSpecForProviderGeolocationRoutingPolicy#subdivision
   */
  readonly subdivision?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderGeolocationRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderGeolocationRoutingPolicy(obj: RecordSpecForProviderGeolocationRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'continent': obj.continent,
    'country': obj.country,
    'subdivision': obj.subdivision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HealthCheck to populate healthCheckId.
 *
 * @schema RecordSpecForProviderHealthCheckIdRef
 */
export interface RecordSpecForProviderHealthCheckIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecForProviderHealthCheckIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecForProviderHealthCheckIdRef#policy
   */
  readonly policy?: RecordSpecForProviderHealthCheckIdRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdRef(obj: RecordSpecForProviderHealthCheckIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecForProviderHealthCheckIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HealthCheck to populate healthCheckId.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelector
 */
export interface RecordSpecForProviderHealthCheckIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelector#policy
   */
  readonly policy?: RecordSpecForProviderHealthCheckIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdSelector(obj: RecordSpecForProviderHealthCheckIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSpecForProviderHealthCheckIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderLatencyRoutingPolicy
 */
export interface RecordSpecForProviderLatencyRoutingPolicy {
  /**
   * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
   *
   * @schema RecordSpecForProviderLatencyRoutingPolicy#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderLatencyRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderLatencyRoutingPolicy(obj: RecordSpecForProviderLatencyRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderWeightedRoutingPolicy
 */
export interface RecordSpecForProviderWeightedRoutingPolicy {
  /**
   * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
   *
   * @schema RecordSpecForProviderWeightedRoutingPolicy#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RecordSpecForProviderWeightedRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderWeightedRoutingPolicy(obj: RecordSpecForProviderWeightedRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone to populate zoneId.
 *
 * @schema RecordSpecForProviderZoneIdRef
 */
export interface RecordSpecForProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecForProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecForProviderZoneIdRef#policy
   */
  readonly policy?: RecordSpecForProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdRef(obj: RecordSpecForProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecForProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone to populate zoneId.
 *
 * @schema RecordSpecForProviderZoneIdSelector
 */
export interface RecordSpecForProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RecordSpecForProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSpecForProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSpecForProviderZoneIdSelector#policy
   */
  readonly policy?: RecordSpecForProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdSelector(obj: RecordSpecForProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSpecForProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecProviderConfigRefPolicy
 */
export interface RecordSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RecordSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RecordSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecProviderConfigRefPolicy(obj: RecordSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecProviderRefPolicy
 */
export interface RecordSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RecordSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RecordSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecProviderRefPolicy(obj: RecordSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRef
 */
export interface RecordSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RecordSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsToConfigRef(obj: RecordSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RecordSpecPublishConnectionDetailsToMetadata
 */
export interface RecordSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RecordSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsToMetadata(obj: RecordSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecForProviderHealthCheckIdRefPolicy
 */
export interface RecordSpecForProviderHealthCheckIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderHealthCheckIdRefPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderHealthCheckIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSpecForProviderHealthCheckIdRefPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderHealthCheckIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdRefPolicy(obj: RecordSpecForProviderHealthCheckIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelectorPolicy
 */
export interface RecordSpecForProviderHealthCheckIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderHealthCheckIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderHealthCheckIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdSelectorPolicy(obj: RecordSpecForProviderHealthCheckIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecForProviderZoneIdRefPolicy
 */
export interface RecordSpecForProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSpecForProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdRefPolicy(obj: RecordSpecForProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSpecForProviderZoneIdSelectorPolicy
 */
export interface RecordSpecForProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSpecForProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdSelectorPolicy(obj: RecordSpecForProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSpecProviderConfigRefPolicyResolution
 */
export enum RecordSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSpecProviderConfigRefPolicyResolve
 */
export enum RecordSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSpecProviderRefPolicyResolution
 */
export enum RecordSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSpecProviderRefPolicyResolve
 */
export enum RecordSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RecordSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RecordSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RecordSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsToConfigRefPolicy(obj: RecordSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderHealthCheckIdRefPolicyResolution
 */
export enum RecordSpecForProviderHealthCheckIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSpecForProviderHealthCheckIdRefPolicyResolve
 */
export enum RecordSpecForProviderHealthCheckIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelectorPolicyResolution
 */
export enum RecordSpecForProviderHealthCheckIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelectorPolicyResolve
 */
export enum RecordSpecForProviderHealthCheckIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderZoneIdRefPolicyResolution
 */
export enum RecordSpecForProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSpecForProviderZoneIdRefPolicyResolve
 */
export enum RecordSpecForProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderZoneIdSelectorPolicyResolution
 */
export enum RecordSpecForProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSpecForProviderZoneIdSelectorPolicyResolve
 */
export enum RecordSpecForProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RecordSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RecordSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ResolverConfig is the Schema for the ResolverConfigs API. Provides a Route 53 Resolver config resource.
 *
 * @schema ResolverConfig
 */
export class ResolverConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResolverConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'ResolverConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ResolverConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResolverConfigProps): any {
    return {
      ...ResolverConfig.GVK,
      ...toJson_ResolverConfigProps(props),
    };
  }

  /**
   * Defines a "ResolverConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResolverConfigProps) {
    super(scope, id, {
      ...ResolverConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResolverConfig.GVK,
      ...toJson_ResolverConfigProps(resolved),
    };
  }
}

/**
 * ResolverConfig is the Schema for the ResolverConfigs API. Provides a Route 53 Resolver config resource.
 *
 * @schema ResolverConfig
 */
export interface ResolverConfigProps {
  /**
   * @schema ResolverConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResolverConfigSpec defines the desired state of ResolverConfig
   *
   * @schema ResolverConfig#spec
   */
  readonly spec: ResolverConfigSpec;

}

/**
 * Converts an object of type 'ResolverConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigProps(obj: ResolverConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResolverConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResolverConfigSpec defines the desired state of ResolverConfig
 *
 * @schema ResolverConfigSpec
 */
export interface ResolverConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResolverConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResolverConfigSpecDeletionPolicy;

  /**
   * @schema ResolverConfigSpec#forProvider
   */
  readonly forProvider: ResolverConfigSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResolverConfigSpec#managementPolicy
   */
  readonly managementPolicy?: ResolverConfigSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResolverConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResolverConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ResolverConfigSpec#providerRef
   */
  readonly providerRef?: ResolverConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResolverConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResolverConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResolverConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResolverConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResolverConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpec(obj: ResolverConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResolverConfigSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ResolverConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ResolverConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ResolverConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResolverConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResolverConfigSpecDeletionPolicy
 */
export enum ResolverConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResolverConfigSpecForProvider
 */
export interface ResolverConfigSpecForProvider {
  /**
   * Indicates whether or not the Resolver will create autodefined rules for reverse DNS lookups. Valid values: ENABLE, DISABLE.
   *
   * @schema ResolverConfigSpecForProvider#autodefinedReverseFlag
   */
  readonly autodefinedReverseFlag?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ResolverConfigSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the VPC that the configuration is for.
   *
   * @schema ResolverConfigSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a VPC in ec2 to populate resourceId.
   *
   * @schema ResolverConfigSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: ResolverConfigSpecForProviderResourceIdRef;

  /**
   * Selector for a VPC in ec2 to populate resourceId.
   *
   * @schema ResolverConfigSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: ResolverConfigSpecForProviderResourceIdSelector;

}

/**
 * Converts an object of type 'ResolverConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecForProvider(obj: ResolverConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autodefinedReverseFlag': obj.autodefinedReverseFlag,
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_ResolverConfigSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_ResolverConfigSpecForProviderResourceIdSelector(obj.resourceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResolverConfigSpecManagementPolicy
 */
export enum ResolverConfigSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResolverConfigSpecProviderConfigRef
 */
export interface ResolverConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverConfigSpecProviderConfigRef#policy
   */
  readonly policy?: ResolverConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecProviderConfigRef(obj: ResolverConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ResolverConfigSpecProviderRef
 */
export interface ResolverConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverConfigSpecProviderRef#policy
   */
  readonly policy?: ResolverConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecProviderRef(obj: ResolverConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsTo
 */
export interface ResolverConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResolverConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResolverConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResolverConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecPublishConnectionDetailsTo(obj: ResolverConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResolverConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResolverConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResolverConfigSpecWriteConnectionSecretToRef
 */
export interface ResolverConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResolverConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResolverConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResolverConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecWriteConnectionSecretToRef(obj: ResolverConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate resourceId.
 *
 * @schema ResolverConfigSpecForProviderResourceIdRef
 */
export interface ResolverConfigSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverConfigSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverConfigSpecForProviderResourceIdRef#policy
   */
  readonly policy?: ResolverConfigSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecForProviderResourceIdRef(obj: ResolverConfigSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverConfigSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate resourceId.
 *
 * @schema ResolverConfigSpecForProviderResourceIdSelector
 */
export interface ResolverConfigSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResolverConfigSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResolverConfigSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResolverConfigSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: ResolverConfigSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecForProviderResourceIdSelector(obj: ResolverConfigSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResolverConfigSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverConfigSpecProviderConfigRefPolicy
 */
export interface ResolverConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecProviderConfigRefPolicy(obj: ResolverConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverConfigSpecProviderRefPolicy
 */
export interface ResolverConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecProviderRefPolicy(obj: ResolverConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface ResolverConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecPublishConnectionDetailsToConfigRef(obj: ResolverConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsToMetadata
 */
export interface ResolverConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResolverConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecPublishConnectionDetailsToMetadata(obj: ResolverConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverConfigSpecForProviderResourceIdRefPolicy
 */
export interface ResolverConfigSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverConfigSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecForProviderResourceIdRefPolicy(obj: ResolverConfigSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResolverConfigSpecForProviderResourceIdSelectorPolicy
 */
export interface ResolverConfigSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverConfigSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecForProviderResourceIdSelectorPolicy(obj: ResolverConfigSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecProviderConfigRefPolicyResolution
 */
export enum ResolverConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverConfigSpecProviderConfigRefPolicyResolve
 */
export enum ResolverConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecProviderRefPolicyResolution
 */
export enum ResolverConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverConfigSpecProviderRefPolicyResolve
 */
export enum ResolverConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecForProviderResourceIdRefPolicyResolution
 */
export enum ResolverConfigSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverConfigSpecForProviderResourceIdRefPolicyResolve
 */
export enum ResolverConfigSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum ResolverConfigSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverConfigSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum ResolverConfigSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TrafficPolicy is the Schema for the TrafficPolicys API. Manages a Route53 Traffic Policy
 *
 * @schema TrafficPolicy
 */
export class TrafficPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TrafficPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'TrafficPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "TrafficPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TrafficPolicyProps): any {
    return {
      ...TrafficPolicy.GVK,
      ...toJson_TrafficPolicyProps(props),
    };
  }

  /**
   * Defines a "TrafficPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TrafficPolicyProps) {
    super(scope, id, {
      ...TrafficPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TrafficPolicy.GVK,
      ...toJson_TrafficPolicyProps(resolved),
    };
  }
}

/**
 * TrafficPolicy is the Schema for the TrafficPolicys API. Manages a Route53 Traffic Policy
 *
 * @schema TrafficPolicy
 */
export interface TrafficPolicyProps {
  /**
   * @schema TrafficPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TrafficPolicySpec defines the desired state of TrafficPolicy
   *
   * @schema TrafficPolicy#spec
   */
  readonly spec: TrafficPolicySpec;

}

/**
 * Converts an object of type 'TrafficPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyProps(obj: TrafficPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TrafficPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TrafficPolicySpec defines the desired state of TrafficPolicy
 *
 * @schema TrafficPolicySpec
 */
export interface TrafficPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TrafficPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: TrafficPolicySpecDeletionPolicy;

  /**
   * @schema TrafficPolicySpec#forProvider
   */
  readonly forProvider: TrafficPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TrafficPolicySpec#managementPolicy
   */
  readonly managementPolicy?: TrafficPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TrafficPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: TrafficPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TrafficPolicySpec#providerRef
   */
  readonly providerRef?: TrafficPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TrafficPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TrafficPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TrafficPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TrafficPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TrafficPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpec(obj: TrafficPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TrafficPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TrafficPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TrafficPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TrafficPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TrafficPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TrafficPolicySpecDeletionPolicy
 */
export enum TrafficPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TrafficPolicySpecForProvider
 */
export interface TrafficPolicySpecForProvider {
  /**
   * Comment for the traffic policy.
   *
   * @schema TrafficPolicySpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * Policy document. This is a JSON formatted string. For more information about building Route53 traffic policy documents, see the AWS Route53 Traffic Policy document format
   *
   * @schema TrafficPolicySpecForProvider#document
   */
  readonly document?: string;

  /**
   * Name of the traffic policy.
   *
   * @schema TrafficPolicySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TrafficPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'TrafficPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecForProvider(obj: TrafficPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'document': obj.document,
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TrafficPolicySpecManagementPolicy
 */
export enum TrafficPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TrafficPolicySpecProviderConfigRef
 */
export interface TrafficPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicySpecProviderConfigRef#policy
   */
  readonly policy?: TrafficPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecProviderConfigRef(obj: TrafficPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TrafficPolicySpecProviderRef
 */
export interface TrafficPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicySpecProviderRef#policy
   */
  readonly policy?: TrafficPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecProviderRef(obj: TrafficPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsTo
 */
export interface TrafficPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TrafficPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TrafficPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TrafficPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecPublishConnectionDetailsTo(obj: TrafficPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TrafficPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TrafficPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TrafficPolicySpecWriteConnectionSecretToRef
 */
export interface TrafficPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TrafficPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TrafficPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TrafficPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecWriteConnectionSecretToRef(obj: TrafficPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicySpecProviderConfigRefPolicy
 */
export interface TrafficPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrafficPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecProviderConfigRefPolicy(obj: TrafficPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicySpecProviderRefPolicy
 */
export interface TrafficPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrafficPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecProviderRefPolicy(obj: TrafficPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface TrafficPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecPublishConnectionDetailsToConfigRef(obj: TrafficPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsToMetadata
 */
export interface TrafficPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TrafficPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecPublishConnectionDetailsToMetadata(obj: TrafficPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicySpecProviderConfigRefPolicyResolution
 */
export enum TrafficPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrafficPolicySpecProviderConfigRefPolicyResolve
 */
export enum TrafficPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicySpecProviderRefPolicyResolution
 */
export enum TrafficPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrafficPolicySpecProviderRefPolicyResolve
 */
export enum TrafficPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TrafficPolicyInstance is the Schema for the TrafficPolicyInstances API. Provides a Route53 traffic policy instance resource.
 *
 * @schema TrafficPolicyInstance
 */
export class TrafficPolicyInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TrafficPolicyInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'TrafficPolicyInstance',
  }

  /**
   * Renders a Kubernetes manifest for "TrafficPolicyInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TrafficPolicyInstanceProps): any {
    return {
      ...TrafficPolicyInstance.GVK,
      ...toJson_TrafficPolicyInstanceProps(props),
    };
  }

  /**
   * Defines a "TrafficPolicyInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TrafficPolicyInstanceProps) {
    super(scope, id, {
      ...TrafficPolicyInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TrafficPolicyInstance.GVK,
      ...toJson_TrafficPolicyInstanceProps(resolved),
    };
  }
}

/**
 * TrafficPolicyInstance is the Schema for the TrafficPolicyInstances API. Provides a Route53 traffic policy instance resource.
 *
 * @schema TrafficPolicyInstance
 */
export interface TrafficPolicyInstanceProps {
  /**
   * @schema TrafficPolicyInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TrafficPolicyInstanceSpec defines the desired state of TrafficPolicyInstance
   *
   * @schema TrafficPolicyInstance#spec
   */
  readonly spec: TrafficPolicyInstanceSpec;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceProps(obj: TrafficPolicyInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TrafficPolicyInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TrafficPolicyInstanceSpec defines the desired state of TrafficPolicyInstance
 *
 * @schema TrafficPolicyInstanceSpec
 */
export interface TrafficPolicyInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TrafficPolicyInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: TrafficPolicyInstanceSpecDeletionPolicy;

  /**
   * @schema TrafficPolicyInstanceSpec#forProvider
   */
  readonly forProvider: TrafficPolicyInstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TrafficPolicyInstanceSpec#managementPolicy
   */
  readonly managementPolicy?: TrafficPolicyInstanceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TrafficPolicyInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: TrafficPolicyInstanceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TrafficPolicyInstanceSpec#providerRef
   */
  readonly providerRef?: TrafficPolicyInstanceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TrafficPolicyInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TrafficPolicyInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TrafficPolicyInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TrafficPolicyInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpec(obj: TrafficPolicyInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TrafficPolicyInstanceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TrafficPolicyInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TrafficPolicyInstanceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TrafficPolicyInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TrafficPolicyInstanceSpecDeletionPolicy
 */
export enum TrafficPolicyInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TrafficPolicyInstanceSpecForProvider
 */
export interface TrafficPolicyInstanceSpecForProvider {
  /**
   * ID of the hosted zone that you want Amazon Route 53 to create resource record sets in by using the configuration in a traffic policy.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#hostedZoneId
   */
  readonly hostedZoneId?: string;

  /**
   * Reference to a Zone to populate hostedZoneId.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#hostedZoneIdRef
   */
  readonly hostedZoneIdRef?: TrafficPolicyInstanceSpecForProviderHostedZoneIdRef;

  /**
   * Selector for a Zone to populate hostedZoneId.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#hostedZoneIdSelector
   */
  readonly hostedZoneIdSelector?: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector;

  /**
   * Domain name for which Amazon Route 53 responds to DNS queries by using the resource record sets that Route 53 creates for this traffic policy instance.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the traffic policy that you want to use to create resource record sets in the specified hosted zone.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#trafficPolicyId
   */
  readonly trafficPolicyId?: string;

  /**
   * Reference to a TrafficPolicy to populate trafficPolicyId.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#trafficPolicyIdRef
   */
  readonly trafficPolicyIdRef?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef;

  /**
   * Selector for a TrafficPolicy to populate trafficPolicyId.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#trafficPolicyIdSelector
   */
  readonly trafficPolicyIdSelector?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector;

  /**
   * Version of the traffic policy
   *
   * @schema TrafficPolicyInstanceSpecForProvider#trafficPolicyVersion
   */
  readonly trafficPolicyVersion?: number;

  /**
   * TTL that you want Amazon Route 53 to assign to all the resource record sets that it creates in the specified hosted zone.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#ttl
   */
  readonly ttl?: number;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProvider(obj: TrafficPolicyInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostedZoneId': obj.hostedZoneId,
    'hostedZoneIdRef': toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdRef(obj.hostedZoneIdRef),
    'hostedZoneIdSelector': toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector(obj.hostedZoneIdSelector),
    'name': obj.name,
    'region': obj.region,
    'trafficPolicyId': obj.trafficPolicyId,
    'trafficPolicyIdRef': toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef(obj.trafficPolicyIdRef),
    'trafficPolicyIdSelector': toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector(obj.trafficPolicyIdSelector),
    'trafficPolicyVersion': obj.trafficPolicyVersion,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TrafficPolicyInstanceSpecManagementPolicy
 */
export enum TrafficPolicyInstanceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TrafficPolicyInstanceSpecProviderConfigRef
 */
export interface TrafficPolicyInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecProviderConfigRef(obj: TrafficPolicyInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TrafficPolicyInstanceSpecProviderRef
 */
export interface TrafficPolicyInstanceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecProviderRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecProviderRef(obj: TrafficPolicyInstanceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsTo
 */
export interface TrafficPolicyInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsTo(obj: TrafficPolicyInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TrafficPolicyInstanceSpecWriteConnectionSecretToRef
 */
export interface TrafficPolicyInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TrafficPolicyInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TrafficPolicyInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecWriteConnectionSecretToRef(obj: TrafficPolicyInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone to populate hostedZoneId.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRef
 */
export interface TrafficPolicyInstanceSpecForProviderHostedZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderHostedZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdRef(obj: TrafficPolicyInstanceSpecForProviderHostedZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone to populate hostedZoneId.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector
 */
export interface TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector(obj: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a TrafficPolicy to populate trafficPolicyId.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef
 */
export interface TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef(obj: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a TrafficPolicy to populate trafficPolicyId.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector
 */
export interface TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector(obj: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecProviderConfigRefPolicy
 */
export interface TrafficPolicyInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecProviderConfigRefPolicy(obj: TrafficPolicyInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecProviderRefPolicy
 */
export interface TrafficPolicyInstanceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecProviderRefPolicy(obj: TrafficPolicyInstanceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef(obj: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata(obj: TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy
 */
export interface TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy(obj: TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy
 */
export interface TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy(obj: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy
 */
export interface TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy(obj: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy
 */
export interface TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy(obj: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecProviderConfigRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecProviderConfigRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecProviderRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecProviderRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolution
 */
export enum TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolve
 */
export enum TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolution
 */
export enum TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolve
 */
export enum TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCAssociationAuthorization is the Schema for the VPCAssociationAuthorizations API. Authorizes a VPC in a different account to be associated with a local Route53 Hosted Zone
 *
 * @schema VPCAssociationAuthorization
 */
export class VpcAssociationAuthorization extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCAssociationAuthorization"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'VPCAssociationAuthorization',
  }

  /**
   * Renders a Kubernetes manifest for "VPCAssociationAuthorization".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcAssociationAuthorizationProps): any {
    return {
      ...VpcAssociationAuthorization.GVK,
      ...toJson_VpcAssociationAuthorizationProps(props),
    };
  }

  /**
   * Defines a "VPCAssociationAuthorization" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcAssociationAuthorizationProps) {
    super(scope, id, {
      ...VpcAssociationAuthorization.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcAssociationAuthorization.GVK,
      ...toJson_VpcAssociationAuthorizationProps(resolved),
    };
  }
}

/**
 * VPCAssociationAuthorization is the Schema for the VPCAssociationAuthorizations API. Authorizes a VPC in a different account to be associated with a local Route53 Hosted Zone
 *
 * @schema VPCAssociationAuthorization
 */
export interface VpcAssociationAuthorizationProps {
  /**
   * @schema VPCAssociationAuthorization#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCAssociationAuthorizationSpec defines the desired state of VPCAssociationAuthorization
   *
   * @schema VPCAssociationAuthorization#spec
   */
  readonly spec: VpcAssociationAuthorizationSpec;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationProps(obj: VpcAssociationAuthorizationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcAssociationAuthorizationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCAssociationAuthorizationSpec defines the desired state of VPCAssociationAuthorization
 *
 * @schema VpcAssociationAuthorizationSpec
 */
export interface VpcAssociationAuthorizationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcAssociationAuthorizationSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcAssociationAuthorizationSpecDeletionPolicy;

  /**
   * @schema VpcAssociationAuthorizationSpec#forProvider
   */
  readonly forProvider: VpcAssociationAuthorizationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcAssociationAuthorizationSpec#managementPolicy
   */
  readonly managementPolicy?: VpcAssociationAuthorizationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcAssociationAuthorizationSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcAssociationAuthorizationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema VpcAssociationAuthorizationSpec#providerRef
   */
  readonly providerRef?: VpcAssociationAuthorizationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcAssociationAuthorizationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcAssociationAuthorizationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcAssociationAuthorizationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcAssociationAuthorizationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpec(obj: VpcAssociationAuthorizationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcAssociationAuthorizationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_VpcAssociationAuthorizationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_VpcAssociationAuthorizationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcAssociationAuthorizationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcAssociationAuthorizationSpecDeletionPolicy
 */
export enum VpcAssociationAuthorizationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VpcAssociationAuthorizationSpecForProvider
 */
export interface VpcAssociationAuthorizationSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The VPC to authorize for association with the private hosted zone.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: VpcAssociationAuthorizationSpecForProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: VpcAssociationAuthorizationSpecForProviderVpcIdSelector;

  /**
   * The VPC's region. Defaults to the region of the AWS provider.
   *
   * @default the region of the AWS provider.
   * @schema VpcAssociationAuthorizationSpecForProvider#vpcRegion
   */
  readonly vpcRegion?: string;

  /**
   * The ID of the private hosted zone that you want to authorize associating a VPC with.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone to populate zoneId.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#zoneIdRef
   */
  readonly zoneIdRef?: VpcAssociationAuthorizationSpecForProviderZoneIdRef;

  /**
   * Selector for a Zone to populate zoneId.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: VpcAssociationAuthorizationSpecForProviderZoneIdSelector;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProvider(obj: VpcAssociationAuthorizationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_VpcAssociationAuthorizationSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_VpcAssociationAuthorizationSpecForProviderVpcIdSelector(obj.vpcIdSelector),
    'vpcRegion': obj.vpcRegion,
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_VpcAssociationAuthorizationSpecForProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_VpcAssociationAuthorizationSpecForProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcAssociationAuthorizationSpecManagementPolicy
 */
export enum VpcAssociationAuthorizationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcAssociationAuthorizationSpecProviderConfigRef
 */
export interface VpcAssociationAuthorizationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecProviderConfigRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecProviderConfigRef(obj: VpcAssociationAuthorizationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema VpcAssociationAuthorizationSpecProviderRef
 */
export interface VpcAssociationAuthorizationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecProviderRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecProviderRef(obj: VpcAssociationAuthorizationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsTo
 */
export interface VpcAssociationAuthorizationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsTo(obj: VpcAssociationAuthorizationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcAssociationAuthorizationSpecWriteConnectionSecretToRef
 */
export interface VpcAssociationAuthorizationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcAssociationAuthorizationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcAssociationAuthorizationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecWriteConnectionSecretToRef(obj: VpcAssociationAuthorizationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRef
 */
export interface VpcAssociationAuthorizationSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderVpcIdRef(obj: VpcAssociationAuthorizationSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelector
 */
export interface VpcAssociationAuthorizationSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderVpcIdSelector(obj: VpcAssociationAuthorizationSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone to populate zoneId.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRef
 */
export interface VpcAssociationAuthorizationSpecForProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderZoneIdRef(obj: VpcAssociationAuthorizationSpecForProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone to populate zoneId.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelector
 */
export interface VpcAssociationAuthorizationSpecForProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelector#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderZoneIdSelector(obj: VpcAssociationAuthorizationSpecForProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecProviderConfigRefPolicy
 */
export interface VpcAssociationAuthorizationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecProviderConfigRefPolicy(obj: VpcAssociationAuthorizationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecProviderRefPolicy
 */
export interface VpcAssociationAuthorizationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecProviderRefPolicy(obj: VpcAssociationAuthorizationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef(obj: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata
 */
export interface VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata(obj: VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy
 */
export interface VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy(obj: VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy
 */
export interface VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy(obj: VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy
 */
export interface VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy(obj: VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy
 */
export interface VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy(obj: VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecProviderRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecProviderRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Zone is the Schema for the Zones API. Manages a Route53 Hosted Zone
 *
 * @schema Zone
 */
export class Zone extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Zone"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'Zone',
  }

  /**
   * Renders a Kubernetes manifest for "Zone".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ZoneProps): any {
    return {
      ...Zone.GVK,
      ...toJson_ZoneProps(props),
    };
  }

  /**
   * Defines a "Zone" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ZoneProps) {
    super(scope, id, {
      ...Zone.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Zone.GVK,
      ...toJson_ZoneProps(resolved),
    };
  }
}

/**
 * Zone is the Schema for the Zones API. Manages a Route53 Hosted Zone
 *
 * @schema Zone
 */
export interface ZoneProps {
  /**
   * @schema Zone#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ZoneSpec defines the desired state of Zone
   *
   * @schema Zone#spec
   */
  readonly spec: ZoneSpec;

}

/**
 * Converts an object of type 'ZoneProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneProps(obj: ZoneProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ZoneSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ZoneSpec defines the desired state of Zone
 *
 * @schema ZoneSpec
 */
export interface ZoneSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ZoneSpec#deletionPolicy
   */
  readonly deletionPolicy?: ZoneSpecDeletionPolicy;

  /**
   * @schema ZoneSpec#forProvider
   */
  readonly forProvider: ZoneSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ZoneSpec#managementPolicy
   */
  readonly managementPolicy?: ZoneSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ZoneSpec#providerConfigRef
   */
  readonly providerConfigRef?: ZoneSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ZoneSpec#providerRef
   */
  readonly providerRef?: ZoneSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ZoneSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ZoneSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ZoneSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ZoneSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ZoneSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpec(obj: ZoneSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ZoneSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ZoneSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ZoneSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ZoneSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ZoneSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ZoneSpecDeletionPolicy
 */
export enum ZoneSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ZoneSpecForProvider
 */
export interface ZoneSpecForProvider {
  /**
   * A comment for the hosted zone.
   *
   * @schema ZoneSpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * The ID of the reusable delegation set whose NS records you want to assign to the hosted zone. Conflicts with vpc as delegation sets can only be used for public zones.
   *
   * @schema ZoneSpecForProvider#delegationSetId
   */
  readonly delegationSetId?: string;

  /**
   * Reference to a DelegationSet to populate delegationSetId.
   *
   * @schema ZoneSpecForProvider#delegationSetIdRef
   */
  readonly delegationSetIdRef?: ZoneSpecForProviderDelegationSetIdRef;

  /**
   * Selector for a DelegationSet to populate delegationSetId.
   *
   * @schema ZoneSpecForProvider#delegationSetIdSelector
   */
  readonly delegationSetIdSelector?: ZoneSpecForProviderDelegationSetIdSelector;

  /**
   * @schema ZoneSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * This is the name of the hosted zone.
   *
   * @schema ZoneSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ZoneSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ZoneSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block(s) specifying VPC(s) to associate with a private hosted zone. Conflicts with the delegation_set_id argument in this resource and any aws_route53_zone_association resource specifying the same zone ID. Detailed below.
   *
   * @schema ZoneSpecForProvider#vpc
   */
  readonly vpc?: ZoneSpecForProviderVpc[];

}

/**
 * Converts an object of type 'ZoneSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProvider(obj: ZoneSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'delegationSetId': obj.delegationSetId,
    'delegationSetIdRef': toJson_ZoneSpecForProviderDelegationSetIdRef(obj.delegationSetIdRef),
    'delegationSetIdSelector': toJson_ZoneSpecForProviderDelegationSetIdSelector(obj.delegationSetIdSelector),
    'forceDestroy': obj.forceDestroy,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpc': obj.vpc?.map(y => toJson_ZoneSpecForProviderVpc(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ZoneSpecManagementPolicy
 */
export enum ZoneSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ZoneSpecProviderConfigRef
 */
export interface ZoneSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecProviderConfigRef#policy
   */
  readonly policy?: ZoneSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecProviderConfigRef(obj: ZoneSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ZoneSpecProviderRef
 */
export interface ZoneSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecProviderRef#policy
   */
  readonly policy?: ZoneSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecProviderRef(obj: ZoneSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ZoneSpecPublishConnectionDetailsTo
 */
export interface ZoneSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ZoneSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ZoneSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ZoneSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ZoneSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ZoneSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsTo(obj: ZoneSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ZoneSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ZoneSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ZoneSpecWriteConnectionSecretToRef
 */
export interface ZoneSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ZoneSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ZoneSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ZoneSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecWriteConnectionSecretToRef(obj: ZoneSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DelegationSet to populate delegationSetId.
 *
 * @schema ZoneSpecForProviderDelegationSetIdRef
 */
export interface ZoneSpecForProviderDelegationSetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecForProviderDelegationSetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecForProviderDelegationSetIdRef#policy
   */
  readonly policy?: ZoneSpecForProviderDelegationSetIdRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDelegationSetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDelegationSetIdRef(obj: ZoneSpecForProviderDelegationSetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecForProviderDelegationSetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DelegationSet to populate delegationSetId.
 *
 * @schema ZoneSpecForProviderDelegationSetIdSelector
 */
export interface ZoneSpecForProviderDelegationSetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ZoneSpecForProviderDelegationSetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneSpecForProviderDelegationSetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneSpecForProviderDelegationSetIdSelector#policy
   */
  readonly policy?: ZoneSpecForProviderDelegationSetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDelegationSetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDelegationSetIdSelector(obj: ZoneSpecForProviderDelegationSetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneSpecForProviderDelegationSetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ZoneSpecForProviderVpc
 */
export interface ZoneSpecForProviderVpc {
  /**
   * ID of the VPC to associate.
   *
   * @schema ZoneSpecForProviderVpc#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema ZoneSpecForProviderVpc#vpcIdRef
   */
  readonly vpcIdRef?: ZoneSpecForProviderVpcVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema ZoneSpecForProviderVpc#vpcIdSelector
   */
  readonly vpcIdSelector?: ZoneSpecForProviderVpcVpcIdSelector;

  /**
   * Region of the VPC to associate. Defaults to AWS provider region.
   *
   * @default AWS provider region.
   * @schema ZoneSpecForProviderVpc#vpcRegion
   */
  readonly vpcRegion?: string;

}

/**
 * Converts an object of type 'ZoneSpecForProviderVpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderVpc(obj: ZoneSpecForProviderVpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_ZoneSpecForProviderVpcVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_ZoneSpecForProviderVpcVpcIdSelector(obj.vpcIdSelector),
    'vpcRegion': obj.vpcRegion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecProviderConfigRefPolicy
 */
export interface ZoneSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecProviderConfigRefPolicy(obj: ZoneSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecProviderRefPolicy
 */
export interface ZoneSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecProviderRefPolicy(obj: ZoneSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRef
 */
export interface ZoneSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ZoneSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsToConfigRef(obj: ZoneSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ZoneSpecPublishConnectionDetailsToMetadata
 */
export interface ZoneSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ZoneSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ZoneSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ZoneSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsToMetadata(obj: ZoneSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecForProviderDelegationSetIdRefPolicy
 */
export interface ZoneSpecForProviderDelegationSetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecForProviderDelegationSetIdRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecForProviderDelegationSetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecForProviderDelegationSetIdRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecForProviderDelegationSetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDelegationSetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDelegationSetIdRefPolicy(obj: ZoneSpecForProviderDelegationSetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneSpecForProviderDelegationSetIdSelectorPolicy
 */
export interface ZoneSpecForProviderDelegationSetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecForProviderDelegationSetIdSelectorPolicy#resolution
   */
  readonly resolution?: ZoneSpecForProviderDelegationSetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecForProviderDelegationSetIdSelectorPolicy#resolve
   */
  readonly resolve?: ZoneSpecForProviderDelegationSetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDelegationSetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDelegationSetIdSelectorPolicy(obj: ZoneSpecForProviderDelegationSetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema ZoneSpecForProviderVpcVpcIdRef
 */
export interface ZoneSpecForProviderVpcVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecForProviderVpcVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecForProviderVpcVpcIdRef#policy
   */
  readonly policy?: ZoneSpecForProviderVpcVpcIdRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecForProviderVpcVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderVpcVpcIdRef(obj: ZoneSpecForProviderVpcVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecForProviderVpcVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema ZoneSpecForProviderVpcVpcIdSelector
 */
export interface ZoneSpecForProviderVpcVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ZoneSpecForProviderVpcVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneSpecForProviderVpcVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneSpecForProviderVpcVpcIdSelector#policy
   */
  readonly policy?: ZoneSpecForProviderVpcVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneSpecForProviderVpcVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderVpcVpcIdSelector(obj: ZoneSpecForProviderVpcVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneSpecForProviderVpcVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecProviderConfigRefPolicyResolution
 */
export enum ZoneSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecProviderConfigRefPolicyResolve
 */
export enum ZoneSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecProviderRefPolicyResolution
 */
export enum ZoneSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecProviderRefPolicyResolve
 */
export enum ZoneSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ZoneSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsToConfigRefPolicy(obj: ZoneSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecForProviderDelegationSetIdRefPolicyResolution
 */
export enum ZoneSpecForProviderDelegationSetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecForProviderDelegationSetIdRefPolicyResolve
 */
export enum ZoneSpecForProviderDelegationSetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecForProviderDelegationSetIdSelectorPolicyResolution
 */
export enum ZoneSpecForProviderDelegationSetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecForProviderDelegationSetIdSelectorPolicyResolve
 */
export enum ZoneSpecForProviderDelegationSetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecForProviderVpcVpcIdRefPolicy
 */
export interface ZoneSpecForProviderVpcVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecForProviderVpcVpcIdRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecForProviderVpcVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecForProviderVpcVpcIdRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecForProviderVpcVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecForProviderVpcVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderVpcVpcIdRefPolicy(obj: ZoneSpecForProviderVpcVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneSpecForProviderVpcVpcIdSelectorPolicy
 */
export interface ZoneSpecForProviderVpcVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecForProviderVpcVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: ZoneSpecForProviderVpcVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ZoneSpecForProviderVpcVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: ZoneSpecForProviderVpcVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecForProviderVpcVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderVpcVpcIdSelectorPolicy(obj: ZoneSpecForProviderVpcVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecForProviderVpcVpcIdRefPolicyResolution
 */
export enum ZoneSpecForProviderVpcVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecForProviderVpcVpcIdRefPolicyResolve
 */
export enum ZoneSpecForProviderVpcVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecForProviderVpcVpcIdSelectorPolicyResolution
 */
export enum ZoneSpecForProviderVpcVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ZoneSpecForProviderVpcVpcIdSelectorPolicyResolve
 */
export enum ZoneSpecForProviderVpcVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

