// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DomainMapping is the Schema for the DomainMappings API. Resource to hold the state and status of a user's domain mapping.
 *
 * @schema DomainMapping
 */
export class DomainMapping extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainMapping"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudrun.gcp.upbound.io/v1beta1',
    kind: 'DomainMapping',
  }

  /**
   * Renders a Kubernetes manifest for "DomainMapping".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainMappingProps): any {
    return {
      ...DomainMapping.GVK,
      ...toJson_DomainMappingProps(props),
    };
  }

  /**
   * Defines a "DomainMapping" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainMappingProps) {
    super(scope, id, {
      ...DomainMapping.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainMapping.GVK,
      ...toJson_DomainMappingProps(resolved),
    };
  }
}

/**
 * DomainMapping is the Schema for the DomainMappings API. Resource to hold the state and status of a user's domain mapping.
 *
 * @schema DomainMapping
 */
export interface DomainMappingProps {
  /**
   * @schema DomainMapping#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainMappingSpec defines the desired state of DomainMapping
   *
   * @schema DomainMapping#spec
   */
  readonly spec: DomainMappingSpec;

}

/**
 * Converts an object of type 'DomainMappingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingProps(obj: DomainMappingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainMappingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainMappingSpec defines the desired state of DomainMapping
 *
 * @schema DomainMappingSpec
 */
export interface DomainMappingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainMappingSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainMappingSpecDeletionPolicy;

  /**
   * @schema DomainMappingSpec#forProvider
   */
  readonly forProvider: DomainMappingSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainMappingSpec#managementPolicy
   */
  readonly managementPolicy?: DomainMappingSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainMappingSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainMappingSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DomainMappingSpec#providerRef
   */
  readonly providerRef?: DomainMappingSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainMappingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainMappingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainMappingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainMappingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainMappingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpec(obj: DomainMappingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainMappingSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DomainMappingSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DomainMappingSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DomainMappingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainMappingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainMappingSpecDeletionPolicy
 */
export enum DomainMappingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainMappingSpecForProvider
 */
export interface DomainMappingSpecForProvider {
  /**
   * The location of the cloud run instance. eg us-central1
   *
   * @schema DomainMappingSpecForProvider#location
   */
  readonly location?: string;

  /**
   * Metadata associated with this DomainMapping. Structure is documented below.
   *
   * @schema DomainMappingSpecForProvider#metadata
   */
  readonly metadata?: DomainMappingSpecForProviderMetadata[];

  /**
   * Name should be a verified domain
   *
   * @schema DomainMappingSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DomainMappingSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The spec for this DomainMapping. Structure is documented below.
   *
   * @schema DomainMappingSpecForProvider#spec
   */
  readonly spec?: DomainMappingSpecForProviderSpec[];

}

/**
 * Converts an object of type 'DomainMappingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProvider(obj: DomainMappingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'location': obj.location,
    'metadata': obj.metadata?.map(y => toJson_DomainMappingSpecForProviderMetadata(y)),
    'name': obj.name,
    'project': obj.project,
    'spec': obj.spec?.map(y => toJson_DomainMappingSpecForProviderSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainMappingSpecManagementPolicy
 */
export enum DomainMappingSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainMappingSpecProviderConfigRef
 */
export interface DomainMappingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainMappingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainMappingSpecProviderConfigRef#policy
   */
  readonly policy?: DomainMappingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainMappingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecProviderConfigRef(obj: DomainMappingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainMappingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DomainMappingSpecProviderRef
 */
export interface DomainMappingSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainMappingSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainMappingSpecProviderRef#policy
   */
  readonly policy?: DomainMappingSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DomainMappingSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecProviderRef(obj: DomainMappingSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainMappingSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainMappingSpecPublishConnectionDetailsTo
 */
export interface DomainMappingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainMappingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainMappingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainMappingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainMappingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainMappingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainMappingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecPublishConnectionDetailsTo(obj: DomainMappingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainMappingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainMappingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainMappingSpecWriteConnectionSecretToRef
 */
export interface DomainMappingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainMappingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainMappingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainMappingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecWriteConnectionSecretToRef(obj: DomainMappingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainMappingSpecForProviderMetadata
 */
export interface DomainMappingSpecForProviderMetadata {
  /**
   * Annotations is a key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations Note: The Cloud Run API may add additional annotations that were not provided in your config.ignore_changes rule to the metadata.0.annotations field.
   *
   * @schema DomainMappingSpecForProviderMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and routes. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema DomainMappingSpecForProviderMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * In Cloud Run the namespace must be equal to either the project ID or project number.
   *
   * @schema DomainMappingSpecForProviderMetadata#namespace
   */
  readonly namespace?: string;

  /**
   * Reference to a Project in cloudplatform to populate namespace.
   *
   * @schema DomainMappingSpecForProviderMetadata#namespaceRef
   */
  readonly namespaceRef?: DomainMappingSpecForProviderMetadataNamespaceRef;

  /**
   * Selector for a Project in cloudplatform to populate namespace.
   *
   * @schema DomainMappingSpecForProviderMetadata#namespaceSelector
   */
  readonly namespaceSelector?: DomainMappingSpecForProviderMetadataNamespaceSelector;

}

/**
 * Converts an object of type 'DomainMappingSpecForProviderMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProviderMetadata(obj: DomainMappingSpecForProviderMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespace': obj.namespace,
    'namespaceRef': toJson_DomainMappingSpecForProviderMetadataNamespaceRef(obj.namespaceRef),
    'namespaceSelector': toJson_DomainMappingSpecForProviderMetadataNamespaceSelector(obj.namespaceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainMappingSpecForProviderSpec
 */
export interface DomainMappingSpecForProviderSpec {
  /**
   * The mode of the certificate. Default value is AUTOMATIC. Possible values are: NONE, AUTOMATIC.
   *
   * @schema DomainMappingSpecForProviderSpec#certificateMode
   */
  readonly certificateMode?: string;

  /**
   * If set, the mapping will override any mapping set before this spec was set. It is recommended that the user leaves this empty to receive an error warning about a potential conflict and only set it once the respective UI has given such a warning.
   *
   * @schema DomainMappingSpecForProviderSpec#forceOverride
   */
  readonly forceOverride?: boolean;

  /**
   * The name of the Cloud Run Service that this DomainMapping applies to. The route must exist.
   *
   * @schema DomainMappingSpecForProviderSpec#routeName
   */
  readonly routeName?: string;

  /**
   * Reference to a Service to populate routeName.
   *
   * @schema DomainMappingSpecForProviderSpec#routeNameRef
   */
  readonly routeNameRef?: DomainMappingSpecForProviderSpecRouteNameRef;

  /**
   * Selector for a Service to populate routeName.
   *
   * @schema DomainMappingSpecForProviderSpec#routeNameSelector
   */
  readonly routeNameSelector?: DomainMappingSpecForProviderSpecRouteNameSelector;

}

/**
 * Converts an object of type 'DomainMappingSpecForProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProviderSpec(obj: DomainMappingSpecForProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateMode': obj.certificateMode,
    'forceOverride': obj.forceOverride,
    'routeName': obj.routeName,
    'routeNameRef': toJson_DomainMappingSpecForProviderSpecRouteNameRef(obj.routeNameRef),
    'routeNameSelector': toJson_DomainMappingSpecForProviderSpecRouteNameSelector(obj.routeNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainMappingSpecProviderConfigRefPolicy
 */
export interface DomainMappingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMappingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainMappingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMappingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainMappingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainMappingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecProviderConfigRefPolicy(obj: DomainMappingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainMappingSpecProviderRefPolicy
 */
export interface DomainMappingSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMappingSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DomainMappingSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMappingSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DomainMappingSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainMappingSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecProviderRefPolicy(obj: DomainMappingSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainMappingSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainMappingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainMappingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainMappingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainMappingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainMappingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecPublishConnectionDetailsToConfigRef(obj: DomainMappingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainMappingSpecPublishConnectionDetailsToMetadata
 */
export interface DomainMappingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainMappingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainMappingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainMappingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainMappingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecPublishConnectionDetailsToMetadata(obj: DomainMappingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project in cloudplatform to populate namespace.
 *
 * @schema DomainMappingSpecForProviderMetadataNamespaceRef
 */
export interface DomainMappingSpecForProviderMetadataNamespaceRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainMappingSpecForProviderMetadataNamespaceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainMappingSpecForProviderMetadataNamespaceRef#policy
   */
  readonly policy?: DomainMappingSpecForProviderMetadataNamespaceRefPolicy;

}

/**
 * Converts an object of type 'DomainMappingSpecForProviderMetadataNamespaceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProviderMetadataNamespaceRef(obj: DomainMappingSpecForProviderMetadataNamespaceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainMappingSpecForProviderMetadataNamespaceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project in cloudplatform to populate namespace.
 *
 * @schema DomainMappingSpecForProviderMetadataNamespaceSelector
 */
export interface DomainMappingSpecForProviderMetadataNamespaceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainMappingSpecForProviderMetadataNamespaceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainMappingSpecForProviderMetadataNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainMappingSpecForProviderMetadataNamespaceSelector#policy
   */
  readonly policy?: DomainMappingSpecForProviderMetadataNamespaceSelectorPolicy;

}

/**
 * Converts an object of type 'DomainMappingSpecForProviderMetadataNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProviderMetadataNamespaceSelector(obj: DomainMappingSpecForProviderMetadataNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainMappingSpecForProviderMetadataNamespaceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Service to populate routeName.
 *
 * @schema DomainMappingSpecForProviderSpecRouteNameRef
 */
export interface DomainMappingSpecForProviderSpecRouteNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainMappingSpecForProviderSpecRouteNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainMappingSpecForProviderSpecRouteNameRef#policy
   */
  readonly policy?: DomainMappingSpecForProviderSpecRouteNameRefPolicy;

}

/**
 * Converts an object of type 'DomainMappingSpecForProviderSpecRouteNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProviderSpecRouteNameRef(obj: DomainMappingSpecForProviderSpecRouteNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainMappingSpecForProviderSpecRouteNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Service to populate routeName.
 *
 * @schema DomainMappingSpecForProviderSpecRouteNameSelector
 */
export interface DomainMappingSpecForProviderSpecRouteNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainMappingSpecForProviderSpecRouteNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainMappingSpecForProviderSpecRouteNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainMappingSpecForProviderSpecRouteNameSelector#policy
   */
  readonly policy?: DomainMappingSpecForProviderSpecRouteNameSelectorPolicy;

}

/**
 * Converts an object of type 'DomainMappingSpecForProviderSpecRouteNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProviderSpecRouteNameSelector(obj: DomainMappingSpecForProviderSpecRouteNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainMappingSpecForProviderSpecRouteNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMappingSpecProviderConfigRefPolicyResolution
 */
export enum DomainMappingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMappingSpecProviderConfigRefPolicyResolve
 */
export enum DomainMappingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMappingSpecProviderRefPolicyResolution
 */
export enum DomainMappingSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMappingSpecProviderRefPolicyResolve
 */
export enum DomainMappingSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainMappingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainMappingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainMappingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainMappingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainMappingSpecForProviderMetadataNamespaceRefPolicy
 */
export interface DomainMappingSpecForProviderMetadataNamespaceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMappingSpecForProviderMetadataNamespaceRefPolicy#resolution
   */
  readonly resolution?: DomainMappingSpecForProviderMetadataNamespaceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMappingSpecForProviderMetadataNamespaceRefPolicy#resolve
   */
  readonly resolve?: DomainMappingSpecForProviderMetadataNamespaceRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainMappingSpecForProviderMetadataNamespaceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProviderMetadataNamespaceRefPolicy(obj: DomainMappingSpecForProviderMetadataNamespaceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainMappingSpecForProviderMetadataNamespaceSelectorPolicy
 */
export interface DomainMappingSpecForProviderMetadataNamespaceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMappingSpecForProviderMetadataNamespaceSelectorPolicy#resolution
   */
  readonly resolution?: DomainMappingSpecForProviderMetadataNamespaceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMappingSpecForProviderMetadataNamespaceSelectorPolicy#resolve
   */
  readonly resolve?: DomainMappingSpecForProviderMetadataNamespaceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainMappingSpecForProviderMetadataNamespaceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProviderMetadataNamespaceSelectorPolicy(obj: DomainMappingSpecForProviderMetadataNamespaceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainMappingSpecForProviderSpecRouteNameRefPolicy
 */
export interface DomainMappingSpecForProviderSpecRouteNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMappingSpecForProviderSpecRouteNameRefPolicy#resolution
   */
  readonly resolution?: DomainMappingSpecForProviderSpecRouteNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMappingSpecForProviderSpecRouteNameRefPolicy#resolve
   */
  readonly resolve?: DomainMappingSpecForProviderSpecRouteNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainMappingSpecForProviderSpecRouteNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProviderSpecRouteNameRefPolicy(obj: DomainMappingSpecForProviderSpecRouteNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainMappingSpecForProviderSpecRouteNameSelectorPolicy
 */
export interface DomainMappingSpecForProviderSpecRouteNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainMappingSpecForProviderSpecRouteNameSelectorPolicy#resolution
   */
  readonly resolution?: DomainMappingSpecForProviderSpecRouteNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainMappingSpecForProviderSpecRouteNameSelectorPolicy#resolve
   */
  readonly resolve?: DomainMappingSpecForProviderSpecRouteNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainMappingSpecForProviderSpecRouteNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainMappingSpecForProviderSpecRouteNameSelectorPolicy(obj: DomainMappingSpecForProviderSpecRouteNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMappingSpecForProviderMetadataNamespaceRefPolicyResolution
 */
export enum DomainMappingSpecForProviderMetadataNamespaceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMappingSpecForProviderMetadataNamespaceRefPolicyResolve
 */
export enum DomainMappingSpecForProviderMetadataNamespaceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMappingSpecForProviderMetadataNamespaceSelectorPolicyResolution
 */
export enum DomainMappingSpecForProviderMetadataNamespaceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMappingSpecForProviderMetadataNamespaceSelectorPolicyResolve
 */
export enum DomainMappingSpecForProviderMetadataNamespaceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMappingSpecForProviderSpecRouteNameRefPolicyResolution
 */
export enum DomainMappingSpecForProviderSpecRouteNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMappingSpecForProviderSpecRouteNameRefPolicyResolve
 */
export enum DomainMappingSpecForProviderSpecRouteNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainMappingSpecForProviderSpecRouteNameSelectorPolicyResolution
 */
export enum DomainMappingSpecForProviderSpecRouteNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainMappingSpecForProviderSpecRouteNameSelectorPolicyResolve
 */
export enum DomainMappingSpecForProviderSpecRouteNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Service is the Schema for the Services API. A Cloud Run service has a unique endpoint and autoscales containers.
 *
 * @schema Service
 */
export class Service extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Service"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudrun.gcp.upbound.io/v1beta1',
    kind: 'Service',
  }

  /**
   * Renders a Kubernetes manifest for "Service".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceProps): any {
    return {
      ...Service.GVK,
      ...toJson_ServiceProps(props),
    };
  }

  /**
   * Defines a "Service" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceProps) {
    super(scope, id, {
      ...Service.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Service.GVK,
      ...toJson_ServiceProps(resolved),
    };
  }
}

/**
 * Service is the Schema for the Services API. A Cloud Run service has a unique endpoint and autoscales containers.
 *
 * @schema Service
 */
export interface ServiceProps {
  /**
   * @schema Service#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceSpec defines the desired state of Service
   *
   * @schema Service#spec
   */
  readonly spec: ServiceSpec;

}

/**
 * Converts an object of type 'ServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceProps(obj: ServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSpec defines the desired state of Service
 *
 * @schema ServiceSpec
 */
export interface ServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceSpecDeletionPolicy;

  /**
   * @schema ServiceSpec#forProvider
   */
  readonly forProvider: ServiceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceSpec#managementPolicy
   */
  readonly managementPolicy?: ServiceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ServiceSpec#providerRef
   */
  readonly providerRef?: ServiceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpec(obj: ServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ServiceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ServiceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceSpecDeletionPolicy
 */
export enum ServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceSpecForProvider
 */
export interface ServiceSpecForProvider {
  /**
   * If set to true, the revision name (template.metadata.name) will be omitted and autogenerated by Cloud Run. This cannot be set to true while template.metadata.name is also set. (For legacy support, if template.metadata.name is unset in state while this field is set to false, the revision name will still autogenerate.)
   *
   * @schema ServiceSpecForProvider#autogenerateRevisionName
   */
  readonly autogenerateRevisionName?: boolean;

  /**
   * The location of the cloud run instance. eg us-central1
   *
   * @schema ServiceSpecForProvider#location
   */
  readonly location: string;

  /**
   * Optional metadata for this Revision, including labels and annotations. Name will be generated by the Configuration. To set minimum instances for this revision, use the "autoscaling.knative.dev/minScale" annotation key. To set maximum instances for this revision, use the "autoscaling.knative.dev/maxScale" annotation key. To set Cloud SQL connections for the revision, use the "run.googleapis.com/cloudsql-instances" annotation key. Structure is documented below.
   *
   * @schema ServiceSpecForProvider#metadata
   */
  readonly metadata?: ServiceSpecForProviderMetadata[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema ServiceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * template holds the latest specification for the Revision to be stamped out. The template references the container image, and may also include labels and annotations that should be attached to the Revision. To correlate a Revision, and/or to force a Revision to be created when the spec doesn't otherwise change, a nonce label may be provided in the template metadata. For more details, see: https://github.com/knative/serving/blob/main/docs/client-conventions.md#associate-modifications-with-revisions Cloud Run does not currently support referencing a build that is responsible for materializing the container image from source. Structure is documented below.
   *
   * @schema ServiceSpecForProvider#template
   */
  readonly template?: ServiceSpecForProviderTemplate[];

  /**
   * Traffic specifies how to distribute traffic over a collection of Knative Revisions and Configurations Structure is documented below.
   *
   * @schema ServiceSpecForProvider#traffic
   */
  readonly traffic?: ServiceSpecForProviderTraffic[];

}

/**
 * Converts an object of type 'ServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProvider(obj: ServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autogenerateRevisionName': obj.autogenerateRevisionName,
    'location': obj.location,
    'metadata': obj.metadata?.map(y => toJson_ServiceSpecForProviderMetadata(y)),
    'project': obj.project,
    'template': obj.template?.map(y => toJson_ServiceSpecForProviderTemplate(y)),
    'traffic': obj.traffic?.map(y => toJson_ServiceSpecForProviderTraffic(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceSpecManagementPolicy
 */
export enum ServiceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceSpecProviderConfigRef
 */
export interface ServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRef(obj: ServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ServiceSpecProviderRef
 */
export interface ServiceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecProviderRef#policy
   */
  readonly policy?: ServiceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderRef(obj: ServiceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceSpecPublishConnectionDetailsTo
 */
export interface ServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsTo(obj: ServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceSpecWriteConnectionSecretToRef
 */
export interface ServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecWriteConnectionSecretToRef(obj: ServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderMetadata
 */
export interface ServiceSpecForProviderMetadata {
  /**
   * Annotations is a key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations Note: The Cloud Run API may add additional annotations that were not provided in your config.ignore_changes rule to the metadata.0.annotations field. Annotations with run.googleapis.com/ and autoscaling.knative.dev are restricted. Use the following annotation keys to configure features on a Revision template:
   *
   * @schema ServiceSpecForProviderMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
   *
   * @schema ServiceSpecForProviderMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * In Cloud Run the namespace must be equal to either the project ID or project number. It will default to the resource's project.
   *
   * @schema ServiceSpecForProviderMetadata#namespace
   */
  readonly namespace?: string;

  /**
   * Reference to a Project in cloudplatform to populate namespace.
   *
   * @schema ServiceSpecForProviderMetadata#namespaceRef
   */
  readonly namespaceRef?: ServiceSpecForProviderMetadataNamespaceRef;

  /**
   * Selector for a Project in cloudplatform to populate namespace.
   *
   * @schema ServiceSpecForProviderMetadata#namespaceSelector
   */
  readonly namespaceSelector?: ServiceSpecForProviderMetadataNamespaceSelector;

}

/**
 * Converts an object of type 'ServiceSpecForProviderMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderMetadata(obj: ServiceSpecForProviderMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'namespace': obj.namespace,
    'namespaceRef': toJson_ServiceSpecForProviderMetadataNamespaceRef(obj.namespaceRef),
    'namespaceSelector': toJson_ServiceSpecForProviderMetadataNamespaceSelector(obj.namespaceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplate
 */
export interface ServiceSpecForProviderTemplate {
  /**
   * Optional metadata for this Revision, including labels and annotations. Name will be generated by the Configuration. To set minimum instances for this revision, use the "autoscaling.knative.dev/minScale" annotation key. To set maximum instances for this revision, use the "autoscaling.knative.dev/maxScale" annotation key. To set Cloud SQL connections for the revision, use the "run.googleapis.com/cloudsql-instances" annotation key. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplate#metadata
   */
  readonly metadata?: ServiceSpecForProviderTemplateMetadata[];

  /**
   * RevisionSpec holds the desired state of the Revision (from the client). Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplate#spec
   */
  readonly spec?: ServiceSpecForProviderTemplateSpec[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplate(obj: ServiceSpecForProviderTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata?.map(y => toJson_ServiceSpecForProviderTemplateMetadata(y)),
    'spec': obj.spec?.map(y => toJson_ServiceSpecForProviderTemplateSpec(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTraffic
 */
export interface ServiceSpecForProviderTraffic {
  /**
   * LatestRevision may be optionally provided to indicate that the latest ready Revision of the Configuration should be used for this traffic target. When provided LatestRevision must be true if RevisionName is empty; it must be false when RevisionName is non-empty.
   *
   * @schema ServiceSpecForProviderTraffic#latestRevision
   */
  readonly latestRevision?: boolean;

  /**
   * Percent specifies percent of the traffic to this Revision or Configuration.
   *
   * @schema ServiceSpecForProviderTraffic#percent
   */
  readonly percent: number;

  /**
   * RevisionName of a specific revision to which to send this portion of traffic.
   *
   * @schema ServiceSpecForProviderTraffic#revisionName
   */
  readonly revisionName?: string;

  /**
   * Tag is optionally used to expose a dedicated url for referencing this target exclusively.
   *
   * @schema ServiceSpecForProviderTraffic#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTraffic' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTraffic(obj: ServiceSpecForProviderTraffic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'latestRevision': obj.latestRevision,
    'percent': obj.percent,
    'revisionName': obj.revisionName,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecProviderConfigRefPolicy
 */
export interface ServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRefPolicy(obj: ServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecProviderRefPolicy
 */
export interface ServiceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderRefPolicy(obj: ServiceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj: ServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj: ServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project in cloudplatform to populate namespace.
 *
 * @schema ServiceSpecForProviderMetadataNamespaceRef
 */
export interface ServiceSpecForProviderMetadataNamespaceRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderMetadataNamespaceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderMetadataNamespaceRef#policy
   */
  readonly policy?: ServiceSpecForProviderMetadataNamespaceRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderMetadataNamespaceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderMetadataNamespaceRef(obj: ServiceSpecForProviderMetadataNamespaceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderMetadataNamespaceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project in cloudplatform to populate namespace.
 *
 * @schema ServiceSpecForProviderMetadataNamespaceSelector
 */
export interface ServiceSpecForProviderMetadataNamespaceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderMetadataNamespaceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderMetadataNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderMetadataNamespaceSelector#policy
   */
  readonly policy?: ServiceSpecForProviderMetadataNamespaceSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderMetadataNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderMetadataNamespaceSelector(obj: ServiceSpecForProviderMetadataNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderMetadataNamespaceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateMetadata
 */
export interface ServiceSpecForProviderTemplateMetadata {
  /**
   * Annotations is a key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations Note: The Cloud Run API may add additional annotations that were not provided in your config.ignore_changes rule to the metadata.0.annotations field. Annotations with run.googleapis.com/ and autoscaling.knative.dev are restricted. Use the following annotation keys to configure features on a Revision template:
   *
   * @schema ServiceSpecForProviderTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
   *
   * @schema ServiceSpecForProviderTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Volume's name.
   *
   * @schema ServiceSpecForProviderTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * In Cloud Run the namespace must be equal to either the project ID or project number. It will default to the resource's project.
   *
   * @schema ServiceSpecForProviderTemplateMetadata#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateMetadata(obj: ServiceSpecForProviderTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpec
 */
export interface ServiceSpecForProviderTemplateSpec {
  /**
   * ContainerConcurrency specifies the maximum allowed in-flight (concurrent) requests per container of the Revision. Values are:
   *
   * @schema ServiceSpecForProviderTemplateSpec#containerConcurrency
   */
  readonly containerConcurrency?: number;

  /**
   * Container defines the unit of execution for this Revision. In the context of a Revision, we disallow a number of the fields of this Container, including: name, ports, and volumeMounts. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpec#containers
   */
  readonly containers?: ServiceSpecForProviderTemplateSpecContainers[];

  /**
   * Email address of the IAM service account associated with the revision of the service. The service account represents the identity of the running revision, and determines what permissions the revision has. If not provided, the revision will use the project's default service account.
   *
   * @schema ServiceSpecForProviderTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds.
   *
   * @default 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds.
   * @schema ServiceSpecForProviderTemplateSpec#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * Volume represents a named volume in a container. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpec#volumes
   */
  readonly volumes?: ServiceSpecForProviderTemplateSpecVolumes[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpec(obj: ServiceSpecForProviderTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerConcurrency': obj.containerConcurrency,
    'containers': obj.containers?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainers(y)),
    'serviceAccountName': obj.serviceAccountName,
    'timeoutSeconds': obj.timeoutSeconds,
    'volumes': obj.volumes?.map(y => toJson_ServiceSpecForProviderTemplateSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolution
 */
export enum ServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolve
 */
export enum ServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecProviderRefPolicyResolution
 */
export enum ServiceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecProviderRefPolicyResolve
 */
export enum ServiceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderMetadataNamespaceRefPolicy
 */
export interface ServiceSpecForProviderMetadataNamespaceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderMetadataNamespaceRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderMetadataNamespaceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderMetadataNamespaceRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderMetadataNamespaceRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderMetadataNamespaceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderMetadataNamespaceRefPolicy(obj: ServiceSpecForProviderMetadataNamespaceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderMetadataNamespaceSelectorPolicy
 */
export interface ServiceSpecForProviderMetadataNamespaceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderMetadataNamespaceSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderMetadataNamespaceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderMetadataNamespaceSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderMetadataNamespaceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderMetadataNamespaceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderMetadataNamespaceSelectorPolicy(obj: ServiceSpecForProviderMetadataNamespaceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainers
 */
export interface ServiceSpecForProviderTemplateSpecContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#env
   */
  readonly env?: ServiceSpecForProviderTemplateSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#envFrom
   */
  readonly envFrom?: ServiceSpecForProviderTemplateSpecContainersEnvFrom[];

  /**
   * Docker image name. This is most often a reference to a container located in the container registry, such as gcr.io/cloudrun/hello
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#image
   */
  readonly image: string;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#livenessProbe
   */
  readonly livenessProbe?: ServiceSpecForProviderTemplateSpecContainersLivenessProbe[];

  /**
   * List of open ports in the container. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#ports
   */
  readonly ports?: ServiceSpecForProviderTemplateSpecContainersPorts[];

  /**
   * Compute Resources required by this container. Used to set values such as max memory Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#resources
   */
  readonly resources?: ServiceSpecForProviderTemplateSpecContainersResources[];

  /**
   * Startup probe of application within the container. All other probes are disabled if a startup probe is provided, until it succeeds. Container will not be added to service endpoints if the probe fails. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#startupProbe
   */
  readonly startupProbe?: ServiceSpecForProviderTemplateSpecContainersStartupProbe[];

  /**
   * Volume to mount into the container's filesystem. Only supports SecretVolumeSources. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#volumeMounts
   */
  readonly volumeMounts?: ServiceSpecForProviderTemplateSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainers(obj: ServiceSpecForProviderTemplateSpecContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersEnvFrom(y)),
    'image': obj.image,
    'livenessProbe': obj.livenessProbe?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersLivenessProbe(y)),
    'ports': obj.ports?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersPorts(y)),
    'resources': obj.resources?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersResources(y)),
    'startupProbe': obj.startupProbe?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersStartupProbe(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecVolumes
 */
export interface ServiceSpecForProviderTemplateSpecVolumes {
  /**
   * Volume's name.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumes#name
   */
  readonly name: string;

  /**
   * The secret's value will be presented as the content of a file whose name is defined in the item path. If no items are defined, the name of the file is the secret_name. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumes#secret
   */
  readonly secret: ServiceSpecForProviderTemplateSpecVolumesSecret[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecVolumes(obj: ServiceSpecForProviderTemplateSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secret': obj.secret?.map(y => toJson_ServiceSpecForProviderTemplateSpecVolumesSecret(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderMetadataNamespaceRefPolicyResolution
 */
export enum ServiceSpecForProviderMetadataNamespaceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderMetadataNamespaceRefPolicyResolve
 */
export enum ServiceSpecForProviderMetadataNamespaceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderMetadataNamespaceSelectorPolicyResolution
 */
export enum ServiceSpecForProviderMetadataNamespaceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderMetadataNamespaceSelectorPolicyResolve
 */
export enum ServiceSpecForProviderMetadataNamespaceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersEnv
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnv {
  /**
   * Volume's name.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnv#name
   */
  readonly name?: string;

  /**
   * The header field value.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Only supports secret_key_ref. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: ServiceSpecForProviderTemplateSpecContainersEnvValueFrom[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnv(obj: ServiceSpecForProviderTemplateSpecContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': obj.valueFrom?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvFrom
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRef[];

  /**
   * An optional identifier to prepend to each key in the ConfigMap.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRef[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvFrom(obj: ServiceSpecForProviderTemplateSpecContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': obj.configMapRef?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRef(y)),
    'prefix': obj.prefix,
    'secretRef': obj.secretRef?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRef(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbe
 */
export interface ServiceSpecForProviderTemplateSpecContainersLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: ServiceSpecForProviderTemplateSpecContainersLivenessProbeGrpc[];

  /**
   * HttpGet specifies the http request to perform. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGet[];

  /**
   * Number of seconds after the container has started before the probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum value is 240.
   *
   * @default 0 seconds. Minimum value is 0. Maximum value is 240.
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
   *
   * @default 10 seconds. Minimum value is 1. Maximum value is 240.
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds.
   *
   * @default 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds.
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersLivenessProbe(obj: ServiceSpecForProviderTemplateSpecContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'grpc': obj.grpc?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersLivenessProbeGrpc(y)),
    'httpGet': obj.httpGet?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGet(y)),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersPorts
 */
export interface ServiceSpecForProviderTemplateSpecContainersPorts {
  /**
   * Port number the container listens on. This must be a valid port number (between 1 and 65535). Defaults to "8080".
   *
   * @default 8080".
   * @schema ServiceSpecForProviderTemplateSpecContainersPorts#containerPort
   */
  readonly containerPort?: number;

  /**
   * Volume's name.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be "TCP". Defaults to "TCP".
   *
   * @default TCP".
   * @schema ServiceSpecForProviderTemplateSpecContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersPorts(obj: ServiceSpecForProviderTemplateSpecContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersResources
 */
export interface ServiceSpecForProviderTemplateSpecContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: string };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersResources#requests
   */
  readonly requests?: { [key: string]: string };

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersResources(obj: ServiceSpecForProviderTemplateSpecContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbe
 */
export interface ServiceSpecForProviderTemplateSpecContainersStartupProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbe#grpc
   */
  readonly grpc?: ServiceSpecForProviderTemplateSpecContainersStartupProbeGrpc[];

  /**
   * HttpGet specifies the http request to perform. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGet[];

  /**
   * Number of seconds after the container has started before the probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum value is 240.
   *
   * @default 0 seconds. Minimum value is 0. Maximum value is 240.
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
   *
   * @default 10 seconds. Minimum value is 1. Maximum value is 240.
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * TcpSocket specifies an action involving a TCP port. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: ServiceSpecForProviderTemplateSpecContainersStartupProbeTcpSocket[];

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds.
   *
   * @default 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds.
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersStartupProbe(obj: ServiceSpecForProviderTemplateSpecContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'grpc': obj.grpc?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersStartupProbeGrpc(y)),
    'httpGet': obj.httpGet?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGet(y)),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'tcpSocket': obj.tcpSocket?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersStartupProbeTcpSocket(y)),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersVolumeMounts
 */
export interface ServiceSpecForProviderTemplateSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * Volume's name.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersVolumeMounts#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersVolumeMounts(obj: ServiceSpecForProviderTemplateSpecContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecVolumesSecret
 */
export interface ServiceSpecForProviderTemplateSpecVolumesSecret {
  /**
   * Mode bits to use on created files by default. Must be a value between 0000 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, the volume will expose a file whose name is the secret_name. If specified, the key will be used as the version to fetch from Cloud Secret Manager and the path will be the name of the file exposed in the volume. When items are defined, they must specify a key and a path. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecret#items
   */
  readonly items?: ServiceSpecForProviderTemplateSpecVolumesSecretItems[];

  /**
   * The name of the secret in Cloud Secret Manager. By default, the secret is assumed to be in the same project. If the secret is in another project, you must define an alias. An alias definition has the form: {alias}:projects/{project-id|project-number}/secrets/{secret-name}. If multiple alias definitions are needed, they must be separated by commas. The alias definitions must be set on the run.googleapis.com/secrets annotation.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

  /**
   * Reference to a Secret in secretmanager to populate secretName.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecret#secretNameRef
   */
  readonly secretNameRef?: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRef;

  /**
   * Selector for a Secret in secretmanager to populate secretName.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecret#secretNameSelector
   */
  readonly secretNameSelector?: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelector;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecVolumesSecret(obj: ServiceSpecForProviderTemplateSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ServiceSpecForProviderTemplateSpecVolumesSecretItems(y)),
    'secretName': obj.secretName,
    'secretNameRef': toJson_ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRef(obj.secretNameRef),
    'secretNameSelector': toJson_ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelector(obj.secretNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFrom
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvValueFrom {
  /**
   * Selects a key (version) of a secret in Secret Manager. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFrom(obj: ServiceSpecForProviderTemplateSpecContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': obj.secretKeyRef?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRef
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRef {
  /**
   * The Secret to select from. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRef#localObjectReference
   */
  readonly localObjectReference?: ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference[];

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRef(obj: ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localObjectReference': obj.localObjectReference?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference(y)),
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRef
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRef {
  /**
   * The Secret to select from. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRef#localObjectReference
   */
  readonly localObjectReference?: ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRefLocalObjectReference[];

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRef(obj: ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localObjectReference': obj.localObjectReference?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRefLocalObjectReference(y)),
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbeGrpc
 */
export interface ServiceSpecForProviderTemplateSpecContainersLivenessProbeGrpc {
  /**
   * Port number to access on the container. Number must be in the range 1 to 65535. If not specified, defaults to the same value as container.ports[0].containerPort.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbeGrpc#port
   */
  readonly port?: number;

  /**
   * The name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersLivenessProbeGrpc(obj: ServiceSpecForProviderTemplateSpecContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGet
 */
export interface ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGet {
  /**
   * Custom headers to set in the request. HTTP allows repeated headers. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Port number to access on the container. Number must be in the range 1 to 65535. If not specified, defaults to the same value as container.ports[0].containerPort.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGet#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGet(obj: ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeGrpc
 */
export interface ServiceSpecForProviderTemplateSpecContainersStartupProbeGrpc {
  /**
   * Port number to access on the container. Number must be in the range 1 to 65535. If not specified, defaults to the same value as container.ports[0].containerPort.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeGrpc#port
   */
  readonly port?: number;

  /**
   * The name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersStartupProbeGrpc(obj: ServiceSpecForProviderTemplateSpecContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGet
 */
export interface ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGet {
  /**
   * Custom headers to set in the request. HTTP allows repeated headers. Structure is documented below.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Port number to access on the container. Number must be in the range 1 to 65535. If not specified, defaults to the same value as container.ports[0].containerPort.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGet#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGet(obj: ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeTcpSocket
 */
export interface ServiceSpecForProviderTemplateSpecContainersStartupProbeTcpSocket {
  /**
   * Port number to access on the container. Number must be in the range 1 to 65535. If not specified, defaults to the same value as container.ports[0].containerPort.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeTcpSocket#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersStartupProbeTcpSocket(obj: ServiceSpecForProviderTemplateSpecContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecVolumesSecretItems
 */
export interface ServiceSpecForProviderTemplateSpecVolumesSecretItems {
  /**
   * A Cloud Secret Manager secret version. Must be 'latest' for the latest version or an integer for a specific version.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * Mode bits to use on this file, must be a value between 0000 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecVolumesSecretItems(obj: ServiceSpecForProviderTemplateSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretmanager to populate secretName.
 *
 * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRef
 */
export interface ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRef#policy
   */
  readonly policy?: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRef(obj: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretmanager to populate secretName.
 *
 * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelector
 */
export interface ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelector#policy
   */
  readonly policy?: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelector(obj: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef {
  /**
   * A Cloud Secret Manager secret version. Must be 'latest' for the latest version or an integer for a specific version.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Volume's name.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Reference to a Secret in secretmanager to populate name.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef#nameRef
   */
  readonly nameRef?: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRef;

  /**
   * Selector for a Secret in secretmanager to populate name.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef#nameSelector
   */
  readonly nameSelector?: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelector;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef(obj: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'nameRef': toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRef(obj.nameRef),
    'nameSelector': toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelector(obj.nameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference {
  /**
   * Volume's name.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference(obj: ServiceSpecForProviderTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRefLocalObjectReference
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRefLocalObjectReference {
  /**
   * Volume's name.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRefLocalObjectReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRefLocalObjectReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRefLocalObjectReference(obj: ServiceSpecForProviderTemplateSpecContainersEnvFromSecretRefLocalObjectReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * Volume's name.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(obj: ServiceSpecForProviderTemplateSpecContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * Volume's name.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGetHttpHeaders(obj: ServiceSpecForProviderTemplateSpecContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicy
 */
export interface ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicy(obj: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicy
 */
export interface ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicy(obj: ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretmanager to populate name.
 *
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRef
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRef#policy
   */
  readonly policy?: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRef(obj: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretmanager to populate name.
 *
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelector
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelector#policy
   */
  readonly policy?: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelector(obj: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicyResolution
 */
export enum ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicyResolve
 */
export enum ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicyResolution
 */
export enum ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicyResolve
 */
export enum ServiceSpecForProviderTemplateSpecVolumesSecretSecretNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicy
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicy(obj: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicy
 */
export interface ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicy(obj: ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicyResolution
 */
export enum ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicyResolve
 */
export enum ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicyResolution
 */
export enum ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicyResolve
 */
export enum ServiceSpecForProviderTemplateSpecContainersEnvValueFromSecretKeyRefNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceIAMMember is the Schema for the ServiceIAMMembers API. <no value>
 *
 * @schema ServiceIAMMember
 */
export class ServiceIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudrun.gcp.upbound.io/v1beta1',
    kind: 'ServiceIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceIamMemberProps): any {
    return {
      ...ServiceIamMember.GVK,
      ...toJson_ServiceIamMemberProps(props),
    };
  }

  /**
   * Defines a "ServiceIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceIamMemberProps) {
    super(scope, id, {
      ...ServiceIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceIamMember.GVK,
      ...toJson_ServiceIamMemberProps(resolved),
    };
  }
}

/**
 * ServiceIAMMember is the Schema for the ServiceIAMMembers API. <no value>
 *
 * @schema ServiceIAMMember
 */
export interface ServiceIamMemberProps {
  /**
   * @schema ServiceIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceIAMMemberSpec defines the desired state of ServiceIAMMember
   *
   * @schema ServiceIAMMember#spec
   */
  readonly spec: ServiceIamMemberSpec;

}

/**
 * Converts an object of type 'ServiceIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberProps(obj: ServiceIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceIAMMemberSpec defines the desired state of ServiceIAMMember
 *
 * @schema ServiceIamMemberSpec
 */
export interface ServiceIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceIamMemberSpecDeletionPolicy;

  /**
   * @schema ServiceIamMemberSpec#forProvider
   */
  readonly forProvider: ServiceIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceIamMemberSpec#managementPolicy
   */
  readonly managementPolicy?: ServiceIamMemberSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ServiceIamMemberSpec#providerRef
   */
  readonly providerRef?: ServiceIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpec(obj: ServiceIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceIamMemberSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ServiceIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ServiceIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ServiceIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceIamMemberSpecDeletionPolicy
 */
export enum ServiceIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceIamMemberSpecForProvider
 */
export interface ServiceIamMemberSpecForProvider {
  /**
   * @schema ServiceIamMemberSpecForProvider#condition
   */
  readonly condition?: ServiceIamMemberSpecForProviderCondition[];

  /**
   * @schema ServiceIamMemberSpecForProvider#location
   */
  readonly location?: string;

  /**
   * @schema ServiceIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ServiceIamMemberSpecForProvider#projectRef
   */
  readonly projectRef?: ServiceIamMemberSpecForProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ServiceIamMemberSpecForProvider#projectSelector
   */
  readonly projectSelector?: ServiceIamMemberSpecForProviderProjectSelector;

  /**
   * @schema ServiceIamMemberSpecForProvider#role
   */
  readonly role?: string;

  /**
   * @schema ServiceIamMemberSpecForProvider#service
   */
  readonly service?: string;

  /**
   * Reference to a Service to populate service.
   *
   * @schema ServiceIamMemberSpecForProvider#serviceRef
   */
  readonly serviceRef?: ServiceIamMemberSpecForProviderServiceRef;

  /**
   * Selector for a Service to populate service.
   *
   * @schema ServiceIamMemberSpecForProvider#serviceSelector
   */
  readonly serviceSelector?: ServiceIamMemberSpecForProviderServiceSelector;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecForProvider(obj: ServiceIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ServiceIamMemberSpecForProviderCondition(y)),
    'location': obj.location,
    'member': obj.member,
    'project': obj.project,
    'projectRef': toJson_ServiceIamMemberSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ServiceIamMemberSpecForProviderProjectSelector(obj.projectSelector),
    'role': obj.role,
    'service': obj.service,
    'serviceRef': toJson_ServiceIamMemberSpecForProviderServiceRef(obj.serviceRef),
    'serviceSelector': toJson_ServiceIamMemberSpecForProviderServiceSelector(obj.serviceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceIamMemberSpecManagementPolicy
 */
export enum ServiceIamMemberSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceIamMemberSpecProviderConfigRef
 */
export interface ServiceIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecProviderConfigRef(obj: ServiceIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ServiceIamMemberSpecProviderRef
 */
export interface ServiceIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceIamMemberSpecProviderRef#policy
   */
  readonly policy?: ServiceIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecProviderRef(obj: ServiceIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceIamMemberSpecPublishConnectionDetailsTo
 */
export interface ServiceIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecPublishConnectionDetailsTo(obj: ServiceIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceIamMemberSpecWriteConnectionSecretToRef
 */
export interface ServiceIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecWriteConnectionSecretToRef(obj: ServiceIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceIamMemberSpecForProviderCondition
 */
export interface ServiceIamMemberSpecForProviderCondition {
  /**
   * @schema ServiceIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema ServiceIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecForProviderCondition(obj: ServiceIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ServiceIamMemberSpecForProviderProjectRef
 */
export interface ServiceIamMemberSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceIamMemberSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceIamMemberSpecForProviderProjectRef#policy
   */
  readonly policy?: ServiceIamMemberSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecForProviderProjectRef(obj: ServiceIamMemberSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceIamMemberSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ServiceIamMemberSpecForProviderProjectSelector
 */
export interface ServiceIamMemberSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceIamMemberSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceIamMemberSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceIamMemberSpecForProviderProjectSelector#policy
   */
  readonly policy?: ServiceIamMemberSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecForProviderProjectSelector(obj: ServiceIamMemberSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceIamMemberSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Service to populate service.
 *
 * @schema ServiceIamMemberSpecForProviderServiceRef
 */
export interface ServiceIamMemberSpecForProviderServiceRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceIamMemberSpecForProviderServiceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceIamMemberSpecForProviderServiceRef#policy
   */
  readonly policy?: ServiceIamMemberSpecForProviderServiceRefPolicy;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecForProviderServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecForProviderServiceRef(obj: ServiceIamMemberSpecForProviderServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceIamMemberSpecForProviderServiceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Service to populate service.
 *
 * @schema ServiceIamMemberSpecForProviderServiceSelector
 */
export interface ServiceIamMemberSpecForProviderServiceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceIamMemberSpecForProviderServiceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceIamMemberSpecForProviderServiceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceIamMemberSpecForProviderServiceSelector#policy
   */
  readonly policy?: ServiceIamMemberSpecForProviderServiceSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecForProviderServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecForProviderServiceSelector(obj: ServiceIamMemberSpecForProviderServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceIamMemberSpecForProviderServiceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceIamMemberSpecProviderConfigRefPolicy
 */
export interface ServiceIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecProviderConfigRefPolicy(obj: ServiceIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceIamMemberSpecProviderRefPolicy
 */
export interface ServiceIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ServiceIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ServiceIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecProviderRefPolicy(obj: ServiceIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecPublishConnectionDetailsToConfigRef(obj: ServiceIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecPublishConnectionDetailsToMetadata(obj: ServiceIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceIamMemberSpecForProviderProjectRefPolicy
 */
export interface ServiceIamMemberSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceIamMemberSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ServiceIamMemberSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceIamMemberSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ServiceIamMemberSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecForProviderProjectRefPolicy(obj: ServiceIamMemberSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceIamMemberSpecForProviderProjectSelectorPolicy
 */
export interface ServiceIamMemberSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceIamMemberSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ServiceIamMemberSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceIamMemberSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ServiceIamMemberSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecForProviderProjectSelectorPolicy(obj: ServiceIamMemberSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceIamMemberSpecForProviderServiceRefPolicy
 */
export interface ServiceIamMemberSpecForProviderServiceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceIamMemberSpecForProviderServiceRefPolicy#resolution
   */
  readonly resolution?: ServiceIamMemberSpecForProviderServiceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceIamMemberSpecForProviderServiceRefPolicy#resolve
   */
  readonly resolve?: ServiceIamMemberSpecForProviderServiceRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecForProviderServiceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecForProviderServiceRefPolicy(obj: ServiceIamMemberSpecForProviderServiceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceIamMemberSpecForProviderServiceSelectorPolicy
 */
export interface ServiceIamMemberSpecForProviderServiceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceIamMemberSpecForProviderServiceSelectorPolicy#resolution
   */
  readonly resolution?: ServiceIamMemberSpecForProviderServiceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceIamMemberSpecForProviderServiceSelectorPolicy#resolve
   */
  readonly resolve?: ServiceIamMemberSpecForProviderServiceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecForProviderServiceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecForProviderServiceSelectorPolicy(obj: ServiceIamMemberSpecForProviderServiceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum ServiceIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum ServiceIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceIamMemberSpecProviderRefPolicyResolution
 */
export enum ServiceIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceIamMemberSpecProviderRefPolicyResolve
 */
export enum ServiceIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceIamMemberSpecForProviderProjectRefPolicyResolution
 */
export enum ServiceIamMemberSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceIamMemberSpecForProviderProjectRefPolicyResolve
 */
export enum ServiceIamMemberSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceIamMemberSpecForProviderProjectSelectorPolicyResolution
 */
export enum ServiceIamMemberSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceIamMemberSpecForProviderProjectSelectorPolicyResolve
 */
export enum ServiceIamMemberSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceIamMemberSpecForProviderServiceRefPolicyResolution
 */
export enum ServiceIamMemberSpecForProviderServiceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceIamMemberSpecForProviderServiceRefPolicyResolve
 */
export enum ServiceIamMemberSpecForProviderServiceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceIamMemberSpecForProviderServiceSelectorPolicyResolution
 */
export enum ServiceIamMemberSpecForProviderServiceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceIamMemberSpecForProviderServiceSelectorPolicyResolve
 */
export enum ServiceIamMemberSpecForProviderServiceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * V2Job is the Schema for the V2Jobs API. A Cloud Run Job resource that references a container image which is run to completion.
 *
 * @schema V2Job
 */
export class V2Job extends ApiObject {
  /**
   * Returns the apiVersion and kind for "V2Job"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudrun.gcp.upbound.io/v1beta1',
    kind: 'V2Job',
  }

  /**
   * Renders a Kubernetes manifest for "V2Job".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: V2JobProps): any {
    return {
      ...V2Job.GVK,
      ...toJson_V2JobProps(props),
    };
  }

  /**
   * Defines a "V2Job" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: V2JobProps) {
    super(scope, id, {
      ...V2Job.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...V2Job.GVK,
      ...toJson_V2JobProps(resolved),
    };
  }
}

/**
 * V2Job is the Schema for the V2Jobs API. A Cloud Run Job resource that references a container image which is run to completion.
 *
 * @schema V2Job
 */
export interface V2JobProps {
  /**
   * @schema V2Job#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * V2JobSpec defines the desired state of V2Job
   *
   * @schema V2Job#spec
   */
  readonly spec: V2JobSpec;

}

/**
 * Converts an object of type 'V2JobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobProps(obj: V2JobProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_V2JobSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * V2JobSpec defines the desired state of V2Job
 *
 * @schema V2JobSpec
 */
export interface V2JobSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema V2JobSpec#deletionPolicy
   */
  readonly deletionPolicy?: V2JobSpecDeletionPolicy;

  /**
   * @schema V2JobSpec#forProvider
   */
  readonly forProvider: V2JobSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema V2JobSpec#managementPolicy
   */
  readonly managementPolicy?: V2JobSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema V2JobSpec#providerConfigRef
   */
  readonly providerConfigRef?: V2JobSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema V2JobSpec#providerRef
   */
  readonly providerRef?: V2JobSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema V2JobSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: V2JobSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema V2JobSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: V2JobSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'V2JobSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpec(obj: V2JobSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_V2JobSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_V2JobSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_V2JobSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_V2JobSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_V2JobSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema V2JobSpecDeletionPolicy
 */
export enum V2JobSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema V2JobSpecForProvider
 */
export interface V2JobSpecForProvider {
  /**
   * Settings for the Binary Authorization feature. Structure is documented below.
   *
   * @schema V2JobSpecForProvider#binaryAuthorization
   */
  readonly binaryAuthorization?: V2JobSpecForProviderBinaryAuthorization[];

  /**
   * Arbitrary identifier for the API client.
   *
   * @schema V2JobSpecForProvider#client
   */
  readonly client?: string;

  /**
   * Arbitrary version identifier for the API client.
   *
   * @schema V2JobSpecForProvider#clientVersion
   */
  readonly clientVersion?: string;

  /**
   * KRM-style labels for the resource. User-provided labels are shared with Google's billing system, so they can be used to filter, or break down billing charges by team, component, environment, state, etc. For more information, visit https://cloud.google.com/resource-manager/docs/creating-managing-labels or https://cloud.google.com/run/docs/configuring/labels Cloud Run will populate some labels with 'run.googleapis.com' or 'serving.knative.dev' namespaces. Those labels are read-only, and user changes will not be preserved.
   *
   * @schema V2JobSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The launch stage as defined by Google Cloud Platform Launch Stages. Cloud Run supports ALPHA, BETA, and GA. If no value is specified, GA is assumed. Set the launch stage to a preview stage on input to allow use of preview features in that stage. On read (or output), describes whether the resource uses preview features. For example, if ALPHA is provided as input, but only BETA and GA-level features are used, this field will be BETA on output. Possible values are: UNIMPLEMENTED, PRELAUNCH, EARLY_ACCESS, ALPHA, BETA, GA, DEPRECATED.
   *
   * @schema V2JobSpecForProvider#launchStage
   */
  readonly launchStage?: string;

  /**
   * The location of the cloud run job
   *
   * @schema V2JobSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema V2JobSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The template used to create executions for this Job. Structure is documented below.
   *
   * @schema V2JobSpecForProvider#template
   */
  readonly template?: V2JobSpecForProviderTemplate[];

}

/**
 * Converts an object of type 'V2JobSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProvider(obj: V2JobSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binaryAuthorization': obj.binaryAuthorization?.map(y => toJson_V2JobSpecForProviderBinaryAuthorization(y)),
    'client': obj.client,
    'clientVersion': obj.clientVersion,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'launchStage': obj.launchStage,
    'location': obj.location,
    'project': obj.project,
    'template': obj.template?.map(y => toJson_V2JobSpecForProviderTemplate(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema V2JobSpecManagementPolicy
 */
export enum V2JobSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema V2JobSpecProviderConfigRef
 */
export interface V2JobSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema V2JobSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema V2JobSpecProviderConfigRef#policy
   */
  readonly policy?: V2JobSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'V2JobSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecProviderConfigRef(obj: V2JobSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_V2JobSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema V2JobSpecProviderRef
 */
export interface V2JobSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema V2JobSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema V2JobSpecProviderRef#policy
   */
  readonly policy?: V2JobSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'V2JobSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecProviderRef(obj: V2JobSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_V2JobSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema V2JobSpecPublishConnectionDetailsTo
 */
export interface V2JobSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema V2JobSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: V2JobSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema V2JobSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: V2JobSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema V2JobSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'V2JobSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecPublishConnectionDetailsTo(obj: V2JobSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_V2JobSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_V2JobSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema V2JobSpecWriteConnectionSecretToRef
 */
export interface V2JobSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema V2JobSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema V2JobSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'V2JobSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecWriteConnectionSecretToRef(obj: V2JobSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderBinaryAuthorization
 */
export interface V2JobSpecForProviderBinaryAuthorization {
  /**
   * If present, indicates to use Breakglass using this justification. If useDefault is False, then it must be empty. For more information on breakglass, see https://cloud.google.com/binary-authorization/docs/using-breakglass
   *
   * @default False, then it must be empty. For more information on breakglass, see https://cloud.google.com/binary-authorization/docs/using-breakglass
   * @schema V2JobSpecForProviderBinaryAuthorization#breakglassJustification
   */
  readonly breakglassJustification?: string;

  /**
   * If True, indicates to use the default project's binary authorization policy. If False, binary authorization will be disabled.
   *
   * @schema V2JobSpecForProviderBinaryAuthorization#useDefault
   */
  readonly useDefault?: boolean;

}

/**
 * Converts an object of type 'V2JobSpecForProviderBinaryAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderBinaryAuthorization(obj: V2JobSpecForProviderBinaryAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'breakglassJustification': obj.breakglassJustification,
    'useDefault': obj.useDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplate
 */
export interface V2JobSpecForProviderTemplate {
  /**
   * KRM-style labels for the resource.
   *
   * @schema V2JobSpecForProviderTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Specifies the maximum desired number of tasks the execution should run at given time. Must be <= taskCount. When the job is run, if this field is 0 or unset, the maximum possible value will be used for that execution. The actual number of tasks running in steady state will be less than this number when there are fewer tasks waiting to be completed remaining, i.e. when the work left to do is less than max parallelism.
   *
   * @schema V2JobSpecForProviderTemplate#parallelism
   */
  readonly parallelism?: number;

  /**
   * Specifies the desired number of tasks the execution should run. Setting to 1 means that parallelism is limited to 1 and the success of that task signals the success of the execution. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
   *
   * @schema V2JobSpecForProviderTemplate#taskCount
   */
  readonly taskCount?: number;

  /**
   * Describes the task(s) that will be created when executing an execution Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplate#template
   */
  readonly template: V2JobSpecForProviderTemplateTemplate[];

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplate(obj: V2JobSpecForProviderTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'parallelism': obj.parallelism,
    'taskCount': obj.taskCount,
    'template': obj.template?.map(y => toJson_V2JobSpecForProviderTemplateTemplate(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema V2JobSpecProviderConfigRefPolicy
 */
export interface V2JobSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2JobSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: V2JobSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2JobSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: V2JobSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'V2JobSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecProviderConfigRefPolicy(obj: V2JobSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema V2JobSpecProviderRefPolicy
 */
export interface V2JobSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2JobSpecProviderRefPolicy#resolution
   */
  readonly resolution?: V2JobSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2JobSpecProviderRefPolicy#resolve
   */
  readonly resolve?: V2JobSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'V2JobSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecProviderRefPolicy(obj: V2JobSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema V2JobSpecPublishConnectionDetailsToConfigRef
 */
export interface V2JobSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema V2JobSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema V2JobSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: V2JobSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'V2JobSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecPublishConnectionDetailsToConfigRef(obj: V2JobSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_V2JobSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema V2JobSpecPublishConnectionDetailsToMetadata
 */
export interface V2JobSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema V2JobSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema V2JobSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema V2JobSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'V2JobSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecPublishConnectionDetailsToMetadata(obj: V2JobSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplate
 */
export interface V2JobSpecForProviderTemplateTemplate {
  /**
   * Holds the single container that defines the unit of execution for this task. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplate#containers
   */
  readonly containers?: V2JobSpecForProviderTemplateTemplateContainers[];

  /**
   * A reference to a customer managed encryption key (CMEK) to use to encrypt this container image. For more information, go to https://cloud.google.com/run/docs/securing/using-cmek
   *
   * @schema V2JobSpecForProviderTemplateTemplate#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The execution environment being used to host this Task. Possible values are: EXECUTION_ENVIRONMENT_GEN1, EXECUTION_ENVIRONMENT_GEN2.
   *
   * @schema V2JobSpecForProviderTemplateTemplate#executionEnvironment
   */
  readonly executionEnvironment?: string;

  /**
   * Number of retries allowed per Task, before marking this Task failed.
   *
   * @schema V2JobSpecForProviderTemplateTemplate#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * Email address of the IAM service account associated with the Task of a Job. The service account represents the identity of the running task, and determines what permissions the task has. If not provided, the task will use the project's default service account.
   *
   * @schema V2JobSpecForProviderTemplateTemplate#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Max allowed time duration the Task may be active before the system will actively try to mark it failed and kill associated containers. This applies per attempt of a task, meaning each retry can run for the full timeout. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
   *
   * @schema V2JobSpecForProviderTemplateTemplate#timeout
   */
  readonly timeout?: string;

  /**
   * A list of Volumes to make available to containers. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplate#volumes
   */
  readonly volumes?: V2JobSpecForProviderTemplateTemplateVolumes[];

  /**
   * VPC Access configuration to use for this Task. For more information, visit https://cloud.google.com/run/docs/configuring/connecting-vpc. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplate#vpcAccess
   */
  readonly vpcAccess?: V2JobSpecForProviderTemplateTemplateVpcAccess[];

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplate(obj: V2JobSpecForProviderTemplateTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containers': obj.containers?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainers(y)),
    'encryptionKey': obj.encryptionKey,
    'executionEnvironment': obj.executionEnvironment,
    'maxRetries': obj.maxRetries,
    'serviceAccount': obj.serviceAccount,
    'timeout': obj.timeout,
    'volumes': obj.volumes?.map(y => toJson_V2JobSpecForProviderTemplateTemplateVolumes(y)),
    'vpcAccess': obj.vpcAccess?.map(y => toJson_V2JobSpecForProviderTemplateTemplateVpcAccess(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2JobSpecProviderConfigRefPolicyResolution
 */
export enum V2JobSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2JobSpecProviderConfigRefPolicyResolve
 */
export enum V2JobSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2JobSpecProviderRefPolicyResolution
 */
export enum V2JobSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2JobSpecProviderRefPolicyResolve
 */
export enum V2JobSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema V2JobSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface V2JobSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2JobSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: V2JobSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2JobSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: V2JobSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'V2JobSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecPublishConnectionDetailsToConfigRefPolicy(obj: V2JobSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainers
 */
export interface V2JobSpecForProviderTemplateTemplateContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#env
   */
  readonly env?: V2JobSpecForProviderTemplateTemplateContainersEnv[];

  /**
   * URL of the Container image in Google Container Registry or Google Artifact Registry. More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#image
   */
  readonly image: string;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes This field is not supported in Cloud Run Job currently. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#livenessProbe
   */
  readonly livenessProbe?: V2JobSpecForProviderTemplateTemplateContainersLivenessProbe[];

  /**
   * Volume's name.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#name
   */
  readonly name?: string;

  /**
   * List of ports to expose from the container. Only a single port can be specified. The specified ports must be listening on all interfaces (0.0.0.0) within the container to be accessible. If omitted, a port number will be chosen and passed to the container through the PORT environment variable for the container to listen on Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#ports
   */
  readonly ports?: V2JobSpecForProviderTemplateTemplateContainersPorts[];

  /**
   * Compute Resource requirements by this container. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#resources
   */
  readonly resources?: V2JobSpecForProviderTemplateTemplateContainersResources[];

  /**
   * Startup probe of application within the container. All other probes are disabled if a startup probe is provided, until it succeeds. Container will not be added to service endpoints if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes This field is not supported in Cloud Run Job currently. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#startupProbe
   */
  readonly startupProbe?: V2JobSpecForProviderTemplateTemplateContainersStartupProbe[];

  /**
   * Volume to mount into the container's filesystem. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#volumeMounts
   */
  readonly volumeMounts?: V2JobSpecForProviderTemplateTemplateContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainers(obj: V2JobSpecForProviderTemplateTemplateContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersEnv(y)),
    'image': obj.image,
    'livenessProbe': obj.livenessProbe?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersLivenessProbe(y)),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersPorts(y)),
    'resources': obj.resources?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersResources(y)),
    'startupProbe': obj.startupProbe?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersStartupProbe(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateVolumes
 */
export interface V2JobSpecForProviderTemplateTemplateVolumes {
  /**
   * For Cloud SQL volumes, contains the specific instances that should be mounted. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumes#cloudSqlInstance
   */
  readonly cloudSqlInstance?: V2JobSpecForProviderTemplateTemplateVolumesCloudSqlInstance[];

  /**
   * Volume's name.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumes#name
   */
  readonly name: string;

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumes#secret
   */
  readonly secret?: V2JobSpecForProviderTemplateTemplateVolumesSecret[];

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateVolumes(obj: V2JobSpecForProviderTemplateTemplateVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudSqlInstance': obj.cloudSqlInstance?.map(y => toJson_V2JobSpecForProviderTemplateTemplateVolumesCloudSqlInstance(y)),
    'name': obj.name,
    'secret': obj.secret?.map(y => toJson_V2JobSpecForProviderTemplateTemplateVolumesSecret(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateVpcAccess
 */
export interface V2JobSpecForProviderTemplateTemplateVpcAccess {
  /**
   * VPC Access connector name. Format: projects/{project}/locations/{location}/connectors/{connector}, where {project} can be project id or number.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVpcAccess#connector
   */
  readonly connector?: string;

  /**
   * Traffic VPC egress settings. Possible values are: ALL_TRAFFIC, PRIVATE_RANGES_ONLY.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVpcAccess#egress
   */
  readonly egress?: string;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateVpcAccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateVpcAccess(obj: V2JobSpecForProviderTemplateTemplateVpcAccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connector': obj.connector,
    'egress': obj.egress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2JobSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum V2JobSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2JobSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum V2JobSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnv
 */
export interface V2JobSpecForProviderTemplateTemplateContainersEnv {
  /**
   * Volume's name.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnv#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnv#valueSource
   */
  readonly valueSource?: V2JobSpecForProviderTemplateTemplateContainersEnvValueSource[];

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersEnv(obj: V2JobSpecForProviderTemplateTemplateContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueSource': obj.valueSource?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbe
 */
export interface V2JobSpecForProviderTemplateTemplateContainersLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGet specifies the http request to perform. Exactly one of HTTPGet or TCPSocket must be specified. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbe#httpGet
   */
  readonly httpGet?: V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGet[];

  /**
   * Number of seconds after the container has started before the probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds
   *
   * @default 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * TCPSocket specifies an action involving a TCP port. Exactly one of HTTPGet or TCPSocket must be specified. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: V2JobSpecForProviderTemplateTemplateContainersLivenessProbeTcpSocket[];

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersLivenessProbe(obj: V2JobSpecForProviderTemplateTemplateContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'httpGet': obj.httpGet?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGet(y)),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'tcpSocket': obj.tcpSocket?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersLivenessProbeTcpSocket(y)),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersPorts
 */
export interface V2JobSpecForProviderTemplateTemplateContainersPorts {
  /**
   * Port number the container listens on. This must be a valid TCP port number, 0 < containerPort < 65536.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersPorts#containerPort
   */
  readonly containerPort?: number;

  /**
   * Volume's name.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersPorts#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersPorts(obj: V2JobSpecForProviderTemplateTemplateContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersResources
 */
export interface V2JobSpecForProviderTemplateTemplateContainersResources {
  /**
   * Only memory and CPU are supported. Note: The only supported values for CPU are '1', '2', '4', and '8'. Setting 4 CPU requires at least 2Gi of memory. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersResources#limits
   */
  readonly limits?: { [key: string]: string };

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersResources(obj: V2JobSpecForProviderTemplateTemplateContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbe
 */
export interface V2JobSpecForProviderTemplateTemplateContainersStartupProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGet specifies the http request to perform. Exactly one of HTTPGet or TCPSocket must be specified. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbe#httpGet
   */
  readonly httpGet?: V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGet[];

  /**
   * Number of seconds after the container has started before the probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds
   *
   * @default 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * TCPSocket specifies an action involving a TCP port. Exactly one of HTTPGet or TCPSocket must be specified. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: V2JobSpecForProviderTemplateTemplateContainersStartupProbeTcpSocket[];

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersStartupProbe(obj: V2JobSpecForProviderTemplateTemplateContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'httpGet': obj.httpGet?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGet(y)),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'tcpSocket': obj.tcpSocket?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersStartupProbeTcpSocket(y)),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersVolumeMounts
 */
export interface V2JobSpecForProviderTemplateTemplateContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted. Must not contain ':'. For Cloud SQL volumes, it can be left empty, or must otherwise be /cloudsql. All instances defined in the Volume will be available as /cloudsql/[instance]. For more information on Cloud SQL volumes, visit https://cloud.google.com/sql/docs/mysql/connect-run
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * Volume's name.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersVolumeMounts#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersVolumeMounts(obj: V2JobSpecForProviderTemplateTemplateContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateVolumesCloudSqlInstance
 */
export interface V2JobSpecForProviderTemplateTemplateVolumesCloudSqlInstance {
  /**
   * The Cloud SQL instance connection names, as can be found in https://console.cloud.google.com/sql/instances. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run. Format: {project}:{location}:{instance}
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesCloudSqlInstance#instances
   */
  readonly instances?: string[];

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateVolumesCloudSqlInstance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateVolumesCloudSqlInstance(obj: V2JobSpecForProviderTemplateTemplateVolumesCloudSqlInstance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instances': obj.instances?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateVolumesSecret
 */
export interface V2JobSpecForProviderTemplateTemplateVolumesSecret {
  /**
   * Integer representation of mode bits to use on created files by default. Must be a value between 0000 and 0777 (octal), defaulting to 0444. Directories within the path are not affected by this setting.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, the volume will expose a file whose name is the secret, relative to VolumeMount.mount_path. If specified, the key will be used as the version to fetch from Cloud Secret Manager and the path will be the name of the file exposed in the volume. When items are defined, they must specify a path and a version. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecret#items
   */
  readonly items?: V2JobSpecForProviderTemplateTemplateVolumesSecretItems[];

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecret#secret
   */
  readonly secret?: string;

  /**
   * Reference to a Secret in secretmanager to populate secret.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecret#secretRef
   */
  readonly secretRef?: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRef;

  /**
   * Selector for a Secret in secretmanager to populate secret.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecret#secretSelector
   */
  readonly secretSelector?: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelector;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateVolumesSecret(obj: V2JobSpecForProviderTemplateTemplateVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_V2JobSpecForProviderTemplateTemplateVolumesSecretItems(y)),
    'secret': obj.secret,
    'secretRef': toJson_V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRef(obj.secretRef),
    'secretSelector': toJson_V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelector(obj.secretSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSource
 */
export interface V2JobSpecForProviderTemplateTemplateContainersEnvValueSource {
  /**
   * Selects a secret and a specific version from Cloud Secret Manager. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSource#secretKeyRef
   */
  readonly secretKeyRef?: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef[];

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersEnvValueSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSource(obj: V2JobSpecForProviderTemplateTemplateContainersEnvValueSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': obj.secretKeyRef?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGet
 */
export interface V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGet {
  /**
   * Custom headers to set in the request. HTTP allows repeated headers. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * The relative path of the secret in the container.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGet(obj: V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpHeaders': obj.httpHeaders?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbeTcpSocket
 */
export interface V2JobSpecForProviderTemplateTemplateContainersLivenessProbeTcpSocket {
  /**
   * Port number to access on the container. Must be in the range 1 to 65535. If not specified, defaults to 8080.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbeTcpSocket#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersLivenessProbeTcpSocket(obj: V2JobSpecForProviderTemplateTemplateContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGet
 */
export interface V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGet {
  /**
   * Custom headers to set in the request. HTTP allows repeated headers. Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * The relative path of the secret in the container.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGet(obj: V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpHeaders': obj.httpHeaders?.map(y => toJson_V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbeTcpSocket
 */
export interface V2JobSpecForProviderTemplateTemplateContainersStartupProbeTcpSocket {
  /**
   * Port number to access on the container. Must be in the range 1 to 65535. If not specified, defaults to 8080.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbeTcpSocket#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersStartupProbeTcpSocket(obj: V2JobSpecForProviderTemplateTemplateContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretItems
 */
export interface V2JobSpecForProviderTemplateTemplateVolumesSecretItems {
  /**
   * Integer octal mode bits to use on this file, must be a value between 01 and 0777 (octal). If 0 or not set, the Volume's default mode will be used.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretItems#mode
   */
  readonly mode: number;

  /**
   * The relative path of the secret in the container.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretItems#path
   */
  readonly path: string;

  /**
   * The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretItems#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateVolumesSecretItems(obj: V2JobSpecForProviderTemplateTemplateVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'path': obj.path,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretmanager to populate secret.
 *
 * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRef
 */
export interface V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRef {
  /**
   * Name of the referenced object.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRef#policy
   */
  readonly policy?: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicy;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRef(obj: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretmanager to populate secret.
 *
 * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelector
 */
export interface V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelector#policy
   */
  readonly policy?: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicy;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelector(obj: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef
 */
export interface V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef {
  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret Structure is documented below.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef#secret
   */
  readonly secret?: string;

  /**
   * Reference to a Secret in secretmanager to populate secret.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef#secretRef
   */
  readonly secretRef?: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRef;

  /**
   * Selector for a Secret in secretmanager to populate secret.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef#secretSelector
   */
  readonly secretSelector?: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelector;

  /**
   * The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef(obj: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': obj.secret,
    'secretRef': toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRef(obj.secretRef),
    'secretSelector': toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelector(obj.secretSelector),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGetHttpHeaders
 */
export interface V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * Volume's name.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGetHttpHeaders(obj: V2JobSpecForProviderTemplateTemplateContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGetHttpHeaders
 */
export interface V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGetHttpHeaders {
  /**
   * Volume's name.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGetHttpHeaders(obj: V2JobSpecForProviderTemplateTemplateContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicy
 */
export interface V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicy#resolution
   */
  readonly resolution?: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicy#resolve
   */
  readonly resolve?: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicyResolve;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicy(obj: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicy
 */
export interface V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicy#resolution
   */
  readonly resolution?: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicy#resolve
   */
  readonly resolve?: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicyResolve;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicy(obj: V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretmanager to populate secret.
 *
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRef
 */
export interface V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRef {
  /**
   * Name of the referenced object.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRef#policy
   */
  readonly policy?: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRef(obj: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretmanager to populate secret.
 *
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelector
 */
export interface V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelector#policy
   */
  readonly policy?: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelector(obj: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicyResolution
 */
export enum V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicyResolve
 */
export enum V2JobSpecForProviderTemplateTemplateVolumesSecretSecretRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicyResolution
 */
export enum V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicyResolve
 */
export enum V2JobSpecForProviderTemplateTemplateVolumesSecretSecretSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy
 */
export interface V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy#resolution
   */
  readonly resolution?: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy#resolve
   */
  readonly resolve?: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolve;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy(obj: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy
 */
export interface V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy#resolution
   */
  readonly resolution?: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy#resolve
   */
  readonly resolve?: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolve;

}

/**
 * Converts an object of type 'V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy(obj: V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolution
 */
export enum V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolve
 */
export enum V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolution
 */
export enum V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolve
 */
export enum V2JobSpecForProviderTemplateTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * V2Service is the Schema for the V2Services API. Service acts as a top-level container that manages a set of configurations and revision templates which implement a network service.
 *
 * @schema V2Service
 */
export class V2Service extends ApiObject {
  /**
   * Returns the apiVersion and kind for "V2Service"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudrun.gcp.upbound.io/v1beta1',
    kind: 'V2Service',
  }

  /**
   * Renders a Kubernetes manifest for "V2Service".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: V2ServiceProps): any {
    return {
      ...V2Service.GVK,
      ...toJson_V2ServiceProps(props),
    };
  }

  /**
   * Defines a "V2Service" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: V2ServiceProps) {
    super(scope, id, {
      ...V2Service.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...V2Service.GVK,
      ...toJson_V2ServiceProps(resolved),
    };
  }
}

/**
 * V2Service is the Schema for the V2Services API. Service acts as a top-level container that manages a set of configurations and revision templates which implement a network service.
 *
 * @schema V2Service
 */
export interface V2ServiceProps {
  /**
   * @schema V2Service#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * V2ServiceSpec defines the desired state of V2Service
   *
   * @schema V2Service#spec
   */
  readonly spec: V2ServiceSpec;

}

/**
 * Converts an object of type 'V2ServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceProps(obj: V2ServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_V2ServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * V2ServiceSpec defines the desired state of V2Service
 *
 * @schema V2ServiceSpec
 */
export interface V2ServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema V2ServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: V2ServiceSpecDeletionPolicy;

  /**
   * @schema V2ServiceSpec#forProvider
   */
  readonly forProvider: V2ServiceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema V2ServiceSpec#managementPolicy
   */
  readonly managementPolicy?: V2ServiceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema V2ServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: V2ServiceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema V2ServiceSpec#providerRef
   */
  readonly providerRef?: V2ServiceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema V2ServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: V2ServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema V2ServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: V2ServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'V2ServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpec(obj: V2ServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_V2ServiceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_V2ServiceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_V2ServiceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_V2ServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_V2ServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema V2ServiceSpecDeletionPolicy
 */
export enum V2ServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema V2ServiceSpecForProvider
 */
export interface V2ServiceSpecForProvider {
  /**
   * KRM-style annotations for the resource.
   *
   * @schema V2ServiceSpecForProvider#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Settings for the Binary Authorization feature. Structure is documented below.
   *
   * @schema V2ServiceSpecForProvider#binaryAuthorization
   */
  readonly binaryAuthorization?: V2ServiceSpecForProviderBinaryAuthorization[];

  /**
   * Arbitrary identifier for the API client.
   *
   * @schema V2ServiceSpecForProvider#client
   */
  readonly client?: string;

  /**
   * Arbitrary version identifier for the API client.
   *
   * @schema V2ServiceSpecForProvider#clientVersion
   */
  readonly clientVersion?: string;

  /**
   * User-provided description of the Service. This field currently has a 512-character limit.
   *
   * @schema V2ServiceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Provides the ingress settings for this Service. On output, returns the currently observed ingress settings, or INGRESS_TRAFFIC_UNSPECIFIED if no revision is active. Possible values are: INGRESS_TRAFFIC_ALL, INGRESS_TRAFFIC_INTERNAL_ONLY, INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER.
   *
   * @schema V2ServiceSpecForProvider#ingress
   */
  readonly ingress?: string;

  /**
   * KRM-style labels for the resource.
   *
   * @schema V2ServiceSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The launch stage as defined by Google Cloud Platform Launch Stages. Cloud Run supports ALPHA, BETA, and GA. If no value is specified, GA is assumed. Set the launch stage to a preview stage on input to allow use of preview features in that stage. On read (or output), describes whether the resource uses preview features. For example, if ALPHA is provided as input, but only BETA and GA-level features are used, this field will be BETA on output. Possible values are: UNIMPLEMENTED, PRELAUNCH, EARLY_ACCESS, ALPHA, BETA, GA, DEPRECATED.
   *
   * @schema V2ServiceSpecForProvider#launchStage
   */
  readonly launchStage?: string;

  /**
   * The location of the cloud run service
   *
   * @schema V2ServiceSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema V2ServiceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The template used to create revisions for this Service. Structure is documented below.
   *
   * @schema V2ServiceSpecForProvider#template
   */
  readonly template?: V2ServiceSpecForProviderTemplate[];

  /**
   * Specifies how to distribute traffic over a collection of Revisions belonging to the Service. If traffic is empty or not provided, defaults to 100% traffic to the latest Ready Revision. Structure is documented below.
   *
   * @schema V2ServiceSpecForProvider#traffic
   */
  readonly traffic?: V2ServiceSpecForProviderTraffic[];

}

/**
 * Converts an object of type 'V2ServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProvider(obj: V2ServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'binaryAuthorization': obj.binaryAuthorization?.map(y => toJson_V2ServiceSpecForProviderBinaryAuthorization(y)),
    'client': obj.client,
    'clientVersion': obj.clientVersion,
    'description': obj.description,
    'ingress': obj.ingress,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'launchStage': obj.launchStage,
    'location': obj.location,
    'project': obj.project,
    'template': obj.template?.map(y => toJson_V2ServiceSpecForProviderTemplate(y)),
    'traffic': obj.traffic?.map(y => toJson_V2ServiceSpecForProviderTraffic(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema V2ServiceSpecManagementPolicy
 */
export enum V2ServiceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema V2ServiceSpecProviderConfigRef
 */
export interface V2ServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema V2ServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema V2ServiceSpecProviderConfigRef#policy
   */
  readonly policy?: V2ServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'V2ServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecProviderConfigRef(obj: V2ServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_V2ServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema V2ServiceSpecProviderRef
 */
export interface V2ServiceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema V2ServiceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema V2ServiceSpecProviderRef#policy
   */
  readonly policy?: V2ServiceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'V2ServiceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecProviderRef(obj: V2ServiceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_V2ServiceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema V2ServiceSpecPublishConnectionDetailsTo
 */
export interface V2ServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema V2ServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: V2ServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema V2ServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: V2ServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema V2ServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'V2ServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecPublishConnectionDetailsTo(obj: V2ServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_V2ServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_V2ServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema V2ServiceSpecWriteConnectionSecretToRef
 */
export interface V2ServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema V2ServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema V2ServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'V2ServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecWriteConnectionSecretToRef(obj: V2ServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderBinaryAuthorization
 */
export interface V2ServiceSpecForProviderBinaryAuthorization {
  /**
   * If present, indicates to use Breakglass using this justification. If useDefault is False, then it must be empty. For more information on breakglass, see https://cloud.google.com/binary-authorization/docs/using-breakglass
   *
   * @default False, then it must be empty. For more information on breakglass, see https://cloud.google.com/binary-authorization/docs/using-breakglass
   * @schema V2ServiceSpecForProviderBinaryAuthorization#breakglassJustification
   */
  readonly breakglassJustification?: string;

  /**
   * If True, indicates to use the default project's binary authorization policy. If False, binary authorization will be disabled.
   *
   * @schema V2ServiceSpecForProviderBinaryAuthorization#useDefault
   */
  readonly useDefault?: boolean;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderBinaryAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderBinaryAuthorization(obj: V2ServiceSpecForProviderBinaryAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'breakglassJustification': obj.breakglassJustification,
    'useDefault': obj.useDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplate
 */
export interface V2ServiceSpecForProviderTemplate {
  /**
   * KRM-style annotations for the resource.
   *
   * @schema V2ServiceSpecForProviderTemplate#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Holds the single container that defines the unit of execution for this task. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplate#containers
   */
  readonly containers?: V2ServiceSpecForProviderTemplateContainers[];

  /**
   * A reference to a customer managed encryption key (CMEK) to use to encrypt this container image. For more information, go to https://cloud.google.com/run/docs/securing/using-cmek
   *
   * @schema V2ServiceSpecForProviderTemplate#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The sandbox environment to host this Revision. Possible values are: EXECUTION_ENVIRONMENT_GEN1, EXECUTION_ENVIRONMENT_GEN2.
   *
   * @schema V2ServiceSpecForProviderTemplate#executionEnvironment
   */
  readonly executionEnvironment?: string;

  /**
   * KRM-style labels for the resource.
   *
   * @schema V2ServiceSpecForProviderTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Sets the maximum number of requests that each serving instance can receive.
   *
   * @schema V2ServiceSpecForProviderTemplate#maxInstanceRequestConcurrency
   */
  readonly maxInstanceRequestConcurrency?: number;

  /**
   * The unique name for the revision. If this field is omitted, it will be automatically generated based on the Service name.
   *
   * @schema V2ServiceSpecForProviderTemplate#revision
   */
  readonly revision?: string;

  /**
   * Scaling settings for this Revision. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplate#scaling
   */
  readonly scaling?: V2ServiceSpecForProviderTemplateScaling[];

  /**
   * Email address of the IAM service account associated with the revision of the service. The service account represents the identity of the running revision, and determines what permissions the revision has. If not provided, the revision will use the project's default service account.
   *
   * @schema V2ServiceSpecForProviderTemplate#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Enables session affinity. For more information, go to https://cloud.google.com/run/docs/configuring/session-affinity
   *
   * @schema V2ServiceSpecForProviderTemplate#sessionAffinity
   */
  readonly sessionAffinity?: boolean;

  /**
   * Max allowed time for an instance to respond to a request. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
   *
   * @schema V2ServiceSpecForProviderTemplate#timeout
   */
  readonly timeout?: string;

  /**
   * A list of Volumes to make available to containers. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplate#volumes
   */
  readonly volumes?: V2ServiceSpecForProviderTemplateVolumes[];

  /**
   * VPC Access configuration to use for this Task. For more information, visit https://cloud.google.com/run/docs/configuring/connecting-vpc. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplate#vpcAccess
   */
  readonly vpcAccess?: V2ServiceSpecForProviderTemplateVpcAccess[];

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplate(obj: V2ServiceSpecForProviderTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'containers': obj.containers?.map(y => toJson_V2ServiceSpecForProviderTemplateContainers(y)),
    'encryptionKey': obj.encryptionKey,
    'executionEnvironment': obj.executionEnvironment,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'maxInstanceRequestConcurrency': obj.maxInstanceRequestConcurrency,
    'revision': obj.revision,
    'scaling': obj.scaling?.map(y => toJson_V2ServiceSpecForProviderTemplateScaling(y)),
    'serviceAccount': obj.serviceAccount,
    'sessionAffinity': obj.sessionAffinity,
    'timeout': obj.timeout,
    'volumes': obj.volumes?.map(y => toJson_V2ServiceSpecForProviderTemplateVolumes(y)),
    'vpcAccess': obj.vpcAccess?.map(y => toJson_V2ServiceSpecForProviderTemplateVpcAccess(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTraffic
 */
export interface V2ServiceSpecForProviderTraffic {
  /**
   * Specifies percent of the traffic to this Revision. This defaults to zero if unspecified.
   *
   * @schema V2ServiceSpecForProviderTraffic#percent
   */
  readonly percent?: number;

  /**
   * Revision to which to send this portion of traffic, if traffic allocation is by revision.
   *
   * @schema V2ServiceSpecForProviderTraffic#revision
   */
  readonly revision?: string;

  /**
   * Indicates a string to be part of the URI to exclusively reference this target.
   *
   * @schema V2ServiceSpecForProviderTraffic#tag
   */
  readonly tag?: string;

  /**
   * The allocation type for this traffic target. Possible values are: TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST, TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION.
   *
   * @schema V2ServiceSpecForProviderTraffic#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTraffic' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTraffic(obj: V2ServiceSpecForProviderTraffic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'percent': obj.percent,
    'revision': obj.revision,
    'tag': obj.tag,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema V2ServiceSpecProviderConfigRefPolicy
 */
export interface V2ServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2ServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: V2ServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2ServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: V2ServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'V2ServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecProviderConfigRefPolicy(obj: V2ServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema V2ServiceSpecProviderRefPolicy
 */
export interface V2ServiceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2ServiceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: V2ServiceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2ServiceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: V2ServiceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'V2ServiceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecProviderRefPolicy(obj: V2ServiceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema V2ServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface V2ServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema V2ServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema V2ServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: V2ServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'V2ServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecPublishConnectionDetailsToConfigRef(obj: V2ServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_V2ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema V2ServiceSpecPublishConnectionDetailsToMetadata
 */
export interface V2ServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema V2ServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema V2ServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema V2ServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecPublishConnectionDetailsToMetadata(obj: V2ServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainers
 */
export interface V2ServiceSpecForProviderTemplateContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#env
   */
  readonly env?: V2ServiceSpecForProviderTemplateContainersEnv[];

  /**
   * URL of the Container image in Google Container Registry or Google Artifact Registry. More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#image
   */
  readonly image: string;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#livenessProbe
   */
  readonly livenessProbe?: V2ServiceSpecForProviderTemplateContainersLivenessProbe[];

  /**
   * Volume's name.
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#name
   */
  readonly name?: string;

  /**
   * List of ports to expose from the container. Only a single port can be specified. The specified ports must be listening on all interfaces (0.0.0.0) within the container to be accessible. If omitted, a port number will be chosen and passed to the container through the PORT environment variable for the container to listen on Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#ports
   */
  readonly ports?: V2ServiceSpecForProviderTemplateContainersPorts[];

  /**
   * Compute Resource requirements by this container. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#resources
   */
  readonly resources?: V2ServiceSpecForProviderTemplateContainersResources[];

  /**
   * Startup probe of application within the container. All other probes are disabled if a startup probe is provided, until it succeeds. Container will not be added to service endpoints if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#startupProbe
   */
  readonly startupProbe?: V2ServiceSpecForProviderTemplateContainersStartupProbe[];

  /**
   * Volume to mount into the container's filesystem. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#volumeMounts
   */
  readonly volumeMounts?: V2ServiceSpecForProviderTemplateContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image.
   *
   * @schema V2ServiceSpecForProviderTemplateContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainers(obj: V2ServiceSpecForProviderTemplateContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersEnv(y)),
    'image': obj.image,
    'livenessProbe': obj.livenessProbe?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersLivenessProbe(y)),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersPorts(y)),
    'resources': obj.resources?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersResources(y)),
    'startupProbe': obj.startupProbe?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersStartupProbe(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateScaling
 */
export interface V2ServiceSpecForProviderTemplateScaling {
  /**
   * Maximum number of serving instances that this resource should have.
   *
   * @schema V2ServiceSpecForProviderTemplateScaling#maxInstanceCount
   */
  readonly maxInstanceCount?: number;

  /**
   * Minimum number of serving instances that this resource should have.
   *
   * @schema V2ServiceSpecForProviderTemplateScaling#minInstanceCount
   */
  readonly minInstanceCount?: number;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateScaling(obj: V2ServiceSpecForProviderTemplateScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxInstanceCount': obj.maxInstanceCount,
    'minInstanceCount': obj.minInstanceCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateVolumes
 */
export interface V2ServiceSpecForProviderTemplateVolumes {
  /**
   * For Cloud SQL volumes, contains the specific instances that should be mounted. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumes#cloudSqlInstance
   */
  readonly cloudSqlInstance?: V2ServiceSpecForProviderTemplateVolumesCloudSqlInstance[];

  /**
   * Volume's name.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumes#name
   */
  readonly name: string;

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumes#secret
   */
  readonly secret?: V2ServiceSpecForProviderTemplateVolumesSecret[];

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateVolumes(obj: V2ServiceSpecForProviderTemplateVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudSqlInstance': obj.cloudSqlInstance?.map(y => toJson_V2ServiceSpecForProviderTemplateVolumesCloudSqlInstance(y)),
    'name': obj.name,
    'secret': obj.secret?.map(y => toJson_V2ServiceSpecForProviderTemplateVolumesSecret(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateVpcAccess
 */
export interface V2ServiceSpecForProviderTemplateVpcAccess {
  /**
   * VPC Access connector name. Format: projects/{project}/locations/{location}/connectors/{connector}, where {project} can be project id or number.
   *
   * @schema V2ServiceSpecForProviderTemplateVpcAccess#connector
   */
  readonly connector?: string;

  /**
   * Traffic VPC egress settings. Possible values are: ALL_TRAFFIC, PRIVATE_RANGES_ONLY.
   *
   * @schema V2ServiceSpecForProviderTemplateVpcAccess#egress
   */
  readonly egress?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateVpcAccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateVpcAccess(obj: V2ServiceSpecForProviderTemplateVpcAccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connector': obj.connector,
    'egress': obj.egress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2ServiceSpecProviderConfigRefPolicyResolution
 */
export enum V2ServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2ServiceSpecProviderConfigRefPolicyResolve
 */
export enum V2ServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2ServiceSpecProviderRefPolicyResolution
 */
export enum V2ServiceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2ServiceSpecProviderRefPolicyResolve
 */
export enum V2ServiceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema V2ServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface V2ServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: V2ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: V2ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'V2ServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: V2ServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersEnv
 */
export interface V2ServiceSpecForProviderTemplateContainersEnv {
  /**
   * Volume's name.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnv#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnv#valueSource
   */
  readonly valueSource?: V2ServiceSpecForProviderTemplateContainersEnvValueSource[];

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersEnv(obj: V2ServiceSpecForProviderTemplateContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueSource': obj.valueSource?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbe
 */
export interface V2ServiceSpecForProviderTemplateContainersLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbe#grpc
   */
  readonly grpc?: V2ServiceSpecForProviderTemplateContainersLivenessProbeGrpc[];

  /**
   * HTTPGet specifies the http request to perform. Exactly one of HTTPGet or TCPSocket must be specified. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbe#httpGet
   */
  readonly httpGet?: V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGet[];

  /**
   * Number of seconds after the container has started before the probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds
   *
   * @default 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * TCPSocket specifies an action involving a TCP port. Exactly one of HTTPGet or TCPSocket must be specified. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: V2ServiceSpecForProviderTemplateContainersLivenessProbeTcpSocket[];

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersLivenessProbe(obj: V2ServiceSpecForProviderTemplateContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'grpc': obj.grpc?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersLivenessProbeGrpc(y)),
    'httpGet': obj.httpGet?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGet(y)),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'tcpSocket': obj.tcpSocket?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersLivenessProbeTcpSocket(y)),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersPorts
 */
export interface V2ServiceSpecForProviderTemplateContainersPorts {
  /**
   * Port number the container listens on. This must be a valid TCP port number, 0 < containerPort < 65536.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersPorts#containerPort
   */
  readonly containerPort?: number;

  /**
   * Volume's name.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersPorts#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersPorts(obj: V2ServiceSpecForProviderTemplateContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersResources
 */
export interface V2ServiceSpecForProviderTemplateContainersResources {
  /**
   * Determines whether CPU should be throttled or not outside of requests.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersResources#cpuIdle
   */
  readonly cpuIdle?: boolean;

  /**
   * Only memory and CPU are supported. Note: The only supported values for CPU are '1', '2', '4', and '8'. Setting 4 CPU requires at least 2Gi of memory. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
   *
   * @schema V2ServiceSpecForProviderTemplateContainersResources#limits
   */
  readonly limits?: { [key: string]: string };

  /**
   * Determines whether CPU should be boosted on startup of a new container instance above the requested CPU threshold, this can help reduce cold-start latency.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersResources#startupCpuBoost
   */
  readonly startupCpuBoost?: boolean;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersResources(obj: V2ServiceSpecForProviderTemplateContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuIdle': obj.cpuIdle,
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'startupCpuBoost': obj.startupCpuBoost,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersStartupProbe
 */
export interface V2ServiceSpecForProviderTemplateContainersStartupProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbe#grpc
   */
  readonly grpc?: V2ServiceSpecForProviderTemplateContainersStartupProbeGrpc[];

  /**
   * HTTPGet specifies the http request to perform. Exactly one of HTTPGet or TCPSocket must be specified. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbe#httpGet
   */
  readonly httpGet?: V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGet[];

  /**
   * Number of seconds after the container has started before the probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds
   *
   * @default 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * TCPSocket specifies an action involving a TCP port. Exactly one of HTTPGet or TCPSocket must be specified. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: V2ServiceSpecForProviderTemplateContainersStartupProbeTcpSocket[];

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersStartupProbe(obj: V2ServiceSpecForProviderTemplateContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'grpc': obj.grpc?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersStartupProbeGrpc(y)),
    'httpGet': obj.httpGet?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGet(y)),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'tcpSocket': obj.tcpSocket?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersStartupProbeTcpSocket(y)),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersVolumeMounts
 */
export interface V2ServiceSpecForProviderTemplateContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted. Must not contain ':'. For Cloud SQL volumes, it can be left empty, or must otherwise be /cloudsql. All instances defined in the Volume will be available as /cloudsql/[instance]. For more information on Cloud SQL volumes, visit https://cloud.google.com/sql/docs/mysql/connect-run
   *
   * @schema V2ServiceSpecForProviderTemplateContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * Volume's name.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersVolumeMounts#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersVolumeMounts(obj: V2ServiceSpecForProviderTemplateContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateVolumesCloudSqlInstance
 */
export interface V2ServiceSpecForProviderTemplateVolumesCloudSqlInstance {
  /**
   * The Cloud SQL instance connection names, as can be found in https://console.cloud.google.com/sql/instances. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run. Format: {project}:{location}:{instance}
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesCloudSqlInstance#instances
   */
  readonly instances?: string[];

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateVolumesCloudSqlInstance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateVolumesCloudSqlInstance(obj: V2ServiceSpecForProviderTemplateVolumesCloudSqlInstance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instances': obj.instances?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateVolumesSecret
 */
export interface V2ServiceSpecForProviderTemplateVolumesSecret {
  /**
   * Integer representation of mode bits to use on created files by default. Must be a value between 0000 and 0777 (octal), defaulting to 0444. Directories within the path are not affected by this setting.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, the volume will expose a file whose name is the secret, relative to VolumeMount.mount_path. If specified, the key will be used as the version to fetch from Cloud Secret Manager and the path will be the name of the file exposed in the volume. When items are defined, they must specify a path and a version. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecret#items
   */
  readonly items?: V2ServiceSpecForProviderTemplateVolumesSecretItems[];

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecret#secret
   */
  readonly secret?: string;

  /**
   * Reference to a Secret in secretmanager to populate secret.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecret#secretRef
   */
  readonly secretRef?: V2ServiceSpecForProviderTemplateVolumesSecretSecretRef;

  /**
   * Selector for a Secret in secretmanager to populate secret.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecret#secretSelector
   */
  readonly secretSelector?: V2ServiceSpecForProviderTemplateVolumesSecretSecretSelector;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateVolumesSecret(obj: V2ServiceSpecForProviderTemplateVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_V2ServiceSpecForProviderTemplateVolumesSecretItems(y)),
    'secret': obj.secret,
    'secretRef': toJson_V2ServiceSpecForProviderTemplateVolumesSecretSecretRef(obj.secretRef),
    'secretSelector': toJson_V2ServiceSpecForProviderTemplateVolumesSecretSecretSelector(obj.secretSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum V2ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum V2ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSource
 */
export interface V2ServiceSpecForProviderTemplateContainersEnvValueSource {
  /**
   * Selects a secret and a specific version from Cloud Secret Manager. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSource#secretKeyRef
   */
  readonly secretKeyRef?: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef[];

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersEnvValueSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSource(obj: V2ServiceSpecForProviderTemplateContainersEnvValueSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': obj.secretKeyRef?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeGrpc
 */
export interface V2ServiceSpecForProviderTemplateContainersLivenessProbeGrpc {
  /**
   * Port number to access on the container. Must be in the range 1 to 65535. If not specified, defaults to 8080.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeGrpc#port
   */
  readonly port?: number;

  /**
   * The name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersLivenessProbeGrpc(obj: V2ServiceSpecForProviderTemplateContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGet
 */
export interface V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGet {
  /**
   * Custom headers to set in the request. HTTP allows repeated headers. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * The relative path of the secret in the container.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Port number to access on the container. Must be in the range 1 to 65535. If not specified, defaults to 8080.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGet#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGet(obj: V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpHeaders': obj.httpHeaders?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeTcpSocket
 */
export interface V2ServiceSpecForProviderTemplateContainersLivenessProbeTcpSocket {
  /**
   * Port number to access on the container. Must be in the range 1 to 65535. If not specified, defaults to 8080.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeTcpSocket#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersLivenessProbeTcpSocket(obj: V2ServiceSpecForProviderTemplateContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeGrpc
 */
export interface V2ServiceSpecForProviderTemplateContainersStartupProbeGrpc {
  /**
   * Port number to access on the container. Must be in the range 1 to 65535. If not specified, defaults to 8080.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeGrpc#port
   */
  readonly port?: number;

  /**
   * The name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersStartupProbeGrpc(obj: V2ServiceSpecForProviderTemplateContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGet
 */
export interface V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGet {
  /**
   * Custom headers to set in the request. HTTP allows repeated headers. Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * The relative path of the secret in the container.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Port number to access on the container. Must be in the range 1 to 65535. If not specified, defaults to 8080.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGet#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGet(obj: V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpHeaders': obj.httpHeaders?.map(y => toJson_V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeTcpSocket
 */
export interface V2ServiceSpecForProviderTemplateContainersStartupProbeTcpSocket {
  /**
   * Port number to access on the container. Must be in the range 1 to 65535. If not specified, defaults to 8080.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeTcpSocket#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersStartupProbeTcpSocket(obj: V2ServiceSpecForProviderTemplateContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateVolumesSecretItems
 */
export interface V2ServiceSpecForProviderTemplateVolumesSecretItems {
  /**
   * Integer octal mode bits to use on this file, must be a value between 01 and 0777 (octal). If 0 or not set, the Volume's default mode will be used.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretItems#mode
   */
  readonly mode: number;

  /**
   * The relative path of the secret in the container.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretItems#path
   */
  readonly path: string;

  /**
   * The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretItems#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateVolumesSecretItems(obj: V2ServiceSpecForProviderTemplateVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'path': obj.path,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretmanager to populate secret.
 *
 * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretRef
 */
export interface V2ServiceSpecForProviderTemplateVolumesSecretSecretRef {
  /**
   * Name of the referenced object.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretRef#policy
   */
  readonly policy?: V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicy;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateVolumesSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateVolumesSecretSecretRef(obj: V2ServiceSpecForProviderTemplateVolumesSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretmanager to populate secret.
 *
 * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretSelector
 */
export interface V2ServiceSpecForProviderTemplateVolumesSecretSecretSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretSelector#policy
   */
  readonly policy?: V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicy;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateVolumesSecretSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateVolumesSecretSecretSelector(obj: V2ServiceSpecForProviderTemplateVolumesSecretSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef
 */
export interface V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef {
  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret Structure is documented below.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef#secret
   */
  readonly secret?: string;

  /**
   * Reference to a Secret in secretmanager to populate secret.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef#secretRef
   */
  readonly secretRef?: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRef;

  /**
   * Selector for a Secret in secretmanager to populate secret.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef#secretSelector
   */
  readonly secretSelector?: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelector;

  /**
   * The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef(obj: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': obj.secret,
    'secretRef': toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRef(obj.secretRef),
    'secretSelector': toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelector(obj.secretSelector),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGetHttpHeaders
 */
export interface V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * Volume's name.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGetHttpHeaders(obj: V2ServiceSpecForProviderTemplateContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGetHttpHeaders
 */
export interface V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGetHttpHeaders {
  /**
   * Volume's name.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGetHttpHeaders(obj: V2ServiceSpecForProviderTemplateContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicy
 */
export interface V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicy#resolution
   */
  readonly resolution?: V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicy#resolve
   */
  readonly resolve?: V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicyResolve;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicy(obj: V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicy
 */
export interface V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicy#resolution
   */
  readonly resolution?: V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicy#resolve
   */
  readonly resolve?: V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicyResolve;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicy(obj: V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretmanager to populate secret.
 *
 * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRef
 */
export interface V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRef {
  /**
   * Name of the referenced object.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRef#policy
   */
  readonly policy?: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRef(obj: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretmanager to populate secret.
 *
 * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelector
 */
export interface V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelector#policy
   */
  readonly policy?: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelector(obj: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicyResolution
 */
export enum V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicyResolve
 */
export enum V2ServiceSpecForProviderTemplateVolumesSecretSecretRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicyResolution
 */
export enum V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicyResolve
 */
export enum V2ServiceSpecForProviderTemplateVolumesSecretSecretSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy
 */
export interface V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy#resolution
   */
  readonly resolution?: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy#resolve
   */
  readonly resolve?: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolve;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy(obj: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy
 */
export interface V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy#resolution
   */
  readonly resolution?: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy#resolve
   */
  readonly resolve?: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolve;

}

/**
 * Converts an object of type 'V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy(obj: V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolution
 */
export enum V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolve
 */
export enum V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolution
 */
export enum V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolve
 */
export enum V2ServiceSpecForProviderTemplateContainersEnvValueSourceSecretKeyRefSecretSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

