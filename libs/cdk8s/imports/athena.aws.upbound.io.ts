// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Database is the Schema for the Databases API. Provides an Athena database.
 *
 * @schema Database
 */
export class Database extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Database"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'athena.aws.upbound.io/v1beta1',
    kind: 'Database',
  }

  /**
   * Renders a Kubernetes manifest for "Database".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatabaseProps): any {
    return {
      ...Database.GVK,
      ...toJson_DatabaseProps(props),
    };
  }

  /**
   * Defines a "Database" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatabaseProps) {
    super(scope, id, {
      ...Database.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Database.GVK,
      ...toJson_DatabaseProps(resolved),
    };
  }
}

/**
 * Database is the Schema for the Databases API. Provides an Athena database.
 *
 * @schema Database
 */
export interface DatabaseProps {
  /**
   * @schema Database#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatabaseSpec defines the desired state of Database
   *
   * @schema Database#spec
   */
  readonly spec: DatabaseSpec;

}

/**
 * Converts an object of type 'DatabaseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseProps(obj: DatabaseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatabaseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatabaseSpec defines the desired state of Database
 *
 * @schema DatabaseSpec
 */
export interface DatabaseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DatabaseSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatabaseSpecDeletionPolicy;

  /**
   * @schema DatabaseSpec#forProvider
   */
  readonly forProvider: DatabaseSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DatabaseSpec#managementPolicy
   */
  readonly managementPolicy?: DatabaseSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatabaseSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatabaseSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DatabaseSpec#providerRef
   */
  readonly providerRef?: DatabaseSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatabaseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatabaseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatabaseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatabaseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatabaseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpec(obj: DatabaseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatabaseSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DatabaseSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DatabaseSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DatabaseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatabaseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DatabaseSpecDeletionPolicy
 */
export enum DatabaseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatabaseSpecForProvider
 */
export interface DatabaseSpecForProvider {
  /**
   * That an Amazon S3 canned ACL should be set to control ownership of stored query results. See ACL Configuration below.
   *
   * @schema DatabaseSpecForProvider#aclConfiguration
   */
  readonly aclConfiguration?: DatabaseSpecForProviderAclConfiguration[];

  /**
   * Name of S3 bucket to save the results of the query execution.
   *
   * @schema DatabaseSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema DatabaseSpecForProvider#bucketRef
   */
  readonly bucketRef?: DatabaseSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema DatabaseSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: DatabaseSpecForProviderBucketSelector;

  /**
   * Description of the database.
   *
   * @schema DatabaseSpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * Encryption key block AWS Athena uses to decrypt the data in S3, such as an AWS Key Management Service (AWS KMS) key. See Encryption Configuration below.
   *
   * @schema DatabaseSpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: DatabaseSpecForProviderEncryptionConfiguration[];

  /**
   * AWS account ID that you expect to be the owner of the Amazon S3 bucket.
   *
   * @schema DatabaseSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Boolean that indicates all tables should be deleted from the database so that the database can be destroyed without error. The tables are not recoverable.
   *
   * @schema DatabaseSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * Key-value map of custom metadata properties for the database definition.
   *
   * @schema DatabaseSpecForProvider#properties
   */
  readonly properties?: { [key: string]: string };

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DatabaseSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DatabaseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProvider(obj: DatabaseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aclConfiguration': obj.aclConfiguration?.map(y => toJson_DatabaseSpecForProviderAclConfiguration(y)),
    'bucket': obj.bucket,
    'bucketRef': toJson_DatabaseSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_DatabaseSpecForProviderBucketSelector(obj.bucketSelector),
    'comment': obj.comment,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_DatabaseSpecForProviderEncryptionConfiguration(y)),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'forceDestroy': obj.forceDestroy,
    'properties': ((obj.properties) === undefined) ? undefined : (Object.entries(obj.properties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DatabaseSpecManagementPolicy
 */
export enum DatabaseSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatabaseSpecProviderConfigRef
 */
export interface DatabaseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecProviderConfigRef#policy
   */
  readonly policy?: DatabaseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderConfigRef(obj: DatabaseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DatabaseSpecProviderRef
 */
export interface DatabaseSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecProviderRef#policy
   */
  readonly policy?: DatabaseSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderRef(obj: DatabaseSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatabaseSpecPublishConnectionDetailsTo
 */
export interface DatabaseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatabaseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatabaseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatabaseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsTo(obj: DatabaseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatabaseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatabaseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatabaseSpecWriteConnectionSecretToRef
 */
export interface DatabaseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatabaseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatabaseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatabaseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecWriteConnectionSecretToRef(obj: DatabaseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseSpecForProviderAclConfiguration
 */
export interface DatabaseSpecForProviderAclConfiguration {
  /**
   * Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is BUCKET_OWNER_FULL_CONTROL.
   *
   * @schema DatabaseSpecForProviderAclConfiguration#s3AclOption
   */
  readonly s3AclOption: string;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderAclConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderAclConfiguration(obj: DatabaseSpecForProviderAclConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3AclOption': obj.s3AclOption,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema DatabaseSpecForProviderBucketRef
 */
export interface DatabaseSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecForProviderBucketRef#policy
   */
  readonly policy?: DatabaseSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderBucketRef(obj: DatabaseSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema DatabaseSpecForProviderBucketSelector
 */
export interface DatabaseSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatabaseSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatabaseSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatabaseSpecForProviderBucketSelector#policy
   */
  readonly policy?: DatabaseSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderBucketSelector(obj: DatabaseSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatabaseSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatabaseSpecForProviderEncryptionConfiguration
 */
export interface DatabaseSpecForProviderEncryptionConfiguration {
  /**
   * Type of key; one of SSE_S3, SSE_KMS, CSE_KMS
   *
   * @schema DatabaseSpecForProviderEncryptionConfiguration#encryptionOption
   */
  readonly encryptionOption: string;

  /**
   * KMS key ARN or ID; required for key types SSE_KMS and CSE_KMS.
   *
   * @schema DatabaseSpecForProviderEncryptionConfiguration#kmsKey
   */
  readonly kmsKey?: string;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderEncryptionConfiguration(obj: DatabaseSpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionOption': obj.encryptionOption,
    'kmsKey': obj.kmsKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecProviderConfigRefPolicy
 */
export interface DatabaseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderConfigRefPolicy(obj: DatabaseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecProviderRefPolicy
 */
export interface DatabaseSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecProviderRefPolicy(obj: DatabaseSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRef
 */
export interface DatabaseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToConfigRef(obj: DatabaseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatabaseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToMetadata
 */
export interface DatabaseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToMetadata(obj: DatabaseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecForProviderBucketRefPolicy
 */
export interface DatabaseSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderBucketRefPolicy(obj: DatabaseSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatabaseSpecForProviderBucketSelectorPolicy
 */
export interface DatabaseSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: DatabaseSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: DatabaseSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecForProviderBucketSelectorPolicy(obj: DatabaseSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecProviderConfigRefPolicyResolution
 */
export enum DatabaseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecProviderConfigRefPolicyResolve
 */
export enum DatabaseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecProviderRefPolicyResolution
 */
export enum DatabaseSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecProviderRefPolicyResolve
 */
export enum DatabaseSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatabaseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatabaseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatabaseSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatabaseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecForProviderBucketRefPolicyResolution
 */
export enum DatabaseSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecForProviderBucketRefPolicyResolve
 */
export enum DatabaseSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecForProviderBucketSelectorPolicyResolution
 */
export enum DatabaseSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecForProviderBucketSelectorPolicyResolve
 */
export enum DatabaseSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DataCatalog is the Schema for the DataCatalogs API. Provides an Athena data catalog.
 *
 * @schema DataCatalog
 */
export class DataCatalog extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DataCatalog"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'athena.aws.upbound.io/v1beta1',
    kind: 'DataCatalog',
  }

  /**
   * Renders a Kubernetes manifest for "DataCatalog".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DataCatalogProps): any {
    return {
      ...DataCatalog.GVK,
      ...toJson_DataCatalogProps(props),
    };
  }

  /**
   * Defines a "DataCatalog" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DataCatalogProps) {
    super(scope, id, {
      ...DataCatalog.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DataCatalog.GVK,
      ...toJson_DataCatalogProps(resolved),
    };
  }
}

/**
 * DataCatalog is the Schema for the DataCatalogs API. Provides an Athena data catalog.
 *
 * @schema DataCatalog
 */
export interface DataCatalogProps {
  /**
   * @schema DataCatalog#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DataCatalogSpec defines the desired state of DataCatalog
   *
   * @schema DataCatalog#spec
   */
  readonly spec: DataCatalogSpec;

}

/**
 * Converts an object of type 'DataCatalogProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogProps(obj: DataCatalogProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DataCatalogSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataCatalogSpec defines the desired state of DataCatalog
 *
 * @schema DataCatalogSpec
 */
export interface DataCatalogSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DataCatalogSpec#deletionPolicy
   */
  readonly deletionPolicy?: DataCatalogSpecDeletionPolicy;

  /**
   * @schema DataCatalogSpec#forProvider
   */
  readonly forProvider: DataCatalogSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DataCatalogSpec#managementPolicy
   */
  readonly managementPolicy?: DataCatalogSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DataCatalogSpec#providerConfigRef
   */
  readonly providerConfigRef?: DataCatalogSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DataCatalogSpec#providerRef
   */
  readonly providerRef?: DataCatalogSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DataCatalogSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DataCatalogSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DataCatalogSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DataCatalogSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DataCatalogSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpec(obj: DataCatalogSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DataCatalogSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DataCatalogSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DataCatalogSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DataCatalogSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DataCatalogSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DataCatalogSpecDeletionPolicy
 */
export enum DataCatalogSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DataCatalogSpecForProvider
 */
export interface DataCatalogSpecForProvider {
  /**
   * Description of the data catalog.
   *
   * @schema DataCatalogSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Key value pairs that specifies the Lambda function or functions to use for the data catalog. The mapping used depends on the catalog type.
   *
   * @schema DataCatalogSpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DataCatalogSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DataCatalogSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Type of data catalog: LAMBDA for a federated catalog, GLUE for AWS Glue Catalog, or HIVE for an external hive metastore.
   *
   * @schema DataCatalogSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DataCatalogSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpecForProvider(obj: DataCatalogSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DataCatalogSpecManagementPolicy
 */
export enum DataCatalogSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DataCatalogSpecProviderConfigRef
 */
export interface DataCatalogSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataCatalogSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataCatalogSpecProviderConfigRef#policy
   */
  readonly policy?: DataCatalogSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DataCatalogSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpecProviderConfigRef(obj: DataCatalogSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataCatalogSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DataCatalogSpecProviderRef
 */
export interface DataCatalogSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataCatalogSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataCatalogSpecProviderRef#policy
   */
  readonly policy?: DataCatalogSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DataCatalogSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpecProviderRef(obj: DataCatalogSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataCatalogSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DataCatalogSpecPublishConnectionDetailsTo
 */
export interface DataCatalogSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DataCatalogSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DataCatalogSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DataCatalogSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DataCatalogSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DataCatalogSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DataCatalogSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpecPublishConnectionDetailsTo(obj: DataCatalogSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DataCatalogSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DataCatalogSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DataCatalogSpecWriteConnectionSecretToRef
 */
export interface DataCatalogSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DataCatalogSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DataCatalogSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DataCatalogSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpecWriteConnectionSecretToRef(obj: DataCatalogSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataCatalogSpecProviderConfigRefPolicy
 */
export interface DataCatalogSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataCatalogSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DataCatalogSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataCatalogSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DataCatalogSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataCatalogSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpecProviderConfigRefPolicy(obj: DataCatalogSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataCatalogSpecProviderRefPolicy
 */
export interface DataCatalogSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataCatalogSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DataCatalogSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataCatalogSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DataCatalogSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DataCatalogSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpecProviderRefPolicy(obj: DataCatalogSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DataCatalogSpecPublishConnectionDetailsToConfigRef
 */
export interface DataCatalogSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataCatalogSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataCatalogSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DataCatalogSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DataCatalogSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpecPublishConnectionDetailsToConfigRef(obj: DataCatalogSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataCatalogSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DataCatalogSpecPublishConnectionDetailsToMetadata
 */
export interface DataCatalogSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataCatalogSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataCatalogSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DataCatalogSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DataCatalogSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpecPublishConnectionDetailsToMetadata(obj: DataCatalogSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataCatalogSpecProviderConfigRefPolicyResolution
 */
export enum DataCatalogSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataCatalogSpecProviderConfigRefPolicyResolve
 */
export enum DataCatalogSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataCatalogSpecProviderRefPolicyResolution
 */
export enum DataCatalogSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataCatalogSpecProviderRefPolicyResolve
 */
export enum DataCatalogSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DataCatalogSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DataCatalogSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataCatalogSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DataCatalogSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataCatalogSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DataCatalogSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataCatalogSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogSpecPublishConnectionDetailsToConfigRefPolicy(obj: DataCatalogSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataCatalogSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DataCatalogSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataCatalogSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DataCatalogSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * NamedQuery is the Schema for the NamedQuerys API. Provides an Athena Named Query resource.
 *
 * @schema NamedQuery
 */
export class NamedQuery extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NamedQuery"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'athena.aws.upbound.io/v1beta1',
    kind: 'NamedQuery',
  }

  /**
   * Renders a Kubernetes manifest for "NamedQuery".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NamedQueryProps): any {
    return {
      ...NamedQuery.GVK,
      ...toJson_NamedQueryProps(props),
    };
  }

  /**
   * Defines a "NamedQuery" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NamedQueryProps) {
    super(scope, id, {
      ...NamedQuery.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NamedQuery.GVK,
      ...toJson_NamedQueryProps(resolved),
    };
  }
}

/**
 * NamedQuery is the Schema for the NamedQuerys API. Provides an Athena Named Query resource.
 *
 * @schema NamedQuery
 */
export interface NamedQueryProps {
  /**
   * @schema NamedQuery#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NamedQuerySpec defines the desired state of NamedQuery
   *
   * @schema NamedQuery#spec
   */
  readonly spec: NamedQuerySpec;

}

/**
 * Converts an object of type 'NamedQueryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQueryProps(obj: NamedQueryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NamedQuerySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamedQuerySpec defines the desired state of NamedQuery
 *
 * @schema NamedQuerySpec
 */
export interface NamedQuerySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NamedQuerySpec#deletionPolicy
   */
  readonly deletionPolicy?: NamedQuerySpecDeletionPolicy;

  /**
   * @schema NamedQuerySpec#forProvider
   */
  readonly forProvider: NamedQuerySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NamedQuerySpec#managementPolicy
   */
  readonly managementPolicy?: NamedQuerySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NamedQuerySpec#providerConfigRef
   */
  readonly providerConfigRef?: NamedQuerySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema NamedQuerySpec#providerRef
   */
  readonly providerRef?: NamedQuerySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NamedQuerySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NamedQuerySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NamedQuerySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NamedQuerySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NamedQuerySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpec(obj: NamedQuerySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NamedQuerySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_NamedQuerySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_NamedQuerySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_NamedQuerySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NamedQuerySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NamedQuerySpecDeletionPolicy
 */
export enum NamedQuerySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NamedQuerySpecForProvider
 */
export interface NamedQuerySpecForProvider {
  /**
   * Database to which the query belongs.
   *
   * @schema NamedQuerySpecForProvider#database
   */
  readonly database?: string;

  /**
   * Reference to a Database in athena to populate database.
   *
   * @schema NamedQuerySpecForProvider#databaseRef
   */
  readonly databaseRef?: NamedQuerySpecForProviderDatabaseRef;

  /**
   * Selector for a Database in athena to populate database.
   *
   * @schema NamedQuerySpecForProvider#databaseSelector
   */
  readonly databaseSelector?: NamedQuerySpecForProviderDatabaseSelector;

  /**
   * Brief explanation of the query. Maximum length of 1024.
   *
   * @schema NamedQuerySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Plain language name for the query. Maximum length of 128.
   *
   * @schema NamedQuerySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Text of the query itself. In other words, all query statements. Maximum length of 262144.
   *
   * @schema NamedQuerySpecForProvider#query
   */
  readonly query?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema NamedQuerySpecForProvider#region
   */
  readonly region: string;

  /**
   * Workgroup to which the query belongs. Defaults to primary
   *
   * @default primary
   * @schema NamedQuerySpecForProvider#workgroup
   */
  readonly workgroup?: string;

  /**
   * Reference to a Workgroup in athena to populate workgroup.
   *
   * @schema NamedQuerySpecForProvider#workgroupRef
   */
  readonly workgroupRef?: NamedQuerySpecForProviderWorkgroupRef;

  /**
   * Selector for a Workgroup in athena to populate workgroup.
   *
   * @schema NamedQuerySpecForProvider#workgroupSelector
   */
  readonly workgroupSelector?: NamedQuerySpecForProviderWorkgroupSelector;

}

/**
 * Converts an object of type 'NamedQuerySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecForProvider(obj: NamedQuerySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'databaseRef': toJson_NamedQuerySpecForProviderDatabaseRef(obj.databaseRef),
    'databaseSelector': toJson_NamedQuerySpecForProviderDatabaseSelector(obj.databaseSelector),
    'description': obj.description,
    'name': obj.name,
    'query': obj.query,
    'region': obj.region,
    'workgroup': obj.workgroup,
    'workgroupRef': toJson_NamedQuerySpecForProviderWorkgroupRef(obj.workgroupRef),
    'workgroupSelector': toJson_NamedQuerySpecForProviderWorkgroupSelector(obj.workgroupSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NamedQuerySpecManagementPolicy
 */
export enum NamedQuerySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NamedQuerySpecProviderConfigRef
 */
export interface NamedQuerySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NamedQuerySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NamedQuerySpecProviderConfigRef#policy
   */
  readonly policy?: NamedQuerySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NamedQuerySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecProviderConfigRef(obj: NamedQuerySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NamedQuerySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema NamedQuerySpecProviderRef
 */
export interface NamedQuerySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema NamedQuerySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NamedQuerySpecProviderRef#policy
   */
  readonly policy?: NamedQuerySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'NamedQuerySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecProviderRef(obj: NamedQuerySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NamedQuerySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NamedQuerySpecPublishConnectionDetailsTo
 */
export interface NamedQuerySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NamedQuerySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NamedQuerySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NamedQuerySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NamedQuerySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NamedQuerySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NamedQuerySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecPublishConnectionDetailsTo(obj: NamedQuerySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NamedQuerySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NamedQuerySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NamedQuerySpecWriteConnectionSecretToRef
 */
export interface NamedQuerySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NamedQuerySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NamedQuerySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NamedQuerySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecWriteConnectionSecretToRef(obj: NamedQuerySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Database in athena to populate database.
 *
 * @schema NamedQuerySpecForProviderDatabaseRef
 */
export interface NamedQuerySpecForProviderDatabaseRef {
  /**
   * Name of the referenced object.
   *
   * @schema NamedQuerySpecForProviderDatabaseRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NamedQuerySpecForProviderDatabaseRef#policy
   */
  readonly policy?: NamedQuerySpecForProviderDatabaseRefPolicy;

}

/**
 * Converts an object of type 'NamedQuerySpecForProviderDatabaseRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecForProviderDatabaseRef(obj: NamedQuerySpecForProviderDatabaseRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NamedQuerySpecForProviderDatabaseRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Database in athena to populate database.
 *
 * @schema NamedQuerySpecForProviderDatabaseSelector
 */
export interface NamedQuerySpecForProviderDatabaseSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NamedQuerySpecForProviderDatabaseSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NamedQuerySpecForProviderDatabaseSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NamedQuerySpecForProviderDatabaseSelector#policy
   */
  readonly policy?: NamedQuerySpecForProviderDatabaseSelectorPolicy;

}

/**
 * Converts an object of type 'NamedQuerySpecForProviderDatabaseSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecForProviderDatabaseSelector(obj: NamedQuerySpecForProviderDatabaseSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NamedQuerySpecForProviderDatabaseSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workgroup in athena to populate workgroup.
 *
 * @schema NamedQuerySpecForProviderWorkgroupRef
 */
export interface NamedQuerySpecForProviderWorkgroupRef {
  /**
   * Name of the referenced object.
   *
   * @schema NamedQuerySpecForProviderWorkgroupRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NamedQuerySpecForProviderWorkgroupRef#policy
   */
  readonly policy?: NamedQuerySpecForProviderWorkgroupRefPolicy;

}

/**
 * Converts an object of type 'NamedQuerySpecForProviderWorkgroupRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecForProviderWorkgroupRef(obj: NamedQuerySpecForProviderWorkgroupRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NamedQuerySpecForProviderWorkgroupRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workgroup in athena to populate workgroup.
 *
 * @schema NamedQuerySpecForProviderWorkgroupSelector
 */
export interface NamedQuerySpecForProviderWorkgroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NamedQuerySpecForProviderWorkgroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NamedQuerySpecForProviderWorkgroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NamedQuerySpecForProviderWorkgroupSelector#policy
   */
  readonly policy?: NamedQuerySpecForProviderWorkgroupSelectorPolicy;

}

/**
 * Converts an object of type 'NamedQuerySpecForProviderWorkgroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecForProviderWorkgroupSelector(obj: NamedQuerySpecForProviderWorkgroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NamedQuerySpecForProviderWorkgroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NamedQuerySpecProviderConfigRefPolicy
 */
export interface NamedQuerySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NamedQuerySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NamedQuerySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NamedQuerySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NamedQuerySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NamedQuerySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecProviderConfigRefPolicy(obj: NamedQuerySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NamedQuerySpecProviderRefPolicy
 */
export interface NamedQuerySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NamedQuerySpecProviderRefPolicy#resolution
   */
  readonly resolution?: NamedQuerySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NamedQuerySpecProviderRefPolicy#resolve
   */
  readonly resolve?: NamedQuerySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'NamedQuerySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecProviderRefPolicy(obj: NamedQuerySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NamedQuerySpecPublishConnectionDetailsToConfigRef
 */
export interface NamedQuerySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NamedQuerySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NamedQuerySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NamedQuerySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NamedQuerySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecPublishConnectionDetailsToConfigRef(obj: NamedQuerySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NamedQuerySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NamedQuerySpecPublishConnectionDetailsToMetadata
 */
export interface NamedQuerySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NamedQuerySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NamedQuerySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NamedQuerySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NamedQuerySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecPublishConnectionDetailsToMetadata(obj: NamedQuerySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NamedQuerySpecForProviderDatabaseRefPolicy
 */
export interface NamedQuerySpecForProviderDatabaseRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NamedQuerySpecForProviderDatabaseRefPolicy#resolution
   */
  readonly resolution?: NamedQuerySpecForProviderDatabaseRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NamedQuerySpecForProviderDatabaseRefPolicy#resolve
   */
  readonly resolve?: NamedQuerySpecForProviderDatabaseRefPolicyResolve;

}

/**
 * Converts an object of type 'NamedQuerySpecForProviderDatabaseRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecForProviderDatabaseRefPolicy(obj: NamedQuerySpecForProviderDatabaseRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NamedQuerySpecForProviderDatabaseSelectorPolicy
 */
export interface NamedQuerySpecForProviderDatabaseSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NamedQuerySpecForProviderDatabaseSelectorPolicy#resolution
   */
  readonly resolution?: NamedQuerySpecForProviderDatabaseSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NamedQuerySpecForProviderDatabaseSelectorPolicy#resolve
   */
  readonly resolve?: NamedQuerySpecForProviderDatabaseSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NamedQuerySpecForProviderDatabaseSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecForProviderDatabaseSelectorPolicy(obj: NamedQuerySpecForProviderDatabaseSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NamedQuerySpecForProviderWorkgroupRefPolicy
 */
export interface NamedQuerySpecForProviderWorkgroupRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NamedQuerySpecForProviderWorkgroupRefPolicy#resolution
   */
  readonly resolution?: NamedQuerySpecForProviderWorkgroupRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NamedQuerySpecForProviderWorkgroupRefPolicy#resolve
   */
  readonly resolve?: NamedQuerySpecForProviderWorkgroupRefPolicyResolve;

}

/**
 * Converts an object of type 'NamedQuerySpecForProviderWorkgroupRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecForProviderWorkgroupRefPolicy(obj: NamedQuerySpecForProviderWorkgroupRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NamedQuerySpecForProviderWorkgroupSelectorPolicy
 */
export interface NamedQuerySpecForProviderWorkgroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NamedQuerySpecForProviderWorkgroupSelectorPolicy#resolution
   */
  readonly resolution?: NamedQuerySpecForProviderWorkgroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NamedQuerySpecForProviderWorkgroupSelectorPolicy#resolve
   */
  readonly resolve?: NamedQuerySpecForProviderWorkgroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NamedQuerySpecForProviderWorkgroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecForProviderWorkgroupSelectorPolicy(obj: NamedQuerySpecForProviderWorkgroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NamedQuerySpecProviderConfigRefPolicyResolution
 */
export enum NamedQuerySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NamedQuerySpecProviderConfigRefPolicyResolve
 */
export enum NamedQuerySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NamedQuerySpecProviderRefPolicyResolution
 */
export enum NamedQuerySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NamedQuerySpecProviderRefPolicyResolve
 */
export enum NamedQuerySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NamedQuerySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NamedQuerySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NamedQuerySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NamedQuerySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NamedQuerySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NamedQuerySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NamedQuerySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NamedQuerySpecPublishConnectionDetailsToConfigRefPolicy(obj: NamedQuerySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NamedQuerySpecForProviderDatabaseRefPolicyResolution
 */
export enum NamedQuerySpecForProviderDatabaseRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NamedQuerySpecForProviderDatabaseRefPolicyResolve
 */
export enum NamedQuerySpecForProviderDatabaseRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NamedQuerySpecForProviderDatabaseSelectorPolicyResolution
 */
export enum NamedQuerySpecForProviderDatabaseSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NamedQuerySpecForProviderDatabaseSelectorPolicyResolve
 */
export enum NamedQuerySpecForProviderDatabaseSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NamedQuerySpecForProviderWorkgroupRefPolicyResolution
 */
export enum NamedQuerySpecForProviderWorkgroupRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NamedQuerySpecForProviderWorkgroupRefPolicyResolve
 */
export enum NamedQuerySpecForProviderWorkgroupRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NamedQuerySpecForProviderWorkgroupSelectorPolicyResolution
 */
export enum NamedQuerySpecForProviderWorkgroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NamedQuerySpecForProviderWorkgroupSelectorPolicyResolve
 */
export enum NamedQuerySpecForProviderWorkgroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NamedQuerySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NamedQuerySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NamedQuerySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NamedQuerySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Workgroup is the Schema for the Workgroups API. Manages an Athena Workgroup.
 *
 * @schema Workgroup
 */
export class Workgroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Workgroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'athena.aws.upbound.io/v1beta1',
    kind: 'Workgroup',
  }

  /**
   * Renders a Kubernetes manifest for "Workgroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkgroupProps): any {
    return {
      ...Workgroup.GVK,
      ...toJson_WorkgroupProps(props),
    };
  }

  /**
   * Defines a "Workgroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkgroupProps) {
    super(scope, id, {
      ...Workgroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Workgroup.GVK,
      ...toJson_WorkgroupProps(resolved),
    };
  }
}

/**
 * Workgroup is the Schema for the Workgroups API. Manages an Athena Workgroup.
 *
 * @schema Workgroup
 */
export interface WorkgroupProps {
  /**
   * @schema Workgroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkgroupSpec defines the desired state of Workgroup
   *
   * @schema Workgroup#spec
   */
  readonly spec: WorkgroupSpec;

}

/**
 * Converts an object of type 'WorkgroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupProps(obj: WorkgroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkgroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkgroupSpec defines the desired state of Workgroup
 *
 * @schema WorkgroupSpec
 */
export interface WorkgroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkgroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkgroupSpecDeletionPolicy;

  /**
   * @schema WorkgroupSpec#forProvider
   */
  readonly forProvider: WorkgroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkgroupSpec#managementPolicy
   */
  readonly managementPolicy?: WorkgroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkgroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkgroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WorkgroupSpec#providerRef
   */
  readonly providerRef?: WorkgroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkgroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkgroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkgroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkgroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkgroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpec(obj: WorkgroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkgroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_WorkgroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WorkgroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WorkgroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkgroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkgroupSpecDeletionPolicy
 */
export enum WorkgroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkgroupSpecForProvider
 */
export interface WorkgroupSpecForProvider {
  /**
   * Configuration block with various settings for the workgroup. Documented below.
   *
   * @schema WorkgroupSpecForProvider#configuration
   */
  readonly configuration?: WorkgroupSpecForProviderConfiguration[];

  /**
   * Description of the workgroup.
   *
   * @schema WorkgroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Option to delete the workgroup and its contents even if the workgroup contains any named queries.
   *
   * @schema WorkgroupSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkgroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * State of the workgroup. Valid values are DISABLED or ENABLED. Defaults to ENABLED.
   *
   * @default ENABLED.
   * @schema WorkgroupSpecForProvider#state
   */
  readonly state?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkgroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkgroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProvider(obj: WorkgroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration?.map(y => toJson_WorkgroupSpecForProviderConfiguration(y)),
    'description': obj.description,
    'forceDestroy': obj.forceDestroy,
    'region': obj.region,
    'state': obj.state,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkgroupSpecManagementPolicy
 */
export enum WorkgroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkgroupSpecProviderConfigRef
 */
export interface WorkgroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkgroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkgroupSpecProviderConfigRef#policy
   */
  readonly policy?: WorkgroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecProviderConfigRef(obj: WorkgroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkgroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WorkgroupSpecProviderRef
 */
export interface WorkgroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkgroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkgroupSpecProviderRef#policy
   */
  readonly policy?: WorkgroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecProviderRef(obj: WorkgroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkgroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsTo
 */
export interface WorkgroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkgroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkgroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkgroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecPublishConnectionDetailsTo(obj: WorkgroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkgroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkgroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkgroupSpecWriteConnectionSecretToRef
 */
export interface WorkgroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkgroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkgroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkgroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecWriteConnectionSecretToRef(obj: WorkgroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkgroupSpecForProviderConfiguration
 */
export interface WorkgroupSpecForProviderConfiguration {
  /**
   * Integer for the upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan. Must be at least 10485760.
   *
   * @schema WorkgroupSpecForProviderConfiguration#bytesScannedCutoffPerQuery
   */
  readonly bytesScannedCutoffPerQuery?: number;

  /**
   * Boolean whether the settings for the workgroup override client-side settings. For more information, see Workgroup Settings Override Client-Side Settings. Defaults to true.
   *
   * @default true.
   * @schema WorkgroupSpecForProviderConfiguration#enforceWorkgroupConfiguration
   */
  readonly enforceWorkgroupConfiguration?: boolean;

  /**
   * Configuration block for the Athena Engine Versioning. For more information, see Athena Engine Versioning. See Engine Version below.
   *
   * @schema WorkgroupSpecForProviderConfiguration#engineVersion
   */
  readonly engineVersion?: WorkgroupSpecForProviderConfigurationEngineVersion[];

  /**
   * Role used in a notebook session for accessing the user's resources.
   *
   * @schema WorkgroupSpecForProviderConfiguration#executionRole
   */
  readonly executionRole?: string;

  /**
   * Boolean whether Amazon CloudWatch metrics are enabled for the workgroup. Defaults to true.
   *
   * @default true.
   * @schema WorkgroupSpecForProviderConfiguration#publishCloudwatchMetricsEnabled
   */
  readonly publishCloudwatchMetricsEnabled?: boolean;

  /**
   * If set to true , allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to false , workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false . For more information about Requester Pays buckets, see Requester Pays Buckets in the Amazon Simple Storage Service Developer Guide.
   *
   * @schema WorkgroupSpecForProviderConfiguration#requesterPaysEnabled
   */
  readonly requesterPaysEnabled?: boolean;

  /**
   * Configuration block with result settings. See Result Configuration below.
   *
   * @schema WorkgroupSpecForProviderConfiguration#resultConfiguration
   */
  readonly resultConfiguration?: WorkgroupSpecForProviderConfigurationResultConfiguration[];

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderConfiguration(obj: WorkgroupSpecForProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bytesScannedCutoffPerQuery': obj.bytesScannedCutoffPerQuery,
    'enforceWorkgroupConfiguration': obj.enforceWorkgroupConfiguration,
    'engineVersion': obj.engineVersion?.map(y => toJson_WorkgroupSpecForProviderConfigurationEngineVersion(y)),
    'executionRole': obj.executionRole,
    'publishCloudwatchMetricsEnabled': obj.publishCloudwatchMetricsEnabled,
    'requesterPaysEnabled': obj.requesterPaysEnabled,
    'resultConfiguration': obj.resultConfiguration?.map(y => toJson_WorkgroupSpecForProviderConfigurationResultConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkgroupSpecProviderConfigRefPolicy
 */
export interface WorkgroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecProviderConfigRefPolicy(obj: WorkgroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkgroupSpecProviderRefPolicy
 */
export interface WorkgroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecProviderRefPolicy(obj: WorkgroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkgroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecPublishConnectionDetailsToConfigRef(obj: WorkgroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsToMetadata
 */
export interface WorkgroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkgroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecPublishConnectionDetailsToMetadata(obj: WorkgroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkgroupSpecForProviderConfigurationEngineVersion
 */
export interface WorkgroupSpecForProviderConfigurationEngineVersion {
  /**
   * Requested engine version. Defaults to AUTO.
   *
   * @default AUTO.
   * @schema WorkgroupSpecForProviderConfigurationEngineVersion#selectedEngineVersion
   */
  readonly selectedEngineVersion?: string;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderConfigurationEngineVersion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderConfigurationEngineVersion(obj: WorkgroupSpecForProviderConfigurationEngineVersion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'selectedEngineVersion': obj.selectedEngineVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkgroupSpecForProviderConfigurationResultConfiguration
 */
export interface WorkgroupSpecForProviderConfigurationResultConfiguration {
  /**
   * That an Amazon S3 canned ACL should be set to control ownership of stored query results. See ACL Configuration below.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfiguration#aclConfiguration
   */
  readonly aclConfiguration?: WorkgroupSpecForProviderConfigurationResultConfigurationAclConfiguration[];

  /**
   * Configuration block with encryption settings. See Encryption Configuration below.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfiguration#encryptionConfiguration
   */
  readonly encryptionConfiguration?: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration[];

  /**
   * AWS account ID that you expect to be the owner of the Amazon S3 bucket.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfiguration#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Location in Amazon S3 where your query results are stored, such as s3://path/to/query/bucket/. For more information, see Queries and Query Result Files.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfiguration#outputLocation
   */
  readonly outputLocation?: string;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderConfigurationResultConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderConfigurationResultConfiguration(obj: WorkgroupSpecForProviderConfigurationResultConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aclConfiguration': obj.aclConfiguration?.map(y => toJson_WorkgroupSpecForProviderConfigurationResultConfigurationAclConfiguration(y)),
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration(y)),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'outputLocation': obj.outputLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecProviderConfigRefPolicyResolution
 */
export enum WorkgroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecProviderConfigRefPolicyResolve
 */
export enum WorkgroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecProviderRefPolicyResolution
 */
export enum WorkgroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecProviderRefPolicyResolve
 */
export enum WorkgroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkgroupSpecForProviderConfigurationResultConfigurationAclConfiguration
 */
export interface WorkgroupSpecForProviderConfigurationResultConfigurationAclConfiguration {
  /**
   * Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is BUCKET_OWNER_FULL_CONTROL.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationAclConfiguration#s3AclOption
   */
  readonly s3AclOption: string;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderConfigurationResultConfigurationAclConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderConfigurationResultConfigurationAclConfiguration(obj: WorkgroupSpecForProviderConfigurationResultConfigurationAclConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3AclOption': obj.s3AclOption,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration
 */
export interface WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration {
  /**
   * Whether Amazon S3 server-side encryption with Amazon S3-managed keys (SSE_S3), server-side encryption with KMS-managed keys (SSE_KMS), or client-side encryption with KMS-managed keys (CSE_KMS) is used. If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration#encryptionOption
   */
  readonly encryptionOption?: string;

  /**
   * For SSE_KMS and CSE_KMS, this is the KMS key ARN.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelector;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration(obj: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionOption': obj.encryptionOption,
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelector(obj.kmsKeyArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRef
 */
export interface WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRef#policy
   */
  readonly policy?: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRef(obj: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelector
 */
export interface WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelector#policy
   */
  readonly policy?: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelector(obj: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicy
 */
export interface WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicy(obj: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicy
 */
export interface WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicy(obj: WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicyResolution
 */
export enum WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicyResolve
 */
export enum WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicyResolution
 */
export enum WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicyResolve
 */
export enum WorkgroupSpecForProviderConfigurationResultConfigurationEncryptionConfigurationKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

