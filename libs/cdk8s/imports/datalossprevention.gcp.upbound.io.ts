// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DeidentifyTemplate is the Schema for the DeidentifyTemplates API. Allows creation of templates to de-identify content.
 *
 * @schema DeidentifyTemplate
 */
export class DeidentifyTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DeidentifyTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datalossprevention.gcp.upbound.io/v1beta1',
    kind: 'DeidentifyTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "DeidentifyTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeidentifyTemplateProps): any {
    return {
      ...DeidentifyTemplate.GVK,
      ...toJson_DeidentifyTemplateProps(props),
    };
  }

  /**
   * Defines a "DeidentifyTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeidentifyTemplateProps) {
    super(scope, id, {
      ...DeidentifyTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DeidentifyTemplate.GVK,
      ...toJson_DeidentifyTemplateProps(resolved),
    };
  }
}

/**
 * DeidentifyTemplate is the Schema for the DeidentifyTemplates API. Allows creation of templates to de-identify content.
 *
 * @schema DeidentifyTemplate
 */
export interface DeidentifyTemplateProps {
  /**
   * @schema DeidentifyTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeidentifyTemplateSpec defines the desired state of DeidentifyTemplate
   *
   * @schema DeidentifyTemplate#spec
   */
  readonly spec: DeidentifyTemplateSpec;

}

/**
 * Converts an object of type 'DeidentifyTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateProps(obj: DeidentifyTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeidentifyTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeidentifyTemplateSpec defines the desired state of DeidentifyTemplate
 *
 * @schema DeidentifyTemplateSpec
 */
export interface DeidentifyTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DeidentifyTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeidentifyTemplateSpecDeletionPolicy;

  /**
   * @schema DeidentifyTemplateSpec#forProvider
   */
  readonly forProvider: DeidentifyTemplateSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeidentifyTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeidentifyTemplateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DeidentifyTemplateSpec#providerRef
   */
  readonly providerRef?: DeidentifyTemplateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeidentifyTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeidentifyTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeidentifyTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeidentifyTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpec(obj: DeidentifyTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeidentifyTemplateSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DeidentifyTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DeidentifyTemplateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DeidentifyTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeidentifyTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DeidentifyTemplateSpecDeletionPolicy
 */
export enum DeidentifyTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeidentifyTemplateSpecForProvider
 */
export interface DeidentifyTemplateSpecForProvider {
  /**
   * Configuration of the deidentify template Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProvider#deidentifyConfig
   */
  readonly deidentifyConfig: DeidentifyTemplateSpecForProviderDeidentifyConfig[];

  /**
   * A description of the template.
   *
   * @schema DeidentifyTemplateSpecForProvider#description
   */
  readonly description?: string;

  /**
   * User set display name of the template.
   *
   * @schema DeidentifyTemplateSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The parent of the template in any of the following formats:
   *
   * @schema DeidentifyTemplateSpecForProvider#parent
   */
  readonly parent: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProvider(obj: DeidentifyTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deidentifyConfig': obj.deidentifyConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfig(y)),
    'description': obj.description,
    'displayName': obj.displayName,
    'parent': obj.parent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeidentifyTemplateSpecProviderConfigRef
 */
export interface DeidentifyTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeidentifyTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeidentifyTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: DeidentifyTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecProviderConfigRef(obj: DeidentifyTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeidentifyTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DeidentifyTemplateSpecProviderRef
 */
export interface DeidentifyTemplateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeidentifyTemplateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeidentifyTemplateSpecProviderRef#policy
   */
  readonly policy?: DeidentifyTemplateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecProviderRef(obj: DeidentifyTemplateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeidentifyTemplateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsTo
 */
export interface DeidentifyTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeidentifyTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecPublishConnectionDetailsTo(obj: DeidentifyTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeidentifyTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeidentifyTemplateSpecWriteConnectionSecretToRef
 */
export interface DeidentifyTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeidentifyTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeidentifyTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecWriteConnectionSecretToRef(obj: DeidentifyTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfig {
  /**
   * Treat the dataset as free-form text and apply the same free text transformation everywhere Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfig#infoTypeTransformations
   */
  readonly infoTypeTransformations?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations[];

  /**
   * Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfig#recordTransformations
   */
  readonly recordTransformations?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypeTransformations': obj.infoTypeTransformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations(y)),
    'recordTransformations': obj.recordTransformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeidentifyTemplateSpecProviderConfigRefPolicy
 */
export interface DeidentifyTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeidentifyTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeidentifyTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeidentifyTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeidentifyTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecProviderConfigRefPolicy(obj: DeidentifyTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeidentifyTemplateSpecProviderRefPolicy
 */
export interface DeidentifyTemplateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeidentifyTemplateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DeidentifyTemplateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeidentifyTemplateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DeidentifyTemplateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecProviderRefPolicy(obj: DeidentifyTemplateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef(obj: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface DeidentifyTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecPublishConnectionDetailsToMetadata(obj: DeidentifyTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations {
  /**
   * Transformation for each infoType. Cannot specify more than one for a given infoType. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations#transformations
   */
  readonly transformations: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transformations': obj.transformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations {
  /**
   * Transform the record by applying various field transformations. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations#fieldTransformations
   */
  readonly fieldTransformations?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations[];

  /**
   * Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations#recordSuppressions
   */
  readonly recordSuppressions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldTransformations': obj.fieldTransformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations(y)),
    'recordSuppressions': obj.recordSuppressions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeidentifyTemplateSpecProviderConfigRefPolicyResolution
 */
export enum DeidentifyTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeidentifyTemplateSpecProviderConfigRefPolicyResolve
 */
export enum DeidentifyTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeidentifyTemplateSpecProviderRefPolicyResolution
 */
export enum DeidentifyTemplateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeidentifyTemplateSpecProviderRefPolicyResolve
 */
export enum DeidentifyTemplateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations {
  /**
   * InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to all findings that correspond to infoTypes that were requested in InspectConfig. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations#infoTypes
   */
  readonly infoTypes?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes[];

  /**
   * Primitive transformation to apply to the infoType. The primitive_transformation block must only contain one argument, corresponding to the type of transformation. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations#primitiveTransformation
   */
  readonly primitiveTransformation: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes(y)),
    'primitiveTransformation': obj.primitiveTransformation?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations {
  /**
   * A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations#condition
   */
  readonly condition?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition[];

  /**
   * Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId. FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type". Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations#fields
   */
  readonly fields: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields[];

  /**
   * Primitive transformation to apply to the infoType. The primitive_transformation block must only contain one argument, corresponding to the type of transformation. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations#primitiveTransformation
   */
  readonly primitiveTransformation: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition(y)),
    'fields': obj.fields?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields(y)),
    'primitiveTransformation': obj.primitiveTransformation?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions {
  /**
   * A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions#condition
   */
  readonly condition?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation {
  /**
   * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig[];

  /**
   * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig[];

  /**
   * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig[];

  /**
   * Replace each input value with a given value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig[];

  /**
   * Replace each matching finding with the name of the info type.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceWithInfoTypeConfig
   */
  readonly replaceWithInfoTypeConfig?: boolean;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'characterMaskConfig': obj.characterMaskConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(y)),
    'cryptoDeterministicConfig': obj.cryptoDeterministicConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(y)),
    'cryptoReplaceFfxFpeConfig': obj.cryptoReplaceFfxFpeConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(y)),
    'replaceConfig': obj.replaceConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(y)),
    'replaceWithInfoTypeConfig': obj.replaceWithInfoTypeConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition {
  /**
   * An expression, consisting of an operator and conditions. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition#expressions
   */
  readonly expressions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expressions': obj.expressions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation {
  /**
   * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH This can be used on data of type: number, long, string, timestamp. If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#bucketingConfig
   */
  readonly bucketingConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig[];

  /**
   * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig[];

  /**
   * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig[];

  /**
   * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes. Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=). Currently, only string and integer values can be hashed. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoHashConfig
   */
  readonly cryptoHashConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig[];

  /**
   * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig[];

  /**
   * Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#dateShiftConfig
   */
  readonly dateShiftConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig[];

  /**
   * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies. The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20". This can be used on data of type: double, long. If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#fixedSizeBucketingConfig
   */
  readonly fixedSizeBucketingConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig[];

  /**
   * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#redactConfig
   */
  readonly redactConfig?: any[];

  /**
   * Replace each input value with a given value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig[];

  /**
   * Replace with a value randomly drawn (with replacement) from a dictionary. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#replaceDictionaryConfig
   */
  readonly replaceDictionaryConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig[];

  /**
   * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#timePartConfig
   */
  readonly timePartConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketingConfig': obj.bucketingConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig(y)),
    'characterMaskConfig': obj.characterMaskConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig(y)),
    'cryptoDeterministicConfig': obj.cryptoDeterministicConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig(y)),
    'cryptoHashConfig': obj.cryptoHashConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig(y)),
    'cryptoReplaceFfxFpeConfig': obj.cryptoReplaceFfxFpeConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(y)),
    'dateShiftConfig': obj.dateShiftConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig(y)),
    'fixedSizeBucketingConfig': obj.fixedSizeBucketingConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig(y)),
    'redactConfig': obj.redactConfig?.map(y => y),
    'replaceConfig': obj.replaceConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig(y)),
    'replaceDictionaryConfig': obj.replaceDictionaryConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig(y)),
    'timePartConfig': obj.timePartConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition {
  /**
   * An expression, consisting of an operator and conditions. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition#expressions
   */
  readonly expressions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expressions': obj.expressions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * is *
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * 4
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * is false
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext[];

  /**
   * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey[];

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(y)),
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values are FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, and ALPHA_NUMERIC.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext[];

  /**
   * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey[];

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(y)),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Replace each input value with a given value. The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': obj.newValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions[];

  /**
   * The operator to apply to the result of conditions. Default and currently only supported value is AND. Default value is AND. Possible values are AND.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions#logicalOperator
   */
  readonly logicalOperator?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions(y)),
    'logicalOperator': obj.logicalOperator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig {
  /**
   * Set of buckets. Ranges must be non-overlapping. Bucket is represented as a range, along with replacement values. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig#buckets
   */
  readonly buckets?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * is *
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * 4
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * is false
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext[];

  /**
   * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey[];

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(y)),
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig {
  /**
   * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values are FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, and ALPHA_NUMERIC.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext[];

  /**
   * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey[];

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(y)),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext[];

  /**
   * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey[];

  /**
   * For example, -5 means shift date to at most 5 days back in the past.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#lowerBoundDays
   */
  readonly lowerBoundDays: number;

  /**
   * Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction. For example, 3 means shift date to at most 3 days into the future.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#upperBoundDays
   */
  readonly upperBoundDays: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(y)),
    'lowerBoundDays': obj.lowerBoundDays,
    'upperBoundDays': obj.upperBoundDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
  /**
   * Size of each bucket (except for minimum and maximum buckets). So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#bucketSize
   */
  readonly bucketSize: number;

  /**
   * Lower bound value of buckets. All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10". The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#lowerBound
   */
  readonly lowerBound: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound[];

  /**
   * Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+". The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#upperBound
   */
  readonly upperBound: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketSize': obj.bucketSize,
    'lowerBound': obj.lowerBound?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(y)),
    'upperBound': obj.upperBound?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Replace each input value with a given value. The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': obj.newValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig {
  /**
   * A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig#wordList
   */
  readonly wordList?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'wordList': obj.wordList?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig {
  /**
   * The part of the time to keep. Possible values are YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, and HOUR_OF_DAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig#partToExtract
   */
  readonly partToExtract?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partToExtract': obj.partToExtract,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions[];

  /**
   * The operator to apply to the result of conditions. Default and currently only supported value is AND. Default value is AND. Possible values are AND.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions#logicalOperator
   */
  readonly logicalOperator?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions(y)),
    'logicalOperator': obj.logicalOperator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values are NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, and WHITESPACE.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue[];

  /**
   * Represents a day of the week. Possible values are MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets {
  /**
   * Upper bound of the range, exclusive; type must match min. The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#max
   */
  readonly max?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax[];

  /**
   * Lower bound of the range, inclusive. Type should be the same as max if used. The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#min
   */
  readonly min?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin[];

  /**
   * Replacement value for this bucket. The replacement_value block must only contain one argument. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#replacementValue
   */
  readonly replacementValue: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax(y)),
    'min': obj.min?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin(y)),
    'replacementValue': obj.replacementValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values are NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, and WHITESPACE.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue[];

  /**
   * Represents a day of the week. Possible values are MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue[];

  /**
   * Represents a day of the week. Possible values are MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue[];

  /**
   * Represents a day of the week. Possible values are MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList#words
   */
  readonly words: string[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions {
  /**
   * Field within the record this condition is evaluated against. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#field
   */
  readonly field: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField[];

  /**
   * Operator used to compare the field or infoType to the value. Possible values are EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, and EXISTS.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#operator
   */
  readonly operator: string;

  /**
   * Value to compare against. The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set. This argument is mandatory, except for conditions using the EXISTS operator. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#value
   */
  readonly value?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField(y)),
    'operator': obj.operator,
    'value': obj.value?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue[];

  /**
   * Represents a day of the week. Possible values are MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue[];

  /**
   * Represents a day of the week. Possible values are MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue[];

  /**
   * Represents a day of the week. Possible values are MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions {
  /**
   * Field within the record this condition is evaluated against. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#field
   */
  readonly field: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField[];

  /**
   * Operator used to compare the field or infoType to the value. Possible values are EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, and EXISTS.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#operator
   */
  readonly operator: string;

  /**
   * Value to compare against. The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set. This argument is mandatory, except for conditions using the EXISTS operator. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#value
   */
  readonly value?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField(y)),
    'operator': obj.operator,
    'value': obj.value?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue[];

  /**
   * Represents a day of the week. Possible values are MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue[];

  /**
   * Represents a day of the week. Possible values are MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * InspectTemplate is the Schema for the InspectTemplates API. An inspect job template.
 *
 * @schema InspectTemplate
 */
export class InspectTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InspectTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datalossprevention.gcp.upbound.io/v1beta1',
    kind: 'InspectTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "InspectTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InspectTemplateProps): any {
    return {
      ...InspectTemplate.GVK,
      ...toJson_InspectTemplateProps(props),
    };
  }

  /**
   * Defines a "InspectTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InspectTemplateProps) {
    super(scope, id, {
      ...InspectTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InspectTemplate.GVK,
      ...toJson_InspectTemplateProps(resolved),
    };
  }
}

/**
 * InspectTemplate is the Schema for the InspectTemplates API. An inspect job template.
 *
 * @schema InspectTemplate
 */
export interface InspectTemplateProps {
  /**
   * @schema InspectTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InspectTemplateSpec defines the desired state of InspectTemplate
   *
   * @schema InspectTemplate#spec
   */
  readonly spec: InspectTemplateSpec;

}

/**
 * Converts an object of type 'InspectTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateProps(obj: InspectTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InspectTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InspectTemplateSpec defines the desired state of InspectTemplate
 *
 * @schema InspectTemplateSpec
 */
export interface InspectTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema InspectTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: InspectTemplateSpecDeletionPolicy;

  /**
   * @schema InspectTemplateSpec#forProvider
   */
  readonly forProvider: InspectTemplateSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InspectTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: InspectTemplateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InspectTemplateSpec#providerRef
   */
  readonly providerRef?: InspectTemplateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InspectTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InspectTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InspectTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InspectTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InspectTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpec(obj: InspectTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InspectTemplateSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_InspectTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InspectTemplateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InspectTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InspectTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema InspectTemplateSpecDeletionPolicy
 */
export enum InspectTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InspectTemplateSpecForProvider
 */
export interface InspectTemplateSpecForProvider {
  /**
   * A description of the inspect template.
   *
   * @schema InspectTemplateSpecForProvider#description
   */
  readonly description?: string;

  /**
   * User set display name of the inspect template.
   *
   * @schema InspectTemplateSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The core content of the template. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProvider#inspectConfig
   */
  readonly inspectConfig?: InspectTemplateSpecForProviderInspectConfig[];

  /**
   * The parent of the inspect template in any of the following formats:
   *
   * @schema InspectTemplateSpecForProvider#parent
   */
  readonly parent: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProvider(obj: InspectTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'inspectConfig': obj.inspectConfig?.map(y => toJson_InspectTemplateSpecForProviderInspectConfig(y)),
    'parent': obj.parent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InspectTemplateSpecProviderConfigRef
 */
export interface InspectTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InspectTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InspectTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: InspectTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InspectTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecProviderConfigRef(obj: InspectTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InspectTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InspectTemplateSpecProviderRef
 */
export interface InspectTemplateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InspectTemplateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InspectTemplateSpecProviderRef#policy
   */
  readonly policy?: InspectTemplateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InspectTemplateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecProviderRef(obj: InspectTemplateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InspectTemplateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsTo
 */
export interface InspectTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InspectTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InspectTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecPublishConnectionDetailsTo(obj: InspectTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InspectTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InspectTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InspectTemplateSpecWriteConnectionSecretToRef
 */
export interface InspectTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InspectTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InspectTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecWriteConnectionSecretToRef(obj: InspectTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfig
 */
export interface InspectTemplateSpecForProviderInspectConfig {
  /**
   * List of options defining data content to scan. If empty, text, images, and other content will be included. Each value may be one of CONTENT_TEXT and CONTENT_IMAGE.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#contentOptions
   */
  readonly contentOptions?: string[];

  /**
   * Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#customInfoTypes
   */
  readonly customInfoTypes?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypes[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#excludeInfoTypes
   */
  readonly excludeInfoTypes?: boolean;

  /**
   * When true, a contextual quote from the data that triggered a finding is included in the response.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#includeQuote
   */
  readonly includeQuote?: boolean;

  /**
   * Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list or listed at https://cloud.google.com/dlp/docs/infotypes-reference. When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run. By default this may be all types, but may change over time as detectors are updated. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#infoTypes
   */
  readonly infoTypes?: InspectTemplateSpecForProviderInspectConfigInfoTypes[];

  /**
   * Configuration to control the number of findings returned. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#limits
   */
  readonly limits?: InspectTemplateSpecForProviderInspectConfigLimits[];

  /**
   * Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info Default value is POSSIBLE. Possible values are VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, and VERY_LIKELY.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#minLikelihood
   */
  readonly minLikelihood?: string;

  /**
   * Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#ruleSet
   */
  readonly ruleSet?: InspectTemplateSpecForProviderInspectConfigRuleSet[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfig(obj: InspectTemplateSpecForProviderInspectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentOptions': obj.contentOptions?.map(y => y),
    'customInfoTypes': obj.customInfoTypes?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypes(y)),
    'excludeInfoTypes': obj.excludeInfoTypes,
    'includeQuote': obj.includeQuote,
    'infoTypes': obj.infoTypes?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigInfoTypes(y)),
    'limits': obj.limits?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigLimits(y)),
    'minLikelihood': obj.minLikelihood,
    'ruleSet': obj.ruleSet?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InspectTemplateSpecProviderConfigRefPolicy
 */
export interface InspectTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InspectTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InspectTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InspectTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InspectTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InspectTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecProviderConfigRefPolicy(obj: InspectTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InspectTemplateSpecProviderRefPolicy
 */
export interface InspectTemplateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InspectTemplateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InspectTemplateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InspectTemplateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InspectTemplateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InspectTemplateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecProviderRefPolicy(obj: InspectTemplateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface InspectTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InspectTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecPublishConnectionDetailsToConfigRef(obj: InspectTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface InspectTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecPublishConnectionDetailsToMetadata(obj: InspectTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypes {
  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#dictionary
   */
  readonly dictionary?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary[];

  /**
   * If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching. Possible values are EXCLUSION_TYPE_EXCLUDE.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#exclusionType
   */
  readonly exclusionType?: string;

  /**
   * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does not have an infoType, the DLP API applies the limit against all infoTypes that are found but not specified in another InfoTypeLimit. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#infoType
   */
  readonly infoType: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType[];

  /**
   * Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria specified by the rule. Default value is VERY_LIKELY. Possible values are VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, and VERY_LIKELY.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#likelihood
   */
  readonly likelihood?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#regex
   */
  readonly regex?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex[];

  /**
   * A reference to a StoredInfoType to use with scanning. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#storedType
   */
  readonly storedType?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypes(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': obj.dictionary?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary(y)),
    'exclusionType': obj.exclusionType,
    'infoType': obj.infoType?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType(y)),
    'likelihood': obj.likelihood,
    'regex': obj.regex?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex(y)),
    'storedType': obj.storedType?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigInfoTypes
 */
export interface InspectTemplateSpecForProviderInspectConfigInfoTypes {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigInfoTypes#name
   */
  readonly name: string;

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecForProviderInspectConfigInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigInfoTypes(obj: InspectTemplateSpecForProviderInspectConfigInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigLimits
 */
export interface InspectTemplateSpecForProviderInspectConfigLimits {
  /**
   * Configuration of findings limit given for specified infoTypes. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimits#maxFindingsPerInfoType
   */
  readonly maxFindingsPerInfoType?: InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType[];

  /**
   * Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimits#maxFindingsPerItem
   */
  readonly maxFindingsPerItem: number;

  /**
   * Max number of findings that will be returned per request/job. The maximum returned is 2000.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimits#maxFindingsPerRequest
   */
  readonly maxFindingsPerRequest: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigLimits(obj: InspectTemplateSpecForProviderInspectConfigLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxFindingsPerInfoType': obj.maxFindingsPerInfoType?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType(y)),
    'maxFindingsPerItem': obj.maxFindingsPerItem,
    'maxFindingsPerRequest': obj.maxFindingsPerRequest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSet
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSet {
  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSet#infoTypes
   */
  readonly infoTypes: InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes[];

  /**
   * Set of rules to be applied to infoTypes. The rules are applied in order. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSet#rules
   */
  readonly rules: InspectTemplateSpecForProviderInspectConfigRuleSetRules[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSet(obj: InspectTemplateSpecForProviderInspectConfigRuleSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes(y)),
    'rules': obj.rules?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InspectTemplateSpecProviderConfigRefPolicyResolution
 */
export enum InspectTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InspectTemplateSpecProviderConfigRefPolicyResolve
 */
export enum InspectTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InspectTemplateSpecProviderRefPolicyResolution
 */
export enum InspectTemplateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InspectTemplateSpecProviderRefPolicyResolve
 */
export enum InspectTemplateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary#wordList
   */
  readonly wordList?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex#pattern
   */
  readonly pattern: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType
 */
export interface InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType {
  /**
   * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does not have an infoType, the DLP API applies the limit against all infoTypes that are found but not specified in another InfoTypeLimit. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType#infoType
   */
  readonly infoType: InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType[];

  /**
   * Max findings limit for the given infoType.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType#maxFindings
   */
  readonly maxFindings: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType(obj: InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoType': obj.infoType?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(y)),
    'maxFindings': obj.maxFindings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes(obj: InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRules
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRules {
  /**
   * The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRules#exclusionRule
   */
  readonly exclusionRule?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule[];

  /**
   * Hotword-based detection rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRules#hotwordRule
   */
  readonly hotwordRule?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRules(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclusionRule': obj.exclusionRule?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule(y)),
    'hotwordRule': obj.hotwordRule?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList#words
   */
  readonly words: string[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType
 */
export interface InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(obj: InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule {
  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule#dictionary
   */
  readonly dictionary?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule#excludeInfoTypes
   */
  readonly excludeInfoTypes?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes[];

  /**
   * How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType Possible values are MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, and MATCHING_TYPE_INVERSE_MATCH.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule#matchingType
   */
  readonly matchingType: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule#regex
   */
  readonly regex?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': obj.dictionary?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary(y)),
    'excludeInfoTypes': obj.excludeInfoTypes?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(y)),
    'matchingType': obj.matchingType,
    'regex': obj.regex?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule {
  /**
   * Regular expression pattern defining what qualifies as a hotword. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule#hotwordRegex
   */
  readonly hotwordRegex: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex[];

  /**
   * Likelihood adjustment to apply to all matching findings. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule#likelihoodAdjustment
   */
  readonly likelihoodAdjustment: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment[];

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex (xxx), where xxx is the area code in question. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule#proximity
   */
  readonly proximity: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': obj.hotwordRegex?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex(y)),
    'likelihoodAdjustment': obj.likelihoodAdjustment?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(y)),
    'proximity': obj.proximity?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary#wordList
   */
  readonly wordList?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes#infoTypes
   */
  readonly infoTypes: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex#pattern
   */
  readonly pattern: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex#pattern
   */
  readonly pattern: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
  /**
   * Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set. Possible values are VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, and VERY_LIKELY.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#fixedLikelihood
   */
  readonly fixedLikelihood?: string;

  /**
   * Increase or decrease the likelihood by the specified number of levels. For example, if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1, then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY. Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#relativeLikelihood
   */
  readonly relativeLikelihood?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedLikelihood': obj.fixedLikelihood,
    'relativeLikelihood': obj.relativeLikelihood,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity {
  /**
   * Number of characters after the finding to consider. Either this or window_before must be specified
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider. Either this or window_after must be specified
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList#words
   */
  readonly words: string[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * JobTrigger is the Schema for the JobTriggers API. A job trigger configuration.
 *
 * @schema JobTrigger
 */
export class JobTrigger extends ApiObject {
  /**
   * Returns the apiVersion and kind for "JobTrigger"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datalossprevention.gcp.upbound.io/v1beta1',
    kind: 'JobTrigger',
  }

  /**
   * Renders a Kubernetes manifest for "JobTrigger".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: JobTriggerProps): any {
    return {
      ...JobTrigger.GVK,
      ...toJson_JobTriggerProps(props),
    };
  }

  /**
   * Defines a "JobTrigger" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: JobTriggerProps) {
    super(scope, id, {
      ...JobTrigger.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...JobTrigger.GVK,
      ...toJson_JobTriggerProps(resolved),
    };
  }
}

/**
 * JobTrigger is the Schema for the JobTriggers API. A job trigger configuration.
 *
 * @schema JobTrigger
 */
export interface JobTriggerProps {
  /**
   * @schema JobTrigger#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * JobTriggerSpec defines the desired state of JobTrigger
   *
   * @schema JobTrigger#spec
   */
  readonly spec: JobTriggerSpec;

}

/**
 * Converts an object of type 'JobTriggerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerProps(obj: JobTriggerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_JobTriggerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JobTriggerSpec defines the desired state of JobTrigger
 *
 * @schema JobTriggerSpec
 */
export interface JobTriggerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema JobTriggerSpec#deletionPolicy
   */
  readonly deletionPolicy?: JobTriggerSpecDeletionPolicy;

  /**
   * @schema JobTriggerSpec#forProvider
   */
  readonly forProvider: JobTriggerSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema JobTriggerSpec#providerConfigRef
   */
  readonly providerConfigRef?: JobTriggerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema JobTriggerSpec#providerRef
   */
  readonly providerRef?: JobTriggerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema JobTriggerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: JobTriggerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema JobTriggerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: JobTriggerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'JobTriggerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpec(obj: JobTriggerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_JobTriggerSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_JobTriggerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_JobTriggerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_JobTriggerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_JobTriggerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema JobTriggerSpecDeletionPolicy
 */
export enum JobTriggerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema JobTriggerSpecForProvider
 */
export interface JobTriggerSpecForProvider {
  /**
   * A description of the job trigger.
   *
   * @schema JobTriggerSpecForProvider#description
   */
  readonly description?: string;

  /**
   * User set display name of the job trigger.
   *
   * @schema JobTriggerSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Controls what and how to inspect for findings. Structure is documented below.
   *
   * @schema JobTriggerSpecForProvider#inspectJob
   */
  readonly inspectJob?: JobTriggerSpecForProviderInspectJob[];

  /**
   * The parent of the trigger, either in the format projects/{{project}} or projects/{{project}}/locations/{{location}}
   *
   * @schema JobTriggerSpecForProvider#parent
   */
  readonly parent: string;

  /**
   * Whether the trigger is currently active. Default value is HEALTHY. Possible values are PAUSED, HEALTHY, and CANCELLED.
   *
   * @schema JobTriggerSpecForProvider#status
   */
  readonly status?: string;

  /**
   * What event needs to occur for a new job to be started. Structure is documented below.
   *
   * @schema JobTriggerSpecForProvider#triggers
   */
  readonly triggers: JobTriggerSpecForProviderTriggers[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProvider(obj: JobTriggerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'inspectJob': obj.inspectJob?.map(y => toJson_JobTriggerSpecForProviderInspectJob(y)),
    'parent': obj.parent,
    'status': obj.status,
    'triggers': obj.triggers?.map(y => toJson_JobTriggerSpecForProviderTriggers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema JobTriggerSpecProviderConfigRef
 */
export interface JobTriggerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobTriggerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobTriggerSpecProviderConfigRef#policy
   */
  readonly policy?: JobTriggerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'JobTriggerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecProviderConfigRef(obj: JobTriggerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobTriggerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema JobTriggerSpecProviderRef
 */
export interface JobTriggerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobTriggerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobTriggerSpecProviderRef#policy
   */
  readonly policy?: JobTriggerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'JobTriggerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecProviderRef(obj: JobTriggerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobTriggerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsTo
 */
export interface JobTriggerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: JobTriggerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: JobTriggerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'JobTriggerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecPublishConnectionDetailsTo(obj: JobTriggerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_JobTriggerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_JobTriggerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema JobTriggerSpecWriteConnectionSecretToRef
 */
export interface JobTriggerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema JobTriggerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema JobTriggerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'JobTriggerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecWriteConnectionSecretToRef(obj: JobTriggerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJob
 */
export interface JobTriggerSpecForProviderInspectJob {
  /**
   * A task to execute on the completion of a job. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJob#actions
   */
  readonly actions: JobTriggerSpecForProviderInspectJobActions[];

  /**
   * The name of the template to run when this job is triggered.
   *
   * @schema JobTriggerSpecForProviderInspectJob#inspectTemplateName
   */
  readonly inspectTemplateName: string;

  /**
   * Information on where to inspect Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJob#storageConfig
   */
  readonly storageConfig: JobTriggerSpecForProviderInspectJobStorageConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJob' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJob(obj: JobTriggerSpecForProviderInspectJob | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_JobTriggerSpecForProviderInspectJobActions(y)),
    'inspectTemplateName': obj.inspectTemplateName,
    'storageConfig': obj.storageConfig?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderTriggers
 */
export interface JobTriggerSpecForProviderTriggers {
  /**
   * Schedule for triggered jobs Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderTriggers#schedule
   */
  readonly schedule?: JobTriggerSpecForProviderTriggersSchedule[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderTriggers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderTriggers(obj: JobTriggerSpecForProviderTriggers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'schedule': obj.schedule?.map(y => toJson_JobTriggerSpecForProviderTriggersSchedule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobTriggerSpecProviderConfigRefPolicy
 */
export interface JobTriggerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobTriggerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: JobTriggerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobTriggerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: JobTriggerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JobTriggerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecProviderConfigRefPolicy(obj: JobTriggerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobTriggerSpecProviderRefPolicy
 */
export interface JobTriggerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobTriggerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: JobTriggerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobTriggerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: JobTriggerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'JobTriggerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecProviderRefPolicy(obj: JobTriggerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsToConfigRef
 */
export interface JobTriggerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'JobTriggerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecPublishConnectionDetailsToConfigRef(obj: JobTriggerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsToMetadata
 */
export interface JobTriggerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecPublishConnectionDetailsToMetadata(obj: JobTriggerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActions
 */
export interface JobTriggerSpecForProviderInspectJobActions {
  /**
   * Publish a message into a given Pub/Sub topic when the job completes. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#pubSub
   */
  readonly pubSub?: JobTriggerSpecForProviderInspectJobActionsPubSub[];

  /**
   * Publish findings of a DlpJob to Data Catalog.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#publishFindingsToCloudDataCatalog
   */
  readonly publishFindingsToCloudDataCatalog?: any[];

  /**
   * Publish the result summary of a DlpJob to the Cloud Security Command Center.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#publishSummaryToCscc
   */
  readonly publishSummaryToCscc?: any[];

  /**
   * If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#saveFindings
   */
  readonly saveFindings?: JobTriggerSpecForProviderInspectJobActionsSaveFindings[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActions(obj: JobTriggerSpecForProviderInspectJobActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pubSub': obj.pubSub?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsPubSub(y)),
    'publishFindingsToCloudDataCatalog': obj.publishFindingsToCloudDataCatalog?.map(y => y),
    'publishSummaryToCscc': obj.publishSummaryToCscc?.map(y => y),
    'saveFindings': obj.saveFindings?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfig
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfig {
  /**
   * Options defining BigQuery table and row identifiers. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfig#bigQueryOptions
   */
  readonly bigQueryOptions?: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions[];

  /**
   * Options defining a file or a set of files within a Google Cloud Storage bucket. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfig#cloudStorageOptions
   */
  readonly cloudStorageOptions?: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions[];

  /**
   * Options defining a data set within Google Cloud Datastore. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfig#datastoreOptions
   */
  readonly datastoreOptions?: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions[];

  /**
   * Information on where to inspect Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfig#timespanConfig
   */
  readonly timespanConfig?: JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfig(obj: JobTriggerSpecForProviderInspectJobStorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigQueryOptions': obj.bigQueryOptions?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions(y)),
    'cloudStorageOptions': obj.cloudStorageOptions?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions(y)),
    'datastoreOptions': obj.datastoreOptions?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions(y)),
    'timespanConfig': obj.timespanConfig?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderTriggersSchedule
 */
export interface JobTriggerSpecForProviderTriggersSchedule {
  /**
   * With this option a job is started a regular periodic basis. For example: every day (86400 seconds). A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs. This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema JobTriggerSpecForProviderTriggersSchedule#recurrencePeriodDuration
   */
  readonly recurrencePeriodDuration?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderTriggersSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderTriggersSchedule(obj: JobTriggerSpecForProviderTriggersSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recurrencePeriodDuration': obj.recurrencePeriodDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobTriggerSpecProviderConfigRefPolicyResolution
 */
export enum JobTriggerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobTriggerSpecProviderConfigRefPolicyResolve
 */
export enum JobTriggerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobTriggerSpecProviderRefPolicyResolution
 */
export enum JobTriggerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobTriggerSpecProviderRefPolicyResolve
 */
export enum JobTriggerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy(obj: JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsPubSub
 */
export interface JobTriggerSpecForProviderInspectJobActionsPubSub {
  /**
   * Cloud Pub/Sub topic to send notifications to.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsPubSub#topic
   */
  readonly topic: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsPubSub' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsPubSub(obj: JobTriggerSpecForProviderInspectJobActionsPubSub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindings
 */
export interface JobTriggerSpecForProviderInspectJobActionsSaveFindings {
  /**
   * Information on where to store output Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindings#outputConfig
   */
  readonly outputConfig: JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsSaveFindings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindings(obj: JobTriggerSpecForProviderInspectJobActionsSaveFindings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputConfig': obj.outputConfig?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions {
  /**
   * Specifies the BigQuery fields that will be returned with findings. If not specified, no identifying fields will be returned for findings. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#identifyingFields
   */
  readonly identifyingFields?: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields[];

  /**
   * Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted. If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#rowsLimit
   */
  readonly rowsLimit?: number;

  /**
   * Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
   *
   * @default 0. Only one of rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#rowsLimitPercent
   */
  readonly rowsLimitPercent?: number;

  /**
   * How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile. If not specified, scanning would start from the top. Possible values are TOP and RANDOM_START.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#sampleMethod
   */
  readonly sampleMethod?: string;

  /**
   * Set of files to scan. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#tableReference
   */
  readonly tableReference: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions(obj: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identifyingFields': obj.identifyingFields?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields(y)),
    'rowsLimit': obj.rowsLimit,
    'rowsLimitPercent': obj.rowsLimitPercent,
    'sampleMethod': obj.sampleMethod,
    'tableReference': obj.tableReference?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions {
  /**
   * Max number of bytes to scan from a file. If a scanned file's size is bigger than this value then the rest of the bytes are omitted.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#bytesLimitPerFile
   */
  readonly bytesLimitPerFile?: number;

  /**
   * Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#bytesLimitPerFilePercent
   */
  readonly bytesLimitPerFilePercent?: number;

  /**
   * Set of files to scan. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#fileSet
   */
  readonly fileSet: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet[];

  /**
   * List of file type groups to include in the scan. If empty, all files are scanned and available data format processors are applied. In addition, the binary content of the selected files is always scanned as well. Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified. Each value may be one of BINARY_FILE, TEXT_FILE, IMAGE, WORD, PDF, AVRO, CSV, and TSV.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#fileTypes
   */
  readonly fileTypes?: string[];

  /**
   * Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#filesLimitPercent
   */
  readonly filesLimitPercent?: number;

  /**
   * How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile. If not specified, scanning would start from the top. Possible values are TOP and RANDOM_START.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#sampleMethod
   */
  readonly sampleMethod?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions(obj: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bytesLimitPerFile': obj.bytesLimitPerFile,
    'bytesLimitPerFilePercent': obj.bytesLimitPerFilePercent,
    'fileSet': obj.fileSet?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet(y)),
    'fileTypes': obj.fileTypes?.map(y => y),
    'filesLimitPercent': obj.filesLimitPercent,
    'sampleMethod': obj.sampleMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions {
  /**
   * A representation of a Datastore kind. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions#kind
   */
  readonly kind: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind[];

  /**
   * Datastore partition ID. A partition ID identifies a grouping of entities. The grouping is always by project and namespace, however the namespace ID may be empty. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions#partitionId
   */
  readonly partitionId: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions(obj: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind(y)),
    'partitionId': obj.partitionId?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig {
  /**
   * When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid scanning files that have not been modified since the last time the JobTrigger executed. This will be based on the time of the execution of the last run of the JobTrigger.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig#enableAutoPopulationOfTimespanConfig
   */
  readonly enableAutoPopulationOfTimespanConfig?: boolean;

  /**
   * Exclude files or rows newer than this value. If set to zero, no upper time limit is applied.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig#endTime
   */
  readonly endTime?: string;

  /**
   * Exclude files or rows older than this value.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig#startTime
   */
  readonly startTime?: string;

  /**
   * Information on where to inspect Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig#timestampField
   */
  readonly timestampField: JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig(obj: JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableAutoPopulationOfTimespanConfig': obj.enableAutoPopulationOfTimespanConfig,
    'endTime': obj.endTime,
    'startTime': obj.startTime,
    'timestampField': obj.timestampField?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig
 */
export interface JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig {
  /**
   * Schema used for writing the findings for Inspect jobs. This field is only used for Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding object. If appending to an existing table, any columns from the predefined schema that are missing will be added. No columns in the existing table will be deleted. If unspecified, then all available columns will be used for a new table or an (existing) table with no schema, and no changes will be made to an existing table that has a schema. Only for use with external storage. Possible values are BASIC_COLUMNS, GCS_COLUMNS, DATASTORE_COLUMNS, BIG_QUERY_COLUMNS, and ALL_COLUMNS.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig#outputSchema
   */
  readonly outputSchema?: string;

  /**
   * Information on the location of the target BigQuery Table. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig#table
   */
  readonly table: JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig(obj: JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputSchema': obj.outputSchema,
    'table': obj.table?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields(obj: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference {
  /**
   * The dataset ID of the table.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference#datasetId
   */
  readonly datasetId: string;

  /**
   * The Google Cloud Platform project ID of the project containing the table.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference#projectId
   */
  readonly projectId: string;

  /**
   * The name of the table.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference#tableId
   */
  readonly tableId: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference(obj: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet {
  /**
   * The regex-filtered set of files to scan. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet#regexFileSet
   */
  readonly regexFileSet?: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet[];

  /**
   * The Cloud Storage url of the file(s) to scan, in the format gs://<bucket>/<path>. Trailing wildcard in the path is allowed. If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned non-recursively (content in sub-directories will not be scanned). This means that gs://mybucket/ is equivalent to gs://mybucket/*, and gs://mybucket/directory/ is equivalent to gs://mybucket/directory/*.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet(obj: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexFileSet': obj.regexFileSet?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind(obj: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId {
  /**
   * If not empty, the ID of the namespace to which the entities belong.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId#namespaceId
   */
  readonly namespaceId?: string;

  /**
   * The Google Cloud Platform project ID of the project containing the table.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId#projectId
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId(obj: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceId': obj.namespaceId,
    'projectId': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField(obj: JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable
 */
export interface JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable {
  /**
   * The dataset ID of the table.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable#datasetId
   */
  readonly datasetId: string;

  /**
   * The Google Cloud Platform project ID of the project containing the table.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable#projectId
   */
  readonly projectId: string;

  /**
   * The name of the table.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable#tableId
   */
  readonly tableId?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable(obj: JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet {
  /**
   * The name of a Cloud Storage bucket.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#bucketName
   */
  readonly bucketName: string;

  /**
   * A list of regular expressions matching file paths to exclude. All files in the bucket that match at least one of these regular expressions will be excluded from the scan.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#excludeRegex
   */
  readonly excludeRegex?: string[];

  /**
   * A list of regular expressions matching file paths to include. All files in the bucket that match at least one of these regular expressions will be included in the set of files, except for those that also match an item in excludeRegex. Leaving this field empty will match all files by default (this is equivalent to including .* in the list)
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#includeRegex
   */
  readonly includeRegex?: string[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet(obj: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'excludeRegex': obj.excludeRegex?.map(y => y),
    'includeRegex': obj.includeRegex?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * StoredInfoType is the Schema for the StoredInfoTypes API. Allows creation of custom info types.
 *
 * @schema StoredInfoType
 */
export class StoredInfoType extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StoredInfoType"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datalossprevention.gcp.upbound.io/v1beta1',
    kind: 'StoredInfoType',
  }

  /**
   * Renders a Kubernetes manifest for "StoredInfoType".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StoredInfoTypeProps): any {
    return {
      ...StoredInfoType.GVK,
      ...toJson_StoredInfoTypeProps(props),
    };
  }

  /**
   * Defines a "StoredInfoType" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StoredInfoTypeProps) {
    super(scope, id, {
      ...StoredInfoType.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StoredInfoType.GVK,
      ...toJson_StoredInfoTypeProps(resolved),
    };
  }
}

/**
 * StoredInfoType is the Schema for the StoredInfoTypes API. Allows creation of custom info types.
 *
 * @schema StoredInfoType
 */
export interface StoredInfoTypeProps {
  /**
   * @schema StoredInfoType#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StoredInfoTypeSpec defines the desired state of StoredInfoType
   *
   * @schema StoredInfoType#spec
   */
  readonly spec: StoredInfoTypeSpec;

}

/**
 * Converts an object of type 'StoredInfoTypeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeProps(obj: StoredInfoTypeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StoredInfoTypeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StoredInfoTypeSpec defines the desired state of StoredInfoType
 *
 * @schema StoredInfoTypeSpec
 */
export interface StoredInfoTypeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema StoredInfoTypeSpec#deletionPolicy
   */
  readonly deletionPolicy?: StoredInfoTypeSpecDeletionPolicy;

  /**
   * @schema StoredInfoTypeSpec#forProvider
   */
  readonly forProvider: StoredInfoTypeSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StoredInfoTypeSpec#providerConfigRef
   */
  readonly providerConfigRef?: StoredInfoTypeSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StoredInfoTypeSpec#providerRef
   */
  readonly providerRef?: StoredInfoTypeSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StoredInfoTypeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StoredInfoTypeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StoredInfoTypeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StoredInfoTypeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StoredInfoTypeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpec(obj: StoredInfoTypeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StoredInfoTypeSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_StoredInfoTypeSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StoredInfoTypeSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StoredInfoTypeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StoredInfoTypeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema StoredInfoTypeSpecDeletionPolicy
 */
export enum StoredInfoTypeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StoredInfoTypeSpecForProvider
 */
export interface StoredInfoTypeSpecForProvider {
  /**
   * A description of the info type.
   *
   * @schema StoredInfoTypeSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProvider#dictionary
   */
  readonly dictionary?: StoredInfoTypeSpecForProviderDictionary[];

  /**
   * User set display name of the info type.
   *
   * @schema StoredInfoTypeSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProvider#largeCustomDictionary
   */
  readonly largeCustomDictionary?: StoredInfoTypeSpecForProviderLargeCustomDictionary[];

  /**
   * The parent of the info type in any of the following formats:
   *
   * @schema StoredInfoTypeSpecForProvider#parent
   */
  readonly parent: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProvider#regex
   */
  readonly regex?: StoredInfoTypeSpecForProviderRegex[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProvider(obj: StoredInfoTypeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'dictionary': obj.dictionary?.map(y => toJson_StoredInfoTypeSpecForProviderDictionary(y)),
    'displayName': obj.displayName,
    'largeCustomDictionary': obj.largeCustomDictionary?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionary(y)),
    'parent': obj.parent,
    'regex': obj.regex?.map(y => toJson_StoredInfoTypeSpecForProviderRegex(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StoredInfoTypeSpecProviderConfigRef
 */
export interface StoredInfoTypeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StoredInfoTypeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StoredInfoTypeSpecProviderConfigRef#policy
   */
  readonly policy?: StoredInfoTypeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecProviderConfigRef(obj: StoredInfoTypeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StoredInfoTypeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StoredInfoTypeSpecProviderRef
 */
export interface StoredInfoTypeSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StoredInfoTypeSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StoredInfoTypeSpecProviderRef#policy
   */
  readonly policy?: StoredInfoTypeSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecProviderRef(obj: StoredInfoTypeSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StoredInfoTypeSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsTo
 */
export interface StoredInfoTypeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StoredInfoTypeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StoredInfoTypeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecPublishConnectionDetailsTo(obj: StoredInfoTypeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StoredInfoTypeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StoredInfoTypeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StoredInfoTypeSpecWriteConnectionSecretToRef
 */
export interface StoredInfoTypeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StoredInfoTypeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StoredInfoTypeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecWriteConnectionSecretToRef(obj: StoredInfoTypeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderDictionary
 */
export interface StoredInfoTypeSpecForProviderDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: StoredInfoTypeSpecForProviderDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderDictionary#wordList
   */
  readonly wordList?: StoredInfoTypeSpecForProviderDictionaryWordList[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderDictionary(obj: StoredInfoTypeSpecForProviderDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_StoredInfoTypeSpecForProviderDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_StoredInfoTypeSpecForProviderDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionary
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionary {
  /**
   * Field in a BigQuery table where each cell represents a dictionary phrase. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionary#bigQueryField
   */
  readonly bigQueryField?: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField[];

  /**
   * Set of files containing newline-delimited lists of dictionary phrases. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionary#cloudStorageFileSet
   */
  readonly cloudStorageFileSet?: StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet[];

  /**
   * Location to store dictionary artifacts in Google Cloud Storage. These files will only be accessible by project owners and the DLP API. If any of these artifacts are modified, the dictionary is considered invalid and can no longer be used. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionary#outputPath
   */
  readonly outputPath: StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionary(obj: StoredInfoTypeSpecForProviderLargeCustomDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigQueryField': obj.bigQueryField?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField(y)),
    'cloudStorageFileSet': obj.cloudStorageFileSet?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet(y)),
    'outputPath': obj.outputPath?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderRegex
 */
export interface StoredInfoTypeSpecForProviderRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema StoredInfoTypeSpecForProviderRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema StoredInfoTypeSpecForProviderRegex#pattern
   */
  readonly pattern: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderRegex(obj: StoredInfoTypeSpecForProviderRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StoredInfoTypeSpecProviderConfigRefPolicy
 */
export interface StoredInfoTypeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StoredInfoTypeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StoredInfoTypeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StoredInfoTypeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StoredInfoTypeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecProviderConfigRefPolicy(obj: StoredInfoTypeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StoredInfoTypeSpecProviderRefPolicy
 */
export interface StoredInfoTypeSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StoredInfoTypeSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StoredInfoTypeSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StoredInfoTypeSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StoredInfoTypeSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecProviderRefPolicy(obj: StoredInfoTypeSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRef
 */
export interface StoredInfoTypeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecPublishConnectionDetailsToConfigRef(obj: StoredInfoTypeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsToMetadata
 */
export interface StoredInfoTypeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecPublishConnectionDetailsToMetadata(obj: StoredInfoTypeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderDictionaryCloudStoragePath
 */
export interface StoredInfoTypeSpecForProviderDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema StoredInfoTypeSpecForProviderDictionaryCloudStoragePath#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderDictionaryCloudStoragePath(obj: StoredInfoTypeSpecForProviderDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderDictionaryWordList
 */
export interface StoredInfoTypeSpecForProviderDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema StoredInfoTypeSpecForProviderDictionaryWordList#words
   */
  readonly words: string[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderDictionaryWordList(obj: StoredInfoTypeSpecForProviderDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField {
  /**
   * Designated field in the BigQuery table. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField#field
   */
  readonly field: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField[];

  /**
   * Field in a BigQuery table where each cell represents a dictionary phrase. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField#table
   */
  readonly table: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField(obj: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField(y)),
    'table': obj.table?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet {
  /**
   * The url, in the format gs://<bucket>/<path>. Trailing wildcard in the path is allowed.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet(obj: StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath(obj: StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StoredInfoTypeSpecProviderConfigRefPolicyResolution
 */
export enum StoredInfoTypeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StoredInfoTypeSpecProviderConfigRefPolicyResolve
 */
export enum StoredInfoTypeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StoredInfoTypeSpecProviderRefPolicyResolution
 */
export enum StoredInfoTypeSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StoredInfoTypeSpecProviderRefPolicyResolve
 */
export enum StoredInfoTypeSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj: StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField {
  /**
   * The resource name of the info type. Set by the server.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField(obj: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable {
  /**
   * The dataset ID of the table.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable#datasetId
   */
  readonly datasetId: string;

  /**
   * The Google Cloud Platform project ID of the project containing the table.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable#projectId
   */
  readonly projectId: string;

  /**
   * The name of the table.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable#tableId
   */
  readonly tableId: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable(obj: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

