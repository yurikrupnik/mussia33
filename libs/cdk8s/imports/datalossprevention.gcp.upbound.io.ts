// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DeidentifyTemplate is the Schema for the DeidentifyTemplates API. Allows creation of templates to de-identify content.
 *
 * @schema DeidentifyTemplate
 */
export class DeidentifyTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DeidentifyTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datalossprevention.gcp.upbound.io/v1beta1',
    kind: 'DeidentifyTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "DeidentifyTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeidentifyTemplateProps): any {
    return {
      ...DeidentifyTemplate.GVK,
      ...toJson_DeidentifyTemplateProps(props),
    };
  }

  /**
   * Defines a "DeidentifyTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeidentifyTemplateProps) {
    super(scope, id, {
      ...DeidentifyTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DeidentifyTemplate.GVK,
      ...toJson_DeidentifyTemplateProps(resolved),
    };
  }
}

/**
 * DeidentifyTemplate is the Schema for the DeidentifyTemplates API. Allows creation of templates to de-identify content.
 *
 * @schema DeidentifyTemplate
 */
export interface DeidentifyTemplateProps {
  /**
   * @schema DeidentifyTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeidentifyTemplateSpec defines the desired state of DeidentifyTemplate
   *
   * @schema DeidentifyTemplate#spec
   */
  readonly spec: DeidentifyTemplateSpec;

}

/**
 * Converts an object of type 'DeidentifyTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateProps(obj: DeidentifyTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeidentifyTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeidentifyTemplateSpec defines the desired state of DeidentifyTemplate
 *
 * @schema DeidentifyTemplateSpec
 */
export interface DeidentifyTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeidentifyTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeidentifyTemplateSpecDeletionPolicy;

  /**
   * @schema DeidentifyTemplateSpec#forProvider
   */
  readonly forProvider: DeidentifyTemplateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DeidentifyTemplateSpec#initProvider
   */
  readonly initProvider?: DeidentifyTemplateSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DeidentifyTemplateSpec#managementPolicies
   */
  readonly managementPolicies?: DeidentifyTemplateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeidentifyTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeidentifyTemplateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeidentifyTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeidentifyTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeidentifyTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeidentifyTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpec(obj: DeidentifyTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeidentifyTemplateSpecForProvider(obj.forProvider),
    'initProvider': toJson_DeidentifyTemplateSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DeidentifyTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DeidentifyTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeidentifyTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeidentifyTemplateSpecDeletionPolicy
 */
export enum DeidentifyTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeidentifyTemplateSpecForProvider
 */
export interface DeidentifyTemplateSpecForProvider {
  /**
   * Configuration of the deidentify template Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProvider#deidentifyConfig
   */
  readonly deidentifyConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfig[];

  /**
   * A description of the template.
   *
   * @schema DeidentifyTemplateSpecForProvider#description
   */
  readonly description?: string;

  /**
   * User set display name of the template.
   *
   * @schema DeidentifyTemplateSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The parent of the template in any of the following formats:
   *
   * @schema DeidentifyTemplateSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * The template id can contain uppercase and lowercase letters, numbers, and hyphens; that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is 100 characters. Can be empty to allow the system to generate one.
   *
   * @schema DeidentifyTemplateSpecForProvider#templateId
   */
  readonly templateId?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProvider(obj: DeidentifyTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deidentifyConfig': obj.deidentifyConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfig(y)),
    'description': obj.description,
    'displayName': obj.displayName,
    'parent': obj.parent,
    'templateId': obj.templateId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DeidentifyTemplateSpecInitProvider
 */
export interface DeidentifyTemplateSpecInitProvider {
  /**
   * Configuration of the deidentify template Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProvider#deidentifyConfig
   */
  readonly deidentifyConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfig[];

  /**
   * A description of the template.
   *
   * @schema DeidentifyTemplateSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * User set display name of the template.
   *
   * @schema DeidentifyTemplateSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The parent of the template in any of the following formats:
   *
   * @schema DeidentifyTemplateSpecInitProvider#parent
   */
  readonly parent?: string;

  /**
   * The template id can contain uppercase and lowercase letters, numbers, and hyphens; that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is 100 characters. Can be empty to allow the system to generate one.
   *
   * @schema DeidentifyTemplateSpecInitProvider#templateId
   */
  readonly templateId?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProvider(obj: DeidentifyTemplateSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deidentifyConfig': obj.deidentifyConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfig(y)),
    'description': obj.description,
    'displayName': obj.displayName,
    'parent': obj.parent,
    'templateId': obj.templateId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DeidentifyTemplateSpecManagementPolicies
 */
export enum DeidentifyTemplateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeidentifyTemplateSpecProviderConfigRef
 */
export interface DeidentifyTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeidentifyTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeidentifyTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: DeidentifyTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecProviderConfigRef(obj: DeidentifyTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeidentifyTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsTo
 */
export interface DeidentifyTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeidentifyTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecPublishConnectionDetailsTo(obj: DeidentifyTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeidentifyTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeidentifyTemplateSpecWriteConnectionSecretToRef
 */
export interface DeidentifyTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeidentifyTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeidentifyTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecWriteConnectionSecretToRef(obj: DeidentifyTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfig {
  /**
   * Treat the dataset as an image and redact. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfig#imageTransformations
   */
  readonly imageTransformations?: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformations[];

  /**
   * Treat the dataset as free-form text and apply the same free text transformation everywhere Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfig#infoTypeTransformations
   */
  readonly infoTypeTransformations?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations[];

  /**
   * Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfig#recordTransformations
   */
  readonly recordTransformations?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageTransformations': obj.imageTransformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformations(y)),
    'infoTypeTransformations': obj.infoTypeTransformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations(y)),
    'recordTransformations': obj.recordTransformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfig {
  /**
   * Treat the dataset as an image and redact. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfig#imageTransformations
   */
  readonly imageTransformations?: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformations[];

  /**
   * Treat the dataset as free-form text and apply the same free text transformation everywhere Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfig#infoTypeTransformations
   */
  readonly infoTypeTransformations?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformations[];

  /**
   * Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfig#recordTransformations
   */
  readonly recordTransformations?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformations[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageTransformations': obj.imageTransformations?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformations(y)),
    'infoTypeTransformations': obj.infoTypeTransformations?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformations(y)),
    'recordTransformations': obj.recordTransformations?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeidentifyTemplateSpecProviderConfigRefPolicy
 */
export interface DeidentifyTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeidentifyTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeidentifyTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeidentifyTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeidentifyTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecProviderConfigRefPolicy(obj: DeidentifyTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef(obj: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface DeidentifyTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecPublishConnectionDetailsToMetadata(obj: DeidentifyTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformations {
  /**
   * For determination of how redaction of images should occur. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformations#transforms
   */
  readonly transforms?: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transforms': obj.transforms?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations {
  /**
   * Transformation for each infoType. Cannot specify more than one for a given infoType. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations#transformations
   */
  readonly transformations?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transformations': obj.transformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations {
  /**
   * Transform the record by applying various field transformations. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations#fieldTransformations
   */
  readonly fieldTransformations?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations[];

  /**
   * Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations#recordSuppressions
   */
  readonly recordSuppressions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldTransformations': obj.fieldTransformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations(y)),
    'recordSuppressions': obj.recordSuppressions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformations
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformations {
  /**
   * For determination of how redaction of images should occur. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformations#transforms
   */
  readonly transforms?: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformations(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transforms': obj.transforms?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformations
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformations {
  /**
   * Transformation for each infoType. Cannot specify more than one for a given infoType. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformations#transformations
   */
  readonly transformations?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformations[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformations(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transformations': obj.transformations?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformations
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformations {
  /**
   * Transform the record by applying various field transformations. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformations#fieldTransformations
   */
  readonly fieldTransformations?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations[];

  /**
   * Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformations#recordSuppressions
   */
  readonly recordSuppressions?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformations(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldTransformations': obj.fieldTransformations?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations(y)),
    'recordSuppressions': obj.recordSuppressions?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeidentifyTemplateSpecProviderConfigRefPolicyResolution
 */
export enum DeidentifyTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeidentifyTemplateSpecProviderConfigRefPolicyResolve
 */
export enum DeidentifyTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms {
  /**
   * Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms#allInfoTypes
   */
  readonly allInfoTypes?: any[];

  /**
   * Apply transformation to all text that doesn't match an infoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms#allText
   */
  readonly allText?: any[];

  /**
   * The color to use when redacting content from an image. If not specified, the default is black. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms#redactionColor
   */
  readonly redactionColor?: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor[];

  /**
   * Apply transformation to the selected infoTypes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms#selectedInfoTypes
   */
  readonly selectedInfoTypes?: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allInfoTypes': obj.allInfoTypes?.map(y => y),
    'allText': obj.allText?.map(y => y),
    'redactionColor': obj.redactionColor?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor(y)),
    'selectedInfoTypes': obj.selectedInfoTypes?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations {
  /**
   * InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to all findings that correspond to infoTypes that were requested in InspectConfig. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations#infoTypes
   */
  readonly infoTypes?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes[];

  /**
   * Primitive transformation to apply to the infoType. The primitive_transformation block must only contain one argument, corresponding to the type of transformation. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations#primitiveTransformation
   */
  readonly primitiveTransformation?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes(y)),
    'primitiveTransformation': obj.primitiveTransformation?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations {
  /**
   * A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations#condition
   */
  readonly condition?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition[];

  /**
   * Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId. FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type". Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations#fields
   */
  readonly fields?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields[];

  /**
   * Treat the contents of the field as free text, and selectively transform content that matches an InfoType. Only one of primitive_transformation or info_type_transformations must be specified. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations#infoTypeTransformations
   */
  readonly infoTypeTransformations?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations[];

  /**
   * Primitive transformation to apply to the infoType. The primitive_transformation block must only contain one argument, corresponding to the type of transformation. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations#primitiveTransformation
   */
  readonly primitiveTransformation?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition(y)),
    'fields': obj.fields?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields(y)),
    'infoTypeTransformations': obj.infoTypeTransformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations(y)),
    'primitiveTransformation': obj.primitiveTransformation?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions {
  /**
   * A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions#condition
   */
  readonly condition?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms {
  /**
   * Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms#allInfoTypes
   */
  readonly allInfoTypes?: any[];

  /**
   * Apply transformation to all text that doesn't match an infoType.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms#allText
   */
  readonly allText?: any[];

  /**
   * The color to use when redacting content from an image. If not specified, the default is black. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms#redactionColor
   */
  readonly redactionColor?: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor[];

  /**
   * Apply transformation to the selected infoTypes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms#selectedInfoTypes
   */
  readonly selectedInfoTypes?: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allInfoTypes': obj.allInfoTypes?.map(y => y),
    'allText': obj.allText?.map(y => y),
    'redactionColor': obj.redactionColor?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor(y)),
    'selectedInfoTypes': obj.selectedInfoTypes?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformations
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformations {
  /**
   * InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to all findings that correspond to infoTypes that were requested in InspectConfig. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformations#infoTypes
   */
  readonly infoTypes?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes[];

  /**
   * Primitive transformation to apply to the infoType. The primitive_transformation block must only contain one argument, corresponding to the type of transformation. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformations#primitiveTransformation
   */
  readonly primitiveTransformation?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformations(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes(y)),
    'primitiveTransformation': obj.primitiveTransformation?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations {
  /**
   * A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations#condition
   */
  readonly condition?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition[];

  /**
   * Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId. FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type". Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations#fields
   */
  readonly fields?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields[];

  /**
   * Treat the contents of the field as free text, and selectively transform content that matches an InfoType. Only one of primitive_transformation or info_type_transformations must be specified. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations#infoTypeTransformations
   */
  readonly infoTypeTransformations?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations[];

  /**
   * Primitive transformation to apply to the infoType. The primitive_transformation block must only contain one argument, corresponding to the type of transformation. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations#primitiveTransformation
   */
  readonly primitiveTransformation?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition(y)),
    'fields': obj.fields?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields(y)),
    'infoTypeTransformations': obj.infoTypeTransformations?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations(y)),
    'primitiveTransformation': obj.primitiveTransformation?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressions
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressions {
  /**
   * A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressions#condition
   */
  readonly condition?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressions(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeidentifyTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor {
  /**
   * The amount of blue in the color as a value in the interval [0, 1].
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor#blue
   */
  readonly blue?: number;

  /**
   * The amount of green in the color as a value in the interval [0, 1].
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor#green
   */
  readonly green?: number;

  /**
   * The amount of red in the color as a value in the interval [0, 1].
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor#red
   */
  readonly red?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsRedactionColor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blue': obj.blue,
    'green': obj.green,
    'red': obj.red,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes {
  /**
   * InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to all findings that correspond to infoTypes that were requested in InspectConfig. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes#infoTypes
   */
  readonly infoTypes?: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation {
  /**
   * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH This can be used on data of type: number, long, string, timestamp. If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#bucketingConfig
   */
  readonly bucketingConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig[];

  /**
   * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig[];

  /**
   * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig[];

  /**
   * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes. Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=). Currently, only string and integer values can be hashed. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoHashConfig
   */
  readonly cryptoHashConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig[];

  /**
   * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig[];

  /**
   * Shifts dates by random number of days, with option to be consistent for the same context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#dateShiftConfig
   */
  readonly dateShiftConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig[];

  /**
   * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies. The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20". This can be used on data of type: double, long. If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#fixedSizeBucketingConfig
   */
  readonly fixedSizeBucketingConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig[];

  /**
   * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#redactConfig
   */
  readonly redactConfig?: any[];

  /**
   * Replace each input value with a given value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig[];

  /**
   * Replace with a value randomly drawn (with replacement) from a dictionary. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceDictionaryConfig
   */
  readonly replaceDictionaryConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig[];

  /**
   * Replace each matching finding with the name of the info type.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceWithInfoTypeConfig
   */
  readonly replaceWithInfoTypeConfig?: boolean;

  /**
   * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#timePartConfig
   */
  readonly timePartConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketingConfig': obj.bucketingConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(y)),
    'characterMaskConfig': obj.characterMaskConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(y)),
    'cryptoDeterministicConfig': obj.cryptoDeterministicConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(y)),
    'cryptoHashConfig': obj.cryptoHashConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(y)),
    'cryptoReplaceFfxFpeConfig': obj.cryptoReplaceFfxFpeConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(y)),
    'dateShiftConfig': obj.dateShiftConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(y)),
    'fixedSizeBucketingConfig': obj.fixedSizeBucketingConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(y)),
    'redactConfig': obj.redactConfig?.map(y => y),
    'replaceConfig': obj.replaceConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(y)),
    'replaceDictionaryConfig': obj.replaceDictionaryConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig(y)),
    'replaceWithInfoTypeConfig': obj.replaceWithInfoTypeConfig,
    'timePartConfig': obj.timePartConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition {
  /**
   * An expression, consisting of an operator and conditions. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition#expressions
   */
  readonly expressions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expressions': obj.expressions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations {
  /**
   * Transformation for each infoType. Cannot specify more than one for a given infoType. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations#transformations
   */
  readonly transformations?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transformations': obj.transformations?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation {
  /**
   * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH This can be used on data of type: number, long, string, timestamp. If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#bucketingConfig
   */
  readonly bucketingConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig[];

  /**
   * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig[];

  /**
   * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig[];

  /**
   * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes. Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=). Currently, only string and integer values can be hashed. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoHashConfig
   */
  readonly cryptoHashConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig[];

  /**
   * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig[];

  /**
   * Shifts dates by random number of days, with option to be consistent for the same context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#dateShiftConfig
   */
  readonly dateShiftConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig[];

  /**
   * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies. The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20". This can be used on data of type: double, long. If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#fixedSizeBucketingConfig
   */
  readonly fixedSizeBucketingConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig[];

  /**
   * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#redactConfig
   */
  readonly redactConfig?: any[];

  /**
   * Replace each input value with a given value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig[];

  /**
   * Replace with a value randomly drawn (with replacement) from a dictionary. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#replaceDictionaryConfig
   */
  readonly replaceDictionaryConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig[];

  /**
   * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#timePartConfig
   */
  readonly timePartConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketingConfig': obj.bucketingConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig(y)),
    'characterMaskConfig': obj.characterMaskConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig(y)),
    'cryptoDeterministicConfig': obj.cryptoDeterministicConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig(y)),
    'cryptoHashConfig': obj.cryptoHashConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig(y)),
    'cryptoReplaceFfxFpeConfig': obj.cryptoReplaceFfxFpeConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(y)),
    'dateShiftConfig': obj.dateShiftConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig(y)),
    'fixedSizeBucketingConfig': obj.fixedSizeBucketingConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig(y)),
    'redactConfig': obj.redactConfig?.map(y => y),
    'replaceConfig': obj.replaceConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig(y)),
    'replaceDictionaryConfig': obj.replaceDictionaryConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig(y)),
    'timePartConfig': obj.timePartConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition {
  /**
   * An expression, consisting of an operator and conditions. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition#expressions
   */
  readonly expressions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expressions': obj.expressions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor {
  /**
   * The amount of blue in the color as a value in the interval [0, 1].
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor#blue
   */
  readonly blue?: number;

  /**
   * The amount of green in the color as a value in the interval [0, 1].
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor#green
   */
  readonly green?: number;

  /**
   * The amount of red in the color as a value in the interval [0, 1].
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor#red
   */
  readonly red?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsRedactionColor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blue': obj.blue,
    'green': obj.green,
    'red': obj.red,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes {
  /**
   * InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to all findings that correspond to infoTypes that were requested in InspectConfig. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes#infoTypes
   */
  readonly infoTypes?: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation {
  /**
   * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH This can be used on data of type: number, long, string, timestamp. If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#bucketingConfig
   */
  readonly bucketingConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig[];

  /**
   * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig[];

  /**
   * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig[];

  /**
   * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes. Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=). Currently, only string and integer values can be hashed. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoHashConfig
   */
  readonly cryptoHashConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig[];

  /**
   * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig[];

  /**
   * Shifts dates by random number of days, with option to be consistent for the same context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#dateShiftConfig
   */
  readonly dateShiftConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig[];

  /**
   * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies. The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20". This can be used on data of type: double, long. If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#fixedSizeBucketingConfig
   */
  readonly fixedSizeBucketingConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig[];

  /**
   * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#redactConfig
   */
  readonly redactConfig?: any[];

  /**
   * Replace each input value with a given value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig[];

  /**
   * Replace with a value randomly drawn (with replacement) from a dictionary. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceDictionaryConfig
   */
  readonly replaceDictionaryConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig[];

  /**
   * Replace each matching finding with the name of the info type.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceWithInfoTypeConfig
   */
  readonly replaceWithInfoTypeConfig?: boolean;

  /**
   * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#timePartConfig
   */
  readonly timePartConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketingConfig': obj.bucketingConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(y)),
    'characterMaskConfig': obj.characterMaskConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(y)),
    'cryptoDeterministicConfig': obj.cryptoDeterministicConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(y)),
    'cryptoHashConfig': obj.cryptoHashConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(y)),
    'cryptoReplaceFfxFpeConfig': obj.cryptoReplaceFfxFpeConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(y)),
    'dateShiftConfig': obj.dateShiftConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(y)),
    'fixedSizeBucketingConfig': obj.fixedSizeBucketingConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(y)),
    'redactConfig': obj.redactConfig?.map(y => y),
    'replaceConfig': obj.replaceConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(y)),
    'replaceDictionaryConfig': obj.replaceDictionaryConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig(y)),
    'replaceWithInfoTypeConfig': obj.replaceWithInfoTypeConfig,
    'timePartConfig': obj.timePartConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition {
  /**
   * An expression, consisting of an operator and conditions. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition#expressions
   */
  readonly expressions?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expressions': obj.expressions?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations {
  /**
   * Transformation for each infoType. Cannot specify more than one for a given infoType. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations#transformations
   */
  readonly transformations?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transformations': obj.transformations?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation {
  /**
   * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH This can be used on data of type: number, long, string, timestamp. If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#bucketingConfig
   */
  readonly bucketingConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig[];

  /**
   * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig[];

  /**
   * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig[];

  /**
   * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes. Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=). Currently, only string and integer values can be hashed. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoHashConfig
   */
  readonly cryptoHashConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig[];

  /**
   * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig[];

  /**
   * Shifts dates by random number of days, with option to be consistent for the same context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#dateShiftConfig
   */
  readonly dateShiftConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig[];

  /**
   * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies. The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20". This can be used on data of type: double, long. If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#fixedSizeBucketingConfig
   */
  readonly fixedSizeBucketingConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig[];

  /**
   * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#redactConfig
   */
  readonly redactConfig?: any[];

  /**
   * Replace each input value with a given value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig[];

  /**
   * Replace with a value randomly drawn (with replacement) from a dictionary. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#replaceDictionaryConfig
   */
  readonly replaceDictionaryConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig[];

  /**
   * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#timePartConfig
   */
  readonly timePartConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketingConfig': obj.bucketingConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig(y)),
    'characterMaskConfig': obj.characterMaskConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig(y)),
    'cryptoDeterministicConfig': obj.cryptoDeterministicConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig(y)),
    'cryptoHashConfig': obj.cryptoHashConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig(y)),
    'cryptoReplaceFfxFpeConfig': obj.cryptoReplaceFfxFpeConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(y)),
    'dateShiftConfig': obj.dateShiftConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig(y)),
    'fixedSizeBucketingConfig': obj.fixedSizeBucketingConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig(y)),
    'redactConfig': obj.redactConfig?.map(y => y),
    'replaceConfig': obj.replaceConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig(y)),
    'replaceDictionaryConfig': obj.replaceDictionaryConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig(y)),
    'timePartConfig': obj.timePartConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition {
  /**
   * An expression, consisting of an operator and conditions. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition#expressions
   */
  readonly expressions?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expressions': obj.expressions?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
  /**
   * Set of buckets. Ranges must be non-overlapping. Bucket is represented as a range, along with replacement values. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig#buckets
   */
  readonly buckets?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * is *
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * 4
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * is false
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey[];

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(y)),
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey[];

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(y)),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey[];

  /**
   * Range of shift in days. Negative means shift to earlier in time.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#lowerBoundDays
   */
  readonly lowerBoundDays?: number;

  /**
   * Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#upperBoundDays
   */
  readonly upperBoundDays?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(y)),
    'lowerBoundDays': obj.lowerBoundDays,
    'upperBoundDays': obj.upperBoundDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
  /**
   * Size of each bucket (except for minimum and maximum buckets). So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#bucketSize
   */
  readonly bucketSize?: number;

  /**
   * Lower bound value of buckets. All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10". The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#lowerBound
   */
  readonly lowerBound?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound[];

  /**
   * Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+". The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#upperBound
   */
  readonly upperBound?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketSize': obj.bucketSize,
    'lowerBound': obj.lowerBound?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(y)),
    'upperBound': obj.upperBound?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Replace each input value with a given value. The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': obj.newValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig {
  /**
   * A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig#wordList
   */
  readonly wordList?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'wordList': obj.wordList?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig {
  /**
   * The part of the time to keep. Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig#partToExtract
   */
  readonly partToExtract?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partToExtract': obj.partToExtract,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions[];

  /**
   * The operator to apply to the result of conditions. Default and currently only supported value is AND. Default value is AND. Possible values are: AND.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions#logicalOperator
   */
  readonly logicalOperator?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions(y)),
    'logicalOperator': obj.logicalOperator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations {
  /**
   * InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to all findings that correspond to infoTypes that were requested in InspectConfig. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations#infoTypes
   */
  readonly infoTypes?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes[];

  /**
   * Primitive transformation to apply to the infoType. The primitive_transformation block must only contain one argument, corresponding to the type of transformation. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations#primitiveTransformation
   */
  readonly primitiveTransformation?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes(y)),
    'primitiveTransformation': obj.primitiveTransformation?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig {
  /**
   * Set of buckets. Ranges must be non-overlapping. Bucket is represented as a range, along with replacement values. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig#buckets
   */
  readonly buckets?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * is *
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * 4
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * is false
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey[];

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(y)),
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig {
  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey[];

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(y)),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey[];

  /**
   * Range of shift in days. Negative means shift to earlier in time.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#lowerBoundDays
   */
  readonly lowerBoundDays?: number;

  /**
   * Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#upperBoundDays
   */
  readonly upperBoundDays?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(y)),
    'lowerBoundDays': obj.lowerBoundDays,
    'upperBoundDays': obj.upperBoundDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
  /**
   * Size of each bucket (except for minimum and maximum buckets). So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#bucketSize
   */
  readonly bucketSize?: number;

  /**
   * Lower bound value of buckets. All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10". The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#lowerBound
   */
  readonly lowerBound?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound[];

  /**
   * Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+". The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#upperBound
   */
  readonly upperBound?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketSize': obj.bucketSize,
    'lowerBound': obj.lowerBound?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(y)),
    'upperBound': obj.upperBound?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Replace each input value with a given value. The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': obj.newValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig {
  /**
   * A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig#wordList
   */
  readonly wordList?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'wordList': obj.wordList?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig {
  /**
   * The part of the time to keep. Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig#partToExtract
   */
  readonly partToExtract?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partToExtract': obj.partToExtract,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions[];

  /**
   * The operator to apply to the result of conditions. Default and currently only supported value is AND. Default value is AND. Possible values are: AND.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions#logicalOperator
   */
  readonly logicalOperator?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions(y)),
    'logicalOperator': obj.logicalOperator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
  /**
   * Set of buckets. Ranges must be non-overlapping. Bucket is represented as a range, along with replacement values. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig#buckets
   */
  readonly buckets?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * is *
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * 4
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * is false
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey[];

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(y)),
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey[];

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(y)),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#context
   */
  readonly context?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey[];

  /**
   * Range of shift in days. Negative means shift to earlier in time.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#lowerBoundDays
   */
  readonly lowerBoundDays?: number;

  /**
   * Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#upperBoundDays
   */
  readonly upperBoundDays?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(y)),
    'lowerBoundDays': obj.lowerBoundDays,
    'upperBoundDays': obj.upperBoundDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
  /**
   * Size of each bucket (except for minimum and maximum buckets). So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#bucketSize
   */
  readonly bucketSize?: number;

  /**
   * Lower bound value of buckets. All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10". The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#lowerBound
   */
  readonly lowerBound?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound[];

  /**
   * Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+". The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#upperBound
   */
  readonly upperBound?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketSize': obj.bucketSize,
    'lowerBound': obj.lowerBound?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(y)),
    'upperBound': obj.upperBound?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Replace each input value with a given value. The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': obj.newValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig {
  /**
   * A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig#wordList
   */
  readonly wordList?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'wordList': obj.wordList?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig {
  /**
   * The part of the time to keep. Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig#partToExtract
   */
  readonly partToExtract?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partToExtract': obj.partToExtract,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions[];

  /**
   * The operator to apply to the result of conditions. Default and currently only supported value is AND. Default value is AND. Possible values are: AND.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions#logicalOperator
   */
  readonly logicalOperator?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions(y)),
    'logicalOperator': obj.logicalOperator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations {
  /**
   * InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to all findings that correspond to infoTypes that were requested in InspectConfig. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations#infoTypes
   */
  readonly infoTypes?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes[];

  /**
   * Primitive transformation to apply to the infoType. The primitive_transformation block must only contain one argument, corresponding to the type of transformation. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations#primitiveTransformation
   */
  readonly primitiveTransformation?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes(y)),
    'primitiveTransformation': obj.primitiveTransformation?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig {
  /**
   * Set of buckets. Ranges must be non-overlapping. Bucket is represented as a range, along with replacement values. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig#buckets
   */
  readonly buckets?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * is *
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * 4
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * is false
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey[];

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(y)),
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig {
  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey[];

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(y)),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#context
   */
  readonly context?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey[];

  /**
   * Range of shift in days. Negative means shift to earlier in time.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#lowerBoundDays
   */
  readonly lowerBoundDays?: number;

  /**
   * Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#upperBoundDays
   */
  readonly upperBoundDays?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(y)),
    'lowerBoundDays': obj.lowerBoundDays,
    'upperBoundDays': obj.upperBoundDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
  /**
   * Size of each bucket (except for minimum and maximum buckets). So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#bucketSize
   */
  readonly bucketSize?: number;

  /**
   * Lower bound value of buckets. All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10". The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#lowerBound
   */
  readonly lowerBound?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound[];

  /**
   * Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+". The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#upperBound
   */
  readonly upperBound?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketSize': obj.bucketSize,
    'lowerBound': obj.lowerBound?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(y)),
    'upperBound': obj.upperBound?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Replace each input value with a given value. The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': obj.newValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig {
  /**
   * A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig#wordList
   */
  readonly wordList?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'wordList': obj.wordList?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig {
  /**
   * The part of the time to keep. Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig#partToExtract
   */
  readonly partToExtract?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partToExtract': obj.partToExtract,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions[];

  /**
   * The operator to apply to the result of conditions. Default and currently only supported value is AND. Default value is AND. Possible values are: AND.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions#logicalOperator
   */
  readonly logicalOperator?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions(y)),
    'logicalOperator': obj.logicalOperator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
  /**
   * Upper bound of the range, exclusive; type must match min. The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#max
   */
  readonly max?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax[];

  /**
   * Lower bound of the range, inclusive. Type should be the same as max if used. The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#min
   */
  readonly min?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin[];

  /**
   * Replacement value for this bucket. The replacement_value block must only contain one argument. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#replacementValue
   */
  readonly replacementValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(y)),
    'min': obj.min?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(y)),
    'replacementValue': obj.replacementValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#integerValue
   */
  readonly integerValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#integerValue
   */
  readonly integerValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation {
  /**
   * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH This can be used on data of type: number, long, string, timestamp. If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#bucketingConfig
   */
  readonly bucketingConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig[];

  /**
   * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig[];

  /**
   * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig[];

  /**
   * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes. Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=). Currently, only string and integer values can be hashed. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoHashConfig
   */
  readonly cryptoHashConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig[];

  /**
   * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig[];

  /**
   * Shifts dates by random number of days, with option to be consistent for the same context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#dateShiftConfig
   */
  readonly dateShiftConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig[];

  /**
   * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies. The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20". This can be used on data of type: double, long. If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#fixedSizeBucketingConfig
   */
  readonly fixedSizeBucketingConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig[];

  /**
   * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#redactConfig
   */
  readonly redactConfig?: any[];

  /**
   * Replace each input value with a given value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig[];

  /**
   * Replace with a value randomly drawn (with replacement) from a dictionary. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceDictionaryConfig
   */
  readonly replaceDictionaryConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig[];

  /**
   * Replace each matching finding with the name of the info type.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceWithInfoTypeConfig
   */
  readonly replaceWithInfoTypeConfig?: any[];

  /**
   * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#timePartConfig
   */
  readonly timePartConfig?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketingConfig': obj.bucketingConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(y)),
    'characterMaskConfig': obj.characterMaskConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(y)),
    'cryptoDeterministicConfig': obj.cryptoDeterministicConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(y)),
    'cryptoHashConfig': obj.cryptoHashConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(y)),
    'cryptoReplaceFfxFpeConfig': obj.cryptoReplaceFfxFpeConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(y)),
    'dateShiftConfig': obj.dateShiftConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(y)),
    'fixedSizeBucketingConfig': obj.fixedSizeBucketingConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(y)),
    'redactConfig': obj.redactConfig?.map(y => y),
    'replaceConfig': obj.replaceConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(y)),
    'replaceDictionaryConfig': obj.replaceDictionaryConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig(y)),
    'replaceWithInfoTypeConfig': obj.replaceWithInfoTypeConfig?.map(y => y),
    'timePartConfig': obj.timePartConfig?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets {
  /**
   * Upper bound of the range, exclusive; type must match min. The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#max
   */
  readonly max?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax[];

  /**
   * Lower bound of the range, inclusive. Type should be the same as max if used. The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#min
   */
  readonly min?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin[];

  /**
   * Replacement value for this bucket. The replacement_value block must only contain one argument. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#replacementValue
   */
  readonly replacementValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax(y)),
    'min': obj.min?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin(y)),
    'replacementValue': obj.replacementValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigImageTransformationsTransformsSelectedInfoTypesInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
  /**
   * Upper bound of the range, exclusive; type must match min. The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#max
   */
  readonly max?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax[];

  /**
   * Lower bound of the range, inclusive. Type should be the same as max if used. The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#min
   */
  readonly min?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin[];

  /**
   * Replacement value for this bucket. The replacement_value block must only contain one argument. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#replacementValue
   */
  readonly replacementValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(y)),
    'min': obj.min?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(y)),
    'replacementValue': obj.replacementValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#integerValue
   */
  readonly integerValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#integerValue
   */
  readonly integerValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation {
  /**
   * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH This can be used on data of type: number, long, string, timestamp. If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#bucketingConfig
   */
  readonly bucketingConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig[];

  /**
   * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig[];

  /**
   * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig[];

  /**
   * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes. Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=). Currently, only string and integer values can be hashed. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoHashConfig
   */
  readonly cryptoHashConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig[];

  /**
   * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the content.reidentify API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn more. Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig[];

  /**
   * Shifts dates by random number of days, with option to be consistent for the same context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#dateShiftConfig
   */
  readonly dateShiftConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig[];

  /**
   * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies. The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20". This can be used on data of type: double, long. If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing. See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#fixedSizeBucketingConfig
   */
  readonly fixedSizeBucketingConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig[];

  /**
   * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#redactConfig
   */
  readonly redactConfig?: any[];

  /**
   * Replace each input value with a given value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig[];

  /**
   * Replace with a value randomly drawn (with replacement) from a dictionary. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceDictionaryConfig
   */
  readonly replaceDictionaryConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig[];

  /**
   * Replace each matching finding with the name of the info type.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceWithInfoTypeConfig
   */
  readonly replaceWithInfoTypeConfig?: any[];

  /**
   * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#timePartConfig
   */
  readonly timePartConfig?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketingConfig': obj.bucketingConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(y)),
    'characterMaskConfig': obj.characterMaskConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(y)),
    'cryptoDeterministicConfig': obj.cryptoDeterministicConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(y)),
    'cryptoHashConfig': obj.cryptoHashConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(y)),
    'cryptoReplaceFfxFpeConfig': obj.cryptoReplaceFfxFpeConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(y)),
    'dateShiftConfig': obj.dateShiftConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(y)),
    'fixedSizeBucketingConfig': obj.fixedSizeBucketingConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(y)),
    'redactConfig': obj.redactConfig?.map(y => y),
    'replaceConfig': obj.replaceConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(y)),
    'replaceDictionaryConfig': obj.replaceDictionaryConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig(y)),
    'replaceWithInfoTypeConfig': obj.replaceWithInfoTypeConfig?.map(y => y),
    'timePartConfig': obj.timePartConfig?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets {
  /**
   * Upper bound of the range, exclusive; type must match min. The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#max
   */
  readonly max?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax[];

  /**
   * Lower bound of the range, inclusive. Type should be the same as max if used. The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#min
   */
  readonly min?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin[];

  /**
   * Replacement value for this bucket. The replacement_value block must only contain one argument. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#replacementValue
   */
  readonly replacementValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax(y)),
    'min': obj.min?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin(y)),
    'replacementValue': obj.replacementValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions {
  /**
   * Conditions to apply to the expression. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions#conditions
   */
  readonly conditions?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions {
  /**
   * Field within the record this condition is evaluated against. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#field
   */
  readonly field?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField[];

  /**
   * Operator used to compare the field or infoType to the value. Possible values are: EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, EXISTS.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#operator
   */
  readonly operator?: string;

  /**
   * Value to compare against. The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set. This argument is mandatory, except for conditions using the EXISTS operator. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#value
   */
  readonly value?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField(y)),
    'operator': obj.operator,
    'value': obj.value?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
  /**
   * Set of buckets. Ranges must be non-overlapping. Bucket is represented as a range, along with replacement values. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig#buckets
   */
  readonly buckets?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * is *
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * 4
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * is false
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey[];

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(y)),
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey[];

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(y)),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#context
   */
  readonly context?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey[];

  /**
   * Range of shift in days. Negative means shift to earlier in time.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#lowerBoundDays
   */
  readonly lowerBoundDays?: number;

  /**
   * Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#upperBoundDays
   */
  readonly upperBoundDays?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(y)),
    'lowerBoundDays': obj.lowerBoundDays,
    'upperBoundDays': obj.upperBoundDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
  /**
   * Size of each bucket (except for minimum and maximum buckets). So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#bucketSize
   */
  readonly bucketSize?: number;

  /**
   * Lower bound value of buckets. All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10". The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#lowerBound
   */
  readonly lowerBound?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound[];

  /**
   * Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+". The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#upperBound
   */
  readonly upperBound?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketSize': obj.bucketSize,
    'lowerBound': obj.lowerBound?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(y)),
    'upperBound': obj.upperBound?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Replace each input value with a given value. The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': obj.newValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig {
  /**
   * A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig#wordList
   */
  readonly wordList?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'wordList': obj.wordList?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig {
  /**
   * The part of the time to keep. Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig#partToExtract
   */
  readonly partToExtract?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partToExtract': obj.partToExtract,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions {
  /**
   * Field within the record this condition is evaluated against. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#field
   */
  readonly field?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField[];

  /**
   * Operator used to compare the field or infoType to the value. Possible values are: EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, EXISTS.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#operator
   */
  readonly operator?: string;

  /**
   * Value to compare against. The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set. This argument is mandatory, except for conditions using the EXISTS operator. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#value
   */
  readonly value?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField(y)),
    'operator': obj.operator,
    'value': obj.value?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions {
  /**
   * Field within the record this condition is evaluated against. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#field
   */
  readonly field?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField[];

  /**
   * Operator used to compare the field or infoType to the value. Possible values are: EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, EXISTS.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#operator
   */
  readonly operator?: string;

  /**
   * Value to compare against. The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set. This argument is mandatory, except for conditions using the EXISTS operator. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#value
   */
  readonly value?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField(y)),
    'operator': obj.operator,
    'value': obj.value?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
  /**
   * Set of buckets. Ranges must be non-overlapping. Bucket is represented as a range, along with replacement values. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig#buckets
   */
  readonly buckets?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * is *
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * 4
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * is false
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey[];

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(y)),
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values are: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey[];

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType SurrogateType. This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(y)),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': obj.surrogateInfoType?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#context
   */
  readonly context?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext[];

  /**
   * The key used by the encryption function. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#cryptoKey
   */
  readonly cryptoKey?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey[];

  /**
   * Range of shift in days. Negative means shift to earlier in time.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#lowerBoundDays
   */
  readonly lowerBoundDays?: number;

  /**
   * Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#upperBoundDays
   */
  readonly upperBoundDays?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(y)),
    'cryptoKey': obj.cryptoKey?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(y)),
    'lowerBoundDays': obj.lowerBoundDays,
    'upperBoundDays': obj.upperBoundDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
  /**
   * Size of each bucket (except for minimum and maximum buckets). So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#bucketSize
   */
  readonly bucketSize?: number;

  /**
   * Lower bound value of buckets. All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10". The lower_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#lowerBound
   */
  readonly lowerBound?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound[];

  /**
   * Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+". The upper_bound block must only contain one argument. See the fixed_size_bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#upperBound
   */
  readonly upperBound?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketSize': obj.bucketSize,
    'lowerBound': obj.lowerBound?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(y)),
    'upperBound': obj.upperBound?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Replace each input value with a given value. The new_value block must only contain one argument. For example when replacing the contents of a string-type field, only string_value should be set. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': obj.newValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig {
  /**
   * A list of words to select from for random replacement. The limits page contains details about the size limits of dictionaries. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig#wordList
   */
  readonly wordList?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'wordList': obj.wordList?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig {
  /**
   * The part of the time to keep. Possible values are: YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig#partToExtract
   */
  readonly partToExtract?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partToExtract': obj.partToExtract,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions {
  /**
   * Field within the record this condition is evaluated against. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#field
   */
  readonly field?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField[];

  /**
   * Operator used to compare the field or infoType to the value. Possible values are: EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN_OR_EQUALS, EXISTS.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#operator
   */
  readonly operator?: string;

  /**
   * Value to compare against. The value block must only contain one argument. For example when a condition is evaluated against a string-type field, only string_value should be set. This argument is mandatory, except for conditions using the EXISTS operator. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#value
   */
  readonly value?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField(y)),
    'operator': obj.operator,
    'value': obj.value?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
  /**
   * Upper bound of the range, exclusive; type must match min. The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#max
   */
  readonly max?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax[];

  /**
   * Lower bound of the range, inclusive. Type should be the same as max if used. The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#min
   */
  readonly min?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin[];

  /**
   * Replacement value for this bucket. The replacement_value block must only contain one argument. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#replacementValue
   */
  readonly replacementValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(y)),
    'min': obj.min?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(y)),
    'replacementValue': obj.replacementValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#integerValue
   */
  readonly integerValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#integerValue
   */
  readonly integerValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
  /**
   * Upper bound of the range, exclusive; type must match min. The max block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#max
   */
  readonly max?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax[];

  /**
   * Lower bound of the range, inclusive. Type should be the same as max if used. The min block must only contain one argument. See the bucketing_config block description for more information about choosing a data type. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#min
   */
  readonly min?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin[];

  /**
   * Replacement value for this bucket. The replacement_value block must only contain one argument. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#replacementValue
   */
  readonly replacementValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(y)),
    'min': obj.min?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(y)),
    'replacementValue': obj.replacementValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values are: NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: any[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: any[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: any[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#sensitivityScore
   */
  readonly sensitivityScore?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore[];

  /**
   * Optional version name for this InfoType.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
  /**
   * KMS wrapped key. Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt For more information, see Creating a wrapped key. Note: When you use Cloud KMS for cryptographic operations, charges apply. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped[];

  /**
   * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#transient
   */
  readonly transient?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient[];

  /**
   * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: any[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': obj.kmsWrapped?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(y)),
    'transient': obj.transient?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(y)),
    'unwrapped': obj.unwrapped?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#integerValue
   */
  readonly integerValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#integerValue
   */
  readonly integerValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceDictionaryConfigWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue {
  /**
   * A boolean value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped#keySecretRef
   */
  readonly keySecretRef: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keySecretRef': toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped#keySecretRef
   */
  readonly keySecretRef: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keySecretRef': toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped#keySecretRef
   */
  readonly keySecretRef: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keySecretRef': toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
  /**
   * A 128/192/256 bit key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped#keySecretRef
   */
  readonly keySecretRef: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keySecretRef': toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
  /**
   * Represents a whole or partial calendar date. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dateValue
   */
  readonly dateValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue[];

  /**
   * Represents a day of the week. Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * A float value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * An integer value (int64 format)
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#integerValue
   */
  readonly integerValue?: string;

  /**
   * A string value.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * Represents a time of day. Structure is documented below.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timeValue
   */
  readonly timeValue?: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue[];

  /**
   * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(y)),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': obj.timeValue?.map(y => toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(y)),
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
  /**
   * The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#cryptoKeyName
   */
  readonly cryptoKeyName?: string;

  /**
   * The wrapped data crypto key. A base64-encoded string.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyName': obj.cryptoKeyName,
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
  /**
   * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate TransientCryptoKey protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A 128/192/256 bit key. A base64-encoded string.
 *
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef {
  /**
   * The key to select.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A 128/192/256 bit key. A base64-encoded string.
 *
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef {
  /**
   * The key to select.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A 128/192/256 bit key. A base64-encoded string.
 *
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef {
  /**
   * The key to select.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A 128/192/256 bit key. A base64-encoded string.
 *
 * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef
 */
export interface DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef {
  /**
   * The key to select.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef(obj: DeidentifyTemplateSpecForProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue {
  /**
   * Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of year. Must be from 1 to 12, or 0 if specifying a year without a month and day.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of date. Must be from 1 to 9999, or 0 if specifying a date without a year.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
 */
export interface DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59.
   *
   * @schema DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj: DeidentifyTemplateSpecInitProviderDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * InspectTemplate is the Schema for the InspectTemplates API. An inspect job template.
 *
 * @schema InspectTemplate
 */
export class InspectTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InspectTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datalossprevention.gcp.upbound.io/v1beta1',
    kind: 'InspectTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "InspectTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InspectTemplateProps): any {
    return {
      ...InspectTemplate.GVK,
      ...toJson_InspectTemplateProps(props),
    };
  }

  /**
   * Defines a "InspectTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InspectTemplateProps) {
    super(scope, id, {
      ...InspectTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InspectTemplate.GVK,
      ...toJson_InspectTemplateProps(resolved),
    };
  }
}

/**
 * InspectTemplate is the Schema for the InspectTemplates API. An inspect job template.
 *
 * @schema InspectTemplate
 */
export interface InspectTemplateProps {
  /**
   * @schema InspectTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InspectTemplateSpec defines the desired state of InspectTemplate
   *
   * @schema InspectTemplate#spec
   */
  readonly spec: InspectTemplateSpec;

}

/**
 * Converts an object of type 'InspectTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateProps(obj: InspectTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InspectTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InspectTemplateSpec defines the desired state of InspectTemplate
 *
 * @schema InspectTemplateSpec
 */
export interface InspectTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InspectTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: InspectTemplateSpecDeletionPolicy;

  /**
   * @schema InspectTemplateSpec#forProvider
   */
  readonly forProvider: InspectTemplateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InspectTemplateSpec#initProvider
   */
  readonly initProvider?: InspectTemplateSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InspectTemplateSpec#managementPolicies
   */
  readonly managementPolicies?: InspectTemplateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InspectTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: InspectTemplateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InspectTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InspectTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InspectTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InspectTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InspectTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpec(obj: InspectTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InspectTemplateSpecForProvider(obj.forProvider),
    'initProvider': toJson_InspectTemplateSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InspectTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InspectTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InspectTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InspectTemplateSpecDeletionPolicy
 */
export enum InspectTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InspectTemplateSpecForProvider
 */
export interface InspectTemplateSpecForProvider {
  /**
   * A description of the inspect template.
   *
   * @schema InspectTemplateSpecForProvider#description
   */
  readonly description?: string;

  /**
   * User set display name of the inspect template.
   *
   * @schema InspectTemplateSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The core content of the template. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProvider#inspectConfig
   */
  readonly inspectConfig?: InspectTemplateSpecForProviderInspectConfig[];

  /**
   * The parent of the inspect template in any of the following formats:
   *
   * @schema InspectTemplateSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * The template id can contain uppercase and lowercase letters, numbers, and hyphens; that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is 100 characters. Can be empty to allow the system to generate one.
   *
   * @schema InspectTemplateSpecForProvider#templateId
   */
  readonly templateId?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProvider(obj: InspectTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'inspectConfig': obj.inspectConfig?.map(y => toJson_InspectTemplateSpecForProviderInspectConfig(y)),
    'parent': obj.parent,
    'templateId': obj.templateId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema InspectTemplateSpecInitProvider
 */
export interface InspectTemplateSpecInitProvider {
  /**
   * A description of the inspect template.
   *
   * @schema InspectTemplateSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * User set display name of the inspect template.
   *
   * @schema InspectTemplateSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The core content of the template. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProvider#inspectConfig
   */
  readonly inspectConfig?: InspectTemplateSpecInitProviderInspectConfig[];

  /**
   * The parent of the inspect template in any of the following formats:
   *
   * @schema InspectTemplateSpecInitProvider#parent
   */
  readonly parent?: string;

  /**
   * The template id can contain uppercase and lowercase letters, numbers, and hyphens; that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is 100 characters. Can be empty to allow the system to generate one.
   *
   * @schema InspectTemplateSpecInitProvider#templateId
   */
  readonly templateId?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProvider(obj: InspectTemplateSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'inspectConfig': obj.inspectConfig?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfig(y)),
    'parent': obj.parent,
    'templateId': obj.templateId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InspectTemplateSpecManagementPolicies
 */
export enum InspectTemplateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InspectTemplateSpecProviderConfigRef
 */
export interface InspectTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InspectTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InspectTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: InspectTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InspectTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecProviderConfigRef(obj: InspectTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InspectTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsTo
 */
export interface InspectTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InspectTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InspectTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecPublishConnectionDetailsTo(obj: InspectTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InspectTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InspectTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InspectTemplateSpecWriteConnectionSecretToRef
 */
export interface InspectTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InspectTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InspectTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecWriteConnectionSecretToRef(obj: InspectTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfig
 */
export interface InspectTemplateSpecForProviderInspectConfig {
  /**
   * List of options defining data content to scan. If empty, text, images, and other content will be included. Each value may be one of: CONTENT_TEXT, CONTENT_IMAGE.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#contentOptions
   */
  readonly contentOptions?: string[];

  /**
   * Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#customInfoTypes
   */
  readonly customInfoTypes?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypes[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#excludeInfoTypes
   */
  readonly excludeInfoTypes?: boolean;

  /**
   * When true, a contextual quote from the data that triggered a finding is included in the response.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#includeQuote
   */
  readonly includeQuote?: boolean;

  /**
   * Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list or listed at https://cloud.google.com/dlp/docs/infotypes-reference. When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run. By default this may be all types, but may change over time as detectors are updated. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#infoTypes
   */
  readonly infoTypes?: InspectTemplateSpecForProviderInspectConfigInfoTypes[];

  /**
   * Configuration to control the number of findings returned. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#limits
   */
  readonly limits?: InspectTemplateSpecForProviderInspectConfigLimits[];

  /**
   * Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info Default value is POSSIBLE. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#minLikelihood
   */
  readonly minLikelihood?: string;

  /**
   * Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfig#ruleSet
   */
  readonly ruleSet?: InspectTemplateSpecForProviderInspectConfigRuleSet[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfig(obj: InspectTemplateSpecForProviderInspectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentOptions': obj.contentOptions?.map(y => y),
    'customInfoTypes': obj.customInfoTypes?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypes(y)),
    'excludeInfoTypes': obj.excludeInfoTypes,
    'includeQuote': obj.includeQuote,
    'infoTypes': obj.infoTypes?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigInfoTypes(y)),
    'limits': obj.limits?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigLimits(y)),
    'minLikelihood': obj.minLikelihood,
    'ruleSet': obj.ruleSet?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfig
 */
export interface InspectTemplateSpecInitProviderInspectConfig {
  /**
   * List of options defining data content to scan. If empty, text, images, and other content will be included. Each value may be one of: CONTENT_TEXT, CONTENT_IMAGE.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfig#contentOptions
   */
  readonly contentOptions?: string[];

  /**
   * Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfig#customInfoTypes
   */
  readonly customInfoTypes?: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfig#excludeInfoTypes
   */
  readonly excludeInfoTypes?: boolean;

  /**
   * When true, a contextual quote from the data that triggered a finding is included in the response.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfig#includeQuote
   */
  readonly includeQuote?: boolean;

  /**
   * Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list or listed at https://cloud.google.com/dlp/docs/infotypes-reference. When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run. By default this may be all types, but may change over time as detectors are updated. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfig#infoTypes
   */
  readonly infoTypes?: InspectTemplateSpecInitProviderInspectConfigInfoTypes[];

  /**
   * Configuration to control the number of findings returned. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfig#limits
   */
  readonly limits?: InspectTemplateSpecInitProviderInspectConfigLimits[];

  /**
   * Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info Default value is POSSIBLE. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfig#minLikelihood
   */
  readonly minLikelihood?: string;

  /**
   * Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfig#ruleSet
   */
  readonly ruleSet?: InspectTemplateSpecInitProviderInspectConfigRuleSet[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfig(obj: InspectTemplateSpecInitProviderInspectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentOptions': obj.contentOptions?.map(y => y),
    'customInfoTypes': obj.customInfoTypes?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes(y)),
    'excludeInfoTypes': obj.excludeInfoTypes,
    'includeQuote': obj.includeQuote,
    'infoTypes': obj.infoTypes?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigInfoTypes(y)),
    'limits': obj.limits?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigLimits(y)),
    'minLikelihood': obj.minLikelihood,
    'ruleSet': obj.ruleSet?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InspectTemplateSpecProviderConfigRefPolicy
 */
export interface InspectTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InspectTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InspectTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InspectTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InspectTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InspectTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecProviderConfigRefPolicy(obj: InspectTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface InspectTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InspectTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecPublishConnectionDetailsToConfigRef(obj: InspectTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface InspectTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecPublishConnectionDetailsToMetadata(obj: InspectTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypes {
  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#dictionary
   */
  readonly dictionary?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary[];

  /**
   * If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching. Possible values are: EXCLUSION_TYPE_EXCLUDE.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#exclusionType
   */
  readonly exclusionType?: string;

  /**
   * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does not have an infoType, the DLP API applies the limit against all infoTypes that are found but not specified in another InfoTypeLimit. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#infoType
   */
  readonly infoType?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType[];

  /**
   * Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria specified by the rule. Default value is VERY_LIKELY. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#likelihood
   */
  readonly likelihood?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#regex
   */
  readonly regex?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex[];

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesSensitivityScore[];

  /**
   * A reference to a StoredInfoType to use with scanning. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#storedType
   */
  readonly storedType?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType[];

  /**
   * Message for detecting output from deidentification transformations that support reversing.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypes#surrogateType
   */
  readonly surrogateType?: any[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypes(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': obj.dictionary?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary(y)),
    'exclusionType': obj.exclusionType,
    'infoType': obj.infoType?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType(y)),
    'likelihood': obj.likelihood,
    'regex': obj.regex?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex(y)),
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesSensitivityScore(y)),
    'storedType': obj.storedType?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType(y)),
    'surrogateType': obj.surrogateType?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigInfoTypes
 */
export interface InspectTemplateSpecForProviderInspectConfigInfoTypes {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecForProviderInspectConfigInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecForProviderInspectConfigInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigInfoTypes(obj: InspectTemplateSpecForProviderInspectConfigInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigLimits
 */
export interface InspectTemplateSpecForProviderInspectConfigLimits {
  /**
   * Configuration of findings limit given for specified infoTypes. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimits#maxFindingsPerInfoType
   */
  readonly maxFindingsPerInfoType?: InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType[];

  /**
   * Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimits#maxFindingsPerItem
   */
  readonly maxFindingsPerItem?: number;

  /**
   * Max number of findings that will be returned per request/job. The maximum returned is 2000.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimits#maxFindingsPerRequest
   */
  readonly maxFindingsPerRequest?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigLimits(obj: InspectTemplateSpecForProviderInspectConfigLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxFindingsPerInfoType': obj.maxFindingsPerInfoType?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType(y)),
    'maxFindingsPerItem': obj.maxFindingsPerItem,
    'maxFindingsPerRequest': obj.maxFindingsPerRequest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSet
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSet {
  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSet#infoTypes
   */
  readonly infoTypes?: InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes[];

  /**
   * Set of rules to be applied to infoTypes. The rules are applied in order. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSet#rules
   */
  readonly rules?: InspectTemplateSpecForProviderInspectConfigRuleSetRules[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSet(obj: InspectTemplateSpecForProviderInspectConfigRuleSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes(y)),
    'rules': obj.rules?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes
 */
export interface InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes {
  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes#dictionary
   */
  readonly dictionary?: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionary[];

  /**
   * If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching. Possible values are: EXCLUSION_TYPE_EXCLUDE.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes#exclusionType
   */
  readonly exclusionType?: string;

  /**
   * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does not have an infoType, the DLP API applies the limit against all infoTypes that are found but not specified in another InfoTypeLimit. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes#infoType
   */
  readonly infoType?: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoType[];

  /**
   * Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria specified by the rule. Default value is VERY_LIKELY. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes#likelihood
   */
  readonly likelihood?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes#regex
   */
  readonly regex?: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesRegex[];

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesSensitivityScore[];

  /**
   * A reference to a StoredInfoType to use with scanning. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes#storedType
   */
  readonly storedType?: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesStoredType[];

  /**
   * Message for detecting output from deidentification transformations that support reversing.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes#surrogateType
   */
  readonly surrogateType?: any[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes(obj: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': obj.dictionary?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionary(y)),
    'exclusionType': obj.exclusionType,
    'infoType': obj.infoType?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoType(y)),
    'likelihood': obj.likelihood,
    'regex': obj.regex?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesRegex(y)),
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesSensitivityScore(y)),
    'storedType': obj.storedType?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesStoredType(y)),
    'surrogateType': obj.surrogateType?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigInfoTypes
 */
export interface InspectTemplateSpecInitProviderInspectConfigInfoTypes {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecInitProviderInspectConfigInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigInfoTypes(obj: InspectTemplateSpecInitProviderInspectConfigInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigLimits
 */
export interface InspectTemplateSpecInitProviderInspectConfigLimits {
  /**
   * Configuration of findings limit given for specified infoTypes. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigLimits#maxFindingsPerInfoType
   */
  readonly maxFindingsPerInfoType?: InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoType[];

  /**
   * Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigLimits#maxFindingsPerItem
   */
  readonly maxFindingsPerItem?: number;

  /**
   * Max number of findings that will be returned per request/job. The maximum returned is 2000.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigLimits#maxFindingsPerRequest
   */
  readonly maxFindingsPerRequest?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigLimits(obj: InspectTemplateSpecInitProviderInspectConfigLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxFindingsPerInfoType': obj.maxFindingsPerInfoType?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoType(y)),
    'maxFindingsPerItem': obj.maxFindingsPerItem,
    'maxFindingsPerRequest': obj.maxFindingsPerRequest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSet
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSet {
  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSet#infoTypes
   */
  readonly infoTypes?: InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypes[];

  /**
   * Set of rules to be applied to infoTypes. The rules are applied in order. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSet#rules
   */
  readonly rules?: InspectTemplateSpecInitProviderInspectConfigRuleSetRules[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSet(obj: InspectTemplateSpecInitProviderInspectConfigRuleSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypes(y)),
    'rules': obj.rules?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InspectTemplateSpecProviderConfigRefPolicyResolution
 */
export enum InspectTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InspectTemplateSpecProviderConfigRefPolicyResolve
 */
export enum InspectTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary#wordList
   */
  readonly wordList?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesSensitivityScore
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesSensitivityScore(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesStoredType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigInfoTypesSensitivityScore
 */
export interface InspectTemplateSpecForProviderInspectConfigInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigInfoTypesSensitivityScore(obj: InspectTemplateSpecForProviderInspectConfigInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType
 */
export interface InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType {
  /**
   * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does not have an infoType, the DLP API applies the limit against all infoTypes that are found but not specified in another InfoTypeLimit. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType#infoType
   */
  readonly infoType?: InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType[];

  /**
   * Max findings limit for the given infoType.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType#maxFindings
   */
  readonly maxFindings?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType(obj: InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoType': obj.infoType?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(y)),
    'maxFindings': obj.maxFindings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes(obj: InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRules
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRules {
  /**
   * The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRules#exclusionRule
   */
  readonly exclusionRule?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule[];

  /**
   * Hotword-based detection rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRules#hotwordRule
   */
  readonly hotwordRule?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRules(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclusionRule': obj.exclusionRule?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule(y)),
    'hotwordRule': obj.hotwordRule?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionary
 */
export interface InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionary#wordList
   */
  readonly wordList?: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryWordList[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionary(obj: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoType
 */
export interface InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoType {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoType#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoType(obj: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesRegex
 */
export interface InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesRegex(obj: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesSensitivityScore
 */
export interface InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesSensitivityScore(obj: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesStoredType
 */
export interface InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesStoredType {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesStoredType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesStoredType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesStoredType(obj: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesStoredType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigInfoTypesSensitivityScore
 */
export interface InspectTemplateSpecInitProviderInspectConfigInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigInfoTypesSensitivityScore(obj: InspectTemplateSpecInitProviderInspectConfigInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoType
 */
export interface InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoType {
  /**
   * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does not have an infoType, the DLP API applies the limit against all infoTypes that are found but not specified in another InfoTypeLimit. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoType#infoType
   */
  readonly infoType?: InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType[];

  /**
   * Max findings limit for the given infoType.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoType#maxFindings
   */
  readonly maxFindings?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoType(obj: InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoType': obj.infoType?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(y)),
    'maxFindings': obj.maxFindings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypes
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypes {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypes(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRules
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRules {
  /**
   * The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRules#exclusionRule
   */
  readonly exclusionRule?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule[];

  /**
   * Hotword-based detection rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRules#hotwordRule
   */
  readonly hotwordRule?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRule[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRules(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclusionRule': obj.exclusionRule?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule(y)),
    'hotwordRule': obj.hotwordRule?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InspectTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore
 */
export interface InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore(obj: InspectTemplateSpecForProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType
 */
export interface InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(obj: InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypesSensitivityScore
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypesSensitivityScore(obj: InspectTemplateSpecForProviderInspectConfigRuleSetInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule {
  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule#dictionary
   */
  readonly dictionary?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary[];

  /**
   * Drop if the hotword rule is contained in the proximate context. For tabular data, the context includes the column name. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule#excludeByHotword
   */
  readonly excludeByHotword?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule#excludeInfoTypes
   */
  readonly excludeInfoTypes?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes[];

  /**
   * How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule#matchingType
   */
  readonly matchingType?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule#regex
   */
  readonly regex?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': obj.dictionary?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary(y)),
    'excludeByHotword': obj.excludeByHotword?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword(y)),
    'excludeInfoTypes': obj.excludeInfoTypes?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(y)),
    'matchingType': obj.matchingType,
    'regex': obj.regex?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule {
  /**
   * Regular expression pattern defining what qualifies as a hotword. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule#hotwordRegex
   */
  readonly hotwordRegex?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex[];

  /**
   * Likelihood adjustment to apply to all matching findings. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule#likelihoodAdjustment
   */
  readonly likelihoodAdjustment?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment[];

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex (xxx), where xxx is the area code in question. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule#proximity
   */
  readonly proximity?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': obj.hotwordRegex?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex(y)),
    'likelihoodAdjustment': obj.likelihoodAdjustment?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(y)),
    'proximity': obj.proximity?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath
 */
export interface InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath(obj: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryWordList
 */
export interface InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryWordList(obj: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore
 */
export interface InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore(obj: InspectTemplateSpecInitProviderInspectConfigCustomInfoTypesInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType
 */
export interface InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(obj: InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypesSensitivityScore
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypesSensitivityScore(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule {
  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule#dictionary
   */
  readonly dictionary?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary[];

  /**
   * Drop if the hotword rule is contained in the proximate context. For tabular data, the context includes the column name. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule#excludeByHotword
   */
  readonly excludeByHotword?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule#excludeInfoTypes
   */
  readonly excludeInfoTypes?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes[];

  /**
   * How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule#matchingType
   */
  readonly matchingType?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule#regex
   */
  readonly regex?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleRegex[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': obj.dictionary?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary(y)),
    'excludeByHotword': obj.excludeByHotword?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword(y)),
    'excludeInfoTypes': obj.excludeInfoTypes?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(y)),
    'matchingType': obj.matchingType,
    'regex': obj.regex?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleRegex(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRule
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRule {
  /**
   * Regular expression pattern defining what qualifies as a hotword. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRule#hotwordRegex
   */
  readonly hotwordRegex?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex[];

  /**
   * Likelihood adjustment to apply to all matching findings. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRule#likelihoodAdjustment
   */
  readonly likelihoodAdjustment?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment[];

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex (xxx), where xxx is the area code in question. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRule#proximity
   */
  readonly proximity?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleProximity[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRule(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': obj.hotwordRegex?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex(y)),
    'likelihoodAdjustment': obj.likelihoodAdjustment?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(y)),
    'proximity': obj.proximity?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleProximity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore
 */
export interface InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore(obj: InspectTemplateSpecForProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary#wordList
   */
  readonly wordList?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword {
  /**
   * Regular expression pattern defining what qualifies as a hotword. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword#hotwordRegex
   */
  readonly hotwordRegex?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex[];

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex (xxx), where xxx is the area code in question. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword#proximity
   */
  readonly proximity?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': obj.hotwordRegex?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex(y)),
    'proximity': obj.proximity?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes#infoTypes
   */
  readonly infoTypes?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
  /**
   * Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#fixedLikelihood
   */
  readonly fixedLikelihood?: string;

  /**
   * Increase or decrease the likelihood by the specified number of levels. For example, if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1, then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY. Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#relativeLikelihood
   */
  readonly relativeLikelihood?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedLikelihood': obj.fixedLikelihood,
    'relativeLikelihood': obj.relativeLikelihood,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity {
  /**
   * Number of characters after the finding to consider. Either this or window_before must be specified
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider. Either this or window_after must be specified
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesHotwordRuleProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore
 */
export interface InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore(obj: InspectTemplateSpecInitProviderInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary#wordList
   */
  readonly wordList?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword {
  /**
   * Regular expression pattern defining what qualifies as a hotword. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword#hotwordRegex
   */
  readonly hotwordRegex?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex[];

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex (xxx), where xxx is the area code in question. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword#proximity
   */
  readonly proximity?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': obj.hotwordRegex?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex(y)),
    'proximity': obj.proximity?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes#infoTypes
   */
  readonly infoTypes?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleRegex
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleRegex(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
  /**
   * Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#fixedLikelihood
   */
  readonly fixedLikelihood?: string;

  /**
   * Increase or decrease the likelihood by the specified number of levels. For example, if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1, then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY. Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#relativeLikelihood
   */
  readonly relativeLikelihood?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedLikelihood': obj.fixedLikelihood,
    'relativeLikelihood': obj.relativeLikelihood,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleProximity
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleProximity {
  /**
   * Number of characters after the finding to consider. Either this or window_before must be specified
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider. Either this or window_after must be specified
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleProximity(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesHotwordRuleProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity {
  /**
   * Number of characters after the finding to consider. Either this or window_before must be specified
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider. Either this or window_after must be specified
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity {
  /**
   * Number of characters after the finding to consider. Either this or window_before must be specified
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider. Either this or window_after must be specified
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
  /**
   * Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342 or projects/project-id/storedInfoTypes/432452342.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore
 */
export interface InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore(obj: InspectTemplateSpecForProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore
 */
export interface InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore(obj: InspectTemplateSpecInitProviderInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * JobTrigger is the Schema for the JobTriggers API. A job trigger configuration.
 *
 * @schema JobTrigger
 */
export class JobTrigger extends ApiObject {
  /**
   * Returns the apiVersion and kind for "JobTrigger"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datalossprevention.gcp.upbound.io/v1beta1',
    kind: 'JobTrigger',
  }

  /**
   * Renders a Kubernetes manifest for "JobTrigger".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: JobTriggerProps): any {
    return {
      ...JobTrigger.GVK,
      ...toJson_JobTriggerProps(props),
    };
  }

  /**
   * Defines a "JobTrigger" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: JobTriggerProps) {
    super(scope, id, {
      ...JobTrigger.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...JobTrigger.GVK,
      ...toJson_JobTriggerProps(resolved),
    };
  }
}

/**
 * JobTrigger is the Schema for the JobTriggers API. A job trigger configuration.
 *
 * @schema JobTrigger
 */
export interface JobTriggerProps {
  /**
   * @schema JobTrigger#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * JobTriggerSpec defines the desired state of JobTrigger
   *
   * @schema JobTrigger#spec
   */
  readonly spec: JobTriggerSpec;

}

/**
 * Converts an object of type 'JobTriggerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerProps(obj: JobTriggerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_JobTriggerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JobTriggerSpec defines the desired state of JobTrigger
 *
 * @schema JobTriggerSpec
 */
export interface JobTriggerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema JobTriggerSpec#deletionPolicy
   */
  readonly deletionPolicy?: JobTriggerSpecDeletionPolicy;

  /**
   * @schema JobTriggerSpec#forProvider
   */
  readonly forProvider: JobTriggerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema JobTriggerSpec#initProvider
   */
  readonly initProvider?: JobTriggerSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema JobTriggerSpec#managementPolicies
   */
  readonly managementPolicies?: JobTriggerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema JobTriggerSpec#providerConfigRef
   */
  readonly providerConfigRef?: JobTriggerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema JobTriggerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: JobTriggerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema JobTriggerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: JobTriggerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'JobTriggerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpec(obj: JobTriggerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_JobTriggerSpecForProvider(obj.forProvider),
    'initProvider': toJson_JobTriggerSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_JobTriggerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_JobTriggerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_JobTriggerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema JobTriggerSpecDeletionPolicy
 */
export enum JobTriggerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema JobTriggerSpecForProvider
 */
export interface JobTriggerSpecForProvider {
  /**
   * A description of the job trigger.
   *
   * @schema JobTriggerSpecForProvider#description
   */
  readonly description?: string;

  /**
   * User set display name of the job trigger.
   *
   * @schema JobTriggerSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Controls what and how to inspect for findings. Structure is documented below.
   *
   * @schema JobTriggerSpecForProvider#inspectJob
   */
  readonly inspectJob?: JobTriggerSpecForProviderInspectJob[];

  /**
   * The parent of the trigger, either in the format projects/{{project}} or projects/{{project}}/locations/{{location}}
   *
   * @schema JobTriggerSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Whether the trigger is currently active. Default value is HEALTHY. Possible values are: PAUSED, HEALTHY, CANCELLED.
   *
   * @schema JobTriggerSpecForProvider#status
   */
  readonly status?: string;

  /**
   * The trigger id can contain uppercase and lowercase letters, numbers, and hyphens; that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is 100 characters. Can be empty to allow the system to generate one.
   *
   * @schema JobTriggerSpecForProvider#triggerId
   */
  readonly triggerId?: string;

  /**
   * What event needs to occur for a new job to be started. Structure is documented below.
   *
   * @schema JobTriggerSpecForProvider#triggers
   */
  readonly triggers?: JobTriggerSpecForProviderTriggers[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProvider(obj: JobTriggerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'inspectJob': obj.inspectJob?.map(y => toJson_JobTriggerSpecForProviderInspectJob(y)),
    'parent': obj.parent,
    'status': obj.status,
    'triggerId': obj.triggerId,
    'triggers': obj.triggers?.map(y => toJson_JobTriggerSpecForProviderTriggers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema JobTriggerSpecInitProvider
 */
export interface JobTriggerSpecInitProvider {
  /**
   * A description of the job trigger.
   *
   * @schema JobTriggerSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * User set display name of the job trigger.
   *
   * @schema JobTriggerSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Controls what and how to inspect for findings. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProvider#inspectJob
   */
  readonly inspectJob?: JobTriggerSpecInitProviderInspectJob[];

  /**
   * The parent of the trigger, either in the format projects/{{project}} or projects/{{project}}/locations/{{location}}
   *
   * @schema JobTriggerSpecInitProvider#parent
   */
  readonly parent?: string;

  /**
   * Whether the trigger is currently active. Default value is HEALTHY. Possible values are: PAUSED, HEALTHY, CANCELLED.
   *
   * @schema JobTriggerSpecInitProvider#status
   */
  readonly status?: string;

  /**
   * The trigger id can contain uppercase and lowercase letters, numbers, and hyphens; that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is 100 characters. Can be empty to allow the system to generate one.
   *
   * @schema JobTriggerSpecInitProvider#triggerId
   */
  readonly triggerId?: string;

  /**
   * What event needs to occur for a new job to be started. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProvider#triggers
   */
  readonly triggers?: JobTriggerSpecInitProviderTriggers[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProvider(obj: JobTriggerSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'inspectJob': obj.inspectJob?.map(y => toJson_JobTriggerSpecInitProviderInspectJob(y)),
    'parent': obj.parent,
    'status': obj.status,
    'triggerId': obj.triggerId,
    'triggers': obj.triggers?.map(y => toJson_JobTriggerSpecInitProviderTriggers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema JobTriggerSpecManagementPolicies
 */
export enum JobTriggerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema JobTriggerSpecProviderConfigRef
 */
export interface JobTriggerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobTriggerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobTriggerSpecProviderConfigRef#policy
   */
  readonly policy?: JobTriggerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'JobTriggerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecProviderConfigRef(obj: JobTriggerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobTriggerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsTo
 */
export interface JobTriggerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: JobTriggerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: JobTriggerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'JobTriggerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecPublishConnectionDetailsTo(obj: JobTriggerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_JobTriggerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_JobTriggerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema JobTriggerSpecWriteConnectionSecretToRef
 */
export interface JobTriggerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema JobTriggerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema JobTriggerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'JobTriggerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecWriteConnectionSecretToRef(obj: JobTriggerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJob
 */
export interface JobTriggerSpecForProviderInspectJob {
  /**
   * A task to execute on the completion of a job. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJob#actions
   */
  readonly actions?: JobTriggerSpecForProviderInspectJobActions[];

  /**
   * The core content of the template. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJob#inspectConfig
   */
  readonly inspectConfig?: JobTriggerSpecForProviderInspectJobInspectConfig[];

  /**
   * The name of the template to run when this job is triggered.
   *
   * @schema JobTriggerSpecForProviderInspectJob#inspectTemplateName
   */
  readonly inspectTemplateName?: string;

  /**
   * Information on where to inspect Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJob#storageConfig
   */
  readonly storageConfig?: JobTriggerSpecForProviderInspectJobStorageConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJob' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJob(obj: JobTriggerSpecForProviderInspectJob | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_JobTriggerSpecForProviderInspectJobActions(y)),
    'inspectConfig': obj.inspectConfig?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfig(y)),
    'inspectTemplateName': obj.inspectTemplateName,
    'storageConfig': obj.storageConfig?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderTriggers
 */
export interface JobTriggerSpecForProviderTriggers {
  /**
   * For use with hybrid jobs. Jobs must be manually created and finished.
   *
   * @schema JobTriggerSpecForProviderTriggers#manual
   */
  readonly manual?: any[];

  /**
   * Schedule for triggered jobs Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderTriggers#schedule
   */
  readonly schedule?: JobTriggerSpecForProviderTriggersSchedule[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderTriggers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderTriggers(obj: JobTriggerSpecForProviderTriggers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'manual': obj.manual?.map(y => y),
    'schedule': obj.schedule?.map(y => toJson_JobTriggerSpecForProviderTriggersSchedule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJob
 */
export interface JobTriggerSpecInitProviderInspectJob {
  /**
   * A task to execute on the completion of a job. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJob#actions
   */
  readonly actions?: JobTriggerSpecInitProviderInspectJobActions[];

  /**
   * The core content of the template. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJob#inspectConfig
   */
  readonly inspectConfig?: JobTriggerSpecInitProviderInspectJobInspectConfig[];

  /**
   * The name of the template to run when this job is triggered.
   *
   * @schema JobTriggerSpecInitProviderInspectJob#inspectTemplateName
   */
  readonly inspectTemplateName?: string;

  /**
   * Information on where to inspect Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJob#storageConfig
   */
  readonly storageConfig?: JobTriggerSpecInitProviderInspectJobStorageConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJob' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJob(obj: JobTriggerSpecInitProviderInspectJob | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_JobTriggerSpecInitProviderInspectJobActions(y)),
    'inspectConfig': obj.inspectConfig?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfig(y)),
    'inspectTemplateName': obj.inspectTemplateName,
    'storageConfig': obj.storageConfig?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderTriggers
 */
export interface JobTriggerSpecInitProviderTriggers {
  /**
   * For use with hybrid jobs. Jobs must be manually created and finished.
   *
   * @schema JobTriggerSpecInitProviderTriggers#manual
   */
  readonly manual?: any[];

  /**
   * Schedule for triggered jobs Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderTriggers#schedule
   */
  readonly schedule?: JobTriggerSpecInitProviderTriggersSchedule[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderTriggers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderTriggers(obj: JobTriggerSpecInitProviderTriggers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'manual': obj.manual?.map(y => y),
    'schedule': obj.schedule?.map(y => toJson_JobTriggerSpecInitProviderTriggersSchedule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobTriggerSpecProviderConfigRefPolicy
 */
export interface JobTriggerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobTriggerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: JobTriggerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobTriggerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: JobTriggerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JobTriggerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecProviderConfigRefPolicy(obj: JobTriggerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsToConfigRef
 */
export interface JobTriggerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'JobTriggerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecPublishConnectionDetailsToConfigRef(obj: JobTriggerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsToMetadata
 */
export interface JobTriggerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecPublishConnectionDetailsToMetadata(obj: JobTriggerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActions
 */
export interface JobTriggerSpecForProviderInspectJobActions {
  /**
   * Create a de-identified copy of the requested table or files. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#deidentify
   */
  readonly deidentify?: JobTriggerSpecForProviderInspectJobActionsDeidentify[];

  /**
   * Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#jobNotificationEmails
   */
  readonly jobNotificationEmails?: any[];

  /**
   * Publish a message into a given Pub/Sub topic when the job completes. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#pubSub
   */
  readonly pubSub?: JobTriggerSpecForProviderInspectJobActionsPubSub[];

  /**
   * Publish findings of a DlpJob to Data Catalog.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#publishFindingsToCloudDataCatalog
   */
  readonly publishFindingsToCloudDataCatalog?: any[];

  /**
   * Publish the result summary of a DlpJob to the Cloud Security Command Center.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#publishSummaryToCscc
   */
  readonly publishSummaryToCscc?: any[];

  /**
   * Enable Stackdriver metric dlp.googleapis.com/findingCount.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#publishToStackdriver
   */
  readonly publishToStackdriver?: any[];

  /**
   * If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActions#saveFindings
   */
  readonly saveFindings?: JobTriggerSpecForProviderInspectJobActionsSaveFindings[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActions(obj: JobTriggerSpecForProviderInspectJobActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deidentify': obj.deidentify?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsDeidentify(y)),
    'jobNotificationEmails': obj.jobNotificationEmails?.map(y => y),
    'pubSub': obj.pubSub?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsPubSub(y)),
    'publishFindingsToCloudDataCatalog': obj.publishFindingsToCloudDataCatalog?.map(y => y),
    'publishSummaryToCscc': obj.publishSummaryToCscc?.map(y => y),
    'publishToStackdriver': obj.publishToStackdriver?.map(y => y),
    'saveFindings': obj.saveFindings?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfig
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfig {
  /**
   * Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfig#customInfoTypes
   */
  readonly customInfoTypes?: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfig#excludeInfoTypes
   */
  readonly excludeInfoTypes?: boolean;

  /**
   * When true, a contextual quote from the data that triggered a finding is included in the response.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfig#includeQuote
   */
  readonly includeQuote?: boolean;

  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfig#infoTypes
   */
  readonly infoTypes?: JobTriggerSpecForProviderInspectJobInspectConfigInfoTypes[];

  /**
   * Configuration to control the number of findings returned. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfig#limits
   */
  readonly limits?: JobTriggerSpecForProviderInspectJobInspectConfigLimits[];

  /**
   * Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info Default value is POSSIBLE. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfig#minLikelihood
   */
  readonly minLikelihood?: string;

  /**
   * Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfig#ruleSet
   */
  readonly ruleSet?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSet[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfig(obj: JobTriggerSpecForProviderInspectJobInspectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customInfoTypes': obj.customInfoTypes?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes(y)),
    'excludeInfoTypes': obj.excludeInfoTypes,
    'includeQuote': obj.includeQuote,
    'infoTypes': obj.infoTypes?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigInfoTypes(y)),
    'limits': obj.limits?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigLimits(y)),
    'minLikelihood': obj.minLikelihood,
    'ruleSet': obj.ruleSet?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfig
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfig {
  /**
   * Options defining BigQuery table and row identifiers. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfig#bigQueryOptions
   */
  readonly bigQueryOptions?: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions[];

  /**
   * Options defining a file or a set of files within a Google Cloud Storage bucket. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfig#cloudStorageOptions
   */
  readonly cloudStorageOptions?: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions[];

  /**
   * Options defining a data set within Google Cloud Datastore. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfig#datastoreOptions
   */
  readonly datastoreOptions?: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions[];

  /**
   * Configuration to control jobs where the content being inspected is outside of Google Cloud Platform. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfig#hybridOptions
   */
  readonly hybridOptions?: JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions[];

  /**
   * Information on where to inspect Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfig#timespanConfig
   */
  readonly timespanConfig?: JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfig(obj: JobTriggerSpecForProviderInspectJobStorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigQueryOptions': obj.bigQueryOptions?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions(y)),
    'cloudStorageOptions': obj.cloudStorageOptions?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions(y)),
    'datastoreOptions': obj.datastoreOptions?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions(y)),
    'hybridOptions': obj.hybridOptions?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions(y)),
    'timespanConfig': obj.timespanConfig?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderTriggersSchedule
 */
export interface JobTriggerSpecForProviderTriggersSchedule {
  /**
   * With this option a job is started a regular periodic basis. For example: every day (86400 seconds). A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs. This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema JobTriggerSpecForProviderTriggersSchedule#recurrencePeriodDuration
   */
  readonly recurrencePeriodDuration?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderTriggersSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderTriggersSchedule(obj: JobTriggerSpecForProviderTriggersSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recurrencePeriodDuration': obj.recurrencePeriodDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobActions
 */
export interface JobTriggerSpecInitProviderInspectJobActions {
  /**
   * Create a de-identified copy of the requested table or files. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActions#deidentify
   */
  readonly deidentify?: JobTriggerSpecInitProviderInspectJobActionsDeidentify[];

  /**
   * Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActions#jobNotificationEmails
   */
  readonly jobNotificationEmails?: any[];

  /**
   * Publish a message into a given Pub/Sub topic when the job completes. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActions#pubSub
   */
  readonly pubSub?: JobTriggerSpecInitProviderInspectJobActionsPubSub[];

  /**
   * Publish findings of a DlpJob to Data Catalog.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActions#publishFindingsToCloudDataCatalog
   */
  readonly publishFindingsToCloudDataCatalog?: any[];

  /**
   * Publish the result summary of a DlpJob to the Cloud Security Command Center.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActions#publishSummaryToCscc
   */
  readonly publishSummaryToCscc?: any[];

  /**
   * Enable Stackdriver metric dlp.googleapis.com/findingCount.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActions#publishToStackdriver
   */
  readonly publishToStackdriver?: any[];

  /**
   * If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActions#saveFindings
   */
  readonly saveFindings?: JobTriggerSpecInitProviderInspectJobActionsSaveFindings[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobActions(obj: JobTriggerSpecInitProviderInspectJobActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deidentify': obj.deidentify?.map(y => toJson_JobTriggerSpecInitProviderInspectJobActionsDeidentify(y)),
    'jobNotificationEmails': obj.jobNotificationEmails?.map(y => y),
    'pubSub': obj.pubSub?.map(y => toJson_JobTriggerSpecInitProviderInspectJobActionsPubSub(y)),
    'publishFindingsToCloudDataCatalog': obj.publishFindingsToCloudDataCatalog?.map(y => y),
    'publishSummaryToCscc': obj.publishSummaryToCscc?.map(y => y),
    'publishToStackdriver': obj.publishToStackdriver?.map(y => y),
    'saveFindings': obj.saveFindings?.map(y => toJson_JobTriggerSpecInitProviderInspectJobActionsSaveFindings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfig
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfig {
  /**
   * Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfig#customInfoTypes
   */
  readonly customInfoTypes?: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfig#excludeInfoTypes
   */
  readonly excludeInfoTypes?: boolean;

  /**
   * When true, a contextual quote from the data that triggered a finding is included in the response.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfig#includeQuote
   */
  readonly includeQuote?: boolean;

  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfig#infoTypes
   */
  readonly infoTypes?: JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypes[];

  /**
   * Configuration to control the number of findings returned. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfig#limits
   */
  readonly limits?: JobTriggerSpecInitProviderInspectJobInspectConfigLimits[];

  /**
   * Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info Default value is POSSIBLE. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfig#minLikelihood
   */
  readonly minLikelihood?: string;

  /**
   * Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfig#ruleSet
   */
  readonly ruleSet?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSet[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfig(obj: JobTriggerSpecInitProviderInspectJobInspectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customInfoTypes': obj.customInfoTypes?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes(y)),
    'excludeInfoTypes': obj.excludeInfoTypes,
    'includeQuote': obj.includeQuote,
    'infoTypes': obj.infoTypes?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypes(y)),
    'limits': obj.limits?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigLimits(y)),
    'minLikelihood': obj.minLikelihood,
    'ruleSet': obj.ruleSet?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfig
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfig {
  /**
   * Options defining BigQuery table and row identifiers. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfig#bigQueryOptions
   */
  readonly bigQueryOptions?: JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions[];

  /**
   * Options defining a file or a set of files within a Google Cloud Storage bucket. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfig#cloudStorageOptions
   */
  readonly cloudStorageOptions?: JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions[];

  /**
   * Options defining a data set within Google Cloud Datastore. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfig#datastoreOptions
   */
  readonly datastoreOptions?: JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptions[];

  /**
   * Configuration to control jobs where the content being inspected is outside of Google Cloud Platform. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfig#hybridOptions
   */
  readonly hybridOptions?: JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions[];

  /**
   * Information on where to inspect Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfig#timespanConfig
   */
  readonly timespanConfig?: JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfig(obj: JobTriggerSpecInitProviderInspectJobStorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigQueryOptions': obj.bigQueryOptions?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions(y)),
    'cloudStorageOptions': obj.cloudStorageOptions?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions(y)),
    'datastoreOptions': obj.datastoreOptions?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptions(y)),
    'hybridOptions': obj.hybridOptions?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions(y)),
    'timespanConfig': obj.timespanConfig?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderTriggersSchedule
 */
export interface JobTriggerSpecInitProviderTriggersSchedule {
  /**
   * With this option a job is started a regular periodic basis. For example: every day (86400 seconds). A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs. This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema JobTriggerSpecInitProviderTriggersSchedule#recurrencePeriodDuration
   */
  readonly recurrencePeriodDuration?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderTriggersSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderTriggersSchedule(obj: JobTriggerSpecInitProviderTriggersSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recurrencePeriodDuration': obj.recurrencePeriodDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobTriggerSpecProviderConfigRefPolicyResolution
 */
export enum JobTriggerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobTriggerSpecProviderConfigRefPolicyResolve
 */
export enum JobTriggerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy(obj: JobTriggerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentify
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentify {
  /**
   * User settable Cloud Storage bucket and folders to store de-identified files. This field must be set for cloud storage deidentification. The output Cloud Storage bucket must be different from the input bucket. De-identified files will overwrite files in the output path. Form of: gs://bucket/folder/ or gs://bucket
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentify#cloudStorageOutput
   */
  readonly cloudStorageOutput?: string;

  /**
   * List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed. If empty, all supported files will be transformed. Supported types may be automatically added over time. If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started. Each value may be one of: IMAGE, TEXT_FILE, CSV, TSV.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentify#fileTypesToTransform
   */
  readonly fileTypesToTransform?: string[];

  /**
   * User specified deidentify templates and configs for structured, unstructured, and image files. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentify#transformationConfig
   */
  readonly transformationConfig?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationConfig[];

  /**
   * Config for storing transformation details. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentify#transformationDetailsStorageConfig
   */
  readonly transformationDetailsStorageConfig?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentify' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentify(obj: JobTriggerSpecForProviderInspectJobActionsDeidentify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStorageOutput': obj.cloudStorageOutput,
    'fileTypesToTransform': obj.fileTypesToTransform?.map(y => y),
    'transformationConfig': obj.transformationConfig?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationConfig(y)),
    'transformationDetailsStorageConfig': obj.transformationDetailsStorageConfig?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsPubSub
 */
export interface JobTriggerSpecForProviderInspectJobActionsPubSub {
  /**
   * Cloud Pub/Sub topic to send notifications to.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsPubSub#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsPubSub' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsPubSub(obj: JobTriggerSpecForProviderInspectJobActionsPubSub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindings
 */
export interface JobTriggerSpecForProviderInspectJobActionsSaveFindings {
  /**
   * Information on where to store output Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindings#outputConfig
   */
  readonly outputConfig?: JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsSaveFindings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindings(obj: JobTriggerSpecForProviderInspectJobActionsSaveFindings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputConfig': obj.outputConfig?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes {
  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes#dictionary
   */
  readonly dictionary?: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionary[];

  /**
   * If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching. Possible values are: EXCLUSION_TYPE_EXCLUDE.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes#exclusionType
   */
  readonly exclusionType?: string;

  /**
   * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does not have an infoType, the DLP API applies the limit against all infoTypes that are found but not specified in another InfoTypeLimit. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes#infoType
   */
  readonly infoType?: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoType[];

  /**
   * Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria specified by the rule. Default value is VERY_LIKELY. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes#likelihood
   */
  readonly likelihood?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes#regex
   */
  readonly regex?: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesRegex[];

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore[];

  /**
   * A reference to a StoredInfoType to use with scanning. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes#storedType
   */
  readonly storedType?: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesStoredType[];

  /**
   * Message for detecting output from deidentification transformations that support reversing.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes#surrogateType
   */
  readonly surrogateType?: any[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes(obj: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': obj.dictionary?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionary(y)),
    'exclusionType': obj.exclusionType,
    'infoType': obj.infoType?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoType(y)),
    'likelihood': obj.likelihood,
    'regex': obj.regex?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesRegex(y)),
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore(y)),
    'storedType': obj.storedType?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesStoredType(y)),
    'surrogateType': obj.surrogateType?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigInfoTypes
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigInfoTypes {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecForProviderInspectJobInspectConfigInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigInfoTypes(obj: JobTriggerSpecForProviderInspectJobInspectConfigInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimits
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigLimits {
  /**
   * Configuration of findings limit given for specified infoTypes. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimits#maxFindingsPerInfoType
   */
  readonly maxFindingsPerInfoType?: JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType[];

  /**
   * Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimits#maxFindingsPerItem
   */
  readonly maxFindingsPerItem?: number;

  /**
   * Max number of findings that will be returned per request/job. The maximum returned is 2000.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimits#maxFindingsPerRequest
   */
  readonly maxFindingsPerRequest?: number;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigLimits(obj: JobTriggerSpecForProviderInspectJobInspectConfigLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxFindingsPerInfoType': obj.maxFindingsPerInfoType?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType(y)),
    'maxFindingsPerItem': obj.maxFindingsPerItem,
    'maxFindingsPerRequest': obj.maxFindingsPerRequest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSet
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSet {
  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSet#infoTypes
   */
  readonly infoTypes?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypes[];

  /**
   * Set of rules to be applied to infoTypes. The rules are applied in order. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSet#rules
   */
  readonly rules?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRules[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSet(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypes(y)),
    'rules': obj.rules?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions {
  /**
   * References to fields excluded from scanning. This allows you to skip inspection of entire columns which you know have no findings. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#excludedFields
   */
  readonly excludedFields?: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsExcludedFields[];

  /**
   * The columns that are the primary keys for table objects included in ContentItem. A copy of this cell's value will stored alongside alongside each finding so that the finding can be traced to the specific row it came from. No more than 3 may be provided. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#identifyingFields
   */
  readonly identifyingFields?: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields[];

  /**
   * Limit scanning only to these fields. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#includedFields
   */
  readonly includedFields?: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIncludedFields[];

  /**
   * Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted. If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#rowsLimit
   */
  readonly rowsLimit?: number;

  /**
   * Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
   *
   * @default 0. Only one of rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#rowsLimitPercent
   */
  readonly rowsLimitPercent?: number;

  /**
   * How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile. If not specified, scanning would start from the top. Possible values are: TOP, RANDOM_START.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#sampleMethod
   */
  readonly sampleMethod?: string;

  /**
   * Set of files to scan. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions#tableReference
   */
  readonly tableReference?: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions(obj: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludedFields': obj.excludedFields?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsExcludedFields(y)),
    'identifyingFields': obj.identifyingFields?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields(y)),
    'includedFields': obj.includedFields?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIncludedFields(y)),
    'rowsLimit': obj.rowsLimit,
    'rowsLimitPercent': obj.rowsLimitPercent,
    'sampleMethod': obj.sampleMethod,
    'tableReference': obj.tableReference?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions {
  /**
   * Max number of bytes to scan from a file. If a scanned file's size is bigger than this value then the rest of the bytes are omitted.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#bytesLimitPerFile
   */
  readonly bytesLimitPerFile?: number;

  /**
   * Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#bytesLimitPerFilePercent
   */
  readonly bytesLimitPerFilePercent?: number;

  /**
   * Set of files to scan. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#fileSet
   */
  readonly fileSet?: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet[];

  /**
   * List of file type groups to include in the scan. If empty, all files are scanned and available data format processors are applied. In addition, the binary content of the selected files is always scanned as well. Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified. Each value may be one of: BINARY_FILE, TEXT_FILE, IMAGE, WORD, PDF, AVRO, CSV, TSV, POWERPOINT, EXCEL.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#fileTypes
   */
  readonly fileTypes?: string[];

  /**
   * Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#filesLimitPercent
   */
  readonly filesLimitPercent?: number;

  /**
   * How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile. If not specified, scanning would start from the top. Possible values are: TOP, RANDOM_START.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions#sampleMethod
   */
  readonly sampleMethod?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions(obj: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bytesLimitPerFile': obj.bytesLimitPerFile,
    'bytesLimitPerFilePercent': obj.bytesLimitPerFilePercent,
    'fileSet': obj.fileSet?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet(y)),
    'fileTypes': obj.fileTypes?.map(y => y),
    'filesLimitPercent': obj.filesLimitPercent,
    'sampleMethod': obj.sampleMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions {
  /**
   * A representation of a Datastore kind. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions#kind
   */
  readonly kind?: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind[];

  /**
   * Datastore partition ID. A partition ID identifies a grouping of entities. The grouping is always by project and namespace, however the namespace ID may be empty. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions#partitionId
   */
  readonly partitionId?: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions(obj: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind(y)),
    'partitionId': obj.partitionId?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions {
  /**
   * A description of the job trigger.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions#description
   */
  readonly description?: string;

  /**
   * To organize findings, these labels will be added to each finding. Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?. Label values must be between 0 and 63 characters long and must conform to the regular expression ([a-z]([-a-z0-9]*[a-z0-9])?)?. No more than 10 labels can be associated with a given finding. Examples:
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * These are labels that each inspection request must include within their 'finding_labels' map. Request may contain others, but any missing one of these will be rejected. Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?. No more than 10 keys can be required.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions#requiredFindingLabelKeys
   */
  readonly requiredFindingLabelKeys?: string[];

  /**
   * If the container is a table, additional information to make findings meaningful such as the columns that are primary keys. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions#tableOptions
   */
  readonly tableOptions?: JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptions[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions(obj: JobTriggerSpecForProviderInspectJobStorageConfigHybridOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requiredFindingLabelKeys': obj.requiredFindingLabelKeys?.map(y => y),
    'tableOptions': obj.tableOptions?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig {
  /**
   * When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid scanning files that have not been modified since the last time the JobTrigger executed. This will be based on the time of the execution of the last run of the JobTrigger.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig#enableAutoPopulationOfTimespanConfig
   */
  readonly enableAutoPopulationOfTimespanConfig?: boolean;

  /**
   * Exclude files or rows newer than this value. If set to zero, no upper time limit is applied.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig#endTime
   */
  readonly endTime?: string;

  /**
   * Exclude files or rows older than this value.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig#startTime
   */
  readonly startTime?: string;

  /**
   * Information on where to inspect Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig#timestampField
   */
  readonly timestampField?: JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig(obj: JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableAutoPopulationOfTimespanConfig': obj.enableAutoPopulationOfTimespanConfig,
    'endTime': obj.endTime,
    'startTime': obj.startTime,
    'timestampField': obj.timestampField?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentify
 */
export interface JobTriggerSpecInitProviderInspectJobActionsDeidentify {
  /**
   * User settable Cloud Storage bucket and folders to store de-identified files. This field must be set for cloud storage deidentification. The output Cloud Storage bucket must be different from the input bucket. De-identified files will overwrite files in the output path. Form of: gs://bucket/folder/ or gs://bucket
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentify#cloudStorageOutput
   */
  readonly cloudStorageOutput?: string;

  /**
   * List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed. If empty, all supported files will be transformed. Supported types may be automatically added over time. If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started. Each value may be one of: IMAGE, TEXT_FILE, CSV, TSV.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentify#fileTypesToTransform
   */
  readonly fileTypesToTransform?: string[];

  /**
   * User specified deidentify templates and configs for structured, unstructured, and image files. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentify#transformationConfig
   */
  readonly transformationConfig?: JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationConfig[];

  /**
   * Config for storing transformation details. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentify#transformationDetailsStorageConfig
   */
  readonly transformationDetailsStorageConfig?: JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobActionsDeidentify' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobActionsDeidentify(obj: JobTriggerSpecInitProviderInspectJobActionsDeidentify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStorageOutput': obj.cloudStorageOutput,
    'fileTypesToTransform': obj.fileTypesToTransform?.map(y => y),
    'transformationConfig': obj.transformationConfig?.map(y => toJson_JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationConfig(y)),
    'transformationDetailsStorageConfig': obj.transformationDetailsStorageConfig?.map(y => toJson_JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobActionsPubSub
 */
export interface JobTriggerSpecInitProviderInspectJobActionsPubSub {
  /**
   * Cloud Pub/Sub topic to send notifications to.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsPubSub#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobActionsPubSub' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobActionsPubSub(obj: JobTriggerSpecInitProviderInspectJobActionsPubSub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobActionsSaveFindings
 */
export interface JobTriggerSpecInitProviderInspectJobActionsSaveFindings {
  /**
   * Information on where to store output Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsSaveFindings#outputConfig
   */
  readonly outputConfig?: JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfig[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobActionsSaveFindings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobActionsSaveFindings(obj: JobTriggerSpecInitProviderInspectJobActionsSaveFindings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputConfig': obj.outputConfig?.map(y => toJson_JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes {
  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes#dictionary
   */
  readonly dictionary?: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionary[];

  /**
   * If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching. Possible values are: EXCLUSION_TYPE_EXCLUDE.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes#exclusionType
   */
  readonly exclusionType?: string;

  /**
   * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does not have an infoType, the DLP API applies the limit against all infoTypes that are found but not specified in another InfoTypeLimit. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes#infoType
   */
  readonly infoType?: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoType[];

  /**
   * Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria specified by the rule. Default value is VERY_LIKELY. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes#likelihood
   */
  readonly likelihood?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes#regex
   */
  readonly regex?: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesRegex[];

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore[];

  /**
   * A reference to a StoredInfoType to use with scanning. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes#storedType
   */
  readonly storedType?: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesStoredType[];

  /**
   * Message for detecting output from deidentification transformations that support reversing.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes#surrogateType
   */
  readonly surrogateType?: any[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes(obj: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': obj.dictionary?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionary(y)),
    'exclusionType': obj.exclusionType,
    'infoType': obj.infoType?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoType(y)),
    'likelihood': obj.likelihood,
    'regex': obj.regex?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesRegex(y)),
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore(y)),
    'storedType': obj.storedType?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesStoredType(y)),
    'surrogateType': obj.surrogateType?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypes
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypes {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypes(obj: JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimits
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigLimits {
  /**
   * Configuration of findings limit given for specified infoTypes. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimits#maxFindingsPerInfoType
   */
  readonly maxFindingsPerInfoType?: JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType[];

  /**
   * Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimits#maxFindingsPerItem
   */
  readonly maxFindingsPerItem?: number;

  /**
   * Max number of findings that will be returned per request/job. The maximum returned is 2000.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimits#maxFindingsPerRequest
   */
  readonly maxFindingsPerRequest?: number;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigLimits(obj: JobTriggerSpecInitProviderInspectJobInspectConfigLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxFindingsPerInfoType': obj.maxFindingsPerInfoType?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType(y)),
    'maxFindingsPerItem': obj.maxFindingsPerItem,
    'maxFindingsPerRequest': obj.maxFindingsPerRequest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSet
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSet {
  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSet#infoTypes
   */
  readonly infoTypes?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypes[];

  /**
   * Set of rules to be applied to infoTypes. The rules are applied in order. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSet#rules
   */
  readonly rules?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRules[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSet(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypes(y)),
    'rules': obj.rules?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions {
  /**
   * References to fields excluded from scanning. This allows you to skip inspection of entire columns which you know have no findings. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions#excludedFields
   */
  readonly excludedFields?: JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsExcludedFields[];

  /**
   * The columns that are the primary keys for table objects included in ContentItem. A copy of this cell's value will stored alongside alongside each finding so that the finding can be traced to the specific row it came from. No more than 3 may be provided. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions#identifyingFields
   */
  readonly identifyingFields?: JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields[];

  /**
   * Limit scanning only to these fields. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions#includedFields
   */
  readonly includedFields?: JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIncludedFields[];

  /**
   * Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted. If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions#rowsLimit
   */
  readonly rowsLimit?: number;

  /**
   * Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
   *
   * @default 0. Only one of rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions#rowsLimitPercent
   */
  readonly rowsLimitPercent?: number;

  /**
   * How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile. If not specified, scanning would start from the top. Possible values are: TOP, RANDOM_START.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions#sampleMethod
   */
  readonly sampleMethod?: string;

  /**
   * Set of files to scan. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions#tableReference
   */
  readonly tableReference?: JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsTableReference[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions(obj: JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludedFields': obj.excludedFields?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsExcludedFields(y)),
    'identifyingFields': obj.identifyingFields?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields(y)),
    'includedFields': obj.includedFields?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIncludedFields(y)),
    'rowsLimit': obj.rowsLimit,
    'rowsLimitPercent': obj.rowsLimitPercent,
    'sampleMethod': obj.sampleMethod,
    'tableReference': obj.tableReference?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsTableReference(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions {
  /**
   * Max number of bytes to scan from a file. If a scanned file's size is bigger than this value then the rest of the bytes are omitted.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions#bytesLimitPerFile
   */
  readonly bytesLimitPerFile?: number;

  /**
   * Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions#bytesLimitPerFilePercent
   */
  readonly bytesLimitPerFilePercent?: number;

  /**
   * Set of files to scan. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions#fileSet
   */
  readonly fileSet?: JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet[];

  /**
   * List of file type groups to include in the scan. If empty, all files are scanned and available data format processors are applied. In addition, the binary content of the selected files is always scanned as well. Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified. Each value may be one of: BINARY_FILE, TEXT_FILE, IMAGE, WORD, PDF, AVRO, CSV, TSV, POWERPOINT, EXCEL.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions#fileTypes
   */
  readonly fileTypes?: string[];

  /**
   * Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions#filesLimitPercent
   */
  readonly filesLimitPercent?: number;

  /**
   * How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile. If not specified, scanning would start from the top. Possible values are: TOP, RANDOM_START.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions#sampleMethod
   */
  readonly sampleMethod?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions(obj: JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bytesLimitPerFile': obj.bytesLimitPerFile,
    'bytesLimitPerFilePercent': obj.bytesLimitPerFilePercent,
    'fileSet': obj.fileSet?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet(y)),
    'fileTypes': obj.fileTypes?.map(y => y),
    'filesLimitPercent': obj.filesLimitPercent,
    'sampleMethod': obj.sampleMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptions
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptions {
  /**
   * A representation of a Datastore kind. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptions#kind
   */
  readonly kind?: JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsKind[];

  /**
   * Datastore partition ID. A partition ID identifies a grouping of entities. The grouping is always by project and namespace, however the namespace ID may be empty. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptions#partitionId
   */
  readonly partitionId?: JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptions(obj: JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsKind(y)),
    'partitionId': obj.partitionId?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions {
  /**
   * A description of the job trigger.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions#description
   */
  readonly description?: string;

  /**
   * To organize findings, these labels will be added to each finding. Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?. Label values must be between 0 and 63 characters long and must conform to the regular expression ([a-z]([-a-z0-9]*[a-z0-9])?)?. No more than 10 labels can be associated with a given finding. Examples:
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * These are labels that each inspection request must include within their 'finding_labels' map. Request may contain others, but any missing one of these will be rejected. Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?. No more than 10 keys can be required.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions#requiredFindingLabelKeys
   */
  readonly requiredFindingLabelKeys?: string[];

  /**
   * If the container is a table, additional information to make findings meaningful such as the columns that are primary keys. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions#tableOptions
   */
  readonly tableOptions?: JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptions[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions(obj: JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requiredFindingLabelKeys': obj.requiredFindingLabelKeys?.map(y => y),
    'tableOptions': obj.tableOptions?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig {
  /**
   * When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid scanning files that have not been modified since the last time the JobTrigger executed. This will be based on the time of the execution of the last run of the JobTrigger.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig#enableAutoPopulationOfTimespanConfig
   */
  readonly enableAutoPopulationOfTimespanConfig?: boolean;

  /**
   * Exclude files or rows newer than this value. If set to zero, no upper time limit is applied.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig#endTime
   */
  readonly endTime?: string;

  /**
   * Exclude files or rows older than this value.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig#startTime
   */
  readonly startTime?: string;

  /**
   * Information on where to inspect Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig#timestampField
   */
  readonly timestampField?: JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfigTimestampField[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig(obj: JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableAutoPopulationOfTimespanConfig': obj.enableAutoPopulationOfTimespanConfig,
    'endTime': obj.endTime,
    'startTime': obj.startTime,
    'timestampField': obj.timestampField?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfigTimestampField(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum JobTriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationConfig
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationConfig {
  /**
   * If this template is specified, it will serve as the default de-identify template.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationConfig#deidentifyTemplate
   */
  readonly deidentifyTemplate?: string;

  /**
   * If this template is specified, it will serve as the de-identify template for images.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationConfig#imageRedactTemplate
   */
  readonly imageRedactTemplate?: string;

  /**
   * If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationConfig#structuredDeidentifyTemplate
   */
  readonly structuredDeidentifyTemplate?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationConfig(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deidentifyTemplate': obj.deidentifyTemplate,
    'imageRedactTemplate': obj.imageRedactTemplate,
    'structuredDeidentifyTemplate': obj.structuredDeidentifyTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig {
  /**
   * The BigQuery table in which to store the output. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig#table
   */
  readonly table?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'table': obj.table?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig
 */
export interface JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig {
  /**
   * Schema used for writing the findings for Inspect jobs. This field is only used for Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding object. If appending to an existing table, any columns from the predefined schema that are missing will be added. No columns in the existing table will be deleted. If unspecified, then all available columns will be used for a new table or an (existing) table with no schema, and no changes will be made to an existing table that has a schema. Only for use with external storage. Possible values are: BASIC_COLUMNS, GCS_COLUMNS, DATASTORE_COLUMNS, BIG_QUERY_COLUMNS, ALL_COLUMNS.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig#outputSchema
   */
  readonly outputSchema?: string;

  /**
   * The BigQuery table in which to store the output. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig#table
   */
  readonly table?: JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig(obj: JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputSchema': obj.outputSchema,
    'table': obj.table?.map(y => toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionary
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionary#wordList
   */
  readonly wordList?: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionary(obj: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoType
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoType {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoType#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoType(obj: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesRegex
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesRegex(obj: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore(obj: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesStoredType
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesStoredType {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesStoredType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesStoredType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesStoredType(obj: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesStoredType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigInfoTypesSensitivityScore
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigInfoTypesSensitivityScore(obj: JobTriggerSpecForProviderInspectJobInspectConfigInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType {
  /**
   * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does not have an infoType, the DLP API applies the limit against all infoTypes that are found but not specified in another InfoTypeLimit. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType#infoType
   */
  readonly infoType?: JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType[];

  /**
   * Max findings limit for the given infoType.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType#maxFindings
   */
  readonly maxFindings?: number;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType(obj: JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoType': obj.infoType?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(y)),
    'maxFindings': obj.maxFindings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypes
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypes {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypes(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRules
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRules {
  /**
   * The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRules#exclusionRule
   */
  readonly exclusionRule?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule[];

  /**
   * Hotword-based detection rule. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRules#hotwordRule
   */
  readonly hotwordRule?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRule[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRules(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclusionRule': obj.exclusionRule?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule(y)),
    'hotwordRule': obj.hotwordRule?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsExcludedFields
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsExcludedFields {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsExcludedFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsExcludedFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsExcludedFields(obj: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsExcludedFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields(obj: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIncludedFields
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIncludedFields {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIncludedFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIncludedFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIncludedFields(obj: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsIncludedFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference#datasetId
   */
  readonly datasetId?: string;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference#projectId
   */
  readonly projectId?: string;

  /**
   * The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference#tableId
   */
  readonly tableId?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference(obj: JobTriggerSpecForProviderInspectJobStorageConfigBigQueryOptionsTableReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet {
  /**
   * The regex-filtered set of files to scan. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet#regexFileSet
   */
  readonly regexFileSet?: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet[];

  /**
   * The Cloud Storage url of the file(s) to scan, in the format gs://<bucket>/<path>. Trailing wildcard in the path is allowed. If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned non-recursively (content in sub-directories will not be scanned). This means that gs://mybucket/ is equivalent to gs://mybucket/*, and gs://mybucket/directory/ is equivalent to gs://mybucket/directory/*.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet(obj: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexFileSet': obj.regexFileSet?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind(obj: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsKind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId {
  /**
   * If not empty, the ID of the namespace to which the entities belong.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId#namespaceId
   */
  readonly namespaceId?: string;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId#projectId
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId(obj: JobTriggerSpecForProviderInspectJobStorageConfigDatastoreOptionsPartitionId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceId': obj.namespaceId,
    'projectId': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptions
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptions {
  /**
   * The columns that are the primary keys for table objects included in ContentItem. A copy of this cell's value will stored alongside alongside each finding so that the finding can be traced to the specific row it came from. No more than 3 may be provided. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptions#identifyingFields
   */
  readonly identifyingFields?: JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptions(obj: JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identifyingFields': obj.identifyingFields?.map(y => toJson_JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField(obj: JobTriggerSpecForProviderInspectJobStorageConfigTimespanConfigTimestampField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationConfig
 */
export interface JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationConfig {
  /**
   * If this template is specified, it will serve as the default de-identify template.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationConfig#deidentifyTemplate
   */
  readonly deidentifyTemplate?: string;

  /**
   * If this template is specified, it will serve as the de-identify template for images.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationConfig#imageRedactTemplate
   */
  readonly imageRedactTemplate?: string;

  /**
   * If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationConfig#structuredDeidentifyTemplate
   */
  readonly structuredDeidentifyTemplate?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationConfig(obj: JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deidentifyTemplate': obj.deidentifyTemplate,
    'imageRedactTemplate': obj.imageRedactTemplate,
    'structuredDeidentifyTemplate': obj.structuredDeidentifyTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig
 */
export interface JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig {
  /**
   * The BigQuery table in which to store the output. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig#table
   */
  readonly table?: JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig(obj: JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'table': obj.table?.map(y => toJson_JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfig
 */
export interface JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfig {
  /**
   * Schema used for writing the findings for Inspect jobs. This field is only used for Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding object. If appending to an existing table, any columns from the predefined schema that are missing will be added. No columns in the existing table will be deleted. If unspecified, then all available columns will be used for a new table or an (existing) table with no schema, and no changes will be made to an existing table that has a schema. Only for use with external storage. Possible values are: BASIC_COLUMNS, GCS_COLUMNS, DATASTORE_COLUMNS, BIG_QUERY_COLUMNS, ALL_COLUMNS.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfig#outputSchema
   */
  readonly outputSchema?: string;

  /**
   * The BigQuery table in which to store the output. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfig#table
   */
  readonly table?: JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfigTable[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfig(obj: JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputSchema': obj.outputSchema,
    'table': obj.table?.map(y => toJson_JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfigTable(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionary
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionary#wordList
   */
  readonly wordList?: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionary(obj: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoType
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoType {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoType#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoType(obj: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesRegex
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesRegex(obj: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore(obj: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesStoredType
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesStoredType {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesStoredType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesStoredType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesStoredType(obj: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesStoredType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypesSensitivityScore
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypesSensitivityScore(obj: JobTriggerSpecInitProviderInspectJobInspectConfigInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType {
  /**
   * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does not have an infoType, the DLP API applies the limit against all infoTypes that are found but not specified in another InfoTypeLimit. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType#infoType
   */
  readonly infoType?: JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType[];

  /**
   * Max findings limit for the given infoType.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType#maxFindings
   */
  readonly maxFindings?: number;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType(obj: JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoType': obj.infoType?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(y)),
    'maxFindings': obj.maxFindings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypes
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypes {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypes(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRules
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRules {
  /**
   * The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRules#exclusionRule
   */
  readonly exclusionRule?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule[];

  /**
   * Hotword-based detection rule. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRules#hotwordRule
   */
  readonly hotwordRule?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRules(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclusionRule': obj.exclusionRule?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule(y)),
    'hotwordRule': obj.hotwordRule?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsExcludedFields
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsExcludedFields {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsExcludedFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsExcludedFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsExcludedFields(obj: JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsExcludedFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields(obj: JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIdentifyingFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIncludedFields
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIncludedFields {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIncludedFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIncludedFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIncludedFields(obj: JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsIncludedFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsTableReference
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsTableReference {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsTableReference#datasetId
   */
  readonly datasetId?: string;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsTableReference#projectId
   */
  readonly projectId?: string;

  /**
   * The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsTableReference#tableId
   */
  readonly tableId?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsTableReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsTableReference(obj: JobTriggerSpecInitProviderInspectJobStorageConfigBigQueryOptionsTableReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet {
  /**
   * The regex-filtered set of files to scan. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet#regexFileSet
   */
  readonly regexFileSet?: JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet[];

  /**
   * The Cloud Storage url of the file(s) to scan, in the format gs://<bucket>/<path>. Trailing wildcard in the path is allowed. If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned non-recursively (content in sub-directories will not be scanned). This means that gs://mybucket/ is equivalent to gs://mybucket/*, and gs://mybucket/directory/ is equivalent to gs://mybucket/directory/*.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet(obj: JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexFileSet': obj.regexFileSet?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsKind
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsKind {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsKind#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsKind' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsKind(obj: JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsKind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId {
  /**
   * If not empty, the ID of the namespace to which the entities belong.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId#namespaceId
   */
  readonly namespaceId?: string;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId#projectId
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId(obj: JobTriggerSpecInitProviderInspectJobStorageConfigDatastoreOptionsPartitionId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceId': obj.namespaceId,
    'projectId': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptions
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptions {
  /**
   * The columns that are the primary keys for table objects included in ContentItem. A copy of this cell's value will stored alongside alongside each finding so that the finding can be traced to the specific row it came from. No more than 3 may be provided. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptions#identifyingFields
   */
  readonly identifyingFields?: JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptions(obj: JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identifyingFields': obj.identifyingFields?.map(y => toJson_JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfigTimestampField
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfigTimestampField {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfigTimestampField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfigTimestampField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfigTimestampField(obj: JobTriggerSpecInitProviderInspectJobStorageConfigTimespanConfigTimestampField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in bigquery to populate datasetId.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable#datasetIdRef
   */
  readonly datasetIdRef?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef;

  /**
   * Selector for a Dataset in bigquery to populate datasetId.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable#datasetIdSelector
   */
  readonly datasetIdSelector?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable#projectId
   */
  readonly projectId?: string;

  /**
   * The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable#tableId
   */
  readonly tableId?: string;

  /**
   * Reference to a Table in bigquery to populate tableId.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable#tableIdRef
   */
  readonly tableIdRef?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef;

  /**
   * Selector for a Table in bigquery to populate tableId.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable#tableIdSelector
   */
  readonly tableIdSelector?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector(obj.datasetIdSelector),
    'projectId': obj.projectId,
    'tableId': obj.tableId,
    'tableIdRef': toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef(obj.tableIdRef),
    'tableIdSelector': toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector(obj.tableIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable
 */
export interface JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable#datasetId
   */
  readonly datasetId?: string;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable#projectId
   */
  readonly projectId?: string;

  /**
   * The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable#tableId
   */
  readonly tableId?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable(obj: JobTriggerSpecForProviderInspectJobActionsSaveFindingsOutputConfigTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath(obj: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList(obj: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore(obj: JobTriggerSpecForProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(obj: JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule {
  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule#dictionary
   */
  readonly dictionary?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary[];

  /**
   * Drop if the hotword rule is contained in the proximate context. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule#excludeByHotword
   */
  readonly excludeByHotword?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule#excludeInfoTypes
   */
  readonly excludeInfoTypes?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes[];

  /**
   * How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule#matchingType
   */
  readonly matchingType?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule#regex
   */
  readonly regex?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': obj.dictionary?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary(y)),
    'excludeByHotword': obj.excludeByHotword?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword(y)),
    'excludeInfoTypes': obj.excludeInfoTypes?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(y)),
    'matchingType': obj.matchingType,
    'regex': obj.regex?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRule
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRule {
  /**
   * Regular expression pattern defining what qualifies as a hotword. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRule#hotwordRegex
   */
  readonly hotwordRegex?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex[];

  /**
   * Likelihood adjustment to apply to all matching findings. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRule#likelihoodAdjustment
   */
  readonly likelihoodAdjustment?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment[];

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex (xxx), where xxx is the area code in question. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRule#proximity
   */
  readonly proximity?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRule(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': obj.hotwordRegex?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex(y)),
    'likelihoodAdjustment': obj.likelihoodAdjustment?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(y)),
    'proximity': obj.proximity?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet {
  /**
   * The name of a Cloud Storage bucket.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#bucketName
   */
  readonly bucketName?: string;

  /**
   * A list of regular expressions matching file paths to exclude. All files in the bucket that match at least one of these regular expressions will be excluded from the scan.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#excludeRegex
   */
  readonly excludeRegex?: string[];

  /**
   * A list of regular expressions matching file paths to include. All files in the bucket that match at least one of these regular expressions will be included in the set of files, except for those that also match an item in excludeRegex. Leaving this field empty will match all files by default (this is equivalent to including .* in the list)
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#includeRegex
   */
  readonly includeRegex?: string[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet(obj: JobTriggerSpecForProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'excludeRegex': obj.excludeRegex?.map(y => y),
    'includeRegex': obj.includeRegex?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields
 */
export interface JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields(obj: JobTriggerSpecForProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable
 */
export interface JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable {
  /**
   * The ID of the project containing this table.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable#projectId
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable(obj: JobTriggerSpecInitProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'projectId': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfigTable
 */
export interface JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfigTable {
  /**
   * The ID of the dataset containing this table.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfigTable#datasetId
   */
  readonly datasetId?: string;

  /**
   * The ID of the project containing this table.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfigTable#projectId
   */
  readonly projectId?: string;

  /**
   * The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
   *
   * @schema JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfigTable#tableId
   */
  readonly tableId?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfigTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfigTable(obj: JobTriggerSpecInitProviderInspectJobActionsSaveFindingsOutputConfigTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath(obj: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList(obj: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore(obj: JobTriggerSpecInitProviderInspectJobInspectConfigCustomInfoTypesInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(obj: JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule {
  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule#dictionary
   */
  readonly dictionary?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary[];

  /**
   * Drop if the hotword rule is contained in the proximate context. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule#excludeByHotword
   */
  readonly excludeByHotword?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule#excludeInfoTypes
   */
  readonly excludeInfoTypes?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes[];

  /**
   * How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule#matchingType
   */
  readonly matchingType?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule#regex
   */
  readonly regex?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': obj.dictionary?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary(y)),
    'excludeByHotword': obj.excludeByHotword?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword(y)),
    'excludeInfoTypes': obj.excludeInfoTypes?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(y)),
    'matchingType': obj.matchingType,
    'regex': obj.regex?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule {
  /**
   * Regular expression pattern defining what qualifies as a hotword. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule#hotwordRegex
   */
  readonly hotwordRegex?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex[];

  /**
   * Likelihood adjustment to apply to all matching findings. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule#likelihoodAdjustment
   */
  readonly likelihoodAdjustment?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment[];

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex (xxx), where xxx is the area code in question. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule#proximity
   */
  readonly proximity?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': obj.hotwordRegex?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex(y)),
    'likelihoodAdjustment': obj.likelihoodAdjustment?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(y)),
    'proximity': obj.proximity?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet {
  /**
   * The name of a Cloud Storage bucket.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#bucketName
   */
  readonly bucketName?: string;

  /**
   * A list of regular expressions matching file paths to exclude. All files in the bucket that match at least one of these regular expressions will be excluded from the scan.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#excludeRegex
   */
  readonly excludeRegex?: string[];

  /**
   * A list of regular expressions matching file paths to include. All files in the bucket that match at least one of these regular expressions will be included in the set of files, except for those that also match an item in excludeRegex. Leaving this field empty will match all files by default (this is equivalent to including .* in the list)
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#includeRegex
   */
  readonly includeRegex?: string[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet(obj: JobTriggerSpecInitProviderInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'excludeRegex': obj.excludeRegex?.map(y => y),
    'includeRegex': obj.includeRegex?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields
 */
export interface JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields(obj: JobTriggerSpecInitProviderInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in bigquery to populate datasetId.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef#policy
   */
  readonly policy?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in bigquery to populate datasetId.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector#policy
   */
  readonly policy?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in bigquery to populate tableId.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef#policy
   */
  readonly policy?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in bigquery to populate tableId.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector#policy
   */
  readonly policy?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore(obj: JobTriggerSpecForProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary#wordList
   */
  readonly wordList?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword {
  /**
   * Regular expression pattern defining what qualifies as a hotword. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword#hotwordRegex
   */
  readonly hotwordRegex?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex[];

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex (xxx), where xxx is the area code in question. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword#proximity
   */
  readonly proximity?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': obj.hotwordRegex?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex(y)),
    'proximity': obj.proximity?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes#infoTypes
   */
  readonly infoTypes?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
  /**
   * Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#fixedLikelihood
   */
  readonly fixedLikelihood?: string;

  /**
   * Increase or decrease the likelihood by the specified number of levels. For example, if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1, then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY. Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#relativeLikelihood
   */
  readonly relativeLikelihood?: number;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedLikelihood': obj.fixedLikelihood,
    'relativeLikelihood': obj.relativeLikelihood,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity {
  /**
   * Number of characters after the finding to consider. Either this or window_before must be specified
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider. Either this or window_after must be specified
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore(obj: JobTriggerSpecInitProviderInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary#wordList
   */
  readonly wordList?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword {
  /**
   * Regular expression pattern defining what qualifies as a hotword. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword#hotwordRegex
   */
  readonly hotwordRegex?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex[];

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex (xxx), where xxx is the area code in question. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword#proximity
   */
  readonly proximity?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': obj.hotwordRegex?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex(y)),
    'proximity': obj.proximity?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
  /**
   * List of infoTypes this rule set is applied to. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes#infoTypes
   */
  readonly infoTypes?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
  /**
   * Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set. Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#fixedLikelihood
   */
  readonly fixedLikelihood?: string;

  /**
   * Increase or decrease the likelihood by the specified number of levels. For example, if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1, then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY. Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#relativeLikelihood
   */
  readonly relativeLikelihood?: number;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedLikelihood': obj.fixedLikelihood,
    'relativeLikelihood': obj.relativeLikelihood,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity {
  /**
   * Number of characters after the finding to consider. Either this or window_before must be specified
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider. Either this or window_after must be specified
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesHotwordRuleProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy#resolution
   */
  readonly resolution?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy#resolve
   */
  readonly resolve?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy#resolution
   */
  readonly resolution?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy#resolve
   */
  readonly resolve?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolve;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy
 */
export interface JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy#resolution
   */
  readonly resolution?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy#resolve
   */
  readonly resolve?: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy(obj: JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity {
  /**
   * Number of characters after the finding to consider. Either this or window_before must be specified
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider. Either this or window_after must be specified
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity {
  /**
   * Number of characters after the finding to consider. Either this or window_before must be specified
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider. Either this or window_after must be specified
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeByHotwordProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column. For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the timestamp property does not exist or its value is empty or invalid.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional custom sensitivity for this InfoType. This only applies to data profiling. Structure is documented below.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#sensitivityScore
   */
  readonly sensitivityScore?: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore[];

  /**
   * Version of the information type to use. By default, the version is set to stable
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sensitivityScore': obj.sensitivityScore?.map(y => toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolution
 */
export enum JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolve
 */
export enum JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolution
 */
export enum JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolve
 */
export enum JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolution
 */
export enum JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolve
 */
export enum JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolution
 */
export enum JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolve
 */
export enum JobTriggerSpecForProviderInspectJobActionsDeidentifyTransformationDetailsStorageConfigTableTableIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore
 */
export interface JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore(obj: JobTriggerSpecForProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore
 */
export interface JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore {
  /**
   * The sensitivity score applied to the resource. Possible values are: SENSITIVITY_LOW, SENSITIVITY_MODERATE, SENSITIVITY_HIGH.
   *
   * @schema JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore#score
   */
  readonly score?: string;

}

/**
 * Converts an object of type 'JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore(obj: JobTriggerSpecInitProviderInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypesSensitivityScore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'score': obj.score,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * StoredInfoType is the Schema for the StoredInfoTypes API. Allows creation of custom info types.
 *
 * @schema StoredInfoType
 */
export class StoredInfoType extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StoredInfoType"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datalossprevention.gcp.upbound.io/v1beta1',
    kind: 'StoredInfoType',
  }

  /**
   * Renders a Kubernetes manifest for "StoredInfoType".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StoredInfoTypeProps): any {
    return {
      ...StoredInfoType.GVK,
      ...toJson_StoredInfoTypeProps(props),
    };
  }

  /**
   * Defines a "StoredInfoType" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StoredInfoTypeProps) {
    super(scope, id, {
      ...StoredInfoType.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StoredInfoType.GVK,
      ...toJson_StoredInfoTypeProps(resolved),
    };
  }
}

/**
 * StoredInfoType is the Schema for the StoredInfoTypes API. Allows creation of custom info types.
 *
 * @schema StoredInfoType
 */
export interface StoredInfoTypeProps {
  /**
   * @schema StoredInfoType#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StoredInfoTypeSpec defines the desired state of StoredInfoType
   *
   * @schema StoredInfoType#spec
   */
  readonly spec: StoredInfoTypeSpec;

}

/**
 * Converts an object of type 'StoredInfoTypeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeProps(obj: StoredInfoTypeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StoredInfoTypeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StoredInfoTypeSpec defines the desired state of StoredInfoType
 *
 * @schema StoredInfoTypeSpec
 */
export interface StoredInfoTypeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StoredInfoTypeSpec#deletionPolicy
   */
  readonly deletionPolicy?: StoredInfoTypeSpecDeletionPolicy;

  /**
   * @schema StoredInfoTypeSpec#forProvider
   */
  readonly forProvider: StoredInfoTypeSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema StoredInfoTypeSpec#initProvider
   */
  readonly initProvider?: StoredInfoTypeSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StoredInfoTypeSpec#managementPolicies
   */
  readonly managementPolicies?: StoredInfoTypeSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StoredInfoTypeSpec#providerConfigRef
   */
  readonly providerConfigRef?: StoredInfoTypeSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StoredInfoTypeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StoredInfoTypeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StoredInfoTypeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StoredInfoTypeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StoredInfoTypeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpec(obj: StoredInfoTypeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StoredInfoTypeSpecForProvider(obj.forProvider),
    'initProvider': toJson_StoredInfoTypeSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StoredInfoTypeSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StoredInfoTypeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StoredInfoTypeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StoredInfoTypeSpecDeletionPolicy
 */
export enum StoredInfoTypeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StoredInfoTypeSpecForProvider
 */
export interface StoredInfoTypeSpecForProvider {
  /**
   * A description of the info type.
   *
   * @schema StoredInfoTypeSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProvider#dictionary
   */
  readonly dictionary?: StoredInfoTypeSpecForProviderDictionary[];

  /**
   * User set display name of the info type.
   *
   * @schema StoredInfoTypeSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProvider#largeCustomDictionary
   */
  readonly largeCustomDictionary?: StoredInfoTypeSpecForProviderLargeCustomDictionary[];

  /**
   * The parent of the info type in any of the following formats:
   *
   * @schema StoredInfoTypeSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProvider#regex
   */
  readonly regex?: StoredInfoTypeSpecForProviderRegex[];

  /**
   * The storedInfoType ID can contain uppercase and lowercase letters, numbers, and hyphens; that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is 100 characters. Can be empty to allow the system to generate one.
   *
   * @schema StoredInfoTypeSpecForProvider#storedInfoTypeId
   */
  readonly storedInfoTypeId?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProvider(obj: StoredInfoTypeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'dictionary': obj.dictionary?.map(y => toJson_StoredInfoTypeSpecForProviderDictionary(y)),
    'displayName': obj.displayName,
    'largeCustomDictionary': obj.largeCustomDictionary?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionary(y)),
    'parent': obj.parent,
    'regex': obj.regex?.map(y => toJson_StoredInfoTypeSpecForProviderRegex(y)),
    'storedInfoTypeId': obj.storedInfoTypeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema StoredInfoTypeSpecInitProvider
 */
export interface StoredInfoTypeSpecInitProvider {
  /**
   * A description of the info type.
   *
   * @schema StoredInfoTypeSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecInitProvider#dictionary
   */
  readonly dictionary?: StoredInfoTypeSpecInitProviderDictionary[];

  /**
   * User set display name of the info type.
   *
   * @schema StoredInfoTypeSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Dictionary which defines the rule. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecInitProvider#largeCustomDictionary
   */
  readonly largeCustomDictionary?: StoredInfoTypeSpecInitProviderLargeCustomDictionary[];

  /**
   * The parent of the info type in any of the following formats:
   *
   * @schema StoredInfoTypeSpecInitProvider#parent
   */
  readonly parent?: string;

  /**
   * Regular expression which defines the rule. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecInitProvider#regex
   */
  readonly regex?: StoredInfoTypeSpecInitProviderRegex[];

  /**
   * The storedInfoType ID can contain uppercase and lowercase letters, numbers, and hyphens; that is, it must match the regular expression: [a-zA-Z\d-_]+. The maximum length is 100 characters. Can be empty to allow the system to generate one.
   *
   * @schema StoredInfoTypeSpecInitProvider#storedInfoTypeId
   */
  readonly storedInfoTypeId?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProvider(obj: StoredInfoTypeSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'dictionary': obj.dictionary?.map(y => toJson_StoredInfoTypeSpecInitProviderDictionary(y)),
    'displayName': obj.displayName,
    'largeCustomDictionary': obj.largeCustomDictionary?.map(y => toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionary(y)),
    'parent': obj.parent,
    'regex': obj.regex?.map(y => toJson_StoredInfoTypeSpecInitProviderRegex(y)),
    'storedInfoTypeId': obj.storedInfoTypeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema StoredInfoTypeSpecManagementPolicies
 */
export enum StoredInfoTypeSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StoredInfoTypeSpecProviderConfigRef
 */
export interface StoredInfoTypeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StoredInfoTypeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StoredInfoTypeSpecProviderConfigRef#policy
   */
  readonly policy?: StoredInfoTypeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecProviderConfigRef(obj: StoredInfoTypeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StoredInfoTypeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsTo
 */
export interface StoredInfoTypeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StoredInfoTypeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StoredInfoTypeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecPublishConnectionDetailsTo(obj: StoredInfoTypeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StoredInfoTypeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StoredInfoTypeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StoredInfoTypeSpecWriteConnectionSecretToRef
 */
export interface StoredInfoTypeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StoredInfoTypeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StoredInfoTypeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecWriteConnectionSecretToRef(obj: StoredInfoTypeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderDictionary
 */
export interface StoredInfoTypeSpecForProviderDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: StoredInfoTypeSpecForProviderDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderDictionary#wordList
   */
  readonly wordList?: StoredInfoTypeSpecForProviderDictionaryWordList[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderDictionary(obj: StoredInfoTypeSpecForProviderDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_StoredInfoTypeSpecForProviderDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_StoredInfoTypeSpecForProviderDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionary
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionary {
  /**
   * Field in a BigQuery table where each cell represents a dictionary phrase. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionary#bigQueryField
   */
  readonly bigQueryField?: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField[];

  /**
   * Set of files containing newline-delimited lists of dictionary phrases. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionary#cloudStorageFileSet
   */
  readonly cloudStorageFileSet?: StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet[];

  /**
   * Location to store dictionary artifacts in Google Cloud Storage. These files will only be accessible by project owners and the DLP API. If any of these artifacts are modified, the dictionary is considered invalid and can no longer be used. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionary#outputPath
   */
  readonly outputPath?: StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionary(obj: StoredInfoTypeSpecForProviderLargeCustomDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigQueryField': obj.bigQueryField?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField(y)),
    'cloudStorageFileSet': obj.cloudStorageFileSet?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet(y)),
    'outputPath': obj.outputPath?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderRegex
 */
export interface StoredInfoTypeSpecForProviderRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema StoredInfoTypeSpecForProviderRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema StoredInfoTypeSpecForProviderRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderRegex(obj: StoredInfoTypeSpecForProviderRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecInitProviderDictionary
 */
export interface StoredInfoTypeSpecInitProviderDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecInitProviderDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: StoredInfoTypeSpecInitProviderDictionaryCloudStoragePath[];

  /**
   * List of words or phrases to search for. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecInitProviderDictionary#wordList
   */
  readonly wordList?: StoredInfoTypeSpecInitProviderDictionaryWordList[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProviderDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProviderDictionary(obj: StoredInfoTypeSpecInitProviderDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': obj.cloudStoragePath?.map(y => toJson_StoredInfoTypeSpecInitProviderDictionaryCloudStoragePath(y)),
    'wordList': obj.wordList?.map(y => toJson_StoredInfoTypeSpecInitProviderDictionaryWordList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionary
 */
export interface StoredInfoTypeSpecInitProviderLargeCustomDictionary {
  /**
   * Field in a BigQuery table where each cell represents a dictionary phrase. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionary#bigQueryField
   */
  readonly bigQueryField?: StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryField[];

  /**
   * Set of files containing newline-delimited lists of dictionary phrases. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionary#cloudStorageFileSet
   */
  readonly cloudStorageFileSet?: StoredInfoTypeSpecInitProviderLargeCustomDictionaryCloudStorageFileSet[];

  /**
   * Location to store dictionary artifacts in Google Cloud Storage. These files will only be accessible by project owners and the DLP API. If any of these artifacts are modified, the dictionary is considered invalid and can no longer be used. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionary#outputPath
   */
  readonly outputPath?: StoredInfoTypeSpecInitProviderLargeCustomDictionaryOutputPath[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProviderLargeCustomDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionary(obj: StoredInfoTypeSpecInitProviderLargeCustomDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigQueryField': obj.bigQueryField?.map(y => toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryField(y)),
    'cloudStorageFileSet': obj.cloudStorageFileSet?.map(y => toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionaryCloudStorageFileSet(y)),
    'outputPath': obj.outputPath?.map(y => toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionaryOutputPath(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecInitProviderRegex
 */
export interface StoredInfoTypeSpecInitProviderRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema StoredInfoTypeSpecInitProviderRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema StoredInfoTypeSpecInitProviderRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProviderRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProviderRegex(obj: StoredInfoTypeSpecInitProviderRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StoredInfoTypeSpecProviderConfigRefPolicy
 */
export interface StoredInfoTypeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StoredInfoTypeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StoredInfoTypeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StoredInfoTypeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StoredInfoTypeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecProviderConfigRefPolicy(obj: StoredInfoTypeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRef
 */
export interface StoredInfoTypeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecPublishConnectionDetailsToConfigRef(obj: StoredInfoTypeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsToMetadata
 */
export interface StoredInfoTypeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecPublishConnectionDetailsToMetadata(obj: StoredInfoTypeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderDictionaryCloudStoragePath
 */
export interface StoredInfoTypeSpecForProviderDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema StoredInfoTypeSpecForProviderDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderDictionaryCloudStoragePath(obj: StoredInfoTypeSpecForProviderDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderDictionaryWordList
 */
export interface StoredInfoTypeSpecForProviderDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema StoredInfoTypeSpecForProviderDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderDictionaryWordList(obj: StoredInfoTypeSpecForProviderDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField {
  /**
   * Designated field in the BigQuery table. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField#field
   */
  readonly field?: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField[];

  /**
   * Field in a BigQuery table where each cell represents a dictionary phrase. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField#table
   */
  readonly table?: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField(obj: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField(y)),
    'table': obj.table?.map(y => toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet {
  /**
   * The url, in the format gs://<bucket>/<path>. Trailing wildcard in the path is allowed.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet(obj: StoredInfoTypeSpecForProviderLargeCustomDictionaryCloudStorageFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath(obj: StoredInfoTypeSpecForProviderLargeCustomDictionaryOutputPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecInitProviderDictionaryCloudStoragePath
 */
export interface StoredInfoTypeSpecInitProviderDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema StoredInfoTypeSpecInitProviderDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProviderDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProviderDictionaryCloudStoragePath(obj: StoredInfoTypeSpecInitProviderDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecInitProviderDictionaryWordList
 */
export interface StoredInfoTypeSpecInitProviderDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
   *
   * @schema StoredInfoTypeSpecInitProviderDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProviderDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProviderDictionaryWordList(obj: StoredInfoTypeSpecInitProviderDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryField
 */
export interface StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryField {
  /**
   * Designated field in the BigQuery table. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryField#field
   */
  readonly field?: StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldField[];

  /**
   * Field in a BigQuery table where each cell represents a dictionary phrase. Structure is documented below.
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryField#table
   */
  readonly table?: StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldTable[];

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryField(obj: StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field?.map(y => toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldField(y)),
    'table': obj.table?.map(y => toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldTable(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryCloudStorageFileSet
 */
export interface StoredInfoTypeSpecInitProviderLargeCustomDictionaryCloudStorageFileSet {
  /**
   * The url, in the format gs://<bucket>/<path>. Trailing wildcard in the path is allowed.
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryCloudStorageFileSet#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProviderLargeCustomDictionaryCloudStorageFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionaryCloudStorageFileSet(obj: StoredInfoTypeSpecInitProviderLargeCustomDictionaryCloudStorageFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryOutputPath
 */
export interface StoredInfoTypeSpecInitProviderLargeCustomDictionaryOutputPath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryOutputPath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProviderLargeCustomDictionaryOutputPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionaryOutputPath(obj: StoredInfoTypeSpecInitProviderLargeCustomDictionaryOutputPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StoredInfoTypeSpecProviderConfigRefPolicyResolution
 */
export enum StoredInfoTypeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StoredInfoTypeSpecProviderConfigRefPolicyResolve
 */
export enum StoredInfoTypeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj: StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField {
  /**
   * The resource name of the info type. Set by the server.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField(obj: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable
 */
export interface StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable {
  /**
   * The dataset ID of the table.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable#datasetId
   */
  readonly datasetId?: string;

  /**
   * The Google Cloud Platform project ID of the project containing the table.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable#projectId
   */
  readonly projectId?: string;

  /**
   * The name of the table.
   *
   * @schema StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable#tableId
   */
  readonly tableId?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable(obj: StoredInfoTypeSpecForProviderLargeCustomDictionaryBigQueryFieldTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldField
 */
export interface StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldField {
  /**
   * The resource name of the info type. Set by the server.
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldField(obj: StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldTable
 */
export interface StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldTable {
  /**
   * The dataset ID of the table.
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldTable#datasetId
   */
  readonly datasetId?: string;

  /**
   * The Google Cloud Platform project ID of the project containing the table.
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldTable#projectId
   */
  readonly projectId?: string;

  /**
   * The name of the table.
   *
   * @schema StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldTable#tableId
   */
  readonly tableId?: string;

}

/**
 * Converts an object of type 'StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldTable(obj: StoredInfoTypeSpecInitProviderLargeCustomDictionaryBigQueryFieldTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
    'projectId': obj.projectId,
    'tableId': obj.tableId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StoredInfoTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

