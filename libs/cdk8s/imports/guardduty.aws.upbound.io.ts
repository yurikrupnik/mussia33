// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Detector is the Schema for the Detectors API. Provides a resource to manage a GuardDuty detector
 *
 * @schema Detector
 */
export class Detector extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Detector"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'guardduty.aws.upbound.io/v1beta1',
    kind: 'Detector',
  }

  /**
   * Renders a Kubernetes manifest for "Detector".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DetectorProps): any {
    return {
      ...Detector.GVK,
      ...toJson_DetectorProps(props),
    };
  }

  /**
   * Defines a "Detector" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DetectorProps) {
    super(scope, id, {
      ...Detector.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Detector.GVK,
      ...toJson_DetectorProps(resolved),
    };
  }
}

/**
 * Detector is the Schema for the Detectors API. Provides a resource to manage a GuardDuty detector
 *
 * @schema Detector
 */
export interface DetectorProps {
  /**
   * @schema Detector#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DetectorSpec defines the desired state of Detector
   *
   * @schema Detector#spec
   */
  readonly spec: DetectorSpec;

}

/**
 * Converts an object of type 'DetectorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorProps(obj: DetectorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DetectorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DetectorSpec defines the desired state of Detector
 *
 * @schema DetectorSpec
 */
export interface DetectorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DetectorSpec#deletionPolicy
   */
  readonly deletionPolicy?: DetectorSpecDeletionPolicy;

  /**
   * @schema DetectorSpec#forProvider
   */
  readonly forProvider: DetectorSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DetectorSpec#managementPolicy
   */
  readonly managementPolicy?: DetectorSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DetectorSpec#providerConfigRef
   */
  readonly providerConfigRef?: DetectorSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DetectorSpec#providerRef
   */
  readonly providerRef?: DetectorSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DetectorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DetectorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DetectorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DetectorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DetectorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpec(obj: DetectorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DetectorSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DetectorSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DetectorSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DetectorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DetectorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DetectorSpecDeletionPolicy
 */
export enum DetectorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DetectorSpecForProvider
 */
export interface DetectorSpecForProvider {
  /**
   * Describes which data sources will be enabled for the detector. See Data Sources below for more details.
   *
   * @schema DetectorSpecForProvider#datasources
   */
  readonly datasources?: DetectorSpecForProviderDatasources[];

  /**
   * Enable monitoring and feedback reporting. Setting to false is equivalent to "suspending" GuardDuty. Defaults to true.
   *
   * @default true.
   * @schema DetectorSpecForProvider#enable
   */
  readonly enable?: boolean;

  /**
   * Specifies the frequency of notifications sent for subsequent finding occurrences. If the detector is a GuardDuty member account, the value is determined by the GuardDuty primary account and cannot be modified, otherwise defaults to SIX_HOURS. Valid values for standalone and primary accounts: FIFTEEN_MINUTES, ONE_HOUR, SIX_HOURS. See AWS Documentation for more information.
   *
   * @schema DetectorSpecForProvider#findingPublishingFrequency
   */
  readonly findingPublishingFrequency?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DetectorSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DetectorSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DetectorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecForProvider(obj: DetectorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasources': obj.datasources?.map(y => toJson_DetectorSpecForProviderDatasources(y)),
    'enable': obj.enable,
    'findingPublishingFrequency': obj.findingPublishingFrequency,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DetectorSpecManagementPolicy
 */
export enum DetectorSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DetectorSpecProviderConfigRef
 */
export interface DetectorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DetectorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DetectorSpecProviderConfigRef#policy
   */
  readonly policy?: DetectorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DetectorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecProviderConfigRef(obj: DetectorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DetectorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DetectorSpecProviderRef
 */
export interface DetectorSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DetectorSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DetectorSpecProviderRef#policy
   */
  readonly policy?: DetectorSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DetectorSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecProviderRef(obj: DetectorSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DetectorSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DetectorSpecPublishConnectionDetailsTo
 */
export interface DetectorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DetectorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DetectorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DetectorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DetectorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DetectorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DetectorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecPublishConnectionDetailsTo(obj: DetectorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DetectorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DetectorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DetectorSpecWriteConnectionSecretToRef
 */
export interface DetectorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DetectorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DetectorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DetectorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecWriteConnectionSecretToRef(obj: DetectorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DetectorSpecForProviderDatasources
 */
export interface DetectorSpecForProviderDatasources {
  /**
   * Configures Kubernetes protection. See Kubernetes and Kubernetes Audit Logs below for more details.
   *
   * @schema DetectorSpecForProviderDatasources#kubernetes
   */
  readonly kubernetes?: DetectorSpecForProviderDatasourcesKubernetes[];

  /**
   * Configures Malware Protection. See Malware Protection, Scan EC2 instance with findings and EBS volumes below for more details.
   *
   * @schema DetectorSpecForProviderDatasources#malwareProtection
   */
  readonly malwareProtection?: DetectorSpecForProviderDatasourcesMalwareProtection[];

  /**
   * Configures S3 protection. See S3 Logs below for more details.
   *
   * @schema DetectorSpecForProviderDatasources#s3Logs
   */
  readonly s3Logs?: DetectorSpecForProviderDatasourcesS3Logs[];

}

/**
 * Converts an object of type 'DetectorSpecForProviderDatasources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecForProviderDatasources(obj: DetectorSpecForProviderDatasources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetes': obj.kubernetes?.map(y => toJson_DetectorSpecForProviderDatasourcesKubernetes(y)),
    'malwareProtection': obj.malwareProtection?.map(y => toJson_DetectorSpecForProviderDatasourcesMalwareProtection(y)),
    's3Logs': obj.s3Logs?.map(y => toJson_DetectorSpecForProviderDatasourcesS3Logs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DetectorSpecProviderConfigRefPolicy
 */
export interface DetectorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DetectorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DetectorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DetectorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DetectorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DetectorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecProviderConfigRefPolicy(obj: DetectorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DetectorSpecProviderRefPolicy
 */
export interface DetectorSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DetectorSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DetectorSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DetectorSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DetectorSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DetectorSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecProviderRefPolicy(obj: DetectorSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DetectorSpecPublishConnectionDetailsToConfigRef
 */
export interface DetectorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DetectorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DetectorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DetectorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DetectorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecPublishConnectionDetailsToConfigRef(obj: DetectorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DetectorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DetectorSpecPublishConnectionDetailsToMetadata
 */
export interface DetectorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DetectorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DetectorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DetectorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DetectorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecPublishConnectionDetailsToMetadata(obj: DetectorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DetectorSpecForProviderDatasourcesKubernetes
 */
export interface DetectorSpecForProviderDatasourcesKubernetes {
  /**
   * Configures Kubernetes audit logs as a data source for Kubernetes protection. See Kubernetes Audit Logs below for more details.
   *
   * @schema DetectorSpecForProviderDatasourcesKubernetes#auditLogs
   */
  readonly auditLogs: DetectorSpecForProviderDatasourcesKubernetesAuditLogs[];

}

/**
 * Converts an object of type 'DetectorSpecForProviderDatasourcesKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecForProviderDatasourcesKubernetes(obj: DetectorSpecForProviderDatasourcesKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auditLogs': obj.auditLogs?.map(y => toJson_DetectorSpecForProviderDatasourcesKubernetesAuditLogs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DetectorSpecForProviderDatasourcesMalwareProtection
 */
export interface DetectorSpecForProviderDatasourcesMalwareProtection {
  /**
   * Configure whether Malware Protection is enabled as data source for EC2 instances with findings for the detector. See Scan EC2 instance with findings below for more details.
   *
   * @schema DetectorSpecForProviderDatasourcesMalwareProtection#scanEc2InstanceWithFindings
   */
  readonly scanEc2InstanceWithFindings: DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindings[];

}

/**
 * Converts an object of type 'DetectorSpecForProviderDatasourcesMalwareProtection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecForProviderDatasourcesMalwareProtection(obj: DetectorSpecForProviderDatasourcesMalwareProtection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scanEc2InstanceWithFindings': obj.scanEc2InstanceWithFindings?.map(y => toJson_DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DetectorSpecForProviderDatasourcesS3Logs
 */
export interface DetectorSpecForProviderDatasourcesS3Logs {
  /**
   * If true, enables S3 protection. Defaults to true.
   *
   * @default true.
   * @schema DetectorSpecForProviderDatasourcesS3Logs#enable
   */
  readonly enable: boolean;

}

/**
 * Converts an object of type 'DetectorSpecForProviderDatasourcesS3Logs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecForProviderDatasourcesS3Logs(obj: DetectorSpecForProviderDatasourcesS3Logs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DetectorSpecProviderConfigRefPolicyResolution
 */
export enum DetectorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DetectorSpecProviderConfigRefPolicyResolve
 */
export enum DetectorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DetectorSpecProviderRefPolicyResolution
 */
export enum DetectorSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DetectorSpecProviderRefPolicyResolve
 */
export enum DetectorSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DetectorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DetectorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DetectorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DetectorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DetectorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DetectorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DetectorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecPublishConnectionDetailsToConfigRefPolicy(obj: DetectorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DetectorSpecForProviderDatasourcesKubernetesAuditLogs
 */
export interface DetectorSpecForProviderDatasourcesKubernetesAuditLogs {
  /**
   * If true, enables Malware Protection as data source for the detector. Defaults to true.
   *
   * @default true.
   * @schema DetectorSpecForProviderDatasourcesKubernetesAuditLogs#enable
   */
  readonly enable: boolean;

}

/**
 * Converts an object of type 'DetectorSpecForProviderDatasourcesKubernetesAuditLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecForProviderDatasourcesKubernetesAuditLogs(obj: DetectorSpecForProviderDatasourcesKubernetesAuditLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindings
 */
export interface DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindings {
  /**
   * Configure whether scanning EBS volumes is enabled as data source for the detector for instances with findings. See EBS volumes below for more details.
   *
   * @schema DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindings#ebsVolumes
   */
  readonly ebsVolumes: DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes[];

}

/**
 * Converts an object of type 'DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindings(obj: DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ebsVolumes': obj.ebsVolumes?.map(y => toJson_DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DetectorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DetectorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DetectorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DetectorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes
 */
export interface DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes {
  /**
   * If true, enables Malware Protection as data source for the detector. Defaults to true.
   *
   * @default true.
   * @schema DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes#enable
   */
  readonly enable: boolean;

}

/**
 * Converts an object of type 'DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes(obj: DetectorSpecForProviderDatasourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Filter is the Schema for the Filters API. Provides a resource to manage a GuardDuty filter
 *
 * @schema Filter
 */
export class Filter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Filter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'guardduty.aws.upbound.io/v1beta1',
    kind: 'Filter',
  }

  /**
   * Renders a Kubernetes manifest for "Filter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FilterProps): any {
    return {
      ...Filter.GVK,
      ...toJson_FilterProps(props),
    };
  }

  /**
   * Defines a "Filter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FilterProps) {
    super(scope, id, {
      ...Filter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Filter.GVK,
      ...toJson_FilterProps(resolved),
    };
  }
}

/**
 * Filter is the Schema for the Filters API. Provides a resource to manage a GuardDuty filter
 *
 * @schema Filter
 */
export interface FilterProps {
  /**
   * @schema Filter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FilterSpec defines the desired state of Filter
   *
   * @schema Filter#spec
   */
  readonly spec: FilterSpec;

}

/**
 * Converts an object of type 'FilterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterProps(obj: FilterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FilterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FilterSpec defines the desired state of Filter
 *
 * @schema FilterSpec
 */
export interface FilterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FilterSpec#deletionPolicy
   */
  readonly deletionPolicy?: FilterSpecDeletionPolicy;

  /**
   * @schema FilterSpec#forProvider
   */
  readonly forProvider: FilterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FilterSpec#managementPolicy
   */
  readonly managementPolicy?: FilterSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FilterSpec#providerConfigRef
   */
  readonly providerConfigRef?: FilterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FilterSpec#providerRef
   */
  readonly providerRef?: FilterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FilterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FilterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FilterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FilterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FilterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpec(obj: FilterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FilterSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_FilterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FilterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FilterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FilterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FilterSpecDeletionPolicy
 */
export enum FilterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FilterSpecForProvider
 */
export interface FilterSpecForProvider {
  /**
   * Specifies the action that is to be applied to the findings that match the filter. Can be one of ARCHIVE or NOOP.
   *
   * @schema FilterSpecForProvider#action
   */
  readonly action?: string;

  /**
   * Description of the filter.
   *
   * @schema FilterSpecForProvider#description
   */
  readonly description?: string;

  /**
   * ID of a GuardDuty detector, attached to your account.
   *
   * @schema FilterSpecForProvider#detectorId
   */
  readonly detectorId?: string;

  /**
   * Reference to a Detector in guardduty to populate detectorId.
   *
   * @schema FilterSpecForProvider#detectorIdRef
   */
  readonly detectorIdRef?: FilterSpecForProviderDetectorIdRef;

  /**
   * Selector for a Detector in guardduty to populate detectorId.
   *
   * @schema FilterSpecForProvider#detectorIdSelector
   */
  readonly detectorIdSelector?: FilterSpecForProviderDetectorIdSelector;

  /**
   * Represents the criteria to be used in the filter for querying findings. Contains one or more criterion blocks, documented below.
   *
   * @schema FilterSpecForProvider#findingCriteria
   */
  readonly findingCriteria?: FilterSpecForProviderFindingCriteria[];

  /**
   * Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
   *
   * @schema FilterSpecForProvider#rank
   */
  readonly rank?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FilterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FilterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FilterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecForProvider(obj: FilterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'description': obj.description,
    'detectorId': obj.detectorId,
    'detectorIdRef': toJson_FilterSpecForProviderDetectorIdRef(obj.detectorIdRef),
    'detectorIdSelector': toJson_FilterSpecForProviderDetectorIdSelector(obj.detectorIdSelector),
    'findingCriteria': obj.findingCriteria?.map(y => toJson_FilterSpecForProviderFindingCriteria(y)),
    'rank': obj.rank,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FilterSpecManagementPolicy
 */
export enum FilterSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FilterSpecProviderConfigRef
 */
export interface FilterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FilterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FilterSpecProviderConfigRef#policy
   */
  readonly policy?: FilterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FilterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecProviderConfigRef(obj: FilterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FilterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FilterSpecProviderRef
 */
export interface FilterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FilterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FilterSpecProviderRef#policy
   */
  readonly policy?: FilterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FilterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecProviderRef(obj: FilterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FilterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FilterSpecPublishConnectionDetailsTo
 */
export interface FilterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FilterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FilterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FilterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FilterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FilterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FilterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecPublishConnectionDetailsTo(obj: FilterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FilterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FilterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FilterSpecWriteConnectionSecretToRef
 */
export interface FilterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FilterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FilterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FilterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecWriteConnectionSecretToRef(obj: FilterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Detector in guardduty to populate detectorId.
 *
 * @schema FilterSpecForProviderDetectorIdRef
 */
export interface FilterSpecForProviderDetectorIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FilterSpecForProviderDetectorIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FilterSpecForProviderDetectorIdRef#policy
   */
  readonly policy?: FilterSpecForProviderDetectorIdRefPolicy;

}

/**
 * Converts an object of type 'FilterSpecForProviderDetectorIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecForProviderDetectorIdRef(obj: FilterSpecForProviderDetectorIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FilterSpecForProviderDetectorIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Detector in guardduty to populate detectorId.
 *
 * @schema FilterSpecForProviderDetectorIdSelector
 */
export interface FilterSpecForProviderDetectorIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FilterSpecForProviderDetectorIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FilterSpecForProviderDetectorIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FilterSpecForProviderDetectorIdSelector#policy
   */
  readonly policy?: FilterSpecForProviderDetectorIdSelectorPolicy;

}

/**
 * Converts an object of type 'FilterSpecForProviderDetectorIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecForProviderDetectorIdSelector(obj: FilterSpecForProviderDetectorIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FilterSpecForProviderDetectorIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FilterSpecForProviderFindingCriteria
 */
export interface FilterSpecForProviderFindingCriteria {
  /**
   * @schema FilterSpecForProviderFindingCriteria#criterion
   */
  readonly criterion: FilterSpecForProviderFindingCriteriaCriterion[];

}

/**
 * Converts an object of type 'FilterSpecForProviderFindingCriteria' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecForProviderFindingCriteria(obj: FilterSpecForProviderFindingCriteria | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'criterion': obj.criterion?.map(y => toJson_FilterSpecForProviderFindingCriteriaCriterion(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FilterSpecProviderConfigRefPolicy
 */
export interface FilterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FilterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FilterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FilterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FilterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FilterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecProviderConfigRefPolicy(obj: FilterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FilterSpecProviderRefPolicy
 */
export interface FilterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FilterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FilterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FilterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FilterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FilterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecProviderRefPolicy(obj: FilterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FilterSpecPublishConnectionDetailsToConfigRef
 */
export interface FilterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FilterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FilterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FilterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FilterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecPublishConnectionDetailsToConfigRef(obj: FilterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FilterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FilterSpecPublishConnectionDetailsToMetadata
 */
export interface FilterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FilterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FilterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FilterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FilterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecPublishConnectionDetailsToMetadata(obj: FilterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FilterSpecForProviderDetectorIdRefPolicy
 */
export interface FilterSpecForProviderDetectorIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FilterSpecForProviderDetectorIdRefPolicy#resolution
   */
  readonly resolution?: FilterSpecForProviderDetectorIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FilterSpecForProviderDetectorIdRefPolicy#resolve
   */
  readonly resolve?: FilterSpecForProviderDetectorIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FilterSpecForProviderDetectorIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecForProviderDetectorIdRefPolicy(obj: FilterSpecForProviderDetectorIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FilterSpecForProviderDetectorIdSelectorPolicy
 */
export interface FilterSpecForProviderDetectorIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FilterSpecForProviderDetectorIdSelectorPolicy#resolution
   */
  readonly resolution?: FilterSpecForProviderDetectorIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FilterSpecForProviderDetectorIdSelectorPolicy#resolve
   */
  readonly resolve?: FilterSpecForProviderDetectorIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FilterSpecForProviderDetectorIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecForProviderDetectorIdSelectorPolicy(obj: FilterSpecForProviderDetectorIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FilterSpecForProviderFindingCriteriaCriterion
 */
export interface FilterSpecForProviderFindingCriteriaCriterion {
  /**
   * List of string values to be evaluated.
   *
   * @schema FilterSpecForProviderFindingCriteriaCriterion#equals
   */
  readonly equals?: string[];

  /**
   * The name of the field to be evaluated. The full list of field names can be found in AWS documentation.
   *
   * @schema FilterSpecForProviderFindingCriteriaCriterion#field
   */
  readonly field: string;

  /**
   * A value to be evaluated. Accepts either an integer or a date in RFC 3339 format.
   *
   * @schema FilterSpecForProviderFindingCriteriaCriterion#greaterThan
   */
  readonly greaterThan?: string;

  /**
   * A value to be evaluated. Accepts either an integer or a date in RFC 3339 format.
   *
   * @schema FilterSpecForProviderFindingCriteriaCriterion#greaterThanOrEqual
   */
  readonly greaterThanOrEqual?: string;

  /**
   * A value to be evaluated. Accepts either an integer or a date in RFC 3339 format.
   *
   * @schema FilterSpecForProviderFindingCriteriaCriterion#lessThan
   */
  readonly lessThan?: string;

  /**
   * A value to be evaluated. Accepts either an integer or a date in RFC 3339 format.
   *
   * @schema FilterSpecForProviderFindingCriteriaCriterion#lessThanOrEqual
   */
  readonly lessThanOrEqual?: string;

  /**
   * List of string values to be evaluated.
   *
   * @schema FilterSpecForProviderFindingCriteriaCriterion#notEquals
   */
  readonly notEquals?: string[];

}

/**
 * Converts an object of type 'FilterSpecForProviderFindingCriteriaCriterion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecForProviderFindingCriteriaCriterion(obj: FilterSpecForProviderFindingCriteriaCriterion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'equals': obj.equals?.map(y => y),
    'field': obj.field,
    'greaterThan': obj.greaterThan,
    'greaterThanOrEqual': obj.greaterThanOrEqual,
    'lessThan': obj.lessThan,
    'lessThanOrEqual': obj.lessThanOrEqual,
    'notEquals': obj.notEquals?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FilterSpecProviderConfigRefPolicyResolution
 */
export enum FilterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FilterSpecProviderConfigRefPolicyResolve
 */
export enum FilterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FilterSpecProviderRefPolicyResolution
 */
export enum FilterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FilterSpecProviderRefPolicyResolve
 */
export enum FilterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FilterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FilterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FilterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FilterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FilterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FilterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FilterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FilterSpecPublishConnectionDetailsToConfigRefPolicy(obj: FilterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FilterSpecForProviderDetectorIdRefPolicyResolution
 */
export enum FilterSpecForProviderDetectorIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FilterSpecForProviderDetectorIdRefPolicyResolve
 */
export enum FilterSpecForProviderDetectorIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FilterSpecForProviderDetectorIdSelectorPolicyResolution
 */
export enum FilterSpecForProviderDetectorIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FilterSpecForProviderDetectorIdSelectorPolicyResolve
 */
export enum FilterSpecForProviderDetectorIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FilterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FilterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FilterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FilterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Member is the Schema for the Members API. Provides a resource to manage a GuardDuty member
 *
 * @schema Member
 */
export class Member extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Member"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'guardduty.aws.upbound.io/v1beta1',
    kind: 'Member',
  }

  /**
   * Renders a Kubernetes manifest for "Member".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MemberProps): any {
    return {
      ...Member.GVK,
      ...toJson_MemberProps(props),
    };
  }

  /**
   * Defines a "Member" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MemberProps) {
    super(scope, id, {
      ...Member.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Member.GVK,
      ...toJson_MemberProps(resolved),
    };
  }
}

/**
 * Member is the Schema for the Members API. Provides a resource to manage a GuardDuty member
 *
 * @schema Member
 */
export interface MemberProps {
  /**
   * @schema Member#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MemberSpec defines the desired state of Member
   *
   * @schema Member#spec
   */
  readonly spec: MemberSpec;

}

/**
 * Converts an object of type 'MemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberProps(obj: MemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MemberSpec defines the desired state of Member
 *
 * @schema MemberSpec
 */
export interface MemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: MemberSpecDeletionPolicy;

  /**
   * @schema MemberSpec#forProvider
   */
  readonly forProvider: MemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MemberSpec#managementPolicy
   */
  readonly managementPolicy?: MemberSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: MemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MemberSpec#providerRef
   */
  readonly providerRef?: MemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpec(obj: MemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MemberSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MemberSpecDeletionPolicy
 */
export enum MemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MemberSpecForProvider
 */
export interface MemberSpecForProvider {
  /**
   * AWS account ID for member account.
   *
   * @schema MemberSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * Reference to a Detector in guardduty to populate accountId.
   *
   * @schema MemberSpecForProvider#accountIdRef
   */
  readonly accountIdRef?: MemberSpecForProviderAccountIdRef;

  /**
   * Selector for a Detector in guardduty to populate accountId.
   *
   * @schema MemberSpecForProvider#accountIdSelector
   */
  readonly accountIdSelector?: MemberSpecForProviderAccountIdSelector;

  /**
   * The detector ID of the GuardDuty account where you want to create member accounts.
   *
   * @schema MemberSpecForProvider#detectorId
   */
  readonly detectorId?: string;

  /**
   * Reference to a Detector in guardduty to populate detectorId.
   *
   * @schema MemberSpecForProvider#detectorIdRef
   */
  readonly detectorIdRef?: MemberSpecForProviderDetectorIdRef;

  /**
   * Selector for a Detector in guardduty to populate detectorId.
   *
   * @schema MemberSpecForProvider#detectorIdSelector
   */
  readonly detectorIdSelector?: MemberSpecForProviderDetectorIdSelector;

  /**
   * Boolean whether an email notification is sent to the accounts. Defaults to false.
   *
   * @default false.
   * @schema MemberSpecForProvider#disableEmailNotification
   */
  readonly disableEmailNotification?: boolean;

  /**
   * Email address for member account.
   *
   * @schema MemberSpecForProvider#email
   */
  readonly email?: string;

  /**
   * Message for invitation.
   *
   * @schema MemberSpecForProvider#invitationMessage
   */
  readonly invitationMessage?: string;

  /**
   * Boolean whether to invite the account to GuardDuty as a member. Defaults to false.
   *
   * @default false.
   * @schema MemberSpecForProvider#invite
   */
  readonly invite?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MemberSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'MemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProvider(obj: MemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'accountIdRef': toJson_MemberSpecForProviderAccountIdRef(obj.accountIdRef),
    'accountIdSelector': toJson_MemberSpecForProviderAccountIdSelector(obj.accountIdSelector),
    'detectorId': obj.detectorId,
    'detectorIdRef': toJson_MemberSpecForProviderDetectorIdRef(obj.detectorIdRef),
    'detectorIdSelector': toJson_MemberSpecForProviderDetectorIdSelector(obj.detectorIdSelector),
    'disableEmailNotification': obj.disableEmailNotification,
    'email': obj.email,
    'invitationMessage': obj.invitationMessage,
    'invite': obj.invite,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MemberSpecManagementPolicy
 */
export enum MemberSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MemberSpecProviderConfigRef
 */
export interface MemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecProviderConfigRef#policy
   */
  readonly policy?: MemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderConfigRef(obj: MemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MemberSpecProviderRef
 */
export interface MemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecProviderRef#policy
   */
  readonly policy?: MemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderRef(obj: MemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MemberSpecPublishConnectionDetailsTo
 */
export interface MemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsTo(obj: MemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MemberSpecWriteConnectionSecretToRef
 */
export interface MemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecWriteConnectionSecretToRef(obj: MemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Detector in guardduty to populate accountId.
 *
 * @schema MemberSpecForProviderAccountIdRef
 */
export interface MemberSpecForProviderAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecForProviderAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecForProviderAccountIdRef#policy
   */
  readonly policy?: MemberSpecForProviderAccountIdRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecForProviderAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderAccountIdRef(obj: MemberSpecForProviderAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecForProviderAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Detector in guardduty to populate accountId.
 *
 * @schema MemberSpecForProviderAccountIdSelector
 */
export interface MemberSpecForProviderAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MemberSpecForProviderAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MemberSpecForProviderAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MemberSpecForProviderAccountIdSelector#policy
   */
  readonly policy?: MemberSpecForProviderAccountIdSelectorPolicy;

}

/**
 * Converts an object of type 'MemberSpecForProviderAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderAccountIdSelector(obj: MemberSpecForProviderAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MemberSpecForProviderAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Detector in guardduty to populate detectorId.
 *
 * @schema MemberSpecForProviderDetectorIdRef
 */
export interface MemberSpecForProviderDetectorIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecForProviderDetectorIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecForProviderDetectorIdRef#policy
   */
  readonly policy?: MemberSpecForProviderDetectorIdRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecForProviderDetectorIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderDetectorIdRef(obj: MemberSpecForProviderDetectorIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecForProviderDetectorIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Detector in guardduty to populate detectorId.
 *
 * @schema MemberSpecForProviderDetectorIdSelector
 */
export interface MemberSpecForProviderDetectorIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MemberSpecForProviderDetectorIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MemberSpecForProviderDetectorIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MemberSpecForProviderDetectorIdSelector#policy
   */
  readonly policy?: MemberSpecForProviderDetectorIdSelectorPolicy;

}

/**
 * Converts an object of type 'MemberSpecForProviderDetectorIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderDetectorIdSelector(obj: MemberSpecForProviderDetectorIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MemberSpecForProviderDetectorIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecProviderConfigRefPolicy
 */
export interface MemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderConfigRefPolicy(obj: MemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecProviderRefPolicy
 */
export interface MemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecProviderRefPolicy(obj: MemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRef
 */
export interface MemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToConfigRef(obj: MemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MemberSpecPublishConnectionDetailsToMetadata
 */
export interface MemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToMetadata(obj: MemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecForProviderAccountIdRefPolicy
 */
export interface MemberSpecForProviderAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecForProviderAccountIdRefPolicy#resolution
   */
  readonly resolution?: MemberSpecForProviderAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecForProviderAccountIdRefPolicy#resolve
   */
  readonly resolve?: MemberSpecForProviderAccountIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecForProviderAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderAccountIdRefPolicy(obj: MemberSpecForProviderAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MemberSpecForProviderAccountIdSelectorPolicy
 */
export interface MemberSpecForProviderAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecForProviderAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: MemberSpecForProviderAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecForProviderAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: MemberSpecForProviderAccountIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecForProviderAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderAccountIdSelectorPolicy(obj: MemberSpecForProviderAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MemberSpecForProviderDetectorIdRefPolicy
 */
export interface MemberSpecForProviderDetectorIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecForProviderDetectorIdRefPolicy#resolution
   */
  readonly resolution?: MemberSpecForProviderDetectorIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecForProviderDetectorIdRefPolicy#resolve
   */
  readonly resolve?: MemberSpecForProviderDetectorIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecForProviderDetectorIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderDetectorIdRefPolicy(obj: MemberSpecForProviderDetectorIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MemberSpecForProviderDetectorIdSelectorPolicy
 */
export interface MemberSpecForProviderDetectorIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecForProviderDetectorIdSelectorPolicy#resolution
   */
  readonly resolution?: MemberSpecForProviderDetectorIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecForProviderDetectorIdSelectorPolicy#resolve
   */
  readonly resolve?: MemberSpecForProviderDetectorIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecForProviderDetectorIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecForProviderDetectorIdSelectorPolicy(obj: MemberSpecForProviderDetectorIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecProviderConfigRefPolicyResolution
 */
export enum MemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecProviderConfigRefPolicyResolve
 */
export enum MemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecProviderRefPolicyResolution
 */
export enum MemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecProviderRefPolicyResolve
 */
export enum MemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: MemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecForProviderAccountIdRefPolicyResolution
 */
export enum MemberSpecForProviderAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecForProviderAccountIdRefPolicyResolve
 */
export enum MemberSpecForProviderAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecForProviderAccountIdSelectorPolicyResolution
 */
export enum MemberSpecForProviderAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecForProviderAccountIdSelectorPolicyResolve
 */
export enum MemberSpecForProviderAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecForProviderDetectorIdRefPolicyResolution
 */
export enum MemberSpecForProviderDetectorIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecForProviderDetectorIdRefPolicyResolve
 */
export enum MemberSpecForProviderDetectorIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecForProviderDetectorIdSelectorPolicyResolution
 */
export enum MemberSpecForProviderDetectorIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecForProviderDetectorIdSelectorPolicyResolve
 */
export enum MemberSpecForProviderDetectorIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

