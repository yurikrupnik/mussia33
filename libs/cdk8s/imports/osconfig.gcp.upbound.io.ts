// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * OsPolicyAssignment is the Schema for the OsPolicyAssignments API.
 *
 * @schema OsPolicyAssignment
 */
export class OsPolicyAssignment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OsPolicyAssignment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'osconfig.gcp.upbound.io/v1beta1',
    kind: 'OsPolicyAssignment',
  }

  /**
   * Renders a Kubernetes manifest for "OsPolicyAssignment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OsPolicyAssignmentProps): any {
    return {
      ...OsPolicyAssignment.GVK,
      ...toJson_OsPolicyAssignmentProps(props),
    };
  }

  /**
   * Defines a "OsPolicyAssignment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OsPolicyAssignmentProps) {
    super(scope, id, {
      ...OsPolicyAssignment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OsPolicyAssignment.GVK,
      ...toJson_OsPolicyAssignmentProps(resolved),
    };
  }
}

/**
 * OsPolicyAssignment is the Schema for the OsPolicyAssignments API.
 *
 * @schema OsPolicyAssignment
 */
export interface OsPolicyAssignmentProps {
  /**
   * @schema OsPolicyAssignment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OsPolicyAssignmentSpec defines the desired state of OsPolicyAssignment
   *
   * @schema OsPolicyAssignment#spec
   */
  readonly spec: OsPolicyAssignmentSpec;

}

/**
 * Converts an object of type 'OsPolicyAssignmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentProps(obj: OsPolicyAssignmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OsPolicyAssignmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OsPolicyAssignmentSpec defines the desired state of OsPolicyAssignment
 *
 * @schema OsPolicyAssignmentSpec
 */
export interface OsPolicyAssignmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OsPolicyAssignmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: OsPolicyAssignmentSpecDeletionPolicy;

  /**
   * @schema OsPolicyAssignmentSpec#forProvider
   */
  readonly forProvider: OsPolicyAssignmentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema OsPolicyAssignmentSpec#initProvider
   */
  readonly initProvider?: OsPolicyAssignmentSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema OsPolicyAssignmentSpec#managementPolicies
   */
  readonly managementPolicies?: OsPolicyAssignmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OsPolicyAssignmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: OsPolicyAssignmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OsPolicyAssignmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OsPolicyAssignmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OsPolicyAssignmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OsPolicyAssignmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpec(obj: OsPolicyAssignmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OsPolicyAssignmentSpecForProvider(obj.forProvider),
    'initProvider': toJson_OsPolicyAssignmentSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_OsPolicyAssignmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_OsPolicyAssignmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OsPolicyAssignmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OsPolicyAssignmentSpecDeletionPolicy
 */
export enum OsPolicyAssignmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OsPolicyAssignmentSpecForProvider
 */
export interface OsPolicyAssignmentSpecForProvider {
  /**
   * Policy description. Length of the description is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Filter to select VMs. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProvider#instanceFilter
   */
  readonly instanceFilter?: OsPolicyAssignmentSpecForProviderInstanceFilter[];

  /**
   * The location for the resource
   *
   * @schema OsPolicyAssignmentSpecForProvider#location
   */
  readonly location: string;

  /**
   * List of OS policies to be applied to the VMs. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProvider#osPolicies
   */
  readonly osPolicies?: OsPolicyAssignmentSpecForProviderOsPolicies[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema OsPolicyAssignmentSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Rollout to deploy the OS policy assignment. A rollout is triggered in the following situations: 1) OSPolicyAssignment is created. 2) OSPolicyAssignment is updated and the update contains changes to one of the following fields: - instance_filter - os_policies 3) OSPolicyAssignment is deleted. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProvider#rollout
   */
  readonly rollout?: OsPolicyAssignmentSpecForProviderRollout[];

  /**
   * Set to true to skip awaiting rollout during resource creation and update.
   *
   * @schema OsPolicyAssignmentSpecForProvider#skipAwaitRollout
   */
  readonly skipAwaitRollout?: boolean;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProvider(obj: OsPolicyAssignmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceFilter': obj.instanceFilter?.map(y => toJson_OsPolicyAssignmentSpecForProviderInstanceFilter(y)),
    'location': obj.location,
    'osPolicies': obj.osPolicies?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPolicies(y)),
    'project': obj.project,
    'rollout': obj.rollout?.map(y => toJson_OsPolicyAssignmentSpecForProviderRollout(y)),
    'skipAwaitRollout': obj.skipAwaitRollout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema OsPolicyAssignmentSpecInitProvider
 */
export interface OsPolicyAssignmentSpecInitProvider {
  /**
   * Policy description. Length of the description is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Filter to select VMs. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProvider#instanceFilter
   */
  readonly instanceFilter?: OsPolicyAssignmentSpecInitProviderInstanceFilter[];

  /**
   * List of OS policies to be applied to the VMs. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProvider#osPolicies
   */
  readonly osPolicies?: OsPolicyAssignmentSpecInitProviderOsPolicies[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema OsPolicyAssignmentSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Rollout to deploy the OS policy assignment. A rollout is triggered in the following situations: 1) OSPolicyAssignment is created. 2) OSPolicyAssignment is updated and the update contains changes to one of the following fields: - instance_filter - os_policies 3) OSPolicyAssignment is deleted. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProvider#rollout
   */
  readonly rollout?: OsPolicyAssignmentSpecInitProviderRollout[];

  /**
   * Set to true to skip awaiting rollout during resource creation and update.
   *
   * @schema OsPolicyAssignmentSpecInitProvider#skipAwaitRollout
   */
  readonly skipAwaitRollout?: boolean;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProvider(obj: OsPolicyAssignmentSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceFilter': obj.instanceFilter?.map(y => toJson_OsPolicyAssignmentSpecInitProviderInstanceFilter(y)),
    'osPolicies': obj.osPolicies?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPolicies(y)),
    'project': obj.project,
    'rollout': obj.rollout?.map(y => toJson_OsPolicyAssignmentSpecInitProviderRollout(y)),
    'skipAwaitRollout': obj.skipAwaitRollout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema OsPolicyAssignmentSpecManagementPolicies
 */
export enum OsPolicyAssignmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OsPolicyAssignmentSpecProviderConfigRef
 */
export interface OsPolicyAssignmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OsPolicyAssignmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OsPolicyAssignmentSpecProviderConfigRef#policy
   */
  readonly policy?: OsPolicyAssignmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecProviderConfigRef(obj: OsPolicyAssignmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OsPolicyAssignmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsTo
 */
export interface OsPolicyAssignmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecPublishConnectionDetailsTo(obj: OsPolicyAssignmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OsPolicyAssignmentSpecWriteConnectionSecretToRef
 */
export interface OsPolicyAssignmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OsPolicyAssignmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OsPolicyAssignmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecWriteConnectionSecretToRef(obj: OsPolicyAssignmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderInstanceFilter
 */
export interface OsPolicyAssignmentSpecForProviderInstanceFilter {
  /**
   * Target all VMs in the project. If true, no other criteria is permitted.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilter#all
   */
  readonly all?: boolean;

  /**
   * List of label sets used for VM exclusion. If the list has more than one label set, the VM is excluded if any of the label sets are applicable for the VM. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilter#exclusionLabels
   */
  readonly exclusionLabels?: OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels[];

  /**
   * List of label sets used for VM inclusion. If the list has more than one LabelSet, the VM is included if any of the label sets are applicable for the VM. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilter#inclusionLabels
   */
  readonly inclusionLabels?: OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels[];

  /**
   * List of inventories to select VMs. A VM is selected if its inventory data matches at least one of the following inventories. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilter#inventories
   */
  readonly inventories?: OsPolicyAssignmentSpecForProviderInstanceFilterInventories[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderInstanceFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderInstanceFilter(obj: OsPolicyAssignmentSpecForProviderInstanceFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all,
    'exclusionLabels': obj.exclusionLabels?.map(y => toJson_OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels(y)),
    'inclusionLabels': obj.inclusionLabels?.map(y => toJson_OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels(y)),
    'inventories': obj.inventories?.map(y => toJson_OsPolicyAssignmentSpecForProviderInstanceFilterInventories(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPolicies
 */
export interface OsPolicyAssignmentSpecForProviderOsPolicies {
  /**
   * This flag determines the OS policy compliance status when none of the resource groups within the policy are applicable for a VM. Set this value to true if the policy needs to be reported as compliant even if the policy has nothing to validate or enforce.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPolicies#allowNoResourceGroupMatch
   */
  readonly allowNoResourceGroupMatch?: boolean;

  /**
   * Policy description. Length of the description is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPolicies#description
   */
  readonly description?: string;

  /**
   * The id of the OS policy with the following restrictions:
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPolicies#id
   */
  readonly id?: string;

  /**
   * Policy mode Possible values are: MODE_UNSPECIFIED, VALIDATION, ENFORCEMENT.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPolicies#mode
   */
  readonly mode?: string;

  /**
   * List of resource groups for the policy. For a particular VM, resource groups are evaluated in the order specified and the first resource group that is applicable is selected and the rest are ignored. If none of the resource groups are applicable for a VM, the VM is considered to be non-compliant w.r.t this policy. This behavior can be toggled by the flag allow_no_resource_group_match Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPolicies#resourceGroups
   */
  readonly resourceGroups?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPolicies(obj: OsPolicyAssignmentSpecForProviderOsPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowNoResourceGroupMatch': obj.allowNoResourceGroupMatch,
    'description': obj.description,
    'id': obj.id,
    'mode': obj.mode,
    'resourceGroups': obj.resourceGroups?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderRollout
 */
export interface OsPolicyAssignmentSpecForProviderRollout {
  /**
   * The maximum number (or percentage) of VMs per zone to disrupt at any given moment. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderRollout#disruptionBudget
   */
  readonly disruptionBudget?: OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget[];

  /**
   * This determines the minimum duration of time to wait after the configuration changes are applied through the current rollout. A VM continues to count towards the disruption_budget at least until this duration of time has passed after configuration changes are applied.
   *
   * @schema OsPolicyAssignmentSpecForProviderRollout#minWaitDuration
   */
  readonly minWaitDuration?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderRollout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderRollout(obj: OsPolicyAssignmentSpecForProviderRollout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disruptionBudget': obj.disruptionBudget?.map(y => toJson_OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget(y)),
    'minWaitDuration': obj.minWaitDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderInstanceFilter
 */
export interface OsPolicyAssignmentSpecInitProviderInstanceFilter {
  /**
   * Target all VMs in the project. If true, no other criteria is permitted.
   *
   * @schema OsPolicyAssignmentSpecInitProviderInstanceFilter#all
   */
  readonly all?: boolean;

  /**
   * List of label sets used for VM exclusion. If the list has more than one label set, the VM is excluded if any of the label sets are applicable for the VM. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderInstanceFilter#exclusionLabels
   */
  readonly exclusionLabels?: OsPolicyAssignmentSpecInitProviderInstanceFilterExclusionLabels[];

  /**
   * List of label sets used for VM inclusion. If the list has more than one LabelSet, the VM is included if any of the label sets are applicable for the VM. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderInstanceFilter#inclusionLabels
   */
  readonly inclusionLabels?: OsPolicyAssignmentSpecInitProviderInstanceFilterInclusionLabels[];

  /**
   * List of inventories to select VMs. A VM is selected if its inventory data matches at least one of the following inventories. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderInstanceFilter#inventories
   */
  readonly inventories?: OsPolicyAssignmentSpecInitProviderInstanceFilterInventories[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderInstanceFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderInstanceFilter(obj: OsPolicyAssignmentSpecInitProviderInstanceFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all,
    'exclusionLabels': obj.exclusionLabels?.map(y => toJson_OsPolicyAssignmentSpecInitProviderInstanceFilterExclusionLabels(y)),
    'inclusionLabels': obj.inclusionLabels?.map(y => toJson_OsPolicyAssignmentSpecInitProviderInstanceFilterInclusionLabels(y)),
    'inventories': obj.inventories?.map(y => toJson_OsPolicyAssignmentSpecInitProviderInstanceFilterInventories(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPolicies
 */
export interface OsPolicyAssignmentSpecInitProviderOsPolicies {
  /**
   * This flag determines the OS policy compliance status when none of the resource groups within the policy are applicable for a VM. Set this value to true if the policy needs to be reported as compliant even if the policy has nothing to validate or enforce.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPolicies#allowNoResourceGroupMatch
   */
  readonly allowNoResourceGroupMatch?: boolean;

  /**
   * Policy description. Length of the description is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPolicies#description
   */
  readonly description?: string;

  /**
   * The id of the OS policy with the following restrictions:
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPolicies#id
   */
  readonly id?: string;

  /**
   * Policy mode Possible values are: MODE_UNSPECIFIED, VALIDATION, ENFORCEMENT.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPolicies#mode
   */
  readonly mode?: string;

  /**
   * List of resource groups for the policy. For a particular VM, resource groups are evaluated in the order specified and the first resource group that is applicable is selected and the rest are ignored. If none of the resource groups are applicable for a VM, the VM is considered to be non-compliant w.r.t this policy. This behavior can be toggled by the flag allow_no_resource_group_match Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPolicies#resourceGroups
   */
  readonly resourceGroups?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroups[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPolicies(obj: OsPolicyAssignmentSpecInitProviderOsPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowNoResourceGroupMatch': obj.allowNoResourceGroupMatch,
    'description': obj.description,
    'id': obj.id,
    'mode': obj.mode,
    'resourceGroups': obj.resourceGroups?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroups(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderRollout
 */
export interface OsPolicyAssignmentSpecInitProviderRollout {
  /**
   * The maximum number (or percentage) of VMs per zone to disrupt at any given moment. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderRollout#disruptionBudget
   */
  readonly disruptionBudget?: OsPolicyAssignmentSpecInitProviderRolloutDisruptionBudget[];

  /**
   * This determines the minimum duration of time to wait after the configuration changes are applied through the current rollout. A VM continues to count towards the disruption_budget at least until this duration of time has passed after configuration changes are applied.
   *
   * @schema OsPolicyAssignmentSpecInitProviderRollout#minWaitDuration
   */
  readonly minWaitDuration?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderRollout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderRollout(obj: OsPolicyAssignmentSpecInitProviderRollout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disruptionBudget': obj.disruptionBudget?.map(y => toJson_OsPolicyAssignmentSpecInitProviderRolloutDisruptionBudget(y)),
    'minWaitDuration': obj.minWaitDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OsPolicyAssignmentSpecProviderConfigRefPolicy
 */
export interface OsPolicyAssignmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OsPolicyAssignmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OsPolicyAssignmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OsPolicyAssignmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OsPolicyAssignmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecProviderConfigRefPolicy(obj: OsPolicyAssignmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef
 */
export interface OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef(obj: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata
 */
export interface OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata(obj: OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels
 */
export interface OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels {
  /**
   * Labels are identified by key/value pairs in this map. A VM should contain all the key/value pairs specified in this map to be selected.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels(obj: OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels
 */
export interface OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels {
  /**
   * Labels are identified by key/value pairs in this map. A VM should contain all the key/value pairs specified in this map to be selected.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels(obj: OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderInstanceFilterInventories
 */
export interface OsPolicyAssignmentSpecForProviderInstanceFilterInventories {
  /**
   * The OS short name
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilterInventories#osShortName
   */
  readonly osShortName?: string;

  /**
   * The OS version Prefix matches are supported if asterisk(*) is provided as the last character. For example, to match all versions with a major version of 7, specify the following value for this field 7.* An empty string matches all OS versions.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilterInventories#osVersion
   */
  readonly osVersion?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderInstanceFilterInventories' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderInstanceFilterInventories(obj: OsPolicyAssignmentSpecForProviderInstanceFilterInventories | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osShortName': obj.osShortName,
    'osVersion': obj.osVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups {
  /**
   * List of inventory filters for the resource group. The resources in this resource group are applied to the target VM if it satisfies at least one of the following inventory filters. For example, to apply this resource group to VMs running either RHEL or CentOS operating systems, specify 2 items for the list with following values: inventory_filters[0].os_short_name='rhel' and inventory_filters[1].os_short_name='centos' If the list is empty, this resource group will be applied to the target VM unconditionally. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups#inventoryFilters
   */
  readonly inventoryFilters?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters[];

  /**
   * List of resources configured for this resource group. The resources are executed in the exact order specified here. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups#resources
   */
  readonly resources?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inventoryFilters': obj.inventoryFilters?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters(y)),
    'resources': obj.resources?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget
 */
export interface OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget {
  /**
   * Specifies a fixed value.
   *
   * @schema OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget#fixed
   */
  readonly fixed?: number;

  /**
   * Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
   *
   * @schema OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget(obj: OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixed': obj.fixed,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderInstanceFilterExclusionLabels
 */
export interface OsPolicyAssignmentSpecInitProviderInstanceFilterExclusionLabels {
  /**
   * Labels are identified by key/value pairs in this map. A VM should contain all the key/value pairs specified in this map to be selected.
   *
   * @schema OsPolicyAssignmentSpecInitProviderInstanceFilterExclusionLabels#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderInstanceFilterExclusionLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderInstanceFilterExclusionLabels(obj: OsPolicyAssignmentSpecInitProviderInstanceFilterExclusionLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderInstanceFilterInclusionLabels
 */
export interface OsPolicyAssignmentSpecInitProviderInstanceFilterInclusionLabels {
  /**
   * Labels are identified by key/value pairs in this map. A VM should contain all the key/value pairs specified in this map to be selected.
   *
   * @schema OsPolicyAssignmentSpecInitProviderInstanceFilterInclusionLabels#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderInstanceFilterInclusionLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderInstanceFilterInclusionLabels(obj: OsPolicyAssignmentSpecInitProviderInstanceFilterInclusionLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderInstanceFilterInventories
 */
export interface OsPolicyAssignmentSpecInitProviderInstanceFilterInventories {
  /**
   * The OS short name
   *
   * @schema OsPolicyAssignmentSpecInitProviderInstanceFilterInventories#osShortName
   */
  readonly osShortName?: string;

  /**
   * The OS version Prefix matches are supported if asterisk(*) is provided as the last character. For example, to match all versions with a major version of 7, specify the following value for this field 7.* An empty string matches all OS versions.
   *
   * @schema OsPolicyAssignmentSpecInitProviderInstanceFilterInventories#osVersion
   */
  readonly osVersion?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderInstanceFilterInventories' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderInstanceFilterInventories(obj: OsPolicyAssignmentSpecInitProviderInstanceFilterInventories | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osShortName': obj.osShortName,
    'osVersion': obj.osVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroups
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroups {
  /**
   * List of inventory filters for the resource group. The resources in this resource group are applied to the target VM if it satisfies at least one of the following inventory filters. For example, to apply this resource group to VMs running either RHEL or CentOS operating systems, specify 2 items for the list with following values: inventory_filters[0].os_short_name='rhel' and inventory_filters[1].os_short_name='centos' If the list is empty, this resource group will be applied to the target VM unconditionally. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroups#inventoryFilters
   */
  readonly inventoryFilters?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsInventoryFilters[];

  /**
   * List of resources configured for this resource group. The resources are executed in the exact order specified here. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroups#resources
   */
  readonly resources?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroups(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inventoryFilters': obj.inventoryFilters?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsInventoryFilters(y)),
    'resources': obj.resources?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderRolloutDisruptionBudget
 */
export interface OsPolicyAssignmentSpecInitProviderRolloutDisruptionBudget {
  /**
   * Specifies a fixed value.
   *
   * @schema OsPolicyAssignmentSpecInitProviderRolloutDisruptionBudget#fixed
   */
  readonly fixed?: number;

  /**
   * Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
   *
   * @schema OsPolicyAssignmentSpecInitProviderRolloutDisruptionBudget#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderRolloutDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderRolloutDisruptionBudget(obj: OsPolicyAssignmentSpecInitProviderRolloutDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixed': obj.fixed,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OsPolicyAssignmentSpecProviderConfigRefPolicyResolution
 */
export enum OsPolicyAssignmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OsPolicyAssignmentSpecProviderConfigRefPolicyResolve
 */
export enum OsPolicyAssignmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters {
  /**
   * The OS short name
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters#osShortName
   */
  readonly osShortName?: string;

  /**
   * The OS version Prefix matches are supported if asterisk(*) is provided as the last character. For example, to match all versions with a major version of 7, specify the following value for this field 7.* An empty string matches all OS versions.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters#osVersion
   */
  readonly osVersion?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osShortName': obj.osShortName,
    'osVersion': obj.osVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources {
  /**
   * Exec resource Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources#exec
   */
  readonly exec?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec[];

  /**
   * A remote or local file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources#file
   */
  readonly file?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile[];

  /**
   * A one word, unique name for this repository. This is the repo id in the zypper config file and also the display_name if display_name is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources#id
   */
  readonly id?: string;

  /**
   * Package resource Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources#pkg
   */
  readonly pkg?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg[];

  /**
   * Package repository resource Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources#repository
   */
  readonly repository?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': obj.exec?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec(y)),
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile(y)),
    'id': obj.id,
    'pkg': obj.pkg?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg(y)),
    'repository': obj.repository?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsInventoryFilters
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsInventoryFilters {
  /**
   * The OS short name
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsInventoryFilters#osShortName
   */
  readonly osShortName?: string;

  /**
   * The OS version Prefix matches are supported if asterisk(*) is provided as the last character. For example, to match all versions with a major version of 7, specify the following value for this field 7.* An empty string matches all OS versions.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsInventoryFilters#osVersion
   */
  readonly osVersion?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsInventoryFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsInventoryFilters(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsInventoryFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osShortName': obj.osShortName,
    'osVersion': obj.osVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources {
  /**
   * Exec resource Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources#exec
   */
  readonly exec?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExec[];

  /**
   * A remote or local file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources#file
   */
  readonly file?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile[];

  /**
   * A one word, unique name for this repository. This is the repo id in the zypper config file and also the display_name if display_name is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources#id
   */
  readonly id?: string;

  /**
   * Package resource Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources#pkg
   */
  readonly pkg?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg[];

  /**
   * Package repository resource Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources#repository
   */
  readonly repository?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': obj.exec?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExec(y)),
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile(y)),
    'id': obj.id,
    'pkg': obj.pkg?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg(y)),
    'repository': obj.repository?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec {
  /**
   * What to run to bring this resource into the desired state. An exit code of 100 indicates "success", any other exit code indicates a failure running enforce. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec#enforce
   */
  readonly enforce?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce[];

  /**
   * What to run to validate this resource is in the desired state. An exit code of 100 indicates "in desired state", and exit code of 101 indicates "not in desired state". Any other exit code indicates a failure running validate. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec#validate
   */
  readonly validate?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enforce': obj.enforce?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce(y)),
    'validate': obj.validate?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile {
  /**
   * A a file with this content. The size of the content is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile#content
   */
  readonly content?: string;

  /**
   * A remote or local file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile#file
   */
  readonly file?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile[];

  /**
   * The absolute path of the file within the VM.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile#path
   */
  readonly path?: string;

  /**
   * Desired state of the file. Possible values are: DESIRED_STATE_UNSPECIFIED, PRESENT, ABSENT, CONTENTS_MATCH.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile(y)),
    'path': obj.path,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg {
  /**
   * An Apt Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#apt
   */
  readonly apt?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt[];

  /**
   * A deb package file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#deb
   */
  readonly deb?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb[];

  /**
   * The desired state the agent should maintain for this package. Possible values are: DESIRED_STATE_UNSPECIFIED, INSTALLED, REMOVED.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#desiredState
   */
  readonly desiredState?: string;

  /**
   * A package managed by GooGet. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#googet
   */
  readonly googet?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget[];

  /**
   * An MSI package. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#msi
   */
  readonly msi?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi[];

  /**
   * An rpm package file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#rpm
   */
  readonly rpm?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm[];

  /**
   * A Yum Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#yum
   */
  readonly yum?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum[];

  /**
   * A Zypper Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#zypper
   */
  readonly zypper?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apt': obj.apt?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt(y)),
    'deb': obj.deb?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb(y)),
    'desiredState': obj.desiredState,
    'googet': obj.googet?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget(y)),
    'msi': obj.msi?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi(y)),
    'rpm': obj.rpm?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm(y)),
    'yum': obj.yum?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum(y)),
    'zypper': obj.zypper?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository {
  /**
   * An Apt Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository#apt
   */
  readonly apt?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt[];

  /**
   * A Goo Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository#goo
   */
  readonly goo?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo[];

  /**
   * A Yum Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository#yum
   */
  readonly yum?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum[];

  /**
   * A Zypper Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository#zypper
   */
  readonly zypper?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apt': obj.apt?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt(y)),
    'goo': obj.goo?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo(y)),
    'yum': obj.yum?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum(y)),
    'zypper': obj.zypper?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExec
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExec {
  /**
   * What to run to bring this resource into the desired state. An exit code of 100 indicates "success", any other exit code indicates a failure running enforce. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExec#enforce
   */
  readonly enforce?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce[];

  /**
   * What to run to validate this resource is in the desired state. An exit code of 100 indicates "in desired state", and exit code of 101 indicates "not in desired state". Any other exit code indicates a failure running validate. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExec#validate
   */
  readonly validate?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExec(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enforce': obj.enforce?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce(y)),
    'validate': obj.validate?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile {
  /**
   * A a file with this content. The size of the content is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile#content
   */
  readonly content?: string;

  /**
   * A remote or local file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile#file
   */
  readonly file?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile[];

  /**
   * The absolute path of the file within the VM.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile#path
   */
  readonly path?: string;

  /**
   * Desired state of the file. Possible values are: DESIRED_STATE_UNSPECIFIED, PRESENT, ABSENT, CONTENTS_MATCH.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile(y)),
    'path': obj.path,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg {
  /**
   * An Apt Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg#apt
   */
  readonly apt?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgApt[];

  /**
   * A deb package file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg#deb
   */
  readonly deb?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDeb[];

  /**
   * The desired state the agent should maintain for this package. Possible values are: DESIRED_STATE_UNSPECIFIED, INSTALLED, REMOVED.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg#desiredState
   */
  readonly desiredState?: string;

  /**
   * A package managed by GooGet. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg#googet
   */
  readonly googet?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgGooget[];

  /**
   * An MSI package. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg#msi
   */
  readonly msi?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsi[];

  /**
   * An rpm package file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg#rpm
   */
  readonly rpm?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpm[];

  /**
   * A Yum Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg#yum
   */
  readonly yum?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgYum[];

  /**
   * A Zypper Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg#zypper
   */
  readonly zypper?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgZypper[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apt': obj.apt?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgApt(y)),
    'deb': obj.deb?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDeb(y)),
    'desiredState': obj.desiredState,
    'googet': obj.googet?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgGooget(y)),
    'msi': obj.msi?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsi(y)),
    'rpm': obj.rpm?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpm(y)),
    'yum': obj.yum?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgYum(y)),
    'zypper': obj.zypper?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgZypper(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository {
  /**
   * An Apt Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository#apt
   */
  readonly apt?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt[];

  /**
   * A Goo Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository#goo
   */
  readonly goo?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryGoo[];

  /**
   * A Yum Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository#yum
   */
  readonly yum?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum[];

  /**
   * A Zypper Repository. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository#zypper
   */
  readonly zypper?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apt': obj.apt?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt(y)),
    'goo': obj.goo?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryGoo(y)),
    'yum': obj.yum?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum(y)),
    'zypper': obj.zypper?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce {
  /**
   * Optional arguments to pass to the source during execution.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce#args
   */
  readonly args?: string[];

  /**
   * A remote or local file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce#file
   */
  readonly file?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile[];

  /**
   * The script interpreter to use. Possible values are: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce#interpreter
   */
  readonly interpreter?: string;

  /**
   * Only recorded for enforce Exec. Path to an output file (that is created by this Exec) whose content will be recorded in OSPolicyResourceCompliance after a successful run. Absence or failure to read this file will result in this ExecResource being non-compliant. Output file size is limited to 100K bytes.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce#outputFilePath
   */
  readonly outputFilePath?: string;

  /**
   * An inline script. The size of the script is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce#script
   */
  readonly script?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile(y)),
    'interpreter': obj.interpreter,
    'outputFilePath': obj.outputFilePath,
    'script': obj.script,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate {
  /**
   * Optional arguments to pass to the source during execution.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate#args
   */
  readonly args?: string[];

  /**
   * A remote or local file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate#file
   */
  readonly file?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile[];

  /**
   * The script interpreter to use. Possible values are: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate#interpreter
   */
  readonly interpreter?: string;

  /**
   * Only recorded for enforce Exec. Path to an output file (that is created by this Exec) whose content will be recorded in OSPolicyResourceCompliance after a successful run. Absence or failure to read this file will result in this ExecResource being non-compliant. Output file size is limited to 100K bytes.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate#outputFilePath
   */
  readonly outputFilePath?: string;

  /**
   * An inline script. The size of the script is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate#script
   */
  readonly script?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile(y)),
    'interpreter': obj.interpreter,
    'outputFilePath': obj.outputFilePath,
    'script': obj.script,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt {
  /**
   * Package name.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb {
  /**
   * Whether dependencies should also be installed. - install when false: rpm --upgrade --replacepkgs package.rpm - install when true: yum -y install package.rpm or zypper -y install package.rpm
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb#pullDeps
   */
  readonly pullDeps?: boolean;

  /**
   * An rpm package. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb#source
   */
  readonly source?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullDeps': obj.pullDeps,
    'source': obj.source?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget {
  /**
   * Package name.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi {
  /**
   * Additional properties to use during installation. This should be in the format of Property=Setting. Appended to the defaults of ACTION=INSTALL REBOOT=ReallySuppress.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi#properties
   */
  readonly properties?: string[];

  /**
   * An rpm package. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi#source
   */
  readonly source?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'properties': obj.properties?.map(y => y),
    'source': obj.source?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm {
  /**
   * Whether dependencies should also be installed. - install when false: rpm --upgrade --replacepkgs package.rpm - install when true: yum -y install package.rpm or zypper -y install package.rpm
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm#pullDeps
   */
  readonly pullDeps?: boolean;

  /**
   * An rpm package. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm#source
   */
  readonly source?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullDeps': obj.pullDeps,
    'source': obj.source?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum {
  /**
   * Package name.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper {
  /**
   * Package name.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt {
  /**
   * Type of archive files in this repository. Possible values are: ARCHIVE_TYPE_UNSPECIFIED, DEB, DEB_SRC.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt#archiveType
   */
  readonly archiveType?: string;

  /**
   * List of components for this repository. Must contain at least one item.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt#components
   */
  readonly components?: string[];

  /**
   * Distribution of this repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt#distribution
   */
  readonly distribution?: string;

  /**
   * URI of the key file for this repository. The agent maintains a keyring at /etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt#gpgKey
   */
  readonly gpgKey?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'archiveType': obj.archiveType,
    'components': obj.components?.map(y => y),
    'distribution': obj.distribution,
    'gpgKey': obj.gpgKey,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo {
  /**
   * Package name.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo#name
   */
  readonly name?: string;

  /**
   * The url of the repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum {
  /**
   * The location of the repository directory.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * The display name of the repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum#displayName
   */
  readonly displayName?: string;

  /**
   * URIs of GPG keys.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum#gpgKeys
   */
  readonly gpgKeys?: string[];

  /**
   * A one word, unique name for this repository. This is the repo id in the zypper config file and also the display_name if display_name is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum#id
   */
  readonly id?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseUrl': obj.baseUrl,
    'displayName': obj.displayName,
    'gpgKeys': obj.gpgKeys?.map(y => y),
    'id': obj.id,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper {
  /**
   * The location of the repository directory.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * The display name of the repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#displayName
   */
  readonly displayName?: string;

  /**
   * URIs of GPG keys.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#gpgKeys
   */
  readonly gpgKeys?: string[];

  /**
   * A one word, unique name for this repository. This is the repo id in the zypper config file and also the display_name if display_name is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#id
   */
  readonly id?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseUrl': obj.baseUrl,
    'displayName': obj.displayName,
    'gpgKeys': obj.gpgKeys?.map(y => y),
    'id': obj.id,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce {
  /**
   * Optional arguments to pass to the source during execution.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce#args
   */
  readonly args?: string[];

  /**
   * A remote or local file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce#file
   */
  readonly file?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile[];

  /**
   * The script interpreter to use. Possible values are: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce#interpreter
   */
  readonly interpreter?: string;

  /**
   * Only recorded for enforce Exec. Path to an output file (that is created by this Exec) whose content will be recorded in OSPolicyResourceCompliance after a successful run. Absence or failure to read this file will result in this ExecResource being non-compliant. Output file size is limited to 100K bytes.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce#outputFilePath
   */
  readonly outputFilePath?: string;

  /**
   * An inline script. The size of the script is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce#script
   */
  readonly script?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile(y)),
    'interpreter': obj.interpreter,
    'outputFilePath': obj.outputFilePath,
    'script': obj.script,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate {
  /**
   * Optional arguments to pass to the source during execution.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate#args
   */
  readonly args?: string[];

  /**
   * A remote or local file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate#file
   */
  readonly file?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile[];

  /**
   * The script interpreter to use. Possible values are: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate#interpreter
   */
  readonly interpreter?: string;

  /**
   * Only recorded for enforce Exec. Path to an output file (that is created by this Exec) whose content will be recorded in OSPolicyResourceCompliance after a successful run. Absence or failure to read this file will result in this ExecResource being non-compliant. Output file size is limited to 100K bytes.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate#outputFilePath
   */
  readonly outputFilePath?: string;

  /**
   * An inline script. The size of the script is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate#script
   */
  readonly script?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile(y)),
    'interpreter': obj.interpreter,
    'outputFilePath': obj.outputFilePath,
    'script': obj.script,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile#remote
   */
  readonly remote?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgApt
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgApt {
  /**
   * Package name.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgApt#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgApt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgApt(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgApt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDeb
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDeb {
  /**
   * Whether dependencies should also be installed. - install when false: rpm --upgrade --replacepkgs package.rpm - install when true: yum -y install package.rpm or zypper -y install package.rpm
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDeb#pullDeps
   */
  readonly pullDeps?: boolean;

  /**
   * An rpm package. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDeb#source
   */
  readonly source?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDeb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDeb(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDeb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullDeps': obj.pullDeps,
    'source': obj.source?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgGooget
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgGooget {
  /**
   * Package name.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgGooget#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgGooget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgGooget(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgGooget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsi
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsi {
  /**
   * Additional properties to use during installation. This should be in the format of Property=Setting. Appended to the defaults of ACTION=INSTALL REBOOT=ReallySuppress.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsi#properties
   */
  readonly properties?: string[];

  /**
   * An rpm package. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsi#source
   */
  readonly source?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsi(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'properties': obj.properties?.map(y => y),
    'source': obj.source?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpm
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpm {
  /**
   * Whether dependencies should also be installed. - install when false: rpm --upgrade --replacepkgs package.rpm - install when true: yum -y install package.rpm or zypper -y install package.rpm
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpm#pullDeps
   */
  readonly pullDeps?: boolean;

  /**
   * An rpm package. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpm#source
   */
  readonly source?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpm(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullDeps': obj.pullDeps,
    'source': obj.source?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgYum
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgYum {
  /**
   * Package name.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgYum#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgYum' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgYum(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgYum | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgZypper
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgZypper {
  /**
   * Package name.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgZypper#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgZypper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgZypper(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgZypper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt {
  /**
   * Type of archive files in this repository. Possible values are: ARCHIVE_TYPE_UNSPECIFIED, DEB, DEB_SRC.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt#archiveType
   */
  readonly archiveType?: string;

  /**
   * List of components for this repository. Must contain at least one item.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt#components
   */
  readonly components?: string[];

  /**
   * Distribution of this repository.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt#distribution
   */
  readonly distribution?: string;

  /**
   * URI of the key file for this repository. The agent maintains a keyring at /etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt#gpgKey
   */
  readonly gpgKey?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryApt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'archiveType': obj.archiveType,
    'components': obj.components?.map(y => y),
    'distribution': obj.distribution,
    'gpgKey': obj.gpgKey,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryGoo
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryGoo {
  /**
   * Package name.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryGoo#name
   */
  readonly name?: string;

  /**
   * The url of the repository.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryGoo#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryGoo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryGoo(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryGoo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum {
  /**
   * The location of the repository directory.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * The display name of the repository.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum#displayName
   */
  readonly displayName?: string;

  /**
   * URIs of GPG keys.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum#gpgKeys
   */
  readonly gpgKeys?: string[];

  /**
   * A one word, unique name for this repository. This is the repo id in the zypper config file and also the display_name if display_name is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum#id
   */
  readonly id?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryYum | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseUrl': obj.baseUrl,
    'displayName': obj.displayName,
    'gpgKeys': obj.gpgKeys?.map(y => y),
    'id': obj.id,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper {
  /**
   * The location of the repository directory.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * The display name of the repository.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#displayName
   */
  readonly displayName?: string;

  /**
   * URIs of GPG keys.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#gpgKeys
   */
  readonly gpgKeys?: string[];

  /**
   * A one word, unique name for this repository. This is the repo id in the zypper config file and also the display_name if display_name is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#id
   */
  readonly id?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesRepositoryZypper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseUrl': obj.baseUrl,
    'displayName': obj.displayName,
    'gpgKeys': obj.gpgKeys?.map(y => y),
    'id': obj.id,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#remote
   */
  readonly remote?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile#remote
   */
  readonly remote?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileGcs
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileGcs(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileRemote
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileRemote(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesFileFileRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource#remote
   */
  readonly remote?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#remote
   */
  readonly remote?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file. Structure is documented below.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#remote
   */
  readonly remote?: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs#generation
   */
  readonly generation?: number;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote
 */
export interface OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote(obj: OsPolicyAssignmentSpecInitProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * PatchDeployment is the Schema for the PatchDeployments API. Patch deployments are configurations that individual patch jobs use to complete a patch.
 *
 * @schema PatchDeployment
 */
export class PatchDeployment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PatchDeployment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'osconfig.gcp.upbound.io/v1beta1',
    kind: 'PatchDeployment',
  }

  /**
   * Renders a Kubernetes manifest for "PatchDeployment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PatchDeploymentProps): any {
    return {
      ...PatchDeployment.GVK,
      ...toJson_PatchDeploymentProps(props),
    };
  }

  /**
   * Defines a "PatchDeployment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PatchDeploymentProps) {
    super(scope, id, {
      ...PatchDeployment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PatchDeployment.GVK,
      ...toJson_PatchDeploymentProps(resolved),
    };
  }
}

/**
 * PatchDeployment is the Schema for the PatchDeployments API. Patch deployments are configurations that individual patch jobs use to complete a patch.
 *
 * @schema PatchDeployment
 */
export interface PatchDeploymentProps {
  /**
   * @schema PatchDeployment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PatchDeploymentSpec defines the desired state of PatchDeployment
   *
   * @schema PatchDeployment#spec
   */
  readonly spec: PatchDeploymentSpec;

}

/**
 * Converts an object of type 'PatchDeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentProps(obj: PatchDeploymentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PatchDeploymentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PatchDeploymentSpec defines the desired state of PatchDeployment
 *
 * @schema PatchDeploymentSpec
 */
export interface PatchDeploymentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PatchDeploymentSpec#deletionPolicy
   */
  readonly deletionPolicy?: PatchDeploymentSpecDeletionPolicy;

  /**
   * @schema PatchDeploymentSpec#forProvider
   */
  readonly forProvider: PatchDeploymentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PatchDeploymentSpec#initProvider
   */
  readonly initProvider?: PatchDeploymentSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PatchDeploymentSpec#managementPolicies
   */
  readonly managementPolicies?: PatchDeploymentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PatchDeploymentSpec#providerConfigRef
   */
  readonly providerConfigRef?: PatchDeploymentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PatchDeploymentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PatchDeploymentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PatchDeploymentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PatchDeploymentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PatchDeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpec(obj: PatchDeploymentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PatchDeploymentSpecForProvider(obj.forProvider),
    'initProvider': toJson_PatchDeploymentSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PatchDeploymentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PatchDeploymentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PatchDeploymentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PatchDeploymentSpecDeletionPolicy
 */
export enum PatchDeploymentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PatchDeploymentSpecForProvider
 */
export interface PatchDeploymentSpecForProvider {
  /**
   * Description of the patch deployment. Length of the description is limited to 1024 characters.
   *
   * @schema PatchDeploymentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Duration of the patch. After the duration ends, the patch times out. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s"
   *
   * @schema PatchDeploymentSpecForProvider#duration
   */
  readonly duration?: string;

  /**
   * VM instances to patch. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProvider#instanceFilter
   */
  readonly instanceFilter?: PatchDeploymentSpecForProviderInstanceFilter[];

  /**
   * Schedule a one-time execution. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProvider#oneTimeSchedule
   */
  readonly oneTimeSchedule?: PatchDeploymentSpecForProviderOneTimeSchedule[];

  /**
   * Patch configuration that is applied. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProvider#patchConfig
   */
  readonly patchConfig?: PatchDeploymentSpecForProviderPatchConfig[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema PatchDeploymentSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Schedule recurring executions. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProvider#recurringSchedule
   */
  readonly recurringSchedule?: PatchDeploymentSpecForProviderRecurringSchedule[];

  /**
   * Rollout strategy of the patch job. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProvider#rollout
   */
  readonly rollout?: PatchDeploymentSpecForProviderRollout[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProvider(obj: PatchDeploymentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'duration': obj.duration,
    'instanceFilter': obj.instanceFilter?.map(y => toJson_PatchDeploymentSpecForProviderInstanceFilter(y)),
    'oneTimeSchedule': obj.oneTimeSchedule?.map(y => toJson_PatchDeploymentSpecForProviderOneTimeSchedule(y)),
    'patchConfig': obj.patchConfig?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfig(y)),
    'project': obj.project,
    'recurringSchedule': obj.recurringSchedule?.map(y => toJson_PatchDeploymentSpecForProviderRecurringSchedule(y)),
    'rollout': obj.rollout?.map(y => toJson_PatchDeploymentSpecForProviderRollout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PatchDeploymentSpecInitProvider
 */
export interface PatchDeploymentSpecInitProvider {
  /**
   * Description of the patch deployment. Length of the description is limited to 1024 characters.
   *
   * @schema PatchDeploymentSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Duration of the patch. After the duration ends, the patch times out. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s"
   *
   * @schema PatchDeploymentSpecInitProvider#duration
   */
  readonly duration?: string;

  /**
   * VM instances to patch. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProvider#instanceFilter
   */
  readonly instanceFilter?: PatchDeploymentSpecInitProviderInstanceFilter[];

  /**
   * Schedule a one-time execution. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProvider#oneTimeSchedule
   */
  readonly oneTimeSchedule?: PatchDeploymentSpecInitProviderOneTimeSchedule[];

  /**
   * Patch configuration that is applied. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProvider#patchConfig
   */
  readonly patchConfig?: PatchDeploymentSpecInitProviderPatchConfig[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema PatchDeploymentSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Schedule recurring executions. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProvider#recurringSchedule
   */
  readonly recurringSchedule?: PatchDeploymentSpecInitProviderRecurringSchedule[];

  /**
   * Rollout strategy of the patch job. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProvider#rollout
   */
  readonly rollout?: PatchDeploymentSpecInitProviderRollout[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProvider(obj: PatchDeploymentSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'duration': obj.duration,
    'instanceFilter': obj.instanceFilter?.map(y => toJson_PatchDeploymentSpecInitProviderInstanceFilter(y)),
    'oneTimeSchedule': obj.oneTimeSchedule?.map(y => toJson_PatchDeploymentSpecInitProviderOneTimeSchedule(y)),
    'patchConfig': obj.patchConfig?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfig(y)),
    'project': obj.project,
    'recurringSchedule': obj.recurringSchedule?.map(y => toJson_PatchDeploymentSpecInitProviderRecurringSchedule(y)),
    'rollout': obj.rollout?.map(y => toJson_PatchDeploymentSpecInitProviderRollout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PatchDeploymentSpecManagementPolicies
 */
export enum PatchDeploymentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PatchDeploymentSpecProviderConfigRef
 */
export interface PatchDeploymentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchDeploymentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchDeploymentSpecProviderConfigRef#policy
   */
  readonly policy?: PatchDeploymentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PatchDeploymentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecProviderConfigRef(obj: PatchDeploymentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchDeploymentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsTo
 */
export interface PatchDeploymentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PatchDeploymentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PatchDeploymentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecPublishConnectionDetailsTo(obj: PatchDeploymentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PatchDeploymentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PatchDeploymentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PatchDeploymentSpecWriteConnectionSecretToRef
 */
export interface PatchDeploymentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PatchDeploymentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PatchDeploymentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecWriteConnectionSecretToRef(obj: PatchDeploymentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderInstanceFilter
 */
export interface PatchDeploymentSpecForProviderInstanceFilter {
  /**
   * Target all VM instances in the project. If true, no other criteria is permitted.
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilter#all
   */
  readonly all?: boolean;

  /**
   * Targets VM instances matching ANY of these GroupLabels. This allows targeting of disparate groups of VM instances. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilter#groupLabels
   */
  readonly groupLabels?: PatchDeploymentSpecForProviderInstanceFilterGroupLabels[];

  /**
   * Targets VMs whose name starts with one of these prefixes. Similar to labels, this is another way to group VMs when targeting configs, for example prefix="prod-".
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilter#instanceNamePrefixes
   */
  readonly instanceNamePrefixes?: string[];

  /**
   * Targets any of the VM instances specified. Instances are specified by their URI in the form zones/{{zone}}/instances/{{instance_name}}, projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}, or https://www.googleapis.com/compute/v1/projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilter#instances
   */
  readonly instances?: string[];

  /**
   * Targets VM instances in ANY of these zones. Leave empty to target VM instances in any zone.
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilter#zones
   */
  readonly zones?: string[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderInstanceFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderInstanceFilter(obj: PatchDeploymentSpecForProviderInstanceFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all,
    'groupLabels': obj.groupLabels?.map(y => toJson_PatchDeploymentSpecForProviderInstanceFilterGroupLabels(y)),
    'instanceNamePrefixes': obj.instanceNamePrefixes?.map(y => y),
    'instances': obj.instances?.map(y => y),
    'zones': obj.zones?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderOneTimeSchedule
 */
export interface PatchDeploymentSpecForProviderOneTimeSchedule {
  /**
   * The desired patch job execution time. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   *
   * @schema PatchDeploymentSpecForProviderOneTimeSchedule#executeTime
   */
  readonly executeTime?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderOneTimeSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderOneTimeSchedule(obj: PatchDeploymentSpecForProviderOneTimeSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executeTime': obj.executeTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfig
 */
export interface PatchDeploymentSpecForProviderPatchConfig {
  /**
   * Apt update settings. Use this setting to override the default apt patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#apt
   */
  readonly apt?: PatchDeploymentSpecForProviderPatchConfigApt[];

  /**
   * goo update settings. Use this setting to override the default goo patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#goo
   */
  readonly goo?: PatchDeploymentSpecForProviderPatchConfigGoo[];

  /**
   * Allows the patch job to run on Managed instance groups (MIGs).
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#migInstancesAllowed
   */
  readonly migInstancesAllowed?: boolean;

  /**
   * The ExecStep to run after the patch update. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#postStep
   */
  readonly postStep?: PatchDeploymentSpecForProviderPatchConfigPostStep[];

  /**
   * The ExecStep to run before the patch update. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#preStep
   */
  readonly preStep?: PatchDeploymentSpecForProviderPatchConfigPreStep[];

  /**
   * Post-patch reboot settings. Possible values are: DEFAULT, ALWAYS, NEVER.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#rebootConfig
   */
  readonly rebootConfig?: string;

  /**
   * Windows update settings. Use this setting to override the default Windows patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#windowsUpdate
   */
  readonly windowsUpdate?: PatchDeploymentSpecForProviderPatchConfigWindowsUpdate[];

  /**
   * Yum update settings. Use this setting to override the default yum patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#yum
   */
  readonly yum?: PatchDeploymentSpecForProviderPatchConfigYum[];

  /**
   * zypper update settings. Use this setting to override the default zypper patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#zypper
   */
  readonly zypper?: PatchDeploymentSpecForProviderPatchConfigZypper[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfig(obj: PatchDeploymentSpecForProviderPatchConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apt': obj.apt?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigApt(y)),
    'goo': obj.goo?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigGoo(y)),
    'migInstancesAllowed': obj.migInstancesAllowed,
    'postStep': obj.postStep?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPostStep(y)),
    'preStep': obj.preStep?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPreStep(y)),
    'rebootConfig': obj.rebootConfig,
    'windowsUpdate': obj.windowsUpdate?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigWindowsUpdate(y)),
    'yum': obj.yum?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigYum(y)),
    'zypper': obj.zypper?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigZypper(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringSchedule
 */
export interface PatchDeploymentSpecForProviderRecurringSchedule {
  /**
   * The end time at which a recurring patch deployment schedule is no longer active. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   *
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#endTime
   */
  readonly endTime?: string;

  /**
   * Schedule with monthly executions. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#monthly
   */
  readonly monthly?: PatchDeploymentSpecForProviderRecurringScheduleMonthly[];

  /**
   * The time that the recurring schedule becomes effective. Defaults to createTime of the patch deployment. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   *
   * @default createTime of the patch deployment. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#startTime
   */
  readonly startTime?: string;

  /**
   * Time of the day to run a recurring deployment. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#timeOfDay
   */
  readonly timeOfDay?: PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay[];

  /**
   * Defines the time zone that timeOfDay is relative to. The rules for daylight saving time are determined by the chosen time zone. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#timeZone
   */
  readonly timeZone?: PatchDeploymentSpecForProviderRecurringScheduleTimeZone[];

  /**
   * Schedule with weekly executions. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#weekly
   */
  readonly weekly?: PatchDeploymentSpecForProviderRecurringScheduleWeekly[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringSchedule(obj: PatchDeploymentSpecForProviderRecurringSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'monthly': obj.monthly?.map(y => toJson_PatchDeploymentSpecForProviderRecurringScheduleMonthly(y)),
    'startTime': obj.startTime,
    'timeOfDay': obj.timeOfDay?.map(y => toJson_PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay(y)),
    'timeZone': obj.timeZone?.map(y => toJson_PatchDeploymentSpecForProviderRecurringScheduleTimeZone(y)),
    'weekly': obj.weekly?.map(y => toJson_PatchDeploymentSpecForProviderRecurringScheduleWeekly(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRollout
 */
export interface PatchDeploymentSpecForProviderRollout {
  /**
   * The maximum number (or percentage) of VMs per zone to disrupt at any given moment. The number of VMs calculated from multiplying the percentage by the total number of VMs in a zone is rounded up. During patching, a VM is considered disrupted from the time the agent is notified to begin until patching has completed. This disruption time includes the time to complete reboot and any post-patch steps. A VM contributes to the disruption budget if its patching operation fails either when applying the patches, running pre or post patch steps, or if it fails to respond with a success notification before timing out. VMs that are not running or do not have an active agent do not count toward this disruption budget. For zone-by-zone rollouts, if the disruption budget in a zone is exceeded, the patch job stops, because continuing to the next zone requires completion of the patch process in the previous zone. For example, if the disruption budget has a fixed value of 10, and 8 VMs fail to patch in the current zone, the patch job continues to patch 2 VMs at a time until the zone is completed. When that zone is completed successfully, patching begins with 10 VMs at a time in the next zone. If 10 VMs in the next zone fail to patch, the patch job stops. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRollout#disruptionBudget
   */
  readonly disruptionBudget?: PatchDeploymentSpecForProviderRolloutDisruptionBudget[];

  /**
   * Mode of the patch rollout. Possible values are: ZONE_BY_ZONE, CONCURRENT_ZONES.
   *
   * @schema PatchDeploymentSpecForProviderRollout#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRollout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRollout(obj: PatchDeploymentSpecForProviderRollout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disruptionBudget': obj.disruptionBudget?.map(y => toJson_PatchDeploymentSpecForProviderRolloutDisruptionBudget(y)),
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderInstanceFilter
 */
export interface PatchDeploymentSpecInitProviderInstanceFilter {
  /**
   * Target all VM instances in the project. If true, no other criteria is permitted.
   *
   * @schema PatchDeploymentSpecInitProviderInstanceFilter#all
   */
  readonly all?: boolean;

  /**
   * Targets VM instances matching ANY of these GroupLabels. This allows targeting of disparate groups of VM instances. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderInstanceFilter#groupLabels
   */
  readonly groupLabels?: PatchDeploymentSpecInitProviderInstanceFilterGroupLabels[];

  /**
   * Targets VMs whose name starts with one of these prefixes. Similar to labels, this is another way to group VMs when targeting configs, for example prefix="prod-".
   *
   * @schema PatchDeploymentSpecInitProviderInstanceFilter#instanceNamePrefixes
   */
  readonly instanceNamePrefixes?: string[];

  /**
   * Targets any of the VM instances specified. Instances are specified by their URI in the form zones/{{zone}}/instances/{{instance_name}}, projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}, or https://www.googleapis.com/compute/v1/projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}
   *
   * @schema PatchDeploymentSpecInitProviderInstanceFilter#instances
   */
  readonly instances?: string[];

  /**
   * Targets VM instances in ANY of these zones. Leave empty to target VM instances in any zone.
   *
   * @schema PatchDeploymentSpecInitProviderInstanceFilter#zones
   */
  readonly zones?: string[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderInstanceFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderInstanceFilter(obj: PatchDeploymentSpecInitProviderInstanceFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all,
    'groupLabels': obj.groupLabels?.map(y => toJson_PatchDeploymentSpecInitProviderInstanceFilterGroupLabels(y)),
    'instanceNamePrefixes': obj.instanceNamePrefixes?.map(y => y),
    'instances': obj.instances?.map(y => y),
    'zones': obj.zones?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderOneTimeSchedule
 */
export interface PatchDeploymentSpecInitProviderOneTimeSchedule {
  /**
   * The desired patch job execution time. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   *
   * @schema PatchDeploymentSpecInitProviderOneTimeSchedule#executeTime
   */
  readonly executeTime?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderOneTimeSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderOneTimeSchedule(obj: PatchDeploymentSpecInitProviderOneTimeSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executeTime': obj.executeTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfig
 */
export interface PatchDeploymentSpecInitProviderPatchConfig {
  /**
   * Apt update settings. Use this setting to override the default apt patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfig#apt
   */
  readonly apt?: PatchDeploymentSpecInitProviderPatchConfigApt[];

  /**
   * goo update settings. Use this setting to override the default goo patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfig#goo
   */
  readonly goo?: PatchDeploymentSpecInitProviderPatchConfigGoo[];

  /**
   * Allows the patch job to run on Managed instance groups (MIGs).
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfig#migInstancesAllowed
   */
  readonly migInstancesAllowed?: boolean;

  /**
   * The ExecStep to run after the patch update. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfig#postStep
   */
  readonly postStep?: PatchDeploymentSpecInitProviderPatchConfigPostStep[];

  /**
   * The ExecStep to run before the patch update. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfig#preStep
   */
  readonly preStep?: PatchDeploymentSpecInitProviderPatchConfigPreStep[];

  /**
   * Post-patch reboot settings. Possible values are: DEFAULT, ALWAYS, NEVER.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfig#rebootConfig
   */
  readonly rebootConfig?: string;

  /**
   * Windows update settings. Use this setting to override the default Windows patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfig#windowsUpdate
   */
  readonly windowsUpdate?: PatchDeploymentSpecInitProviderPatchConfigWindowsUpdate[];

  /**
   * Yum update settings. Use this setting to override the default yum patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfig#yum
   */
  readonly yum?: PatchDeploymentSpecInitProviderPatchConfigYum[];

  /**
   * zypper update settings. Use this setting to override the default zypper patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfig#zypper
   */
  readonly zypper?: PatchDeploymentSpecInitProviderPatchConfigZypper[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfig(obj: PatchDeploymentSpecInitProviderPatchConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apt': obj.apt?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigApt(y)),
    'goo': obj.goo?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigGoo(y)),
    'migInstancesAllowed': obj.migInstancesAllowed,
    'postStep': obj.postStep?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigPostStep(y)),
    'preStep': obj.preStep?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigPreStep(y)),
    'rebootConfig': obj.rebootConfig,
    'windowsUpdate': obj.windowsUpdate?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigWindowsUpdate(y)),
    'yum': obj.yum?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigYum(y)),
    'zypper': obj.zypper?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigZypper(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderRecurringSchedule
 */
export interface PatchDeploymentSpecInitProviderRecurringSchedule {
  /**
   * The end time at which a recurring patch deployment schedule is no longer active. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   *
   * @schema PatchDeploymentSpecInitProviderRecurringSchedule#endTime
   */
  readonly endTime?: string;

  /**
   * Schedule with monthly executions. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringSchedule#monthly
   */
  readonly monthly?: PatchDeploymentSpecInitProviderRecurringScheduleMonthly[];

  /**
   * The time that the recurring schedule becomes effective. Defaults to createTime of the patch deployment. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   *
   * @default createTime of the patch deployment. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   * @schema PatchDeploymentSpecInitProviderRecurringSchedule#startTime
   */
  readonly startTime?: string;

  /**
   * Time of the day to run a recurring deployment. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringSchedule#timeOfDay
   */
  readonly timeOfDay?: PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay[];

  /**
   * Defines the time zone that timeOfDay is relative to. The rules for daylight saving time are determined by the chosen time zone. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringSchedule#timeZone
   */
  readonly timeZone?: PatchDeploymentSpecInitProviderRecurringScheduleTimeZone[];

  /**
   * Schedule with weekly executions. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringSchedule#weekly
   */
  readonly weekly?: PatchDeploymentSpecInitProviderRecurringScheduleWeekly[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderRecurringSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderRecurringSchedule(obj: PatchDeploymentSpecInitProviderRecurringSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'monthly': obj.monthly?.map(y => toJson_PatchDeploymentSpecInitProviderRecurringScheduleMonthly(y)),
    'startTime': obj.startTime,
    'timeOfDay': obj.timeOfDay?.map(y => toJson_PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay(y)),
    'timeZone': obj.timeZone?.map(y => toJson_PatchDeploymentSpecInitProviderRecurringScheduleTimeZone(y)),
    'weekly': obj.weekly?.map(y => toJson_PatchDeploymentSpecInitProviderRecurringScheduleWeekly(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderRollout
 */
export interface PatchDeploymentSpecInitProviderRollout {
  /**
   * The maximum number (or percentage) of VMs per zone to disrupt at any given moment. The number of VMs calculated from multiplying the percentage by the total number of VMs in a zone is rounded up. During patching, a VM is considered disrupted from the time the agent is notified to begin until patching has completed. This disruption time includes the time to complete reboot and any post-patch steps. A VM contributes to the disruption budget if its patching operation fails either when applying the patches, running pre or post patch steps, or if it fails to respond with a success notification before timing out. VMs that are not running or do not have an active agent do not count toward this disruption budget. For zone-by-zone rollouts, if the disruption budget in a zone is exceeded, the patch job stops, because continuing to the next zone requires completion of the patch process in the previous zone. For example, if the disruption budget has a fixed value of 10, and 8 VMs fail to patch in the current zone, the patch job continues to patch 2 VMs at a time until the zone is completed. When that zone is completed successfully, patching begins with 10 VMs at a time in the next zone. If 10 VMs in the next zone fail to patch, the patch job stops. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderRollout#disruptionBudget
   */
  readonly disruptionBudget?: PatchDeploymentSpecInitProviderRolloutDisruptionBudget[];

  /**
   * Mode of the patch rollout. Possible values are: ZONE_BY_ZONE, CONCURRENT_ZONES.
   *
   * @schema PatchDeploymentSpecInitProviderRollout#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderRollout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderRollout(obj: PatchDeploymentSpecInitProviderRollout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disruptionBudget': obj.disruptionBudget?.map(y => toJson_PatchDeploymentSpecInitProviderRolloutDisruptionBudget(y)),
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PatchDeploymentSpecProviderConfigRefPolicy
 */
export interface PatchDeploymentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchDeploymentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PatchDeploymentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchDeploymentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PatchDeploymentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchDeploymentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecProviderConfigRefPolicy(obj: PatchDeploymentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRef
 */
export interface PatchDeploymentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PatchDeploymentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecPublishConnectionDetailsToConfigRef(obj: PatchDeploymentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsToMetadata
 */
export interface PatchDeploymentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecPublishConnectionDetailsToMetadata(obj: PatchDeploymentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderInstanceFilterGroupLabels
 */
export interface PatchDeploymentSpecForProviderInstanceFilterGroupLabels {
  /**
   * Compute Engine instance labels that must be present for a VM instance to be targeted by this filter
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilterGroupLabels#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderInstanceFilterGroupLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderInstanceFilterGroupLabels(obj: PatchDeploymentSpecForProviderInstanceFilterGroupLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigApt
 */
export interface PatchDeploymentSpecForProviderPatchConfigApt {
  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigApt#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of packages to be updated. These are the only packages that will be updated. If these packages are not installed, they will be ignored. This field cannot be specified with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigApt#exclusivePackages
   */
  readonly exclusivePackages?: string[];

  /**
   * By changing the type to DIST, the patching is performed using apt-get dist-upgrade instead. Possible values are: DIST, UPGRADE.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigApt#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigApt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigApt(obj: PatchDeploymentSpecForProviderPatchConfigApt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludes': obj.excludes?.map(y => y),
    'exclusivePackages': obj.exclusivePackages?.map(y => y),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigGoo
 */
export interface PatchDeploymentSpecForProviderPatchConfigGoo {
  /**
   * goo update settings. Use this setting to override the default goo patch rules.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigGoo#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigGoo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigGoo(obj: PatchDeploymentSpecForProviderPatchConfigGoo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPostStep
 */
export interface PatchDeploymentSpecForProviderPatchConfigPostStep {
  /**
   * The ExecStepConfig for all Linux VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStep#linuxExecStepConfig
   */
  readonly linuxExecStepConfig?: PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig[];

  /**
   * The ExecStepConfig for all Windows VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStep#windowsExecStepConfig
   */
  readonly windowsExecStepConfig?: PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPostStep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPostStep(obj: PatchDeploymentSpecForProviderPatchConfigPostStep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linuxExecStepConfig': obj.linuxExecStepConfig?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig(y)),
    'windowsExecStepConfig': obj.windowsExecStepConfig?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPreStep
 */
export interface PatchDeploymentSpecForProviderPatchConfigPreStep {
  /**
   * The ExecStepConfig for all Linux VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStep#linuxExecStepConfig
   */
  readonly linuxExecStepConfig?: PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig[];

  /**
   * The ExecStepConfig for all Windows VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStep#windowsExecStepConfig
   */
  readonly windowsExecStepConfig?: PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPreStep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPreStep(obj: PatchDeploymentSpecForProviderPatchConfigPreStep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linuxExecStepConfig': obj.linuxExecStepConfig?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig(y)),
    'windowsExecStepConfig': obj.windowsExecStepConfig?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigWindowsUpdate
 */
export interface PatchDeploymentSpecForProviderPatchConfigWindowsUpdate {
  /**
   * Only apply updates of these windows update classifications. If empty, all updates are applied. Each value may be one of: CRITICAL, SECURITY, DEFINITION, DRIVER, FEATURE_PACK, SERVICE_PACK, TOOL, UPDATE_ROLLUP, UPDATE.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigWindowsUpdate#classifications
   */
  readonly classifications?: string[];

  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigWindowsUpdate#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command. This field must not be used with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigWindowsUpdate#exclusivePatches
   */
  readonly exclusivePatches?: string[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigWindowsUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigWindowsUpdate(obj: PatchDeploymentSpecForProviderPatchConfigWindowsUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classifications': obj.classifications?.map(y => y),
    'excludes': obj.excludes?.map(y => y),
    'exclusivePatches': obj.exclusivePatches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigYum
 */
export interface PatchDeploymentSpecForProviderPatchConfigYum {
  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigYum#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of packages to be updated. These are the only packages that will be updated. If these packages are not installed, they will be ignored. This field cannot be specified with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigYum#exclusivePackages
   */
  readonly exclusivePackages?: string[];

  /**
   * Will cause patch to run yum update-minimal instead.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigYum#minimal
   */
  readonly minimal?: boolean;

  /**
   * Adds the --security flag to yum update. Not supported on all platforms.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigYum#security
   */
  readonly security?: boolean;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigYum' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigYum(obj: PatchDeploymentSpecForProviderPatchConfigYum | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludes': obj.excludes?.map(y => y),
    'exclusivePackages': obj.exclusivePackages?.map(y => y),
    'minimal': obj.minimal,
    'security': obj.security,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigZypper
 */
export interface PatchDeploymentSpecForProviderPatchConfigZypper {
  /**
   * Install only patches with these categories. Common categories include security, recommended, and feature.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#categories
   */
  readonly categories?: string[];

  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command. This field must not be used with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#exclusivePatches
   */
  readonly exclusivePatches?: string[];

  /**
   * Install only patches with these severities. Common severities include critical, important, moderate, and low.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#severities
   */
  readonly severities?: string[];

  /**
   * Adds the --with-optional flag to zypper patch.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#withOptional
   */
  readonly withOptional?: boolean;

  /**
   * Adds the --with-update flag, to zypper patch.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#withUpdate
   */
  readonly withUpdate?: boolean;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigZypper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigZypper(obj: PatchDeploymentSpecForProviderPatchConfigZypper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categories': obj.categories?.map(y => y),
    'excludes': obj.excludes?.map(y => y),
    'exclusivePatches': obj.exclusivePatches?.map(y => y),
    'severities': obj.severities?.map(y => y),
    'withOptional': obj.withOptional,
    'withUpdate': obj.withUpdate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthly
 */
export interface PatchDeploymentSpecForProviderRecurringScheduleMonthly {
  /**
   * One day of the month. 1-31 indicates the 1st to the 31st day. -1 indicates the last day of the month. Months without the target day will be skipped. For example, a schedule to run "every month on the 31st" will not run in February, April, June, etc.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthly#monthDay
   */
  readonly monthDay?: number;

  /**
   * Week day in a month. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthly#weekDayOfMonth
   */
  readonly weekDayOfMonth?: PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringScheduleMonthly' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringScheduleMonthly(obj: PatchDeploymentSpecForProviderRecurringScheduleMonthly | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monthDay': obj.monthDay,
    'weekDayOfMonth': obj.weekDayOfMonth?.map(y => toJson_PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay
 */
export interface PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay(obj: PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeZone
 */
export interface PatchDeploymentSpecForProviderRecurringScheduleTimeZone {
  /**
   * IANA Time Zone Database time zone, e.g. "America/New_York".
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeZone#id
   */
  readonly id?: string;

  /**
   * IANA Time Zone Database version number, e.g. "2019a".
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeZone#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringScheduleTimeZone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringScheduleTimeZone(obj: PatchDeploymentSpecForProviderRecurringScheduleTimeZone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringScheduleWeekly
 */
export interface PatchDeploymentSpecForProviderRecurringScheduleWeekly {
  /**
   * IANA Time Zone Database time zone, e.g. "America/New_York". Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleWeekly#dayOfWeek
   */
  readonly dayOfWeek?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringScheduleWeekly' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringScheduleWeekly(obj: PatchDeploymentSpecForProviderRecurringScheduleWeekly | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dayOfWeek': obj.dayOfWeek,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRolloutDisruptionBudget
 */
export interface PatchDeploymentSpecForProviderRolloutDisruptionBudget {
  /**
   * Specifies a fixed value.
   *
   * @schema PatchDeploymentSpecForProviderRolloutDisruptionBudget#fixed
   */
  readonly fixed?: number;

  /**
   * Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
   *
   * @schema PatchDeploymentSpecForProviderRolloutDisruptionBudget#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRolloutDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRolloutDisruptionBudget(obj: PatchDeploymentSpecForProviderRolloutDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixed': obj.fixed,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderInstanceFilterGroupLabels
 */
export interface PatchDeploymentSpecInitProviderInstanceFilterGroupLabels {
  /**
   * Compute Engine instance labels that must be present for a VM instance to be targeted by this filter
   *
   * @schema PatchDeploymentSpecInitProviderInstanceFilterGroupLabels#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderInstanceFilterGroupLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderInstanceFilterGroupLabels(obj: PatchDeploymentSpecInitProviderInstanceFilterGroupLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigApt
 */
export interface PatchDeploymentSpecInitProviderPatchConfigApt {
  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigApt#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of packages to be updated. These are the only packages that will be updated. If these packages are not installed, they will be ignored. This field cannot be specified with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigApt#exclusivePackages
   */
  readonly exclusivePackages?: string[];

  /**
   * By changing the type to DIST, the patching is performed using apt-get dist-upgrade instead. Possible values are: DIST, UPGRADE.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigApt#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigApt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigApt(obj: PatchDeploymentSpecInitProviderPatchConfigApt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludes': obj.excludes?.map(y => y),
    'exclusivePackages': obj.exclusivePackages?.map(y => y),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigGoo
 */
export interface PatchDeploymentSpecInitProviderPatchConfigGoo {
  /**
   * goo update settings. Use this setting to override the default goo patch rules.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigGoo#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigGoo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigGoo(obj: PatchDeploymentSpecInitProviderPatchConfigGoo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigPostStep
 */
export interface PatchDeploymentSpecInitProviderPatchConfigPostStep {
  /**
   * The ExecStepConfig for all Linux VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStep#linuxExecStepConfig
   */
  readonly linuxExecStepConfig?: PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig[];

  /**
   * The ExecStepConfig for all Windows VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStep#windowsExecStepConfig
   */
  readonly windowsExecStepConfig?: PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigPostStep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigPostStep(obj: PatchDeploymentSpecInitProviderPatchConfigPostStep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linuxExecStepConfig': obj.linuxExecStepConfig?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig(y)),
    'windowsExecStepConfig': obj.windowsExecStepConfig?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigPreStep
 */
export interface PatchDeploymentSpecInitProviderPatchConfigPreStep {
  /**
   * The ExecStepConfig for all Linux VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStep#linuxExecStepConfig
   */
  readonly linuxExecStepConfig?: PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig[];

  /**
   * The ExecStepConfig for all Windows VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStep#windowsExecStepConfig
   */
  readonly windowsExecStepConfig?: PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigPreStep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigPreStep(obj: PatchDeploymentSpecInitProviderPatchConfigPreStep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linuxExecStepConfig': obj.linuxExecStepConfig?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig(y)),
    'windowsExecStepConfig': obj.windowsExecStepConfig?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigWindowsUpdate
 */
export interface PatchDeploymentSpecInitProviderPatchConfigWindowsUpdate {
  /**
   * Only apply updates of these windows update classifications. If empty, all updates are applied. Each value may be one of: CRITICAL, SECURITY, DEFINITION, DRIVER, FEATURE_PACK, SERVICE_PACK, TOOL, UPDATE_ROLLUP, UPDATE.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigWindowsUpdate#classifications
   */
  readonly classifications?: string[];

  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigWindowsUpdate#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command. This field must not be used with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigWindowsUpdate#exclusivePatches
   */
  readonly exclusivePatches?: string[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigWindowsUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigWindowsUpdate(obj: PatchDeploymentSpecInitProviderPatchConfigWindowsUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classifications': obj.classifications?.map(y => y),
    'excludes': obj.excludes?.map(y => y),
    'exclusivePatches': obj.exclusivePatches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigYum
 */
export interface PatchDeploymentSpecInitProviderPatchConfigYum {
  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigYum#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of packages to be updated. These are the only packages that will be updated. If these packages are not installed, they will be ignored. This field cannot be specified with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigYum#exclusivePackages
   */
  readonly exclusivePackages?: string[];

  /**
   * Will cause patch to run yum update-minimal instead.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigYum#minimal
   */
  readonly minimal?: boolean;

  /**
   * Adds the --security flag to yum update. Not supported on all platforms.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigYum#security
   */
  readonly security?: boolean;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigYum' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigYum(obj: PatchDeploymentSpecInitProviderPatchConfigYum | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludes': obj.excludes?.map(y => y),
    'exclusivePackages': obj.exclusivePackages?.map(y => y),
    'minimal': obj.minimal,
    'security': obj.security,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigZypper
 */
export interface PatchDeploymentSpecInitProviderPatchConfigZypper {
  /**
   * Install only patches with these categories. Common categories include security, recommended, and feature.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigZypper#categories
   */
  readonly categories?: string[];

  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigZypper#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command. This field must not be used with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigZypper#exclusivePatches
   */
  readonly exclusivePatches?: string[];

  /**
   * Install only patches with these severities. Common severities include critical, important, moderate, and low.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigZypper#severities
   */
  readonly severities?: string[];

  /**
   * Adds the --with-optional flag to zypper patch.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigZypper#withOptional
   */
  readonly withOptional?: boolean;

  /**
   * Adds the --with-update flag, to zypper patch.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigZypper#withUpdate
   */
  readonly withUpdate?: boolean;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigZypper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigZypper(obj: PatchDeploymentSpecInitProviderPatchConfigZypper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categories': obj.categories?.map(y => y),
    'excludes': obj.excludes?.map(y => y),
    'exclusivePatches': obj.exclusivePatches?.map(y => y),
    'severities': obj.severities?.map(y => y),
    'withOptional': obj.withOptional,
    'withUpdate': obj.withUpdate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderRecurringScheduleMonthly
 */
export interface PatchDeploymentSpecInitProviderRecurringScheduleMonthly {
  /**
   * One day of the month. 1-31 indicates the 1st to the 31st day. -1 indicates the last day of the month. Months without the target day will be skipped. For example, a schedule to run "every month on the 31st" will not run in February, April, June, etc.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleMonthly#monthDay
   */
  readonly monthDay?: number;

  /**
   * Week day in a month. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleMonthly#weekDayOfMonth
   */
  readonly weekDayOfMonth?: PatchDeploymentSpecInitProviderRecurringScheduleMonthlyWeekDayOfMonth[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderRecurringScheduleMonthly' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderRecurringScheduleMonthly(obj: PatchDeploymentSpecInitProviderRecurringScheduleMonthly | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monthDay': obj.monthDay,
    'weekDayOfMonth': obj.weekDayOfMonth?.map(y => toJson_PatchDeploymentSpecInitProviderRecurringScheduleMonthlyWeekDayOfMonth(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay
 */
export interface PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay(obj: PatchDeploymentSpecInitProviderRecurringScheduleTimeOfDay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderRecurringScheduleTimeZone
 */
export interface PatchDeploymentSpecInitProviderRecurringScheduleTimeZone {
  /**
   * IANA Time Zone Database time zone, e.g. "America/New_York".
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleTimeZone#id
   */
  readonly id?: string;

  /**
   * IANA Time Zone Database version number, e.g. "2019a".
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleTimeZone#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderRecurringScheduleTimeZone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderRecurringScheduleTimeZone(obj: PatchDeploymentSpecInitProviderRecurringScheduleTimeZone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderRecurringScheduleWeekly
 */
export interface PatchDeploymentSpecInitProviderRecurringScheduleWeekly {
  /**
   * IANA Time Zone Database time zone, e.g. "America/New_York". Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleWeekly#dayOfWeek
   */
  readonly dayOfWeek?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderRecurringScheduleWeekly' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderRecurringScheduleWeekly(obj: PatchDeploymentSpecInitProviderRecurringScheduleWeekly | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dayOfWeek': obj.dayOfWeek,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderRolloutDisruptionBudget
 */
export interface PatchDeploymentSpecInitProviderRolloutDisruptionBudget {
  /**
   * Specifies a fixed value.
   *
   * @schema PatchDeploymentSpecInitProviderRolloutDisruptionBudget#fixed
   */
  readonly fixed?: number;

  /**
   * Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
   *
   * @schema PatchDeploymentSpecInitProviderRolloutDisruptionBudget#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderRolloutDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderRolloutDisruptionBudget(obj: PatchDeploymentSpecInitProviderRolloutDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixed': obj.fixed,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchDeploymentSpecProviderConfigRefPolicyResolution
 */
export enum PatchDeploymentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchDeploymentSpecProviderConfigRefPolicyResolve
 */
export enum PatchDeploymentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj: PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig
 */
export interface PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig(obj: PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig
 */
export interface PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig(obj: PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig
 */
export interface PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig(obj: PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig
 */
export interface PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig(obj: PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth
 */
export interface PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth {
  /**
   * IANA Time Zone Database time zone, e.g. "America/New_York". Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth#dayOfWeek
   */
  readonly dayOfWeek?: string;

  /**
   * Week number in a month. 1-4 indicates the 1st to 4th week of the month. -1 indicates the last week of the month.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth#weekOrdinal
   */
  readonly weekOrdinal?: number;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth(obj: PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dayOfWeek': obj.dayOfWeek,
    'weekOrdinal': obj.weekOrdinal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig
 */
export interface PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig(obj: PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig
 */
export interface PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig(obj: PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig
 */
export interface PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig(obj: PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig
 */
export interface PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig(obj: PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderRecurringScheduleMonthlyWeekDayOfMonth
 */
export interface PatchDeploymentSpecInitProviderRecurringScheduleMonthlyWeekDayOfMonth {
  /**
   * IANA Time Zone Database time zone, e.g. "America/New_York". Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleMonthlyWeekDayOfMonth#dayOfWeek
   */
  readonly dayOfWeek?: string;

  /**
   * Week number in a month. 1-4 indicates the 1st to 4th week of the month. -1 indicates the last week of the month.
   *
   * @schema PatchDeploymentSpecInitProviderRecurringScheduleMonthlyWeekDayOfMonth#weekOrdinal
   */
  readonly weekOrdinal?: number;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderRecurringScheduleMonthlyWeekDayOfMonth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderRecurringScheduleMonthlyWeekDayOfMonth(obj: PatchDeploymentSpecInitProviderRecurringScheduleMonthlyWeekDayOfMonth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dayOfWeek': obj.dayOfWeek,
    'weekOrdinal': obj.weekOrdinal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber?: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject(obj: PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber?: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject(obj: PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber?: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject(obj: PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber?: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject(obj: PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber?: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject(obj: PatchDeploymentSpecInitProviderPatchConfigPostStepLinuxExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber?: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject(obj: PatchDeploymentSpecInitProviderPatchConfigPostStepWindowsExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber?: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject(obj: PatchDeploymentSpecInitProviderPatchConfigPreStepLinuxExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject#bucket
   */
  readonly bucket?: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber?: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject#object
   */
  readonly object?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject(obj: PatchDeploymentSpecInitProviderPatchConfigPreStepWindowsExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

