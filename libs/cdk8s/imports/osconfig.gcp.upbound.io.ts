// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * OsPolicyAssignment is the Schema for the OsPolicyAssignments API. Represents an OSPolicyAssignment resource.
 *
 * @schema OsPolicyAssignment
 */
export class OsPolicyAssignment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OsPolicyAssignment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'osconfig.gcp.upbound.io/v1beta1',
    kind: 'OsPolicyAssignment',
  }

  /**
   * Renders a Kubernetes manifest for "OsPolicyAssignment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OsPolicyAssignmentProps): any {
    return {
      ...OsPolicyAssignment.GVK,
      ...toJson_OsPolicyAssignmentProps(props),
    };
  }

  /**
   * Defines a "OsPolicyAssignment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OsPolicyAssignmentProps) {
    super(scope, id, {
      ...OsPolicyAssignment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OsPolicyAssignment.GVK,
      ...toJson_OsPolicyAssignmentProps(resolved),
    };
  }
}

/**
 * OsPolicyAssignment is the Schema for the OsPolicyAssignments API. Represents an OSPolicyAssignment resource.
 *
 * @schema OsPolicyAssignment
 */
export interface OsPolicyAssignmentProps {
  /**
   * @schema OsPolicyAssignment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OsPolicyAssignmentSpec defines the desired state of OsPolicyAssignment
   *
   * @schema OsPolicyAssignment#spec
   */
  readonly spec: OsPolicyAssignmentSpec;

}

/**
 * Converts an object of type 'OsPolicyAssignmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentProps(obj: OsPolicyAssignmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OsPolicyAssignmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OsPolicyAssignmentSpec defines the desired state of OsPolicyAssignment
 *
 * @schema OsPolicyAssignmentSpec
 */
export interface OsPolicyAssignmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OsPolicyAssignmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: OsPolicyAssignmentSpecDeletionPolicy;

  /**
   * @schema OsPolicyAssignmentSpec#forProvider
   */
  readonly forProvider: OsPolicyAssignmentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OsPolicyAssignmentSpec#managementPolicy
   */
  readonly managementPolicy?: OsPolicyAssignmentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OsPolicyAssignmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: OsPolicyAssignmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema OsPolicyAssignmentSpec#providerRef
   */
  readonly providerRef?: OsPolicyAssignmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OsPolicyAssignmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OsPolicyAssignmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OsPolicyAssignmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OsPolicyAssignmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpec(obj: OsPolicyAssignmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OsPolicyAssignmentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_OsPolicyAssignmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_OsPolicyAssignmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_OsPolicyAssignmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OsPolicyAssignmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OsPolicyAssignmentSpecDeletionPolicy
 */
export enum OsPolicyAssignmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OsPolicyAssignmentSpecForProvider
 */
export interface OsPolicyAssignmentSpecForProvider {
  /**
   * Policy description. Length of the description is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Required. Filter to select VMs.
   *
   * @schema OsPolicyAssignmentSpecForProvider#instanceFilter
   */
  readonly instanceFilter?: OsPolicyAssignmentSpecForProviderInstanceFilter[];

  /**
   * The location for the resource
   *
   * @schema OsPolicyAssignmentSpecForProvider#location
   */
  readonly location: string;

  /**
   * Required. List of OS policies to be applied to the VMs.
   *
   * @schema OsPolicyAssignmentSpecForProvider#osPolicies
   */
  readonly osPolicies?: OsPolicyAssignmentSpecForProviderOsPolicies[];

  /**
   * The project for the resource
   *
   * @schema OsPolicyAssignmentSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Required. Rollout to deploy the OS policy assignment. A rollout is triggered in the following situations: 1) OSPolicyAssignment is created. 2) OSPolicyAssignment is updated and the update contains changes to one of the following fields: - instance_filter - os_policies 3) OSPolicyAssignment is deleted.
   *
   * @schema OsPolicyAssignmentSpecForProvider#rollout
   */
  readonly rollout?: OsPolicyAssignmentSpecForProviderRollout[];

  /**
   * Set to true to skip awaiting rollout during resource creation and update.
   *
   * @schema OsPolicyAssignmentSpecForProvider#skipAwaitRollout
   */
  readonly skipAwaitRollout?: boolean;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProvider(obj: OsPolicyAssignmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceFilter': obj.instanceFilter?.map(y => toJson_OsPolicyAssignmentSpecForProviderInstanceFilter(y)),
    'location': obj.location,
    'osPolicies': obj.osPolicies?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPolicies(y)),
    'project': obj.project,
    'rollout': obj.rollout?.map(y => toJson_OsPolicyAssignmentSpecForProviderRollout(y)),
    'skipAwaitRollout': obj.skipAwaitRollout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OsPolicyAssignmentSpecManagementPolicy
 */
export enum OsPolicyAssignmentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OsPolicyAssignmentSpecProviderConfigRef
 */
export interface OsPolicyAssignmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OsPolicyAssignmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OsPolicyAssignmentSpecProviderConfigRef#policy
   */
  readonly policy?: OsPolicyAssignmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecProviderConfigRef(obj: OsPolicyAssignmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OsPolicyAssignmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema OsPolicyAssignmentSpecProviderRef
 */
export interface OsPolicyAssignmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema OsPolicyAssignmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OsPolicyAssignmentSpecProviderRef#policy
   */
  readonly policy?: OsPolicyAssignmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecProviderRef(obj: OsPolicyAssignmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OsPolicyAssignmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsTo
 */
export interface OsPolicyAssignmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecPublishConnectionDetailsTo(obj: OsPolicyAssignmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OsPolicyAssignmentSpecWriteConnectionSecretToRef
 */
export interface OsPolicyAssignmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OsPolicyAssignmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OsPolicyAssignmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecWriteConnectionSecretToRef(obj: OsPolicyAssignmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderInstanceFilter
 */
export interface OsPolicyAssignmentSpecForProviderInstanceFilter {
  /**
   * Target all VMs in the project. If true, no other criteria is permitted.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilter#all
   */
  readonly all?: boolean;

  /**
   * List of label sets used for VM exclusion. If the list has more than one label set, the VM is excluded if any of the label sets are applicable for the VM.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilter#exclusionLabels
   */
  readonly exclusionLabels?: OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels[];

  /**
   * List of label sets used for VM inclusion. If the list has more than one LabelSet, the VM is included if any of the label sets are applicable for the VM.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilter#inclusionLabels
   */
  readonly inclusionLabels?: OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels[];

  /**
   * List of inventories to select VMs. A VM is selected if its inventory data matches at least one of the following inventories.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilter#inventories
   */
  readonly inventories?: OsPolicyAssignmentSpecForProviderInstanceFilterInventories[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderInstanceFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderInstanceFilter(obj: OsPolicyAssignmentSpecForProviderInstanceFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all,
    'exclusionLabels': obj.exclusionLabels?.map(y => toJson_OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels(y)),
    'inclusionLabels': obj.inclusionLabels?.map(y => toJson_OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels(y)),
    'inventories': obj.inventories?.map(y => toJson_OsPolicyAssignmentSpecForProviderInstanceFilterInventories(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPolicies
 */
export interface OsPolicyAssignmentSpecForProviderOsPolicies {
  /**
   * This flag determines the OS policy compliance status when none of the resource groups within the policy are applicable for a VM. Set this value to true if the policy needs to be reported as compliant even if the policy has nothing to validate or enforce.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPolicies#allowNoResourceGroupMatch
   */
  readonly allowNoResourceGroupMatch?: boolean;

  /**
   * Policy description. Length of the description is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPolicies#description
   */
  readonly description?: string;

  /**
   * Required. The id of the OS policy with the following restrictions: * Must contain only lowercase letters, numbers, and hyphens. * Must start with a letter. * Must be between 1-63 characters. * Must end with a number or a letter. * Must be unique within the assignment.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPolicies#id
   */
  readonly id: string;

  /**
   * Required. Policy mode Possible values: MODE_UNSPECIFIED, VALIDATION, ENFORCEMENT
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPolicies#mode
   */
  readonly mode: string;

  /**
   * Required. List of resource groups for the policy. For a particular VM, resource groups are evaluated in the order specified and the first resource group that is applicable is selected and the rest are ignored. If none of the resource groups are applicable for a VM, the VM is considered to be non-compliant w.r.t this policy. This behavior can be toggled by the flag allow_no_resource_group_match
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPolicies#resourceGroups
   */
  readonly resourceGroups: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPolicies(obj: OsPolicyAssignmentSpecForProviderOsPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowNoResourceGroupMatch': obj.allowNoResourceGroupMatch,
    'description': obj.description,
    'id': obj.id,
    'mode': obj.mode,
    'resourceGroups': obj.resourceGroups?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderRollout
 */
export interface OsPolicyAssignmentSpecForProviderRollout {
  /**
   * Required. The maximum number (or percentage) of VMs per zone to disrupt at any given moment.
   *
   * @schema OsPolicyAssignmentSpecForProviderRollout#disruptionBudget
   */
  readonly disruptionBudget: OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget[];

  /**
   * Required. This determines the minimum duration of time to wait after the configuration changes are applied through the current rollout. A VM continues to count towards the disruption_budget at least until this duration of time has passed after configuration changes are applied.
   *
   * @schema OsPolicyAssignmentSpecForProviderRollout#minWaitDuration
   */
  readonly minWaitDuration: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderRollout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderRollout(obj: OsPolicyAssignmentSpecForProviderRollout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disruptionBudget': obj.disruptionBudget?.map(y => toJson_OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget(y)),
    'minWaitDuration': obj.minWaitDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OsPolicyAssignmentSpecProviderConfigRefPolicy
 */
export interface OsPolicyAssignmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OsPolicyAssignmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OsPolicyAssignmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OsPolicyAssignmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OsPolicyAssignmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecProviderConfigRefPolicy(obj: OsPolicyAssignmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OsPolicyAssignmentSpecProviderRefPolicy
 */
export interface OsPolicyAssignmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OsPolicyAssignmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: OsPolicyAssignmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OsPolicyAssignmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: OsPolicyAssignmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecProviderRefPolicy(obj: OsPolicyAssignmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef
 */
export interface OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef(obj: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata
 */
export interface OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata(obj: OsPolicyAssignmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels
 */
export interface OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels {
  /**
   * Labels are identified by key/value pairs in this map. A VM should contain all the key/value pairs specified in this map to be selected.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels(obj: OsPolicyAssignmentSpecForProviderInstanceFilterExclusionLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels
 */
export interface OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels {
  /**
   * Labels are identified by key/value pairs in this map. A VM should contain all the key/value pairs specified in this map to be selected.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels(obj: OsPolicyAssignmentSpecForProviderInstanceFilterInclusionLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderInstanceFilterInventories
 */
export interface OsPolicyAssignmentSpecForProviderInstanceFilterInventories {
  /**
   * Required. The OS short name
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilterInventories#osShortName
   */
  readonly osShortName: string;

  /**
   * The OS version Prefix matches are supported if asterisk(*) is provided as the last character. For example, to match all versions with a major version of 7, specify the following value for this field 7.* An empty string matches all OS versions.
   *
   * @schema OsPolicyAssignmentSpecForProviderInstanceFilterInventories#osVersion
   */
  readonly osVersion?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderInstanceFilterInventories' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderInstanceFilterInventories(obj: OsPolicyAssignmentSpecForProviderInstanceFilterInventories | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osShortName': obj.osShortName,
    'osVersion': obj.osVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups {
  /**
   * List of inventory filters for the resource group. The resources in this resource group are applied to the target VM if it satisfies at least one of the following inventory filters. For example, to apply this resource group to VMs running either RHEL or CentOS operating systems, specify 2 items for the list with following values: inventory_filters[0].os_short_name='rhel' and inventory_filters[1].os_short_name='centos' If the list is empty, this resource group will be applied to the target VM unconditionally.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups#inventoryFilters
   */
  readonly inventoryFilters?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters[];

  /**
   * Required. List of resources configured for this resource group. The resources are executed in the exact order specified here.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups#resources
   */
  readonly resources: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inventoryFilters': obj.inventoryFilters?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters(y)),
    'resources': obj.resources?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget
 */
export interface OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget {
  /**
   * Specifies a fixed value.
   *
   * @schema OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget#fixed
   */
  readonly fixed?: number;

  /**
   * Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
   *
   * @schema OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget(obj: OsPolicyAssignmentSpecForProviderRolloutDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixed': obj.fixed,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OsPolicyAssignmentSpecProviderConfigRefPolicyResolution
 */
export enum OsPolicyAssignmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OsPolicyAssignmentSpecProviderConfigRefPolicyResolve
 */
export enum OsPolicyAssignmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OsPolicyAssignmentSpecProviderRefPolicyResolution
 */
export enum OsPolicyAssignmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OsPolicyAssignmentSpecProviderRefPolicyResolve
 */
export enum OsPolicyAssignmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters {
  /**
   * Required. The OS short name
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters#osShortName
   */
  readonly osShortName: string;

  /**
   * The OS version Prefix matches are supported if asterisk(*) is provided as the last character. For example, to match all versions with a major version of 7, specify the following value for this field 7.* An empty string matches all OS versions.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters#osVersion
   */
  readonly osVersion?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsInventoryFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osShortName': obj.osShortName,
    'osVersion': obj.osVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources {
  /**
   * Exec resource
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources#exec
   */
  readonly exec?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec[];

  /**
   * A remote or local file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources#file
   */
  readonly file?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile[];

  /**
   * Required. A one word, unique name for this repository. This is the repo id in the zypper config file and also the display_name if display_name is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources#id
   */
  readonly id: string;

  /**
   * Package resource
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources#pkg
   */
  readonly pkg?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg[];

  /**
   * Package repository resource
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources#repository
   */
  readonly repository?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': obj.exec?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec(y)),
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile(y)),
    'id': obj.id,
    'pkg': obj.pkg?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg(y)),
    'repository': obj.repository?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OsPolicyAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec {
  /**
   * What to run to bring this resource into the desired state. An exit code of 100 indicates "success", any other exit code indicates a failure running enforce.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec#enforce
   */
  readonly enforce?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce[];

  /**
   * Required. What to run to validate this resource is in the desired state. An exit code of 100 indicates "in desired state", and exit code of 101 indicates "not in desired state". Any other exit code indicates a failure running validate.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec#validate
   */
  readonly validate: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enforce': obj.enforce?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce(y)),
    'validate': obj.validate?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile {
  /**
   * A a file with this content. The size of the content is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile#content
   */
  readonly content?: string;

  /**
   * A remote or local file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile#file
   */
  readonly file?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile[];

  /**
   * Required. The absolute path of the file within the VM.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile#path
   */
  readonly path: string;

  /**
   * Required. Desired state of the file. Possible values: OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED, COMPLIANT, NON_COMPLIANT, UNKNOWN, NO_OS_POLICIES_APPLICABLE
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile#state
   */
  readonly state: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile(y)),
    'path': obj.path,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg {
  /**
   * An Apt Repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#apt
   */
  readonly apt?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt[];

  /**
   * A deb package file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#deb
   */
  readonly deb?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb[];

  /**
   * Required. The desired state the agent should maintain for this package. Possible values: DESIRED_STATE_UNSPECIFIED, INSTALLED, REMOVED
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#desiredState
   */
  readonly desiredState: string;

  /**
   * A package managed by GooGet.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#googet
   */
  readonly googet?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget[];

  /**
   * An MSI package.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#msi
   */
  readonly msi?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi[];

  /**
   * An rpm package file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#rpm
   */
  readonly rpm?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm[];

  /**
   * A Yum Repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#yum
   */
  readonly yum?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum[];

  /**
   * A Zypper Repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg#zypper
   */
  readonly zypper?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apt': obj.apt?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt(y)),
    'deb': obj.deb?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb(y)),
    'desiredState': obj.desiredState,
    'googet': obj.googet?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget(y)),
    'msi': obj.msi?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi(y)),
    'rpm': obj.rpm?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm(y)),
    'yum': obj.yum?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum(y)),
    'zypper': obj.zypper?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository {
  /**
   * An Apt Repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository#apt
   */
  readonly apt?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt[];

  /**
   * A Goo Repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository#goo
   */
  readonly goo?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo[];

  /**
   * A Yum Repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository#yum
   */
  readonly yum?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum[];

  /**
   * A Zypper Repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository#zypper
   */
  readonly zypper?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apt': obj.apt?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt(y)),
    'goo': obj.goo?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo(y)),
    'yum': obj.yum?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum(y)),
    'zypper': obj.zypper?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce {
  /**
   * Optional arguments to pass to the source during execution.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce#args
   */
  readonly args?: string[];

  /**
   * A remote or local file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce#file
   */
  readonly file?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile[];

  /**
   * Required. The script interpreter to use. Possible values: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce#interpreter
   */
  readonly interpreter: string;

  /**
   * Only recorded for enforce Exec. Path to an output file (that is created by this Exec) whose content will be recorded in OSPolicyResourceCompliance after a successful run. Absence or failure to read this file will result in this ExecResource being non-compliant. Output file size is limited to 100K bytes.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce#outputFilePath
   */
  readonly outputFilePath?: string;

  /**
   * An inline script. The size of the script is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce#script
   */
  readonly script?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile(y)),
    'interpreter': obj.interpreter,
    'outputFilePath': obj.outputFilePath,
    'script': obj.script,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate {
  /**
   * Optional arguments to pass to the source during execution.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate#args
   */
  readonly args?: string[];

  /**
   * A remote or local file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate#file
   */
  readonly file?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile[];

  /**
   * Required. The script interpreter to use. Possible values: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate#interpreter
   */
  readonly interpreter: string;

  /**
   * Only recorded for enforce Exec. Path to an output file (that is created by this Exec) whose content will be recorded in OSPolicyResourceCompliance after a successful run. Absence or failure to read this file will result in this ExecResource being non-compliant. Output file size is limited to 100K bytes.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate#outputFilePath
   */
  readonly outputFilePath?: string;

  /**
   * An inline script. The size of the script is limited to 1024 characters.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate#script
   */
  readonly script?: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'file': obj.file?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile(y)),
    'interpreter': obj.interpreter,
    'outputFilePath': obj.outputFilePath,
    'script': obj.script,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt {
  /**
   * Required. Package name.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgApt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb {
  /**
   * Whether dependencies should also be installed. - install when false: rpm --upgrade --replacepkgs package.rpm - install when true: yum -y install package.rpm or zypper -y install package.rpm
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb#pullDeps
   */
  readonly pullDeps?: boolean;

  /**
   * Required. An rpm package.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb#source
   */
  readonly source: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDeb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullDeps': obj.pullDeps,
    'source': obj.source?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget {
  /**
   * Required. Package name.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgGooget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi {
  /**
   * Additional properties to use during installation. This should be in the format of Property=Setting. Appended to the defaults of ACTION=INSTALL REBOOT=ReallySuppress.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi#properties
   */
  readonly properties?: string[];

  /**
   * Required. An rpm package.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi#source
   */
  readonly source: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'properties': obj.properties?.map(y => y),
    'source': obj.source?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm {
  /**
   * Whether dependencies should also be installed. - install when false: rpm --upgrade --replacepkgs package.rpm - install when true: yum -y install package.rpm or zypper -y install package.rpm
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm#pullDeps
   */
  readonly pullDeps?: boolean;

  /**
   * Required. An rpm package.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm#source
   */
  readonly source: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullDeps': obj.pullDeps,
    'source': obj.source?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum {
  /**
   * Required. Package name.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgYum | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper {
  /**
   * Required. Package name.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgZypper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt {
  /**
   * Required. Type of archive files in this repository. Possible values: ARCHIVE_TYPE_UNSPECIFIED, DEB, DEB_SRC
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt#archiveType
   */
  readonly archiveType: string;

  /**
   * Required. List of components for this repository. Must contain at least one item.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt#components
   */
  readonly components: string[];

  /**
   * Required. Distribution of this repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt#distribution
   */
  readonly distribution: string;

  /**
   * URI of the key file for this repository. The agent maintains a keyring at /etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt#gpgKey
   */
  readonly gpgKey?: string;

  /**
   * Required. URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryApt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'archiveType': obj.archiveType,
    'components': obj.components?.map(y => y),
    'distribution': obj.distribution,
    'gpgKey': obj.gpgKey,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo {
  /**
   * Required. Package name.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo#name
   */
  readonly name: string;

  /**
   * Required. The url of the repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryGoo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum {
  /**
   * Required. The location of the repository directory.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum#baseUrl
   */
  readonly baseUrl: string;

  /**
   * The display name of the repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum#displayName
   */
  readonly displayName?: string;

  /**
   * URIs of GPG keys.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum#gpgKeys
   */
  readonly gpgKeys?: string[];

  /**
   * Required. A one word, unique name for this repository. This is the repo id in the zypper config file and also the display_name if display_name is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum#id
   */
  readonly id: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryYum | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseUrl': obj.baseUrl,
    'displayName': obj.displayName,
    'gpgKeys': obj.gpgKeys?.map(y => y),
    'id': obj.id,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper {
  /**
   * Required. The location of the repository directory.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#baseUrl
   */
  readonly baseUrl: string;

  /**
   * The display name of the repository.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#displayName
   */
  readonly displayName?: string;

  /**
   * URIs of GPG keys.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#gpgKeys
   */
  readonly gpgKeys?: string[];

  /**
   * Required. A one word, unique name for this repository. This is the repo id in the zypper config file and also the display_name if display_name is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper#id
   */
  readonly id: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesRepositoryZypper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseUrl': obj.baseUrl,
    'displayName': obj.displayName,
    'gpgKeys': obj.gpgKeys?.map(y => y),
    'id': obj.id,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs {
  /**
   * Required. Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs#bucket
   */
  readonly bucket: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs#generation
   */
  readonly generation?: number;

  /**
   * Required. Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * Required. URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesFileFileRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource {
  /**
   * Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   *
   * @default false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#allowInsecure
   */
  readonly allowInsecure?: boolean;

  /**
   * A Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#gcs
   */
  readonly gcs?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs[];

  /**
   * A local path within the VM to use.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#localPath
   */
  readonly localPath?: string;

  /**
   * A generic remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource#remote
   */
  readonly remote?: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote[];

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecure': obj.allowInsecure,
    'gcs': obj.gcs?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs(y)),
    'localPath': obj.localPath,
    'remote': obj.remote?.map(y => toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs {
  /**
   * Required. Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs#bucket
   */
  readonly bucket: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs#generation
   */
  readonly generation?: number;

  /**
   * Required. Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * Required. URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecEnforceFileRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs {
  /**
   * Required. Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs#bucket
   */
  readonly bucket: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs#generation
   */
  readonly generation?: number;

  /**
   * Required. Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * Required. URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesExecValidateFileRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs {
  /**
   * Required. Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs#bucket
   */
  readonly bucket: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs#generation
   */
  readonly generation?: number;

  /**
   * Required. Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * Required. URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgDebSourceRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs {
  /**
   * Required. Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs#bucket
   */
  readonly bucket: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs#generation
   */
  readonly generation?: number;

  /**
   * Required. Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * Required. URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs {
  /**
   * Required. Bucket of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs#bucket
   */
  readonly bucket: string;

  /**
   * Generation number of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs#generation
   */
  readonly generation?: number;

  /**
   * Required. Name of the Cloud Storage object.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generation': obj.generation,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote
 */
export interface OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote {
  /**
   * SHA256 checksum of the remote file.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote#sha256Checksum
   */
  readonly sha256Checksum?: string;

  /**
   * Required. URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
   *
   * @schema OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote(obj: OsPolicyAssignmentSpecForProviderOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256Checksum': obj.sha256Checksum,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * PatchDeployment is the Schema for the PatchDeployments API. Patch deployments are configurations that individual patch jobs use to complete a patch.
 *
 * @schema PatchDeployment
 */
export class PatchDeployment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PatchDeployment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'osconfig.gcp.upbound.io/v1beta1',
    kind: 'PatchDeployment',
  }

  /**
   * Renders a Kubernetes manifest for "PatchDeployment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PatchDeploymentProps): any {
    return {
      ...PatchDeployment.GVK,
      ...toJson_PatchDeploymentProps(props),
    };
  }

  /**
   * Defines a "PatchDeployment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PatchDeploymentProps) {
    super(scope, id, {
      ...PatchDeployment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PatchDeployment.GVK,
      ...toJson_PatchDeploymentProps(resolved),
    };
  }
}

/**
 * PatchDeployment is the Schema for the PatchDeployments API. Patch deployments are configurations that individual patch jobs use to complete a patch.
 *
 * @schema PatchDeployment
 */
export interface PatchDeploymentProps {
  /**
   * @schema PatchDeployment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PatchDeploymentSpec defines the desired state of PatchDeployment
   *
   * @schema PatchDeployment#spec
   */
  readonly spec: PatchDeploymentSpec;

}

/**
 * Converts an object of type 'PatchDeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentProps(obj: PatchDeploymentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PatchDeploymentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PatchDeploymentSpec defines the desired state of PatchDeployment
 *
 * @schema PatchDeploymentSpec
 */
export interface PatchDeploymentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PatchDeploymentSpec#deletionPolicy
   */
  readonly deletionPolicy?: PatchDeploymentSpecDeletionPolicy;

  /**
   * @schema PatchDeploymentSpec#forProvider
   */
  readonly forProvider: PatchDeploymentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PatchDeploymentSpec#managementPolicy
   */
  readonly managementPolicy?: PatchDeploymentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PatchDeploymentSpec#providerConfigRef
   */
  readonly providerConfigRef?: PatchDeploymentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PatchDeploymentSpec#providerRef
   */
  readonly providerRef?: PatchDeploymentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PatchDeploymentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PatchDeploymentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PatchDeploymentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PatchDeploymentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PatchDeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpec(obj: PatchDeploymentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PatchDeploymentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PatchDeploymentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PatchDeploymentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PatchDeploymentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PatchDeploymentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PatchDeploymentSpecDeletionPolicy
 */
export enum PatchDeploymentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PatchDeploymentSpecForProvider
 */
export interface PatchDeploymentSpecForProvider {
  /**
   * Description of the patch deployment. Length of the description is limited to 1024 characters.
   *
   * @schema PatchDeploymentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Duration of the patch. After the duration ends, the patch times out. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s"
   *
   * @schema PatchDeploymentSpecForProvider#duration
   */
  readonly duration?: string;

  /**
   * VM instances to patch. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProvider#instanceFilter
   */
  readonly instanceFilter?: PatchDeploymentSpecForProviderInstanceFilter[];

  /**
   * Schedule a one-time execution. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProvider#oneTimeSchedule
   */
  readonly oneTimeSchedule?: PatchDeploymentSpecForProviderOneTimeSchedule[];

  /**
   * Patch configuration that is applied. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProvider#patchConfig
   */
  readonly patchConfig?: PatchDeploymentSpecForProviderPatchConfig[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema PatchDeploymentSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Schedule recurring executions. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProvider#recurringSchedule
   */
  readonly recurringSchedule?: PatchDeploymentSpecForProviderRecurringSchedule[];

  /**
   * Rollout strategy of the patch job. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProvider#rollout
   */
  readonly rollout?: PatchDeploymentSpecForProviderRollout[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProvider(obj: PatchDeploymentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'duration': obj.duration,
    'instanceFilter': obj.instanceFilter?.map(y => toJson_PatchDeploymentSpecForProviderInstanceFilter(y)),
    'oneTimeSchedule': obj.oneTimeSchedule?.map(y => toJson_PatchDeploymentSpecForProviderOneTimeSchedule(y)),
    'patchConfig': obj.patchConfig?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfig(y)),
    'project': obj.project,
    'recurringSchedule': obj.recurringSchedule?.map(y => toJson_PatchDeploymentSpecForProviderRecurringSchedule(y)),
    'rollout': obj.rollout?.map(y => toJson_PatchDeploymentSpecForProviderRollout(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PatchDeploymentSpecManagementPolicy
 */
export enum PatchDeploymentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PatchDeploymentSpecProviderConfigRef
 */
export interface PatchDeploymentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchDeploymentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchDeploymentSpecProviderConfigRef#policy
   */
  readonly policy?: PatchDeploymentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PatchDeploymentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecProviderConfigRef(obj: PatchDeploymentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchDeploymentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PatchDeploymentSpecProviderRef
 */
export interface PatchDeploymentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchDeploymentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchDeploymentSpecProviderRef#policy
   */
  readonly policy?: PatchDeploymentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PatchDeploymentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecProviderRef(obj: PatchDeploymentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchDeploymentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsTo
 */
export interface PatchDeploymentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PatchDeploymentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PatchDeploymentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecPublishConnectionDetailsTo(obj: PatchDeploymentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PatchDeploymentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PatchDeploymentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PatchDeploymentSpecWriteConnectionSecretToRef
 */
export interface PatchDeploymentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PatchDeploymentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PatchDeploymentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecWriteConnectionSecretToRef(obj: PatchDeploymentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderInstanceFilter
 */
export interface PatchDeploymentSpecForProviderInstanceFilter {
  /**
   * Target all VM instances in the project. If true, no other criteria is permitted.
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilter#all
   */
  readonly all?: boolean;

  /**
   * Targets VM instances matching ANY of these GroupLabels. This allows targeting of disparate groups of VM instances. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilter#groupLabels
   */
  readonly groupLabels?: PatchDeploymentSpecForProviderInstanceFilterGroupLabels[];

  /**
   * Targets VMs whose name starts with one of these prefixes. Similar to labels, this is another way to group VMs when targeting configs, for example prefix="prod-".
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilter#instanceNamePrefixes
   */
  readonly instanceNamePrefixes?: string[];

  /**
   * Targets any of the VM instances specified. Instances are specified by their URI in the form zones/{{zone}}/instances/{{instance_name}}, projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}, or https://www.googleapis.com/compute/v1/projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilter#instances
   */
  readonly instances?: string[];

  /**
   * Targets VM instances in ANY of these zones. Leave empty to target VM instances in any zone.
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilter#zones
   */
  readonly zones?: string[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderInstanceFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderInstanceFilter(obj: PatchDeploymentSpecForProviderInstanceFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all,
    'groupLabels': obj.groupLabels?.map(y => toJson_PatchDeploymentSpecForProviderInstanceFilterGroupLabels(y)),
    'instanceNamePrefixes': obj.instanceNamePrefixes?.map(y => y),
    'instances': obj.instances?.map(y => y),
    'zones': obj.zones?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderOneTimeSchedule
 */
export interface PatchDeploymentSpecForProviderOneTimeSchedule {
  /**
   * The desired patch job execution time. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   *
   * @schema PatchDeploymentSpecForProviderOneTimeSchedule#executeTime
   */
  readonly executeTime: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderOneTimeSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderOneTimeSchedule(obj: PatchDeploymentSpecForProviderOneTimeSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executeTime': obj.executeTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfig
 */
export interface PatchDeploymentSpecForProviderPatchConfig {
  /**
   * Apt update settings. Use this setting to override the default apt patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#apt
   */
  readonly apt?: PatchDeploymentSpecForProviderPatchConfigApt[];

  /**
   * goo update settings. Use this setting to override the default goo patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#goo
   */
  readonly goo?: PatchDeploymentSpecForProviderPatchConfigGoo[];

  /**
   * Allows the patch job to run on Managed instance groups (MIGs).
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#migInstancesAllowed
   */
  readonly migInstancesAllowed?: boolean;

  /**
   * The ExecStep to run after the patch update. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#postStep
   */
  readonly postStep?: PatchDeploymentSpecForProviderPatchConfigPostStep[];

  /**
   * The ExecStep to run before the patch update. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#preStep
   */
  readonly preStep?: PatchDeploymentSpecForProviderPatchConfigPreStep[];

  /**
   * Post-patch reboot settings. Possible values are: DEFAULT, ALWAYS, NEVER.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#rebootConfig
   */
  readonly rebootConfig?: string;

  /**
   * Windows update settings. Use this setting to override the default Windows patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#windowsUpdate
   */
  readonly windowsUpdate?: PatchDeploymentSpecForProviderPatchConfigWindowsUpdate[];

  /**
   * Yum update settings. Use this setting to override the default yum patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#yum
   */
  readonly yum?: PatchDeploymentSpecForProviderPatchConfigYum[];

  /**
   * zypper update settings. Use this setting to override the default zypper patch rules. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfig#zypper
   */
  readonly zypper?: PatchDeploymentSpecForProviderPatchConfigZypper[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfig(obj: PatchDeploymentSpecForProviderPatchConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apt': obj.apt?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigApt(y)),
    'goo': obj.goo?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigGoo(y)),
    'migInstancesAllowed': obj.migInstancesAllowed,
    'postStep': obj.postStep?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPostStep(y)),
    'preStep': obj.preStep?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPreStep(y)),
    'rebootConfig': obj.rebootConfig,
    'windowsUpdate': obj.windowsUpdate?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigWindowsUpdate(y)),
    'yum': obj.yum?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigYum(y)),
    'zypper': obj.zypper?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigZypper(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringSchedule
 */
export interface PatchDeploymentSpecForProviderRecurringSchedule {
  /**
   * The end time at which a recurring patch deployment schedule is no longer active. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   *
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#endTime
   */
  readonly endTime?: string;

  /**
   * Schedule with monthly executions. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#monthly
   */
  readonly monthly?: PatchDeploymentSpecForProviderRecurringScheduleMonthly[];

  /**
   * The time that the recurring schedule becomes effective. Defaults to createTime of the patch deployment. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   *
   * @default createTime of the patch deployment. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#startTime
   */
  readonly startTime?: string;

  /**
   * Time of the day to run a recurring deployment. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#timeOfDay
   */
  readonly timeOfDay: PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay[];

  /**
   * Defines the time zone that timeOfDay is relative to. The rules for daylight saving time are determined by the chosen time zone. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#timeZone
   */
  readonly timeZone: PatchDeploymentSpecForProviderRecurringScheduleTimeZone[];

  /**
   * Schedule with weekly executions. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRecurringSchedule#weekly
   */
  readonly weekly?: PatchDeploymentSpecForProviderRecurringScheduleWeekly[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringSchedule(obj: PatchDeploymentSpecForProviderRecurringSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'monthly': obj.monthly?.map(y => toJson_PatchDeploymentSpecForProviderRecurringScheduleMonthly(y)),
    'startTime': obj.startTime,
    'timeOfDay': obj.timeOfDay?.map(y => toJson_PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay(y)),
    'timeZone': obj.timeZone?.map(y => toJson_PatchDeploymentSpecForProviderRecurringScheduleTimeZone(y)),
    'weekly': obj.weekly?.map(y => toJson_PatchDeploymentSpecForProviderRecurringScheduleWeekly(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRollout
 */
export interface PatchDeploymentSpecForProviderRollout {
  /**
   * The maximum number (or percentage) of VMs per zone to disrupt at any given moment. The number of VMs calculated from multiplying the percentage by the total number of VMs in a zone is rounded up. During patching, a VM is considered disrupted from the time the agent is notified to begin until patching has completed. This disruption time includes the time to complete reboot and any post-patch steps. A VM contributes to the disruption budget if its patching operation fails either when applying the patches, running pre or post patch steps, or if it fails to respond with a success notification before timing out. VMs that are not running or do not have an active agent do not count toward this disruption budget. For zone-by-zone rollouts, if the disruption budget in a zone is exceeded, the patch job stops, because continuing to the next zone requires completion of the patch process in the previous zone. For example, if the disruption budget has a fixed value of 10, and 8 VMs fail to patch in the current zone, the patch job continues to patch 2 VMs at a time until the zone is completed. When that zone is completed successfully, patching begins with 10 VMs at a time in the next zone. If 10 VMs in the next zone fail to patch, the patch job stops. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRollout#disruptionBudget
   */
  readonly disruptionBudget: PatchDeploymentSpecForProviderRolloutDisruptionBudget[];

  /**
   * Mode of the patch rollout. Possible values are: ZONE_BY_ZONE, CONCURRENT_ZONES.
   *
   * @schema PatchDeploymentSpecForProviderRollout#mode
   */
  readonly mode: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRollout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRollout(obj: PatchDeploymentSpecForProviderRollout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disruptionBudget': obj.disruptionBudget?.map(y => toJson_PatchDeploymentSpecForProviderRolloutDisruptionBudget(y)),
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PatchDeploymentSpecProviderConfigRefPolicy
 */
export interface PatchDeploymentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchDeploymentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PatchDeploymentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchDeploymentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PatchDeploymentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchDeploymentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecProviderConfigRefPolicy(obj: PatchDeploymentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PatchDeploymentSpecProviderRefPolicy
 */
export interface PatchDeploymentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchDeploymentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PatchDeploymentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchDeploymentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PatchDeploymentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchDeploymentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecProviderRefPolicy(obj: PatchDeploymentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRef
 */
export interface PatchDeploymentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PatchDeploymentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecPublishConnectionDetailsToConfigRef(obj: PatchDeploymentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsToMetadata
 */
export interface PatchDeploymentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecPublishConnectionDetailsToMetadata(obj: PatchDeploymentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderInstanceFilterGroupLabels
 */
export interface PatchDeploymentSpecForProviderInstanceFilterGroupLabels {
  /**
   * Compute Engine instance labels that must be present for a VM instance to be targeted by this filter
   *
   * @schema PatchDeploymentSpecForProviderInstanceFilterGroupLabels#labels
   */
  readonly labels: { [key: string]: string };

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderInstanceFilterGroupLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderInstanceFilterGroupLabels(obj: PatchDeploymentSpecForProviderInstanceFilterGroupLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigApt
 */
export interface PatchDeploymentSpecForProviderPatchConfigApt {
  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigApt#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of packages to be updated. These are the only packages that will be updated. If these packages are not installed, they will be ignored. This field cannot be specified with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigApt#exclusivePackages
   */
  readonly exclusivePackages?: string[];

  /**
   * By changing the type to DIST, the patching is performed using apt-get dist-upgrade instead. Possible values are: DIST, UPGRADE.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigApt#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigApt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigApt(obj: PatchDeploymentSpecForProviderPatchConfigApt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludes': obj.excludes?.map(y => y),
    'exclusivePackages': obj.exclusivePackages?.map(y => y),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigGoo
 */
export interface PatchDeploymentSpecForProviderPatchConfigGoo {
  /**
   * goo update settings. Use this setting to override the default goo patch rules.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigGoo#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigGoo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigGoo(obj: PatchDeploymentSpecForProviderPatchConfigGoo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPostStep
 */
export interface PatchDeploymentSpecForProviderPatchConfigPostStep {
  /**
   * The ExecStepConfig for all Linux VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStep#linuxExecStepConfig
   */
  readonly linuxExecStepConfig?: PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig[];

  /**
   * The ExecStepConfig for all Windows VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStep#windowsExecStepConfig
   */
  readonly windowsExecStepConfig?: PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPostStep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPostStep(obj: PatchDeploymentSpecForProviderPatchConfigPostStep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linuxExecStepConfig': obj.linuxExecStepConfig?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig(y)),
    'windowsExecStepConfig': obj.windowsExecStepConfig?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPreStep
 */
export interface PatchDeploymentSpecForProviderPatchConfigPreStep {
  /**
   * The ExecStepConfig for all Linux VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStep#linuxExecStepConfig
   */
  readonly linuxExecStepConfig?: PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig[];

  /**
   * The ExecStepConfig for all Windows VMs targeted by the PatchJob. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStep#windowsExecStepConfig
   */
  readonly windowsExecStepConfig?: PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPreStep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPreStep(obj: PatchDeploymentSpecForProviderPatchConfigPreStep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linuxExecStepConfig': obj.linuxExecStepConfig?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig(y)),
    'windowsExecStepConfig': obj.windowsExecStepConfig?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigWindowsUpdate
 */
export interface PatchDeploymentSpecForProviderPatchConfigWindowsUpdate {
  /**
   * Only apply updates of these windows update classifications. If empty, all updates are applied. Each value may be one of: CRITICAL, SECURITY, DEFINITION, DRIVER, FEATURE_PACK, SERVICE_PACK, TOOL, UPDATE_ROLLUP, UPDATE.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigWindowsUpdate#classifications
   */
  readonly classifications?: string[];

  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigWindowsUpdate#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command. This field must not be used with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigWindowsUpdate#exclusivePatches
   */
  readonly exclusivePatches?: string[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigWindowsUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigWindowsUpdate(obj: PatchDeploymentSpecForProviderPatchConfigWindowsUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classifications': obj.classifications?.map(y => y),
    'excludes': obj.excludes?.map(y => y),
    'exclusivePatches': obj.exclusivePatches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigYum
 */
export interface PatchDeploymentSpecForProviderPatchConfigYum {
  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigYum#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of packages to be updated. These are the only packages that will be updated. If these packages are not installed, they will be ignored. This field cannot be specified with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigYum#exclusivePackages
   */
  readonly exclusivePackages?: string[];

  /**
   * Will cause patch to run yum update-minimal instead.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigYum#minimal
   */
  readonly minimal?: boolean;

  /**
   * Adds the --security flag to yum update. Not supported on all platforms.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigYum#security
   */
  readonly security?: boolean;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigYum' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigYum(obj: PatchDeploymentSpecForProviderPatchConfigYum | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludes': obj.excludes?.map(y => y),
    'exclusivePackages': obj.exclusivePackages?.map(y => y),
    'minimal': obj.minimal,
    'security': obj.security,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigZypper
 */
export interface PatchDeploymentSpecForProviderPatchConfigZypper {
  /**
   * Install only patches with these categories. Common categories include security, recommended, and feature.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#categories
   */
  readonly categories?: string[];

  /**
   * List of packages to exclude from update.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#excludes
   */
  readonly excludes?: string[];

  /**
   * An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command. This field must not be used with any other patch configuration fields.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#exclusivePatches
   */
  readonly exclusivePatches?: string[];

  /**
   * Install only patches with these severities. Common severities include critical, important, moderate, and low.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#severities
   */
  readonly severities?: string[];

  /**
   * Adds the --with-optional flag to zypper patch.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#withOptional
   */
  readonly withOptional?: boolean;

  /**
   * Adds the --with-update flag, to zypper patch.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigZypper#withUpdate
   */
  readonly withUpdate?: boolean;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigZypper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigZypper(obj: PatchDeploymentSpecForProviderPatchConfigZypper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categories': obj.categories?.map(y => y),
    'excludes': obj.excludes?.map(y => y),
    'exclusivePatches': obj.exclusivePatches?.map(y => y),
    'severities': obj.severities?.map(y => y),
    'withOptional': obj.withOptional,
    'withUpdate': obj.withUpdate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthly
 */
export interface PatchDeploymentSpecForProviderRecurringScheduleMonthly {
  /**
   * One day of the month. 1-31 indicates the 1st to the 31st day. -1 indicates the last day of the month. Months without the target day will be skipped. For example, a schedule to run "every month on the 31st" will not run in February, April, June, etc.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthly#monthDay
   */
  readonly monthDay?: number;

  /**
   * Week day in a month. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthly#weekDayOfMonth
   */
  readonly weekDayOfMonth?: PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth[];

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringScheduleMonthly' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringScheduleMonthly(obj: PatchDeploymentSpecForProviderRecurringScheduleMonthly | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monthDay': obj.monthDay,
    'weekDayOfMonth': obj.weekDayOfMonth?.map(y => toJson_PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay
 */
export interface PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay(obj: PatchDeploymentSpecForProviderRecurringScheduleTimeOfDay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeZone
 */
export interface PatchDeploymentSpecForProviderRecurringScheduleTimeZone {
  /**
   * IANA Time Zone Database time zone, e.g. "America/New_York".
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeZone#id
   */
  readonly id: string;

  /**
   * IANA Time Zone Database version number, e.g. "2019a".
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleTimeZone#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringScheduleTimeZone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringScheduleTimeZone(obj: PatchDeploymentSpecForProviderRecurringScheduleTimeZone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringScheduleWeekly
 */
export interface PatchDeploymentSpecForProviderRecurringScheduleWeekly {
  /**
   * IANA Time Zone Database time zone, e.g. "America/New_York". Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleWeekly#dayOfWeek
   */
  readonly dayOfWeek: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringScheduleWeekly' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringScheduleWeekly(obj: PatchDeploymentSpecForProviderRecurringScheduleWeekly | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dayOfWeek': obj.dayOfWeek,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRolloutDisruptionBudget
 */
export interface PatchDeploymentSpecForProviderRolloutDisruptionBudget {
  /**
   * Specifies a fixed value.
   *
   * @schema PatchDeploymentSpecForProviderRolloutDisruptionBudget#fixed
   */
  readonly fixed?: number;

  /**
   * Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
   *
   * @schema PatchDeploymentSpecForProviderRolloutDisruptionBudget#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRolloutDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRolloutDisruptionBudget(obj: PatchDeploymentSpecForProviderRolloutDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixed': obj.fixed,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchDeploymentSpecProviderConfigRefPolicyResolution
 */
export enum PatchDeploymentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchDeploymentSpecProviderConfigRefPolicyResolve
 */
export enum PatchDeploymentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchDeploymentSpecProviderRefPolicyResolution
 */
export enum PatchDeploymentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchDeploymentSpecProviderRefPolicyResolve
 */
export enum PatchDeploymentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj: PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig
 */
export interface PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig(obj: PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig
 */
export interface PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig(obj: PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig
 */
export interface PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig(obj: PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig
 */
export interface PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig {
  /**
   * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
   *
   * @default 0]. A list of possible return values that the execution can return to indicate a success.
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig#allowedSuccessCodes
   */
  readonly allowedSuccessCodes?: number[];

  /**
   * A Cloud Storage object containing the executable. Structure is documented below.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig#gcsObject
   */
  readonly gcsObject?: PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject[];

  /**
   * The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with shebang lines. Possible values are: SHELL, POWERSHELL.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig#interpreter
   */
  readonly interpreter?: string;

  /**
   * An absolute path to the executable on the VM.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig#localPath
   */
  readonly localPath?: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig(obj: PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSuccessCodes': obj.allowedSuccessCodes?.map(y => y),
    'gcsObject': obj.gcsObject?.map(y => toJson_PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject(y)),
    'interpreter': obj.interpreter,
    'localPath': obj.localPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth
 */
export interface PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth {
  /**
   * IANA Time Zone Database time zone, e.g. "America/New_York". Possible values are: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth#dayOfWeek
   */
  readonly dayOfWeek: string;

  /**
   * Week number in a month. 1-4 indicates the 1st to 4th week of the month. -1 indicates the last week of the month.
   *
   * @schema PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth#weekOrdinal
   */
  readonly weekOrdinal: number;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth(obj: PatchDeploymentSpecForProviderRecurringScheduleMonthlyWeekDayOfMonth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dayOfWeek': obj.dayOfWeek,
    'weekOrdinal': obj.weekOrdinal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PatchDeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject#bucket
   */
  readonly bucket: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject(obj: PatchDeploymentSpecForProviderPatchConfigPostStepLinuxExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject#bucket
   */
  readonly bucket: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject(obj: PatchDeploymentSpecForProviderPatchConfigPostStepWindowsExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject#bucket
   */
  readonly bucket: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject(obj: PatchDeploymentSpecForProviderPatchConfigPreStepLinuxExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject
 */
export interface PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject {
  /**
   * Bucket of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject#bucket
   */
  readonly bucket: string;

  /**
   * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject#generationNumber
   */
  readonly generationNumber: string;

  /**
   * Name of the Cloud Storage object.
   *
   * @schema PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject(obj: PatchDeploymentSpecForProviderPatchConfigPreStepWindowsExecStepConfigGcsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'generationNumber': obj.generationNumber,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

