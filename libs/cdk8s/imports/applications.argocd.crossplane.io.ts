// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * An Application is a managed resource that represents an ArgoCD Application
 *
 * @schema Application
 */
export class Application extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Application"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'applications.argocd.crossplane.io/v1alpha1',
    kind: 'Application',
  }

  /**
   * Renders a Kubernetes manifest for "Application".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationProps): any {
    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(props),
    };
  }

  /**
   * Defines a "Application" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationProps) {
    super(scope, id, {
      ...Application.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(resolved),
    };
  }
}

/**
 * An Application is a managed resource that represents an ArgoCD Application
 *
 * @schema Application
 */
export interface ApplicationProps {
  /**
   * @schema Application#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ApplicationSpec defines the desired state of an ArgoCD Application.
   *
   * @schema Application#spec
   */
  readonly spec: ApplicationSpec;

}

/**
 * Converts an object of type 'ApplicationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationProps(obj: ApplicationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ApplicationSpec defines the desired state of an ArgoCD Application.
 *
 * @schema ApplicationSpec
 */
export interface ApplicationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ApplicationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationSpecDeletionPolicy;

  /**
   * ApplicationParameters define the desired state of an ArgoCD Git Application
   *
   * @schema ApplicationSpec#forProvider
   */
  readonly forProvider: ApplicationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApplicationSpec#providerRef
   */
  readonly providerRef?: ApplicationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpec(obj: ApplicationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ApplicationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApplicationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApplicationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ApplicationSpecDeletionPolicy
 */
export enum ApplicationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ApplicationParameters define the desired state of an ArgoCD Git Application
 *
 * @schema ApplicationSpecForProvider
 */
export interface ApplicationSpecForProvider {
  /**
   * Destination is a reference to the target Kubernetes server and namespace
   *
   * @schema ApplicationSpecForProvider#destination
   */
  readonly destination: ApplicationSpecForProviderDestination;

  /**
   * IgnoreDifferences is a list of resources and their fields which should be ignored during comparison
   *
   * @schema ApplicationSpecForProvider#ignoreDifferences
   */
  readonly ignoreDifferences?: ApplicationSpecForProviderIgnoreDifferences[];

  /**
   * Info contains a list of information (URLs, email addresses, and plain text) that relates to the application
   *
   * @schema ApplicationSpecForProvider#info
   */
  readonly info?: ApplicationSpecForProviderInfo[];

  /**
   * Project is a reference to the project this application belongs to. The empty string means that application belongs to the 'default' project.
   *
   * @schema ApplicationSpecForProvider#project
   */
  readonly project: string;

  /**
   * RevisionHistoryLimit limits the number of items kept in the application's revision history, which is used for informational purposes as well as for rollbacks to previous versions. This should only be changed in exceptional circumstances. Setting to zero will store no history. This will reduce storage used. Increasing will increase the space used to store the history, so we do not recommend increasing it. Default is 10.
   *
   * @default 10.
   * @schema ApplicationSpecForProvider#revisionHistoryLimit
   */
  readonly revisionHistoryLimit?: number;

  /**
   * ApplicationSource contains all required information about the source of an application
   *
   * @schema ApplicationSpecForProvider#source
   */
  readonly source?: ApplicationSpecForProviderSource;

  /**
   * Sources is a reference to the location of the application's manifests or chart
   *
   * @schema ApplicationSpecForProvider#sources
   */
  readonly sources?: ApplicationSpecForProviderSources[];

  /**
   * SyncPolicy controls when and how a sync will be performed
   *
   * @schema ApplicationSpecForProvider#syncPolicy
   */
  readonly syncPolicy?: ApplicationSpecForProviderSyncPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProvider(obj: ApplicationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_ApplicationSpecForProviderDestination(obj.destination),
    'ignoreDifferences': obj.ignoreDifferences?.map(y => toJson_ApplicationSpecForProviderIgnoreDifferences(y)),
    'info': obj.info?.map(y => toJson_ApplicationSpecForProviderInfo(y)),
    'project': obj.project,
    'revisionHistoryLimit': obj.revisionHistoryLimit,
    'source': toJson_ApplicationSpecForProviderSource(obj.source),
    'sources': obj.sources?.map(y => toJson_ApplicationSpecForProviderSources(y)),
    'syncPolicy': toJson_ApplicationSpecForProviderSyncPolicy(obj.syncPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationSpecProviderConfigRef
 */
export interface ApplicationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRef(obj: ApplicationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApplicationSpecProviderRef
 */
export interface ApplicationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderRef#policy
   */
  readonly policy?: ApplicationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderRef(obj: ApplicationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationSpecPublishConnectionDetailsTo
 */
export interface ApplicationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsTo(obj: ApplicationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationSpecWriteConnectionSecretToRef
 */
export interface ApplicationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecWriteConnectionSecretToRef(obj: ApplicationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Destination is a reference to the target Kubernetes server and namespace
 *
 * @schema ApplicationSpecForProviderDestination
 */
export interface ApplicationSpecForProviderDestination {
  /**
   * Name is an alternate way of specifying the target cluster by its symbolic name
   *
   * @schema ApplicationSpecForProviderDestination#name
   */
  readonly name?: string;

  /**
   * Namespace specifies the target namespace for the application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace
   *
   * @schema ApplicationSpecForProviderDestination#namespace
   */
  readonly namespace?: string;

  /**
   * Server specifies the URL of the target cluster and must be set to the Kubernetes control plane API
   *
   * @schema ApplicationSpecForProviderDestination#server
   */
  readonly server?: string;

  /**
   * ServerRef is a reference to an Cluster used to set Server
   *
   * @schema ApplicationSpecForProviderDestination#serverRef
   */
  readonly serverRef?: ApplicationSpecForProviderDestinationServerRef;

  /**
   * SourceReposSelector selects references to Repositories used to set SourceRepos
   *
   * @schema ApplicationSpecForProviderDestination#serverSelector
   */
  readonly serverSelector?: ApplicationSpecForProviderDestinationServerSelector;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderDestination(obj: ApplicationSpecForProviderDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'server': obj.server,
    'serverRef': toJson_ApplicationSpecForProviderDestinationServerRef(obj.serverRef),
    'serverSelector': toJson_ApplicationSpecForProviderDestinationServerSelector(obj.serverSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceIgnoreDifferences contains resource filter and list of json paths which should be ignored during comparison with live state.
 *
 * @schema ApplicationSpecForProviderIgnoreDifferences
 */
export interface ApplicationSpecForProviderIgnoreDifferences {
  /**
   * @schema ApplicationSpecForProviderIgnoreDifferences#group
   */
  readonly group?: string;

  /**
   * @schema ApplicationSpecForProviderIgnoreDifferences#jqPathExpressions
   */
  readonly jqPathExpressions?: string[];

  /**
   * @schema ApplicationSpecForProviderIgnoreDifferences#jsonPointers
   */
  readonly jsonPointers?: string[];

  /**
   * @schema ApplicationSpecForProviderIgnoreDifferences#kind
   */
  readonly kind: string;

  /**
   * ManagedFieldsManagers is a list of trusted managers. Fields mutated by those managers will take precedence over the desired state defined in the SCM and won't be displayed in diffs
   *
   * @schema ApplicationSpecForProviderIgnoreDifferences#managedFieldsManagers
   */
  readonly managedFieldsManagers?: string[];

  /**
   * @schema ApplicationSpecForProviderIgnoreDifferences#name
   */
  readonly name?: string;

  /**
   * @schema ApplicationSpecForProviderIgnoreDifferences#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderIgnoreDifferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderIgnoreDifferences(obj: ApplicationSpecForProviderIgnoreDifferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'jqPathExpressions': obj.jqPathExpressions?.map(y => y),
    'jsonPointers': obj.jsonPointers?.map(y => y),
    'kind': obj.kind,
    'managedFieldsManagers': obj.managedFieldsManagers?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Info is a list of informational items for this operation
 *
 * @schema ApplicationSpecForProviderInfo
 */
export interface ApplicationSpecForProviderInfo {
  /**
   * @schema ApplicationSpecForProviderInfo#name
   */
  readonly name: string;

  /**
   * @schema ApplicationSpecForProviderInfo#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInfo(obj: ApplicationSpecForProviderInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSource contains all required information about the source of an application
 *
 * @schema ApplicationSpecForProviderSource
 */
export interface ApplicationSpecForProviderSource {
  /**
   * Chart is a Helm chart name, and must be specified for applications sourced from a Helm repo.
   *
   * @schema ApplicationSpecForProviderSource#chart
   */
  readonly chart?: string;

  /**
   * Directory holds path/directory specific options
   *
   * @schema ApplicationSpecForProviderSource#directory
   */
  readonly directory?: ApplicationSpecForProviderSourceDirectory;

  /**
   * Helm holds helm specific options
   *
   * @schema ApplicationSpecForProviderSource#helm
   */
  readonly helm?: ApplicationSpecForProviderSourceHelm;

  /**
   * Kustomize holds kustomize specific options
   *
   * @schema ApplicationSpecForProviderSource#kustomize
   */
  readonly kustomize?: ApplicationSpecForProviderSourceKustomize;

  /**
   * Path is a directory path within the Git repository, and is only valid for applications sourced from Git.
   *
   * @schema ApplicationSpecForProviderSource#path
   */
  readonly path?: string;

  /**
   * Plugin holds config management plugin specific options
   *
   * @schema ApplicationSpecForProviderSource#plugin
   */
  readonly plugin?: ApplicationSpecForProviderSourcePlugin;

  /**
   * Ref is reference to another source within sources field. This field will not be used if used with a `source` tag.
   *
   * @schema ApplicationSpecForProviderSource#ref
   */
  readonly ref?: string;

  /**
   * RepoURL is the URL to the repository (Git or Helm) that contains the application manifests
   *
   * @schema ApplicationSpecForProviderSource#repoURL
   */
  readonly repoUrl: string;

  /**
   * TargetRevision defines the revision of the source to sync the application to. In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag for the Chart's version.
   *
   * @schema ApplicationSpecForProviderSource#targetRevision
   */
  readonly targetRevision?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSource(obj: ApplicationSpecForProviderSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chart': obj.chart,
    'directory': toJson_ApplicationSpecForProviderSourceDirectory(obj.directory),
    'helm': toJson_ApplicationSpecForProviderSourceHelm(obj.helm),
    'kustomize': toJson_ApplicationSpecForProviderSourceKustomize(obj.kustomize),
    'path': obj.path,
    'plugin': toJson_ApplicationSpecForProviderSourcePlugin(obj.plugin),
    'ref': obj.ref,
    'repoURL': obj.repoUrl,
    'targetRevision': obj.targetRevision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSource contains all required information about the source of an application
 *
 * @schema ApplicationSpecForProviderSources
 */
export interface ApplicationSpecForProviderSources {
  /**
   * Chart is a Helm chart name, and must be specified for applications sourced from a Helm repo.
   *
   * @schema ApplicationSpecForProviderSources#chart
   */
  readonly chart?: string;

  /**
   * Directory holds path/directory specific options
   *
   * @schema ApplicationSpecForProviderSources#directory
   */
  readonly directory?: ApplicationSpecForProviderSourcesDirectory;

  /**
   * Helm holds helm specific options
   *
   * @schema ApplicationSpecForProviderSources#helm
   */
  readonly helm?: ApplicationSpecForProviderSourcesHelm;

  /**
   * Kustomize holds kustomize specific options
   *
   * @schema ApplicationSpecForProviderSources#kustomize
   */
  readonly kustomize?: ApplicationSpecForProviderSourcesKustomize;

  /**
   * Path is a directory path within the Git repository, and is only valid for applications sourced from Git.
   *
   * @schema ApplicationSpecForProviderSources#path
   */
  readonly path?: string;

  /**
   * Plugin holds config management plugin specific options
   *
   * @schema ApplicationSpecForProviderSources#plugin
   */
  readonly plugin?: ApplicationSpecForProviderSourcesPlugin;

  /**
   * Ref is reference to another source within sources field. This field will not be used if used with a `source` tag.
   *
   * @schema ApplicationSpecForProviderSources#ref
   */
  readonly ref?: string;

  /**
   * RepoURL is the URL to the repository (Git or Helm) that contains the application manifests
   *
   * @schema ApplicationSpecForProviderSources#repoURL
   */
  readonly repoUrl: string;

  /**
   * TargetRevision defines the revision of the source to sync the application to. In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag for the Chart's version.
   *
   * @schema ApplicationSpecForProviderSources#targetRevision
   */
  readonly targetRevision?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSources(obj: ApplicationSpecForProviderSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chart': obj.chart,
    'directory': toJson_ApplicationSpecForProviderSourcesDirectory(obj.directory),
    'helm': toJson_ApplicationSpecForProviderSourcesHelm(obj.helm),
    'kustomize': toJson_ApplicationSpecForProviderSourcesKustomize(obj.kustomize),
    'path': obj.path,
    'plugin': toJson_ApplicationSpecForProviderSourcesPlugin(obj.plugin),
    'ref': obj.ref,
    'repoURL': obj.repoUrl,
    'targetRevision': obj.targetRevision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SyncPolicy controls when and how a sync will be performed
 *
 * @schema ApplicationSpecForProviderSyncPolicy
 */
export interface ApplicationSpecForProviderSyncPolicy {
  /**
   * Automated will keep an application synced to the target revision
   *
   * @schema ApplicationSpecForProviderSyncPolicy#automated
   */
  readonly automated?: ApplicationSpecForProviderSyncPolicyAutomated;

  /**
   * ManagedNamespaceMetadata controls metadata in the given namespace (if CreateNamespace=true)
   *
   * @schema ApplicationSpecForProviderSyncPolicy#managedNamespaceMetadata
   */
  readonly managedNamespaceMetadata?: ApplicationSpecForProviderSyncPolicyManagedNamespaceMetadata;

  /**
   * Retry controls failed sync retry behavior
   *
   * @schema ApplicationSpecForProviderSyncPolicy#retry
   */
  readonly retry?: ApplicationSpecForProviderSyncPolicyRetry;

  /**
   * Options allow you to specify whole app sync-options
   *
   * @schema ApplicationSpecForProviderSyncPolicy#syncOptions
   */
  readonly syncOptions?: string[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSyncPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSyncPolicy(obj: ApplicationSpecForProviderSyncPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automated': toJson_ApplicationSpecForProviderSyncPolicyAutomated(obj.automated),
    'managedNamespaceMetadata': toJson_ApplicationSpecForProviderSyncPolicyManagedNamespaceMetadata(obj.managedNamespaceMetadata),
    'retry': toJson_ApplicationSpecForProviderSyncPolicyRetry(obj.retry),
    'syncOptions': obj.syncOptions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderConfigRefPolicy
 */
export interface ApplicationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRefPolicy(obj: ApplicationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderRefPolicy
 */
export interface ApplicationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderRefPolicy(obj: ApplicationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj: ApplicationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj: ApplicationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServerRef is a reference to an Cluster used to set Server
 *
 * @schema ApplicationSpecForProviderDestinationServerRef
 */
export interface ApplicationSpecForProviderDestinationServerRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderDestinationServerRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderDestinationServerRef#policy
   */
  readonly policy?: ApplicationSpecForProviderDestinationServerRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderDestinationServerRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderDestinationServerRef(obj: ApplicationSpecForProviderDestinationServerRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderDestinationServerRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceReposSelector selects references to Repositories used to set SourceRepos
 *
 * @schema ApplicationSpecForProviderDestinationServerSelector
 */
export interface ApplicationSpecForProviderDestinationServerSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderDestinationServerSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderDestinationServerSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderDestinationServerSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderDestinationServerSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderDestinationServerSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderDestinationServerSelector(obj: ApplicationSpecForProviderDestinationServerSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderDestinationServerSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Directory holds path/directory specific options
 *
 * @schema ApplicationSpecForProviderSourceDirectory
 */
export interface ApplicationSpecForProviderSourceDirectory {
  /**
   * Exclude contains a glob pattern to match paths against that should be explicitly excluded from being used during manifest generation
   *
   * @schema ApplicationSpecForProviderSourceDirectory#exclude
   */
  readonly exclude?: string;

  /**
   * Include contains a glob pattern to match paths against that should be explicitly included during manifest generation
   *
   * @schema ApplicationSpecForProviderSourceDirectory#include
   */
  readonly include?: string;

  /**
   * Jsonnet holds options specific to Jsonnet
   *
   * @schema ApplicationSpecForProviderSourceDirectory#jsonnet
   */
  readonly jsonnet?: ApplicationSpecForProviderSourceDirectoryJsonnet;

  /**
   * Recurse specifies whether to scan a directory recursively for manifests
   *
   * @schema ApplicationSpecForProviderSourceDirectory#recurse
   */
  readonly recurse?: boolean;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourceDirectory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourceDirectory(obj: ApplicationSpecForProviderSourceDirectory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclude': obj.exclude,
    'include': obj.include,
    'jsonnet': toJson_ApplicationSpecForProviderSourceDirectoryJsonnet(obj.jsonnet),
    'recurse': obj.recurse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Helm holds helm specific options
 *
 * @schema ApplicationSpecForProviderSourceHelm
 */
export interface ApplicationSpecForProviderSourceHelm {
  /**
   * FileParameters are file parameters to the helm template
   *
   * @schema ApplicationSpecForProviderSourceHelm#fileParameters
   */
  readonly fileParameters?: ApplicationSpecForProviderSourceHelmFileParameters[];

  /**
   * IgnoreMissingValueFiles prevents helm template from failing when valueFiles do not exist locally by not appending them to helm template --values
   *
   * @schema ApplicationSpecForProviderSourceHelm#ignoreMissingValueFiles
   */
  readonly ignoreMissingValueFiles?: boolean;

  /**
   * Parameters is a list of Helm parameters which are passed to the helm template command upon manifest generation
   *
   * @schema ApplicationSpecForProviderSourceHelm#parameters
   */
  readonly parameters?: ApplicationSpecForProviderSourceHelmParameters[];

  /**
   * PassCredentials pass credentials to all domains (Helm's --pass-credentials)
   *
   * @schema ApplicationSpecForProviderSourceHelm#passCredentials
   */
  readonly passCredentials?: boolean;

  /**
   * ReleaseName is the Helm release name to use. If omitted it will use the application name
   *
   * @schema ApplicationSpecForProviderSourceHelm#releaseName
   */
  readonly releaseName?: string;

  /**
   * SkipCrds skips custom resource definition installation step (Helm's --skip-crds)
   *
   * @schema ApplicationSpecForProviderSourceHelm#skipCrds
   */
  readonly skipCrds?: boolean;

  /**
   * ValuesFiles is a list of Helm value files to use when generating a template
   *
   * @schema ApplicationSpecForProviderSourceHelm#valueFiles
   */
  readonly valueFiles?: string[];

  /**
   * Values specifies Helm values to be passed to helm template, typically defined as a block
   *
   * @schema ApplicationSpecForProviderSourceHelm#values
   */
  readonly values?: string;

  /**
   * Version is the Helm version to use for templating ("3")
   *
   * @schema ApplicationSpecForProviderSourceHelm#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourceHelm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourceHelm(obj: ApplicationSpecForProviderSourceHelm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileParameters': obj.fileParameters?.map(y => toJson_ApplicationSpecForProviderSourceHelmFileParameters(y)),
    'ignoreMissingValueFiles': obj.ignoreMissingValueFiles,
    'parameters': obj.parameters?.map(y => toJson_ApplicationSpecForProviderSourceHelmParameters(y)),
    'passCredentials': obj.passCredentials,
    'releaseName': obj.releaseName,
    'skipCrds': obj.skipCrds,
    'valueFiles': obj.valueFiles?.map(y => y),
    'values': obj.values,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kustomize holds kustomize specific options
 *
 * @schema ApplicationSpecForProviderSourceKustomize
 */
export interface ApplicationSpecForProviderSourceKustomize {
  /**
   * CommonAnnotations is a list of additional annotations to add to rendered manifests
   *
   * @schema ApplicationSpecForProviderSourceKustomize#commonAnnotations
   */
  readonly commonAnnotations?: { [key: string]: string };

  /**
   * CommonAnnotationsEnvsubst specifies whether to apply env variables substitution for annotation values
   *
   * @schema ApplicationSpecForProviderSourceKustomize#commonAnnotationsEnvsubst
   */
  readonly commonAnnotationsEnvsubst?: boolean;

  /**
   * CommonLabels is a list of additional labels to add to rendered manifests
   *
   * @schema ApplicationSpecForProviderSourceKustomize#commonLabels
   */
  readonly commonLabels?: { [key: string]: string };

  /**
   * ForceCommonAnnotations specifies whether to force applying common annotations to resources for Kustomize apps
   *
   * @schema ApplicationSpecForProviderSourceKustomize#forceCommonAnnotations
   */
  readonly forceCommonAnnotations?: boolean;

  /**
   * ForceCommonLabels specifies whether to force applying common labels to resources for Kustomize apps
   *
   * @schema ApplicationSpecForProviderSourceKustomize#forceCommonLabels
   */
  readonly forceCommonLabels?: boolean;

  /**
   * Images is a list of Kustomize image override specifications
   *
   * @schema ApplicationSpecForProviderSourceKustomize#images
   */
  readonly images?: string[];

  /**
   * NamePrefix is a prefix appended to resources for Kustomize apps
   *
   * @schema ApplicationSpecForProviderSourceKustomize#namePrefix
   */
  readonly namePrefix?: string;

  /**
   * NameSuffix is a suffix appended to resources for Kustomize apps
   *
   * @schema ApplicationSpecForProviderSourceKustomize#nameSuffix
   */
  readonly nameSuffix?: string;

  /**
   * Namespace sets the namespace that Kustomize adds to all resources
   *
   * @schema ApplicationSpecForProviderSourceKustomize#namespace
   */
  readonly namespace?: string;

  /**
   * Replicas is a list of Kustomize Replicas override specifications
   *
   * @schema ApplicationSpecForProviderSourceKustomize#replicas
   */
  readonly replicas?: ApplicationSpecForProviderSourceKustomizeReplicas[];

  /**
   * Version controls which version of Kustomize to use for rendering manifests
   *
   * @schema ApplicationSpecForProviderSourceKustomize#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourceKustomize' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourceKustomize(obj: ApplicationSpecForProviderSourceKustomize | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAnnotations': ((obj.commonAnnotations) === undefined) ? undefined : (Object.entries(obj.commonAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'commonAnnotationsEnvsubst': obj.commonAnnotationsEnvsubst,
    'commonLabels': ((obj.commonLabels) === undefined) ? undefined : (Object.entries(obj.commonLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'forceCommonAnnotations': obj.forceCommonAnnotations,
    'forceCommonLabels': obj.forceCommonLabels,
    'images': obj.images?.map(y => y),
    'namePrefix': obj.namePrefix,
    'nameSuffix': obj.nameSuffix,
    'namespace': obj.namespace,
    'replicas': obj.replicas?.map(y => toJson_ApplicationSpecForProviderSourceKustomizeReplicas(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Plugin holds config management plugin specific options
 *
 * @schema ApplicationSpecForProviderSourcePlugin
 */
export interface ApplicationSpecForProviderSourcePlugin {
  /**
   * Env holds options specific to config management plugins
   *
   * @schema ApplicationSpecForProviderSourcePlugin#env
   */
  readonly env?: ApplicationSpecForProviderSourcePluginEnv[];

  /**
   * @schema ApplicationSpecForProviderSourcePlugin#name
   */
  readonly name?: string;

  /**
   * ApplicationSourcePluginParameters is a list of specific config management parameters
   *
   * @schema ApplicationSpecForProviderSourcePlugin#parameters
   */
  readonly parameters?: ApplicationSpecForProviderSourcePluginParameters[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcePlugin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcePlugin(obj: ApplicationSpecForProviderSourcePlugin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_ApplicationSpecForProviderSourcePluginEnv(y)),
    'name': obj.name,
    'parameters': obj.parameters?.map(y => toJson_ApplicationSpecForProviderSourcePluginParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Directory holds path/directory specific options
 *
 * @schema ApplicationSpecForProviderSourcesDirectory
 */
export interface ApplicationSpecForProviderSourcesDirectory {
  /**
   * Exclude contains a glob pattern to match paths against that should be explicitly excluded from being used during manifest generation
   *
   * @schema ApplicationSpecForProviderSourcesDirectory#exclude
   */
  readonly exclude?: string;

  /**
   * Include contains a glob pattern to match paths against that should be explicitly included during manifest generation
   *
   * @schema ApplicationSpecForProviderSourcesDirectory#include
   */
  readonly include?: string;

  /**
   * Jsonnet holds options specific to Jsonnet
   *
   * @schema ApplicationSpecForProviderSourcesDirectory#jsonnet
   */
  readonly jsonnet?: ApplicationSpecForProviderSourcesDirectoryJsonnet;

  /**
   * Recurse specifies whether to scan a directory recursively for manifests
   *
   * @schema ApplicationSpecForProviderSourcesDirectory#recurse
   */
  readonly recurse?: boolean;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesDirectory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesDirectory(obj: ApplicationSpecForProviderSourcesDirectory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclude': obj.exclude,
    'include': obj.include,
    'jsonnet': toJson_ApplicationSpecForProviderSourcesDirectoryJsonnet(obj.jsonnet),
    'recurse': obj.recurse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Helm holds helm specific options
 *
 * @schema ApplicationSpecForProviderSourcesHelm
 */
export interface ApplicationSpecForProviderSourcesHelm {
  /**
   * FileParameters are file parameters to the helm template
   *
   * @schema ApplicationSpecForProviderSourcesHelm#fileParameters
   */
  readonly fileParameters?: ApplicationSpecForProviderSourcesHelmFileParameters[];

  /**
   * IgnoreMissingValueFiles prevents helm template from failing when valueFiles do not exist locally by not appending them to helm template --values
   *
   * @schema ApplicationSpecForProviderSourcesHelm#ignoreMissingValueFiles
   */
  readonly ignoreMissingValueFiles?: boolean;

  /**
   * Parameters is a list of Helm parameters which are passed to the helm template command upon manifest generation
   *
   * @schema ApplicationSpecForProviderSourcesHelm#parameters
   */
  readonly parameters?: ApplicationSpecForProviderSourcesHelmParameters[];

  /**
   * PassCredentials pass credentials to all domains (Helm's --pass-credentials)
   *
   * @schema ApplicationSpecForProviderSourcesHelm#passCredentials
   */
  readonly passCredentials?: boolean;

  /**
   * ReleaseName is the Helm release name to use. If omitted it will use the application name
   *
   * @schema ApplicationSpecForProviderSourcesHelm#releaseName
   */
  readonly releaseName?: string;

  /**
   * SkipCrds skips custom resource definition installation step (Helm's --skip-crds)
   *
   * @schema ApplicationSpecForProviderSourcesHelm#skipCrds
   */
  readonly skipCrds?: boolean;

  /**
   * ValuesFiles is a list of Helm value files to use when generating a template
   *
   * @schema ApplicationSpecForProviderSourcesHelm#valueFiles
   */
  readonly valueFiles?: string[];

  /**
   * Values specifies Helm values to be passed to helm template, typically defined as a block
   *
   * @schema ApplicationSpecForProviderSourcesHelm#values
   */
  readonly values?: string;

  /**
   * Version is the Helm version to use for templating ("3")
   *
   * @schema ApplicationSpecForProviderSourcesHelm#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesHelm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesHelm(obj: ApplicationSpecForProviderSourcesHelm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileParameters': obj.fileParameters?.map(y => toJson_ApplicationSpecForProviderSourcesHelmFileParameters(y)),
    'ignoreMissingValueFiles': obj.ignoreMissingValueFiles,
    'parameters': obj.parameters?.map(y => toJson_ApplicationSpecForProviderSourcesHelmParameters(y)),
    'passCredentials': obj.passCredentials,
    'releaseName': obj.releaseName,
    'skipCrds': obj.skipCrds,
    'valueFiles': obj.valueFiles?.map(y => y),
    'values': obj.values,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kustomize holds kustomize specific options
 *
 * @schema ApplicationSpecForProviderSourcesKustomize
 */
export interface ApplicationSpecForProviderSourcesKustomize {
  /**
   * CommonAnnotations is a list of additional annotations to add to rendered manifests
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#commonAnnotations
   */
  readonly commonAnnotations?: { [key: string]: string };

  /**
   * CommonAnnotationsEnvsubst specifies whether to apply env variables substitution for annotation values
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#commonAnnotationsEnvsubst
   */
  readonly commonAnnotationsEnvsubst?: boolean;

  /**
   * CommonLabels is a list of additional labels to add to rendered manifests
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#commonLabels
   */
  readonly commonLabels?: { [key: string]: string };

  /**
   * ForceCommonAnnotations specifies whether to force applying common annotations to resources for Kustomize apps
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#forceCommonAnnotations
   */
  readonly forceCommonAnnotations?: boolean;

  /**
   * ForceCommonLabels specifies whether to force applying common labels to resources for Kustomize apps
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#forceCommonLabels
   */
  readonly forceCommonLabels?: boolean;

  /**
   * Images is a list of Kustomize image override specifications
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#images
   */
  readonly images?: string[];

  /**
   * NamePrefix is a prefix appended to resources for Kustomize apps
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#namePrefix
   */
  readonly namePrefix?: string;

  /**
   * NameSuffix is a suffix appended to resources for Kustomize apps
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#nameSuffix
   */
  readonly nameSuffix?: string;

  /**
   * Namespace sets the namespace that Kustomize adds to all resources
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#namespace
   */
  readonly namespace?: string;

  /**
   * Replicas is a list of Kustomize Replicas override specifications
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#replicas
   */
  readonly replicas?: ApplicationSpecForProviderSourcesKustomizeReplicas[];

  /**
   * Version controls which version of Kustomize to use for rendering manifests
   *
   * @schema ApplicationSpecForProviderSourcesKustomize#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesKustomize' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesKustomize(obj: ApplicationSpecForProviderSourcesKustomize | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAnnotations': ((obj.commonAnnotations) === undefined) ? undefined : (Object.entries(obj.commonAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'commonAnnotationsEnvsubst': obj.commonAnnotationsEnvsubst,
    'commonLabels': ((obj.commonLabels) === undefined) ? undefined : (Object.entries(obj.commonLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'forceCommonAnnotations': obj.forceCommonAnnotations,
    'forceCommonLabels': obj.forceCommonLabels,
    'images': obj.images?.map(y => y),
    'namePrefix': obj.namePrefix,
    'nameSuffix': obj.nameSuffix,
    'namespace': obj.namespace,
    'replicas': obj.replicas?.map(y => toJson_ApplicationSpecForProviderSourcesKustomizeReplicas(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Plugin holds config management plugin specific options
 *
 * @schema ApplicationSpecForProviderSourcesPlugin
 */
export interface ApplicationSpecForProviderSourcesPlugin {
  /**
   * Env holds options specific to config management plugins
   *
   * @schema ApplicationSpecForProviderSourcesPlugin#env
   */
  readonly env?: ApplicationSpecForProviderSourcesPluginEnv[];

  /**
   * @schema ApplicationSpecForProviderSourcesPlugin#name
   */
  readonly name?: string;

  /**
   * ApplicationSourcePluginParameters is a list of specific config management parameters
   *
   * @schema ApplicationSpecForProviderSourcesPlugin#parameters
   */
  readonly parameters?: ApplicationSpecForProviderSourcesPluginParameters[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesPlugin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesPlugin(obj: ApplicationSpecForProviderSourcesPlugin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_ApplicationSpecForProviderSourcesPluginEnv(y)),
    'name': obj.name,
    'parameters': obj.parameters?.map(y => toJson_ApplicationSpecForProviderSourcesPluginParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Automated will keep an application synced to the target revision
 *
 * @schema ApplicationSpecForProviderSyncPolicyAutomated
 */
export interface ApplicationSpecForProviderSyncPolicyAutomated {
  /**
   * AllowEmpty allows apps have zero live resources (default: false)
   *
   * @schema ApplicationSpecForProviderSyncPolicyAutomated#allowEmpty
   */
  readonly allowEmpty?: boolean;

  /**
   * Prune specifies whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false)
   *
   * @schema ApplicationSpecForProviderSyncPolicyAutomated#prune
   */
  readonly prune?: boolean;

  /**
   * SelfHeal specifes whether to revert resources back to their desired state upon modification in the cluster (default: false)
   *
   * @schema ApplicationSpecForProviderSyncPolicyAutomated#selfHeal
   */
  readonly selfHeal?: boolean;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSyncPolicyAutomated' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSyncPolicyAutomated(obj: ApplicationSpecForProviderSyncPolicyAutomated | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowEmpty': obj.allowEmpty,
    'prune': obj.prune,
    'selfHeal': obj.selfHeal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ManagedNamespaceMetadata controls metadata in the given namespace (if CreateNamespace=true)
 *
 * @schema ApplicationSpecForProviderSyncPolicyManagedNamespaceMetadata
 */
export interface ApplicationSpecForProviderSyncPolicyManagedNamespaceMetadata {
  /**
   * @schema ApplicationSpecForProviderSyncPolicyManagedNamespaceMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ApplicationSpecForProviderSyncPolicyManagedNamespaceMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSyncPolicyManagedNamespaceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSyncPolicyManagedNamespaceMetadata(obj: ApplicationSpecForProviderSyncPolicyManagedNamespaceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Retry controls failed sync retry behavior
 *
 * @schema ApplicationSpecForProviderSyncPolicyRetry
 */
export interface ApplicationSpecForProviderSyncPolicyRetry {
  /**
   * Backoff controls how to backoff on subsequent retries of failed syncs
   *
   * @schema ApplicationSpecForProviderSyncPolicyRetry#backoff
   */
  readonly backoff?: ApplicationSpecForProviderSyncPolicyRetryBackoff;

  /**
   * Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
   *
   * @schema ApplicationSpecForProviderSyncPolicyRetry#limit
   */
  readonly limit?: number;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSyncPolicyRetry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSyncPolicyRetry(obj: ApplicationSpecForProviderSyncPolicyRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backoff': toJson_ApplicationSpecForProviderSyncPolicyRetryBackoff(obj.backoff),
    'limit': obj.limit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderRefPolicyResolution
 */
export enum ApplicationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderRefPolicyResolve
 */
export enum ApplicationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderDestinationServerRefPolicy
 */
export interface ApplicationSpecForProviderDestinationServerRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderDestinationServerRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderDestinationServerRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderDestinationServerRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderDestinationServerRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderDestinationServerRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderDestinationServerRefPolicy(obj: ApplicationSpecForProviderDestinationServerRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderDestinationServerSelectorPolicy
 */
export interface ApplicationSpecForProviderDestinationServerSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderDestinationServerSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderDestinationServerSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderDestinationServerSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderDestinationServerSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderDestinationServerSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderDestinationServerSelectorPolicy(obj: ApplicationSpecForProviderDestinationServerSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Jsonnet holds options specific to Jsonnet
 *
 * @schema ApplicationSpecForProviderSourceDirectoryJsonnet
 */
export interface ApplicationSpecForProviderSourceDirectoryJsonnet {
  /**
   * ExtVars is a list of Jsonnet External Variables
   *
   * @schema ApplicationSpecForProviderSourceDirectoryJsonnet#extVars
   */
  readonly extVars?: ApplicationSpecForProviderSourceDirectoryJsonnetExtVars[];

  /**
   * Additional library search dirs
   *
   * @schema ApplicationSpecForProviderSourceDirectoryJsonnet#libs
   */
  readonly libs?: string[];

  /**
   * TLAS is a list of Jsonnet Top-level Arguments
   *
   * @schema ApplicationSpecForProviderSourceDirectoryJsonnet#tlas
   */
  readonly tlas?: ApplicationSpecForProviderSourceDirectoryJsonnetTlas[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourceDirectoryJsonnet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourceDirectoryJsonnet(obj: ApplicationSpecForProviderSourceDirectoryJsonnet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extVars': obj.extVars?.map(y => toJson_ApplicationSpecForProviderSourceDirectoryJsonnetExtVars(y)),
    'libs': obj.libs?.map(y => y),
    'tlas': obj.tlas?.map(y => toJson_ApplicationSpecForProviderSourceDirectoryJsonnetTlas(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HelmFileParameter is a file parameter that's passed to helm template during manifest generation
 *
 * @schema ApplicationSpecForProviderSourceHelmFileParameters
 */
export interface ApplicationSpecForProviderSourceHelmFileParameters {
  /**
   * Name is the name of the Helm parameter
   *
   * @schema ApplicationSpecForProviderSourceHelmFileParameters#name
   */
  readonly name?: string;

  /**
   * Path is the path to the file containing the values for the Helm parameter
   *
   * @schema ApplicationSpecForProviderSourceHelmFileParameters#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourceHelmFileParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourceHelmFileParameters(obj: ApplicationSpecForProviderSourceHelmFileParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HelmParameter is a parameter that's passed to helm template during manifest generation
 *
 * @schema ApplicationSpecForProviderSourceHelmParameters
 */
export interface ApplicationSpecForProviderSourceHelmParameters {
  /**
   * ForceString determines whether to tell Helm to interpret booleans and numbers as strings
   *
   * @schema ApplicationSpecForProviderSourceHelmParameters#forceString
   */
  readonly forceString?: boolean;

  /**
   * Name is the name of the Helm parameter
   *
   * @schema ApplicationSpecForProviderSourceHelmParameters#name
   */
  readonly name?: string;

  /**
   * Value is the value for the Helm parameter
   *
   * @schema ApplicationSpecForProviderSourceHelmParameters#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourceHelmParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourceHelmParameters(obj: ApplicationSpecForProviderSourceHelmParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceString': obj.forceString,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KustomizeReplica override specifications
 *
 * @schema ApplicationSpecForProviderSourceKustomizeReplicas
 */
export interface ApplicationSpecForProviderSourceKustomizeReplicas {
  /**
   * Number of replicas
   *
   * @schema ApplicationSpecForProviderSourceKustomizeReplicas#count
   */
  readonly count: ApplicationSpecForProviderSourceKustomizeReplicasCount;

  /**
   * Name of Deployment or StatefulSet
   *
   * @schema ApplicationSpecForProviderSourceKustomizeReplicas#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourceKustomizeReplicas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourceKustomizeReplicas(obj: ApplicationSpecForProviderSourceKustomizeReplicas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count?.value,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvEntry represents an entry in the application's environment
 *
 * @schema ApplicationSpecForProviderSourcePluginEnv
 */
export interface ApplicationSpecForProviderSourcePluginEnv {
  /**
   * Name is the name of the variable, usually expressed in uppercase
   *
   * @schema ApplicationSpecForProviderSourcePluginEnv#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable
   *
   * @schema ApplicationSpecForProviderSourcePluginEnv#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcePluginEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcePluginEnv(obj: ApplicationSpecForProviderSourcePluginEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSourcePluginParameter holds options specific to config management parameters
 *
 * @schema ApplicationSpecForProviderSourcePluginParameters
 */
export interface ApplicationSpecForProviderSourcePluginParameters {
  /**
   * Array is the value of an array type parameter.
   *
   * @schema ApplicationSpecForProviderSourcePluginParameters#array
   */
  readonly array?: string[];

  /**
   * Map is the value of a map type parameter.
   *
   * @schema ApplicationSpecForProviderSourcePluginParameters#map
   */
  readonly map?: { [key: string]: string };

  /**
   * Name is the name identifying a parameter.
   *
   * @schema ApplicationSpecForProviderSourcePluginParameters#name
   */
  readonly name?: string;

  /**
   * String_ is the value of a string type parameter.
   *
   * @schema ApplicationSpecForProviderSourcePluginParameters#string
   */
  readonly string?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcePluginParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcePluginParameters(obj: ApplicationSpecForProviderSourcePluginParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'array': obj.array?.map(y => y),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'string': obj.string,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Jsonnet holds options specific to Jsonnet
 *
 * @schema ApplicationSpecForProviderSourcesDirectoryJsonnet
 */
export interface ApplicationSpecForProviderSourcesDirectoryJsonnet {
  /**
   * ExtVars is a list of Jsonnet External Variables
   *
   * @schema ApplicationSpecForProviderSourcesDirectoryJsonnet#extVars
   */
  readonly extVars?: ApplicationSpecForProviderSourcesDirectoryJsonnetExtVars[];

  /**
   * Additional library search dirs
   *
   * @schema ApplicationSpecForProviderSourcesDirectoryJsonnet#libs
   */
  readonly libs?: string[];

  /**
   * TLAS is a list of Jsonnet Top-level Arguments
   *
   * @schema ApplicationSpecForProviderSourcesDirectoryJsonnet#tlas
   */
  readonly tlas?: ApplicationSpecForProviderSourcesDirectoryJsonnetTlas[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesDirectoryJsonnet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesDirectoryJsonnet(obj: ApplicationSpecForProviderSourcesDirectoryJsonnet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extVars': obj.extVars?.map(y => toJson_ApplicationSpecForProviderSourcesDirectoryJsonnetExtVars(y)),
    'libs': obj.libs?.map(y => y),
    'tlas': obj.tlas?.map(y => toJson_ApplicationSpecForProviderSourcesDirectoryJsonnetTlas(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HelmFileParameter is a file parameter that's passed to helm template during manifest generation
 *
 * @schema ApplicationSpecForProviderSourcesHelmFileParameters
 */
export interface ApplicationSpecForProviderSourcesHelmFileParameters {
  /**
   * Name is the name of the Helm parameter
   *
   * @schema ApplicationSpecForProviderSourcesHelmFileParameters#name
   */
  readonly name?: string;

  /**
   * Path is the path to the file containing the values for the Helm parameter
   *
   * @schema ApplicationSpecForProviderSourcesHelmFileParameters#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesHelmFileParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesHelmFileParameters(obj: ApplicationSpecForProviderSourcesHelmFileParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HelmParameter is a parameter that's passed to helm template during manifest generation
 *
 * @schema ApplicationSpecForProviderSourcesHelmParameters
 */
export interface ApplicationSpecForProviderSourcesHelmParameters {
  /**
   * ForceString determines whether to tell Helm to interpret booleans and numbers as strings
   *
   * @schema ApplicationSpecForProviderSourcesHelmParameters#forceString
   */
  readonly forceString?: boolean;

  /**
   * Name is the name of the Helm parameter
   *
   * @schema ApplicationSpecForProviderSourcesHelmParameters#name
   */
  readonly name?: string;

  /**
   * Value is the value for the Helm parameter
   *
   * @schema ApplicationSpecForProviderSourcesHelmParameters#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesHelmParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesHelmParameters(obj: ApplicationSpecForProviderSourcesHelmParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceString': obj.forceString,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KustomizeReplica override specifications
 *
 * @schema ApplicationSpecForProviderSourcesKustomizeReplicas
 */
export interface ApplicationSpecForProviderSourcesKustomizeReplicas {
  /**
   * Number of replicas
   *
   * @schema ApplicationSpecForProviderSourcesKustomizeReplicas#count
   */
  readonly count: ApplicationSpecForProviderSourcesKustomizeReplicasCount;

  /**
   * Name of Deployment or StatefulSet
   *
   * @schema ApplicationSpecForProviderSourcesKustomizeReplicas#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesKustomizeReplicas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesKustomizeReplicas(obj: ApplicationSpecForProviderSourcesKustomizeReplicas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count?.value,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvEntry represents an entry in the application's environment
 *
 * @schema ApplicationSpecForProviderSourcesPluginEnv
 */
export interface ApplicationSpecForProviderSourcesPluginEnv {
  /**
   * Name is the name of the variable, usually expressed in uppercase
   *
   * @schema ApplicationSpecForProviderSourcesPluginEnv#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable
   *
   * @schema ApplicationSpecForProviderSourcesPluginEnv#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesPluginEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesPluginEnv(obj: ApplicationSpecForProviderSourcesPluginEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSourcePluginParameter holds options specific to config management parameters
 *
 * @schema ApplicationSpecForProviderSourcesPluginParameters
 */
export interface ApplicationSpecForProviderSourcesPluginParameters {
  /**
   * Array is the value of an array type parameter.
   *
   * @schema ApplicationSpecForProviderSourcesPluginParameters#array
   */
  readonly array?: string[];

  /**
   * Map is the value of a map type parameter.
   *
   * @schema ApplicationSpecForProviderSourcesPluginParameters#map
   */
  readonly map?: { [key: string]: string };

  /**
   * Name is the name identifying a parameter.
   *
   * @schema ApplicationSpecForProviderSourcesPluginParameters#name
   */
  readonly name?: string;

  /**
   * String_ is the value of a string type parameter.
   *
   * @schema ApplicationSpecForProviderSourcesPluginParameters#string
   */
  readonly string?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesPluginParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesPluginParameters(obj: ApplicationSpecForProviderSourcesPluginParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'array': obj.array?.map(y => y),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'string': obj.string,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backoff controls how to backoff on subsequent retries of failed syncs
 *
 * @schema ApplicationSpecForProviderSyncPolicyRetryBackoff
 */
export interface ApplicationSpecForProviderSyncPolicyRetryBackoff {
  /**
   * Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h")
   *
   * @schema ApplicationSpecForProviderSyncPolicyRetryBackoff#duration
   */
  readonly duration?: string;

  /**
   * Factor is a factor to multiply the base duration after each failed retry
   *
   * @schema ApplicationSpecForProviderSyncPolicyRetryBackoff#factor
   */
  readonly factor?: number;

  /**
   * MaxDuration is the maximum amount of time allowed for the backoff strategy
   *
   * @schema ApplicationSpecForProviderSyncPolicyRetryBackoff#maxDuration
   */
  readonly maxDuration?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSyncPolicyRetryBackoff' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSyncPolicyRetryBackoff(obj: ApplicationSpecForProviderSyncPolicyRetryBackoff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'duration': obj.duration,
    'factor': obj.factor,
    'maxDuration': obj.maxDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderDestinationServerRefPolicyResolution
 */
export enum ApplicationSpecForProviderDestinationServerRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderDestinationServerRefPolicyResolve
 */
export enum ApplicationSpecForProviderDestinationServerRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderDestinationServerSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderDestinationServerSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderDestinationServerSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderDestinationServerSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * JsonnetVar represents a variable to be passed to jsonnet during manifest generation
 *
 * @schema ApplicationSpecForProviderSourceDirectoryJsonnetExtVars
 */
export interface ApplicationSpecForProviderSourceDirectoryJsonnetExtVars {
  /**
   * @schema ApplicationSpecForProviderSourceDirectoryJsonnetExtVars#code
   */
  readonly code?: boolean;

  /**
   * @schema ApplicationSpecForProviderSourceDirectoryJsonnetExtVars#name
   */
  readonly name: string;

  /**
   * @schema ApplicationSpecForProviderSourceDirectoryJsonnetExtVars#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourceDirectoryJsonnetExtVars' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourceDirectoryJsonnetExtVars(obj: ApplicationSpecForProviderSourceDirectoryJsonnetExtVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JsonnetVar represents a variable to be passed to jsonnet during manifest generation
 *
 * @schema ApplicationSpecForProviderSourceDirectoryJsonnetTlas
 */
export interface ApplicationSpecForProviderSourceDirectoryJsonnetTlas {
  /**
   * @schema ApplicationSpecForProviderSourceDirectoryJsonnetTlas#code
   */
  readonly code?: boolean;

  /**
   * @schema ApplicationSpecForProviderSourceDirectoryJsonnetTlas#name
   */
  readonly name: string;

  /**
   * @schema ApplicationSpecForProviderSourceDirectoryJsonnetTlas#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourceDirectoryJsonnetTlas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourceDirectoryJsonnetTlas(obj: ApplicationSpecForProviderSourceDirectoryJsonnetTlas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Number of replicas
 *
 * @schema ApplicationSpecForProviderSourceKustomizeReplicasCount
 */
export class ApplicationSpecForProviderSourceKustomizeReplicasCount {
  public static fromNumber(value: number): ApplicationSpecForProviderSourceKustomizeReplicasCount {
    return new ApplicationSpecForProviderSourceKustomizeReplicasCount(value);
  }
  public static fromString(value: string): ApplicationSpecForProviderSourceKustomizeReplicasCount {
    return new ApplicationSpecForProviderSourceKustomizeReplicasCount(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * JsonnetVar represents a variable to be passed to jsonnet during manifest generation
 *
 * @schema ApplicationSpecForProviderSourcesDirectoryJsonnetExtVars
 */
export interface ApplicationSpecForProviderSourcesDirectoryJsonnetExtVars {
  /**
   * @schema ApplicationSpecForProviderSourcesDirectoryJsonnetExtVars#code
   */
  readonly code?: boolean;

  /**
   * @schema ApplicationSpecForProviderSourcesDirectoryJsonnetExtVars#name
   */
  readonly name: string;

  /**
   * @schema ApplicationSpecForProviderSourcesDirectoryJsonnetExtVars#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesDirectoryJsonnetExtVars' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesDirectoryJsonnetExtVars(obj: ApplicationSpecForProviderSourcesDirectoryJsonnetExtVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JsonnetVar represents a variable to be passed to jsonnet during manifest generation
 *
 * @schema ApplicationSpecForProviderSourcesDirectoryJsonnetTlas
 */
export interface ApplicationSpecForProviderSourcesDirectoryJsonnetTlas {
  /**
   * @schema ApplicationSpecForProviderSourcesDirectoryJsonnetTlas#code
   */
  readonly code?: boolean;

  /**
   * @schema ApplicationSpecForProviderSourcesDirectoryJsonnetTlas#name
   */
  readonly name: string;

  /**
   * @schema ApplicationSpecForProviderSourcesDirectoryJsonnetTlas#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderSourcesDirectoryJsonnetTlas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderSourcesDirectoryJsonnetTlas(obj: ApplicationSpecForProviderSourcesDirectoryJsonnetTlas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Number of replicas
 *
 * @schema ApplicationSpecForProviderSourcesKustomizeReplicasCount
 */
export class ApplicationSpecForProviderSourcesKustomizeReplicasCount {
  public static fromNumber(value: number): ApplicationSpecForProviderSourcesKustomizeReplicasCount {
    return new ApplicationSpecForProviderSourcesKustomizeReplicasCount(value);
  }
  public static fromString(value: string): ApplicationSpecForProviderSourcesKustomizeReplicasCount {
    return new ApplicationSpecForProviderSourcesKustomizeReplicasCount(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

