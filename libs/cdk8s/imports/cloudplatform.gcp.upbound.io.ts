// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Folder is the Schema for the Folders API. Allows management of a Google Cloud Platform folder.
 *
 * @schema Folder
 */
export class Folder extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Folder"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'Folder',
  }

  /**
   * Renders a Kubernetes manifest for "Folder".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FolderProps): any {
    return {
      ...Folder.GVK,
      ...toJson_FolderProps(props),
    };
  }

  /**
   * Defines a "Folder" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FolderProps) {
    super(scope, id, {
      ...Folder.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Folder.GVK,
      ...toJson_FolderProps(resolved),
    };
  }
}

/**
 * Folder is the Schema for the Folders API. Allows management of a Google Cloud Platform folder.
 *
 * @schema Folder
 */
export interface FolderProps {
  /**
   * @schema Folder#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FolderSpec defines the desired state of Folder
   *
   * @schema Folder#spec
   */
  readonly spec: FolderSpec;

}

/**
 * Converts an object of type 'FolderProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderProps(obj: FolderProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FolderSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FolderSpec defines the desired state of Folder
 *
 * @schema FolderSpec
 */
export interface FolderSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FolderSpec#deletionPolicy
   */
  readonly deletionPolicy?: FolderSpecDeletionPolicy;

  /**
   * @schema FolderSpec#forProvider
   */
  readonly forProvider: FolderSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FolderSpec#initProvider
   */
  readonly initProvider?: FolderSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FolderSpec#managementPolicies
   */
  readonly managementPolicies?: FolderSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FolderSpec#providerConfigRef
   */
  readonly providerConfigRef?: FolderSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FolderSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FolderSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FolderSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FolderSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FolderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpec(obj: FolderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FolderSpecForProvider(obj.forProvider),
    'initProvider': toJson_FolderSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FolderSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FolderSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FolderSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FolderSpecDeletionPolicy
 */
export enum FolderSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FolderSpecForProvider
 */
export interface FolderSpecForProvider {
  /**
   * The folder’s display name. A folder’s display name must be unique amongst its siblings, e.g. no two folders with the same parent can share the same display name. The display name must start and end with a letter or digit, may contain letters, digits, spaces, hyphens and underscores and can be no longer than 30 characters.
   *
   * @schema FolderSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The resource name of the parent Folder or Organization. Must be of the form folders/{folder_id} or organizations/{org_id}.
   *
   * @schema FolderSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Reference to a Folder in cloudplatform to populate parent.
   *
   * @schema FolderSpecForProvider#parentRef
   */
  readonly parentRef?: FolderSpecForProviderParentRef;

  /**
   * Selector for a Folder in cloudplatform to populate parent.
   *
   * @schema FolderSpecForProvider#parentSelector
   */
  readonly parentSelector?: FolderSpecForProviderParentSelector;

}

/**
 * Converts an object of type 'FolderSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecForProvider(obj: FolderSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'parent': obj.parent,
    'parentRef': toJson_FolderSpecForProviderParentRef(obj.parentRef),
    'parentSelector': toJson_FolderSpecForProviderParentSelector(obj.parentSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FolderSpecInitProvider
 */
export interface FolderSpecInitProvider {
  /**
   * The folder’s display name. A folder’s display name must be unique amongst its siblings, e.g. no two folders with the same parent can share the same display name. The display name must start and end with a letter or digit, may contain letters, digits, spaces, hyphens and underscores and can be no longer than 30 characters.
   *
   * @schema FolderSpecInitProvider#displayName
   */
  readonly displayName?: string;

}

/**
 * Converts an object of type 'FolderSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecInitProvider(obj: FolderSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FolderSpecManagementPolicies
 */
export enum FolderSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FolderSpecProviderConfigRef
 */
export interface FolderSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FolderSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FolderSpecProviderConfigRef#policy
   */
  readonly policy?: FolderSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FolderSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecProviderConfigRef(obj: FolderSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FolderSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FolderSpecPublishConnectionDetailsTo
 */
export interface FolderSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FolderSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FolderSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FolderSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FolderSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FolderSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FolderSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecPublishConnectionDetailsTo(obj: FolderSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FolderSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FolderSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FolderSpecWriteConnectionSecretToRef
 */
export interface FolderSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FolderSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FolderSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FolderSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecWriteConnectionSecretToRef(obj: FolderSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Folder in cloudplatform to populate parent.
 *
 * @schema FolderSpecForProviderParentRef
 */
export interface FolderSpecForProviderParentRef {
  /**
   * Name of the referenced object.
   *
   * @schema FolderSpecForProviderParentRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FolderSpecForProviderParentRef#policy
   */
  readonly policy?: FolderSpecForProviderParentRefPolicy;

}

/**
 * Converts an object of type 'FolderSpecForProviderParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecForProviderParentRef(obj: FolderSpecForProviderParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FolderSpecForProviderParentRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Folder in cloudplatform to populate parent.
 *
 * @schema FolderSpecForProviderParentSelector
 */
export interface FolderSpecForProviderParentSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FolderSpecForProviderParentSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FolderSpecForProviderParentSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FolderSpecForProviderParentSelector#policy
   */
  readonly policy?: FolderSpecForProviderParentSelectorPolicy;

}

/**
 * Converts an object of type 'FolderSpecForProviderParentSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecForProviderParentSelector(obj: FolderSpecForProviderParentSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FolderSpecForProviderParentSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FolderSpecProviderConfigRefPolicy
 */
export interface FolderSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FolderSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FolderSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FolderSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FolderSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FolderSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecProviderConfigRefPolicy(obj: FolderSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FolderSpecPublishConnectionDetailsToConfigRef
 */
export interface FolderSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FolderSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FolderSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FolderSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FolderSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecPublishConnectionDetailsToConfigRef(obj: FolderSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FolderSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FolderSpecPublishConnectionDetailsToMetadata
 */
export interface FolderSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FolderSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FolderSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FolderSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FolderSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecPublishConnectionDetailsToMetadata(obj: FolderSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FolderSpecForProviderParentRefPolicy
 */
export interface FolderSpecForProviderParentRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FolderSpecForProviderParentRefPolicy#resolution
   */
  readonly resolution?: FolderSpecForProviderParentRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FolderSpecForProviderParentRefPolicy#resolve
   */
  readonly resolve?: FolderSpecForProviderParentRefPolicyResolve;

}

/**
 * Converts an object of type 'FolderSpecForProviderParentRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecForProviderParentRefPolicy(obj: FolderSpecForProviderParentRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FolderSpecForProviderParentSelectorPolicy
 */
export interface FolderSpecForProviderParentSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FolderSpecForProviderParentSelectorPolicy#resolution
   */
  readonly resolution?: FolderSpecForProviderParentSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FolderSpecForProviderParentSelectorPolicy#resolve
   */
  readonly resolve?: FolderSpecForProviderParentSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FolderSpecForProviderParentSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecForProviderParentSelectorPolicy(obj: FolderSpecForProviderParentSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FolderSpecProviderConfigRefPolicyResolution
 */
export enum FolderSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FolderSpecProviderConfigRefPolicyResolve
 */
export enum FolderSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FolderSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FolderSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FolderSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FolderSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FolderSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FolderSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FolderSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderSpecPublishConnectionDetailsToConfigRefPolicy(obj: FolderSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FolderSpecForProviderParentRefPolicyResolution
 */
export enum FolderSpecForProviderParentRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FolderSpecForProviderParentRefPolicyResolve
 */
export enum FolderSpecForProviderParentRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FolderSpecForProviderParentSelectorPolicyResolution
 */
export enum FolderSpecForProviderParentSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FolderSpecForProviderParentSelectorPolicyResolve
 */
export enum FolderSpecForProviderParentSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FolderSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FolderSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FolderSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FolderSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FolderIAMMember is the Schema for the FolderIAMMembers API. <no value>
 *
 * @schema FolderIAMMember
 */
export class FolderIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FolderIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'FolderIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "FolderIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FolderIamMemberProps): any {
    return {
      ...FolderIamMember.GVK,
      ...toJson_FolderIamMemberProps(props),
    };
  }

  /**
   * Defines a "FolderIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FolderIamMemberProps) {
    super(scope, id, {
      ...FolderIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FolderIamMember.GVK,
      ...toJson_FolderIamMemberProps(resolved),
    };
  }
}

/**
 * FolderIAMMember is the Schema for the FolderIAMMembers API. <no value>
 *
 * @schema FolderIAMMember
 */
export interface FolderIamMemberProps {
  /**
   * @schema FolderIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FolderIAMMemberSpec defines the desired state of FolderIAMMember
   *
   * @schema FolderIAMMember#spec
   */
  readonly spec: FolderIamMemberSpec;

}

/**
 * Converts an object of type 'FolderIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberProps(obj: FolderIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FolderIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FolderIAMMemberSpec defines the desired state of FolderIAMMember
 *
 * @schema FolderIamMemberSpec
 */
export interface FolderIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FolderIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: FolderIamMemberSpecDeletionPolicy;

  /**
   * @schema FolderIamMemberSpec#forProvider
   */
  readonly forProvider: FolderIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FolderIamMemberSpec#initProvider
   */
  readonly initProvider?: FolderIamMemberSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FolderIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: FolderIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FolderIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: FolderIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FolderIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FolderIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FolderIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FolderIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FolderIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpec(obj: FolderIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FolderIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_FolderIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FolderIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FolderIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FolderIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FolderIamMemberSpecDeletionPolicy
 */
export enum FolderIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FolderIamMemberSpecForProvider
 */
export interface FolderIamMemberSpecForProvider {
  /**
   * @schema FolderIamMemberSpecForProvider#condition
   */
  readonly condition?: FolderIamMemberSpecForProviderCondition[];

  /**
   * @schema FolderIamMemberSpecForProvider#folder
   */
  readonly folder?: string;

  /**
   * Reference to a Folder to populate folder.
   *
   * @schema FolderIamMemberSpecForProvider#folderRef
   */
  readonly folderRef?: FolderIamMemberSpecForProviderFolderRef;

  /**
   * Selector for a Folder to populate folder.
   *
   * @schema FolderIamMemberSpecForProvider#folderSelector
   */
  readonly folderSelector?: FolderIamMemberSpecForProviderFolderSelector;

  /**
   * @schema FolderIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema FolderIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'FolderIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecForProvider(obj: FolderIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_FolderIamMemberSpecForProviderCondition(y)),
    'folder': obj.folder,
    'folderRef': toJson_FolderIamMemberSpecForProviderFolderRef(obj.folderRef),
    'folderSelector': toJson_FolderIamMemberSpecForProviderFolderSelector(obj.folderSelector),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FolderIamMemberSpecInitProvider
 */
export interface FolderIamMemberSpecInitProvider {
  /**
   * @schema FolderIamMemberSpecInitProvider#condition
   */
  readonly condition?: FolderIamMemberSpecInitProviderCondition[];

  /**
   * @schema FolderIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema FolderIamMemberSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'FolderIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecInitProvider(obj: FolderIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_FolderIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FolderIamMemberSpecManagementPolicies
 */
export enum FolderIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FolderIamMemberSpecProviderConfigRef
 */
export interface FolderIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FolderIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FolderIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: FolderIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FolderIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecProviderConfigRef(obj: FolderIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FolderIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FolderIamMemberSpecPublishConnectionDetailsTo
 */
export interface FolderIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FolderIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FolderIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FolderIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FolderIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FolderIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FolderIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecPublishConnectionDetailsTo(obj: FolderIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FolderIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FolderIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FolderIamMemberSpecWriteConnectionSecretToRef
 */
export interface FolderIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FolderIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FolderIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FolderIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecWriteConnectionSecretToRef(obj: FolderIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FolderIamMemberSpecForProviderCondition
 */
export interface FolderIamMemberSpecForProviderCondition {
  /**
   * @schema FolderIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema FolderIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema FolderIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'FolderIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecForProviderCondition(obj: FolderIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Folder to populate folder.
 *
 * @schema FolderIamMemberSpecForProviderFolderRef
 */
export interface FolderIamMemberSpecForProviderFolderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FolderIamMemberSpecForProviderFolderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FolderIamMemberSpecForProviderFolderRef#policy
   */
  readonly policy?: FolderIamMemberSpecForProviderFolderRefPolicy;

}

/**
 * Converts an object of type 'FolderIamMemberSpecForProviderFolderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecForProviderFolderRef(obj: FolderIamMemberSpecForProviderFolderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FolderIamMemberSpecForProviderFolderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Folder to populate folder.
 *
 * @schema FolderIamMemberSpecForProviderFolderSelector
 */
export interface FolderIamMemberSpecForProviderFolderSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FolderIamMemberSpecForProviderFolderSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FolderIamMemberSpecForProviderFolderSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FolderIamMemberSpecForProviderFolderSelector#policy
   */
  readonly policy?: FolderIamMemberSpecForProviderFolderSelectorPolicy;

}

/**
 * Converts an object of type 'FolderIamMemberSpecForProviderFolderSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecForProviderFolderSelector(obj: FolderIamMemberSpecForProviderFolderSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FolderIamMemberSpecForProviderFolderSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FolderIamMemberSpecInitProviderCondition
 */
export interface FolderIamMemberSpecInitProviderCondition {
  /**
   * @schema FolderIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema FolderIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema FolderIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'FolderIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecInitProviderCondition(obj: FolderIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FolderIamMemberSpecProviderConfigRefPolicy
 */
export interface FolderIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FolderIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FolderIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FolderIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FolderIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FolderIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecProviderConfigRefPolicy(obj: FolderIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FolderIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface FolderIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FolderIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FolderIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FolderIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecPublishConnectionDetailsToConfigRef(obj: FolderIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FolderIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface FolderIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FolderIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FolderIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FolderIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FolderIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecPublishConnectionDetailsToMetadata(obj: FolderIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FolderIamMemberSpecForProviderFolderRefPolicy
 */
export interface FolderIamMemberSpecForProviderFolderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FolderIamMemberSpecForProviderFolderRefPolicy#resolution
   */
  readonly resolution?: FolderIamMemberSpecForProviderFolderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FolderIamMemberSpecForProviderFolderRefPolicy#resolve
   */
  readonly resolve?: FolderIamMemberSpecForProviderFolderRefPolicyResolve;

}

/**
 * Converts an object of type 'FolderIamMemberSpecForProviderFolderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecForProviderFolderRefPolicy(obj: FolderIamMemberSpecForProviderFolderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FolderIamMemberSpecForProviderFolderSelectorPolicy
 */
export interface FolderIamMemberSpecForProviderFolderSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FolderIamMemberSpecForProviderFolderSelectorPolicy#resolution
   */
  readonly resolution?: FolderIamMemberSpecForProviderFolderSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FolderIamMemberSpecForProviderFolderSelectorPolicy#resolve
   */
  readonly resolve?: FolderIamMemberSpecForProviderFolderSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FolderIamMemberSpecForProviderFolderSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecForProviderFolderSelectorPolicy(obj: FolderIamMemberSpecForProviderFolderSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FolderIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum FolderIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FolderIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum FolderIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FolderIamMemberSpecForProviderFolderRefPolicyResolution
 */
export enum FolderIamMemberSpecForProviderFolderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FolderIamMemberSpecForProviderFolderRefPolicyResolve
 */
export enum FolderIamMemberSpecForProviderFolderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FolderIamMemberSpecForProviderFolderSelectorPolicyResolution
 */
export enum FolderIamMemberSpecForProviderFolderSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FolderIamMemberSpecForProviderFolderSelectorPolicyResolve
 */
export enum FolderIamMemberSpecForProviderFolderSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FolderIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OrganizationIAMAuditConfig is the Schema for the OrganizationIAMAuditConfigs API. <no value>
 *
 * @schema OrganizationIAMAuditConfig
 */
export class OrganizationIamAuditConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OrganizationIAMAuditConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'OrganizationIAMAuditConfig',
  }

  /**
   * Renders a Kubernetes manifest for "OrganizationIAMAuditConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OrganizationIamAuditConfigProps): any {
    return {
      ...OrganizationIamAuditConfig.GVK,
      ...toJson_OrganizationIamAuditConfigProps(props),
    };
  }

  /**
   * Defines a "OrganizationIAMAuditConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OrganizationIamAuditConfigProps) {
    super(scope, id, {
      ...OrganizationIamAuditConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OrganizationIamAuditConfig.GVK,
      ...toJson_OrganizationIamAuditConfigProps(resolved),
    };
  }
}

/**
 * OrganizationIAMAuditConfig is the Schema for the OrganizationIAMAuditConfigs API. <no value>
 *
 * @schema OrganizationIAMAuditConfig
 */
export interface OrganizationIamAuditConfigProps {
  /**
   * @schema OrganizationIAMAuditConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OrganizationIAMAuditConfigSpec defines the desired state of OrganizationIAMAuditConfig
   *
   * @schema OrganizationIAMAuditConfig#spec
   */
  readonly spec: OrganizationIamAuditConfigSpec;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigProps(obj: OrganizationIamAuditConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OrganizationIamAuditConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrganizationIAMAuditConfigSpec defines the desired state of OrganizationIAMAuditConfig
 *
 * @schema OrganizationIamAuditConfigSpec
 */
export interface OrganizationIamAuditConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OrganizationIamAuditConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: OrganizationIamAuditConfigSpecDeletionPolicy;

  /**
   * @schema OrganizationIamAuditConfigSpec#forProvider
   */
  readonly forProvider: OrganizationIamAuditConfigSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema OrganizationIamAuditConfigSpec#initProvider
   */
  readonly initProvider?: OrganizationIamAuditConfigSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema OrganizationIamAuditConfigSpec#managementPolicies
   */
  readonly managementPolicies?: OrganizationIamAuditConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OrganizationIamAuditConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: OrganizationIamAuditConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OrganizationIamAuditConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OrganizationIamAuditConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OrganizationIamAuditConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OrganizationIamAuditConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpec(obj: OrganizationIamAuditConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OrganizationIamAuditConfigSpecForProvider(obj.forProvider),
    'initProvider': toJson_OrganizationIamAuditConfigSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_OrganizationIamAuditConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_OrganizationIamAuditConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OrganizationIamAuditConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OrganizationIamAuditConfigSpecDeletionPolicy
 */
export enum OrganizationIamAuditConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OrganizationIamAuditConfigSpecForProvider
 */
export interface OrganizationIamAuditConfigSpecForProvider {
  /**
   * @schema OrganizationIamAuditConfigSpecForProvider#auditLogConfig
   */
  readonly auditLogConfig?: OrganizationIamAuditConfigSpecForProviderAuditLogConfig[];

  /**
   * @schema OrganizationIamAuditConfigSpecForProvider#orgId
   */
  readonly orgId?: string;

  /**
   * @schema OrganizationIamAuditConfigSpecForProvider#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecForProvider(obj: OrganizationIamAuditConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auditLogConfig': obj.auditLogConfig?.map(y => toJson_OrganizationIamAuditConfigSpecForProviderAuditLogConfig(y)),
    'orgId': obj.orgId,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema OrganizationIamAuditConfigSpecInitProvider
 */
export interface OrganizationIamAuditConfigSpecInitProvider {
  /**
   * @schema OrganizationIamAuditConfigSpecInitProvider#auditLogConfig
   */
  readonly auditLogConfig?: OrganizationIamAuditConfigSpecInitProviderAuditLogConfig[];

  /**
   * @schema OrganizationIamAuditConfigSpecInitProvider#orgId
   */
  readonly orgId?: string;

  /**
   * @schema OrganizationIamAuditConfigSpecInitProvider#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecInitProvider(obj: OrganizationIamAuditConfigSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auditLogConfig': obj.auditLogConfig?.map(y => toJson_OrganizationIamAuditConfigSpecInitProviderAuditLogConfig(y)),
    'orgId': obj.orgId,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema OrganizationIamAuditConfigSpecManagementPolicies
 */
export enum OrganizationIamAuditConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OrganizationIamAuditConfigSpecProviderConfigRef
 */
export interface OrganizationIamAuditConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationIamAuditConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationIamAuditConfigSpecProviderConfigRef#policy
   */
  readonly policy?: OrganizationIamAuditConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecProviderConfigRef(obj: OrganizationIamAuditConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationIamAuditConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsTo
 */
export interface OrganizationIamAuditConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OrganizationIamAuditConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecPublishConnectionDetailsTo(obj: OrganizationIamAuditConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OrganizationIamAuditConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OrganizationIamAuditConfigSpecWriteConnectionSecretToRef
 */
export interface OrganizationIamAuditConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OrganizationIamAuditConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OrganizationIamAuditConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecWriteConnectionSecretToRef(obj: OrganizationIamAuditConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OrganizationIamAuditConfigSpecForProviderAuditLogConfig
 */
export interface OrganizationIamAuditConfigSpecForProviderAuditLogConfig {
  /**
   * @schema OrganizationIamAuditConfigSpecForProviderAuditLogConfig#exemptedMembers
   */
  readonly exemptedMembers?: string[];

  /**
   * @schema OrganizationIamAuditConfigSpecForProviderAuditLogConfig#logType
   */
  readonly logType?: string;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecForProviderAuditLogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecForProviderAuditLogConfig(obj: OrganizationIamAuditConfigSpecForProviderAuditLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exemptedMembers': obj.exemptedMembers?.map(y => y),
    'logType': obj.logType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OrganizationIamAuditConfigSpecInitProviderAuditLogConfig
 */
export interface OrganizationIamAuditConfigSpecInitProviderAuditLogConfig {
  /**
   * @schema OrganizationIamAuditConfigSpecInitProviderAuditLogConfig#exemptedMembers
   */
  readonly exemptedMembers?: string[];

  /**
   * @schema OrganizationIamAuditConfigSpecInitProviderAuditLogConfig#logType
   */
  readonly logType?: string;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecInitProviderAuditLogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecInitProviderAuditLogConfig(obj: OrganizationIamAuditConfigSpecInitProviderAuditLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exemptedMembers': obj.exemptedMembers?.map(y => y),
    'logType': obj.logType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationIamAuditConfigSpecProviderConfigRefPolicy
 */
export interface OrganizationIamAuditConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationIamAuditConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationIamAuditConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationIamAuditConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationIamAuditConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecProviderConfigRefPolicy(obj: OrganizationIamAuditConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRef(obj: OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToMetadata
 */
export interface OrganizationIamAuditConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecPublishConnectionDetailsToMetadata(obj: OrganizationIamAuditConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationIamAuditConfigSpecProviderConfigRefPolicyResolution
 */
export enum OrganizationIamAuditConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationIamAuditConfigSpecProviderConfigRefPolicyResolve
 */
export enum OrganizationIamAuditConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OrganizationIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OrganizationIAMCustomRole is the Schema for the OrganizationIAMCustomRoles API. Allows management of a customized Cloud IAM organization role.
 *
 * @schema OrganizationIAMCustomRole
 */
export class OrganizationIamCustomRole extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OrganizationIAMCustomRole"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'OrganizationIAMCustomRole',
  }

  /**
   * Renders a Kubernetes manifest for "OrganizationIAMCustomRole".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OrganizationIamCustomRoleProps): any {
    return {
      ...OrganizationIamCustomRole.GVK,
      ...toJson_OrganizationIamCustomRoleProps(props),
    };
  }

  /**
   * Defines a "OrganizationIAMCustomRole" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OrganizationIamCustomRoleProps) {
    super(scope, id, {
      ...OrganizationIamCustomRole.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OrganizationIamCustomRole.GVK,
      ...toJson_OrganizationIamCustomRoleProps(resolved),
    };
  }
}

/**
 * OrganizationIAMCustomRole is the Schema for the OrganizationIAMCustomRoles API. Allows management of a customized Cloud IAM organization role.
 *
 * @schema OrganizationIAMCustomRole
 */
export interface OrganizationIamCustomRoleProps {
  /**
   * @schema OrganizationIAMCustomRole#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OrganizationIAMCustomRoleSpec defines the desired state of OrganizationIAMCustomRole
   *
   * @schema OrganizationIAMCustomRole#spec
   */
  readonly spec: OrganizationIamCustomRoleSpec;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleProps(obj: OrganizationIamCustomRoleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OrganizationIamCustomRoleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrganizationIAMCustomRoleSpec defines the desired state of OrganizationIAMCustomRole
 *
 * @schema OrganizationIamCustomRoleSpec
 */
export interface OrganizationIamCustomRoleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OrganizationIamCustomRoleSpec#deletionPolicy
   */
  readonly deletionPolicy?: OrganizationIamCustomRoleSpecDeletionPolicy;

  /**
   * @schema OrganizationIamCustomRoleSpec#forProvider
   */
  readonly forProvider: OrganizationIamCustomRoleSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema OrganizationIamCustomRoleSpec#initProvider
   */
  readonly initProvider?: OrganizationIamCustomRoleSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema OrganizationIamCustomRoleSpec#managementPolicies
   */
  readonly managementPolicies?: OrganizationIamCustomRoleSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OrganizationIamCustomRoleSpec#providerConfigRef
   */
  readonly providerConfigRef?: OrganizationIamCustomRoleSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OrganizationIamCustomRoleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OrganizationIamCustomRoleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OrganizationIamCustomRoleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OrganizationIamCustomRoleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleSpec(obj: OrganizationIamCustomRoleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OrganizationIamCustomRoleSpecForProvider(obj.forProvider),
    'initProvider': toJson_OrganizationIamCustomRoleSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_OrganizationIamCustomRoleSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_OrganizationIamCustomRoleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OrganizationIamCustomRoleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OrganizationIamCustomRoleSpecDeletionPolicy
 */
export enum OrganizationIamCustomRoleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OrganizationIamCustomRoleSpecForProvider
 */
export interface OrganizationIamCustomRoleSpecForProvider {
  /**
   * A human-readable description for the role.
   *
   * @schema OrganizationIamCustomRoleSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The numeric ID of the organization in which you want to create a custom role.
   *
   * @schema OrganizationIamCustomRoleSpecForProvider#orgId
   */
  readonly orgId?: string;

  /**
   * The names of the permissions this role grants when bound in an IAM policy. At least one permission must be specified.
   *
   * @schema OrganizationIamCustomRoleSpecForProvider#permissions
   */
  readonly permissions?: string[];

  /**
   * The role id to use for this role.
   *
   * @schema OrganizationIamCustomRoleSpecForProvider#roleId
   */
  readonly roleId?: string;

  /**
   * The current launch stage of the role. Defaults to GA. List of possible stages is here.
   *
   * @default GA. List of possible stages is here.
   * @schema OrganizationIamCustomRoleSpecForProvider#stage
   */
  readonly stage?: string;

  /**
   * A human-readable title for the role.
   *
   * @schema OrganizationIamCustomRoleSpecForProvider#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleSpecForProvider(obj: OrganizationIamCustomRoleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'orgId': obj.orgId,
    'permissions': obj.permissions?.map(y => y),
    'roleId': obj.roleId,
    'stage': obj.stage,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema OrganizationIamCustomRoleSpecInitProvider
 */
export interface OrganizationIamCustomRoleSpecInitProvider {
  /**
   * A human-readable description for the role.
   *
   * @schema OrganizationIamCustomRoleSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The numeric ID of the organization in which you want to create a custom role.
   *
   * @schema OrganizationIamCustomRoleSpecInitProvider#orgId
   */
  readonly orgId?: string;

  /**
   * The names of the permissions this role grants when bound in an IAM policy. At least one permission must be specified.
   *
   * @schema OrganizationIamCustomRoleSpecInitProvider#permissions
   */
  readonly permissions?: string[];

  /**
   * The role id to use for this role.
   *
   * @schema OrganizationIamCustomRoleSpecInitProvider#roleId
   */
  readonly roleId?: string;

  /**
   * The current launch stage of the role. Defaults to GA. List of possible stages is here.
   *
   * @default GA. List of possible stages is here.
   * @schema OrganizationIamCustomRoleSpecInitProvider#stage
   */
  readonly stage?: string;

  /**
   * A human-readable title for the role.
   *
   * @schema OrganizationIamCustomRoleSpecInitProvider#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleSpecInitProvider(obj: OrganizationIamCustomRoleSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'orgId': obj.orgId,
    'permissions': obj.permissions?.map(y => y),
    'roleId': obj.roleId,
    'stage': obj.stage,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema OrganizationIamCustomRoleSpecManagementPolicies
 */
export enum OrganizationIamCustomRoleSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OrganizationIamCustomRoleSpecProviderConfigRef
 */
export interface OrganizationIamCustomRoleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationIamCustomRoleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationIamCustomRoleSpecProviderConfigRef#policy
   */
  readonly policy?: OrganizationIamCustomRoleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleSpecProviderConfigRef(obj: OrganizationIamCustomRoleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationIamCustomRoleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsTo
 */
export interface OrganizationIamCustomRoleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OrganizationIamCustomRoleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleSpecPublishConnectionDetailsTo(obj: OrganizationIamCustomRoleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OrganizationIamCustomRoleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OrganizationIamCustomRoleSpecWriteConnectionSecretToRef
 */
export interface OrganizationIamCustomRoleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OrganizationIamCustomRoleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OrganizationIamCustomRoleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleSpecWriteConnectionSecretToRef(obj: OrganizationIamCustomRoleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationIamCustomRoleSpecProviderConfigRefPolicy
 */
export interface OrganizationIamCustomRoleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationIamCustomRoleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationIamCustomRoleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationIamCustomRoleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationIamCustomRoleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleSpecProviderConfigRefPolicy(obj: OrganizationIamCustomRoleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRef
 */
export interface OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRef(obj: OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToMetadata
 */
export interface OrganizationIamCustomRoleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleSpecPublishConnectionDetailsToMetadata(obj: OrganizationIamCustomRoleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationIamCustomRoleSpecProviderConfigRefPolicyResolution
 */
export enum OrganizationIamCustomRoleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationIamCustomRoleSpecProviderConfigRefPolicyResolve
 */
export enum OrganizationIamCustomRoleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy(obj: OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OrganizationIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OrganizationIAMMember is the Schema for the OrganizationIAMMembers API. <no value>
 *
 * @schema OrganizationIAMMember
 */
export class OrganizationIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OrganizationIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'OrganizationIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "OrganizationIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OrganizationIamMemberProps): any {
    return {
      ...OrganizationIamMember.GVK,
      ...toJson_OrganizationIamMemberProps(props),
    };
  }

  /**
   * Defines a "OrganizationIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OrganizationIamMemberProps) {
    super(scope, id, {
      ...OrganizationIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OrganizationIamMember.GVK,
      ...toJson_OrganizationIamMemberProps(resolved),
    };
  }
}

/**
 * OrganizationIAMMember is the Schema for the OrganizationIAMMembers API. <no value>
 *
 * @schema OrganizationIAMMember
 */
export interface OrganizationIamMemberProps {
  /**
   * @schema OrganizationIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OrganizationIAMMemberSpec defines the desired state of OrganizationIAMMember
   *
   * @schema OrganizationIAMMember#spec
   */
  readonly spec: OrganizationIamMemberSpec;

}

/**
 * Converts an object of type 'OrganizationIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberProps(obj: OrganizationIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OrganizationIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrganizationIAMMemberSpec defines the desired state of OrganizationIAMMember
 *
 * @schema OrganizationIamMemberSpec
 */
export interface OrganizationIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OrganizationIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: OrganizationIamMemberSpecDeletionPolicy;

  /**
   * @schema OrganizationIamMemberSpec#forProvider
   */
  readonly forProvider: OrganizationIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema OrganizationIamMemberSpec#initProvider
   */
  readonly initProvider?: OrganizationIamMemberSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema OrganizationIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: OrganizationIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OrganizationIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: OrganizationIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OrganizationIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OrganizationIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OrganizationIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OrganizationIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpec(obj: OrganizationIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OrganizationIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_OrganizationIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_OrganizationIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_OrganizationIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OrganizationIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OrganizationIamMemberSpecDeletionPolicy
 */
export enum OrganizationIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OrganizationIamMemberSpecForProvider
 */
export interface OrganizationIamMemberSpecForProvider {
  /**
   * @schema OrganizationIamMemberSpecForProvider#condition
   */
  readonly condition?: OrganizationIamMemberSpecForProviderCondition[];

  /**
   * @schema OrganizationIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema OrganizationIamMemberSpecForProvider#orgId
   */
  readonly orgId?: string;

  /**
   * @schema OrganizationIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecForProvider(obj: OrganizationIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_OrganizationIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'orgId': obj.orgId,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema OrganizationIamMemberSpecInitProvider
 */
export interface OrganizationIamMemberSpecInitProvider {
  /**
   * @schema OrganizationIamMemberSpecInitProvider#condition
   */
  readonly condition?: OrganizationIamMemberSpecInitProviderCondition[];

  /**
   * @schema OrganizationIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema OrganizationIamMemberSpecInitProvider#orgId
   */
  readonly orgId?: string;

  /**
   * @schema OrganizationIamMemberSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecInitProvider(obj: OrganizationIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_OrganizationIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'orgId': obj.orgId,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema OrganizationIamMemberSpecManagementPolicies
 */
export enum OrganizationIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OrganizationIamMemberSpecProviderConfigRef
 */
export interface OrganizationIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: OrganizationIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecProviderConfigRef(obj: OrganizationIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OrganizationIamMemberSpecPublishConnectionDetailsTo
 */
export interface OrganizationIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OrganizationIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OrganizationIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OrganizationIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OrganizationIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OrganizationIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecPublishConnectionDetailsTo(obj: OrganizationIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OrganizationIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OrganizationIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OrganizationIamMemberSpecWriteConnectionSecretToRef
 */
export interface OrganizationIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OrganizationIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OrganizationIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecWriteConnectionSecretToRef(obj: OrganizationIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OrganizationIamMemberSpecForProviderCondition
 */
export interface OrganizationIamMemberSpecForProviderCondition {
  /**
   * @schema OrganizationIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema OrganizationIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema OrganizationIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecForProviderCondition(obj: OrganizationIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OrganizationIamMemberSpecInitProviderCondition
 */
export interface OrganizationIamMemberSpecInitProviderCondition {
  /**
   * @schema OrganizationIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema OrganizationIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema OrganizationIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecInitProviderCondition(obj: OrganizationIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OrganizationIamMemberSpecProviderConfigRefPolicy
 */
export interface OrganizationIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecProviderConfigRefPolicy(obj: OrganizationIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OrganizationIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface OrganizationIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OrganizationIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OrganizationIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecPublishConnectionDetailsToConfigRef(obj: OrganizationIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OrganizationIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface OrganizationIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OrganizationIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OrganizationIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecPublishConnectionDetailsToMetadata(obj: OrganizationIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum OrganizationIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum OrganizationIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OrganizationIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Project is the Schema for the Projects API. Allows management of a Google Cloud Platform project.
 *
 * @schema Project
 */
export class Project extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Project"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'Project',
  }

  /**
   * Renders a Kubernetes manifest for "Project".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectProps): any {
    return {
      ...Project.GVK,
      ...toJson_ProjectProps(props),
    };
  }

  /**
   * Defines a "Project" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectProps) {
    super(scope, id, {
      ...Project.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Project.GVK,
      ...toJson_ProjectProps(resolved),
    };
  }
}

/**
 * Project is the Schema for the Projects API. Allows management of a Google Cloud Platform project.
 *
 * @schema Project
 */
export interface ProjectProps {
  /**
   * @schema Project#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectSpec defines the desired state of Project
   *
   * @schema Project#spec
   */
  readonly spec: ProjectSpec;

}

/**
 * Converts an object of type 'ProjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectProps(obj: ProjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectSpec defines the desired state of Project
 *
 * @schema ProjectSpec
 */
export interface ProjectSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectSpecDeletionPolicy;

  /**
   * @schema ProjectSpec#forProvider
   */
  readonly forProvider: ProjectSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectSpec#initProvider
   */
  readonly initProvider?: ProjectSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpec(obj: ProjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectSpecDeletionPolicy
 */
export enum ProjectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectSpecForProvider
 */
export interface ProjectSpecForProvider {
  /**
   * Controls whether the 'default' network exists on the project. Defaults to true, where it is created. Therefore, for quota purposes, you will still need to have 1 network slot available to create the project successfully, even if you set auto_create_network to false.googleapis.com on the project to interact with the GCE API and currently leaves it enabled.
   *
   * @default true, where it is created. Therefore, for quota purposes, you will still need to have 1 network slot available to create the project successfully, even if you set auto_create_network to false.googleapis.com on the project to interact with the GCE API and currently leaves it enabled.
   * @schema ProjectSpecForProvider#autoCreateNetwork
   */
  readonly autoCreateNetwork?: boolean;

  /**
   * The alphanumeric ID of the billing account this project belongs to.user) on the billing account. See Google Cloud Billing API Access Control for more details.
   *
   * @schema ProjectSpecForProvider#billingAccount
   */
  readonly billingAccount?: string;

  /**
   * The numeric ID of the folder this project should be created under. Only one of org_id or folder_id may be specified. If the folder_id is specified, then the project is created under the specified folder. Changing this forces the project to be migrated to the newly specified folder.
   *
   * @schema ProjectSpecForProvider#folderId
   */
  readonly folderId?: string;

  /**
   * Reference to a Folder in cloudplatform to populate folderId.
   *
   * @schema ProjectSpecForProvider#folderIdRef
   */
  readonly folderIdRef?: ProjectSpecForProviderFolderIdRef;

  /**
   * Selector for a Folder in cloudplatform to populate folderId.
   *
   * @schema ProjectSpecForProvider#folderIdSelector
   */
  readonly folderIdSelector?: ProjectSpecForProviderFolderIdSelector;

  /**
   * A set of key/value label pairs to assign to the project.
   *
   * @schema ProjectSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The display name of the project.
   *
   * @schema ProjectSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The numeric ID of the organization this project belongs to. Changing this forces a new project to be created.  Only one of org_id or folder_id may be specified. If the org_id is specified then the project is created at the top level. Changing this forces the project to be migrated to the newly specified organization. The numeric ID of the organization this project belongs to.
   *
   * @schema ProjectSpecForProvider#orgId
   */
  readonly orgId?: string;

  /**
   * The project ID. Changing this forces a new project to be created.
   *
   * @schema ProjectSpecForProvider#projectId
   */
  readonly projectId?: string;

  /**
   * @schema ProjectSpecForProvider#skipDelete
   */
  readonly skipDelete?: boolean;

}

/**
 * Converts an object of type 'ProjectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProvider(obj: ProjectSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoCreateNetwork': obj.autoCreateNetwork,
    'billingAccount': obj.billingAccount,
    'folderId': obj.folderId,
    'folderIdRef': toJson_ProjectSpecForProviderFolderIdRef(obj.folderIdRef),
    'folderIdSelector': toJson_ProjectSpecForProviderFolderIdSelector(obj.folderIdSelector),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'orgId': obj.orgId,
    'projectId': obj.projectId,
    'skipDelete': obj.skipDelete,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectSpecInitProvider
 */
export interface ProjectSpecInitProvider {
  /**
   * Controls whether the 'default' network exists on the project. Defaults to true, where it is created. Therefore, for quota purposes, you will still need to have 1 network slot available to create the project successfully, even if you set auto_create_network to false.googleapis.com on the project to interact with the GCE API and currently leaves it enabled.
   *
   * @default true, where it is created. Therefore, for quota purposes, you will still need to have 1 network slot available to create the project successfully, even if you set auto_create_network to false.googleapis.com on the project to interact with the GCE API and currently leaves it enabled.
   * @schema ProjectSpecInitProvider#autoCreateNetwork
   */
  readonly autoCreateNetwork?: boolean;

  /**
   * The alphanumeric ID of the billing account this project belongs to.user) on the billing account. See Google Cloud Billing API Access Control for more details.
   *
   * @schema ProjectSpecInitProvider#billingAccount
   */
  readonly billingAccount?: string;

  /**
   * A set of key/value label pairs to assign to the project.
   *
   * @schema ProjectSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The display name of the project.
   *
   * @schema ProjectSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The numeric ID of the organization this project belongs to. Changing this forces a new project to be created.  Only one of org_id or folder_id may be specified. If the org_id is specified then the project is created at the top level. Changing this forces the project to be migrated to the newly specified organization. The numeric ID of the organization this project belongs to.
   *
   * @schema ProjectSpecInitProvider#orgId
   */
  readonly orgId?: string;

  /**
   * The project ID. Changing this forces a new project to be created.
   *
   * @schema ProjectSpecInitProvider#projectId
   */
  readonly projectId?: string;

  /**
   * @schema ProjectSpecInitProvider#skipDelete
   */
  readonly skipDelete?: boolean;

}

/**
 * Converts an object of type 'ProjectSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecInitProvider(obj: ProjectSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoCreateNetwork': obj.autoCreateNetwork,
    'billingAccount': obj.billingAccount,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'orgId': obj.orgId,
    'projectId': obj.projectId,
    'skipDelete': obj.skipDelete,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectSpecManagementPolicies
 */
export enum ProjectSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectSpecProviderConfigRef
 */
export interface ProjectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderConfigRef(obj: ProjectSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectSpecPublishConnectionDetailsTo
 */
export interface ProjectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsTo(obj: ProjectSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectSpecWriteConnectionSecretToRef
 */
export interface ProjectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecWriteConnectionSecretToRef(obj: ProjectSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Folder in cloudplatform to populate folderId.
 *
 * @schema ProjectSpecForProviderFolderIdRef
 */
export interface ProjectSpecForProviderFolderIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecForProviderFolderIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecForProviderFolderIdRef#policy
   */
  readonly policy?: ProjectSpecForProviderFolderIdRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecForProviderFolderIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderFolderIdRef(obj: ProjectSpecForProviderFolderIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecForProviderFolderIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Folder in cloudplatform to populate folderId.
 *
 * @schema ProjectSpecForProviderFolderIdSelector
 */
export interface ProjectSpecForProviderFolderIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectSpecForProviderFolderIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectSpecForProviderFolderIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectSpecForProviderFolderIdSelector#policy
   */
  readonly policy?: ProjectSpecForProviderFolderIdSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectSpecForProviderFolderIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderFolderIdSelector(obj: ProjectSpecForProviderFolderIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectSpecForProviderFolderIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecProviderConfigRefPolicy
 */
export interface ProjectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderConfigRefPolicy(obj: ProjectSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToConfigRef(obj: ProjectSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToMetadata(obj: ProjectSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecForProviderFolderIdRefPolicy
 */
export interface ProjectSpecForProviderFolderIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecForProviderFolderIdRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecForProviderFolderIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecForProviderFolderIdRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecForProviderFolderIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecForProviderFolderIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderFolderIdRefPolicy(obj: ProjectSpecForProviderFolderIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectSpecForProviderFolderIdSelectorPolicy
 */
export interface ProjectSpecForProviderFolderIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecForProviderFolderIdSelectorPolicy#resolution
   */
  readonly resolution?: ProjectSpecForProviderFolderIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecForProviderFolderIdSelectorPolicy#resolve
   */
  readonly resolve?: ProjectSpecForProviderFolderIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecForProviderFolderIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderFolderIdSelectorPolicy(obj: ProjectSpecForProviderFolderIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecProviderConfigRefPolicyResolution
 */
export enum ProjectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecProviderConfigRefPolicyResolve
 */
export enum ProjectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecForProviderFolderIdRefPolicyResolution
 */
export enum ProjectSpecForProviderFolderIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecForProviderFolderIdRefPolicyResolve
 */
export enum ProjectSpecForProviderFolderIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecForProviderFolderIdSelectorPolicyResolution
 */
export enum ProjectSpecForProviderFolderIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecForProviderFolderIdSelectorPolicyResolve
 */
export enum ProjectSpecForProviderFolderIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectDefaultServiceAccounts is the Schema for the ProjectDefaultServiceAccountss API. Allows management of Google Cloud Platform project default service accounts.
 *
 * @schema ProjectDefaultServiceAccounts
 */
export class ProjectDefaultServiceAccounts extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectDefaultServiceAccounts"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ProjectDefaultServiceAccounts',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectDefaultServiceAccounts".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectDefaultServiceAccountsProps): any {
    return {
      ...ProjectDefaultServiceAccounts.GVK,
      ...toJson_ProjectDefaultServiceAccountsProps(props),
    };
  }

  /**
   * Defines a "ProjectDefaultServiceAccounts" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectDefaultServiceAccountsProps) {
    super(scope, id, {
      ...ProjectDefaultServiceAccounts.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectDefaultServiceAccounts.GVK,
      ...toJson_ProjectDefaultServiceAccountsProps(resolved),
    };
  }
}

/**
 * ProjectDefaultServiceAccounts is the Schema for the ProjectDefaultServiceAccountss API. Allows management of Google Cloud Platform project default service accounts.
 *
 * @schema ProjectDefaultServiceAccounts
 */
export interface ProjectDefaultServiceAccountsProps {
  /**
   * @schema ProjectDefaultServiceAccounts#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectDefaultServiceAccountsSpec defines the desired state of ProjectDefaultServiceAccounts
   *
   * @schema ProjectDefaultServiceAccounts#spec
   */
  readonly spec: ProjectDefaultServiceAccountsSpec;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsProps(obj: ProjectDefaultServiceAccountsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectDefaultServiceAccountsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectDefaultServiceAccountsSpec defines the desired state of ProjectDefaultServiceAccounts
 *
 * @schema ProjectDefaultServiceAccountsSpec
 */
export interface ProjectDefaultServiceAccountsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectDefaultServiceAccountsSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectDefaultServiceAccountsSpecDeletionPolicy;

  /**
   * @schema ProjectDefaultServiceAccountsSpec#forProvider
   */
  readonly forProvider: ProjectDefaultServiceAccountsSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectDefaultServiceAccountsSpec#initProvider
   */
  readonly initProvider?: ProjectDefaultServiceAccountsSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectDefaultServiceAccountsSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectDefaultServiceAccountsSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectDefaultServiceAccountsSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectDefaultServiceAccountsSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectDefaultServiceAccountsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectDefaultServiceAccountsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectDefaultServiceAccountsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectDefaultServiceAccountsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpec(obj: ProjectDefaultServiceAccountsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectDefaultServiceAccountsSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectDefaultServiceAccountsSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectDefaultServiceAccountsSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectDefaultServiceAccountsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectDefaultServiceAccountsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectDefaultServiceAccountsSpecDeletionPolicy
 */
export enum ProjectDefaultServiceAccountsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectDefaultServiceAccountsSpecForProvider
 */
export interface ProjectDefaultServiceAccountsSpecForProvider {
  /**
   * The action to be performed in the default service accounts. Valid values are: DEPRIVILEGE, DELETE, DISABLE. Note that DEPRIVILEGE action will ignore the REVERT configuration in the restore_policy
   *
   * @schema ProjectDefaultServiceAccountsSpecForProvider#action
   */
  readonly action?: string;

  /**
   * The project ID where service accounts are created.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project to populate project.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProvider#projectRef
   */
  readonly projectRef?: ProjectDefaultServiceAccountsSpecForProviderProjectRef;

  /**
   * Selector for a Project to populate project.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProvider#projectSelector
   */
  readonly projectSelector?: ProjectDefaultServiceAccountsSpecForProviderProjectSelector;

  /**
   * The action to be performed in the default service accounts on the resource destroy. Valid values are NONE, REVERT and REVERT_AND_IGNORE_FAILURE. It is applied for any action but in the DEPRIVILEGE. If set to REVERT it attempts to restore all default SAs but the DEPRIVILEGE action. If set to REVERT_AND_IGNORE_FAILURE it is the same behavior as REVERT but ignores errors returned by the API.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProvider#restorePolicy
   */
  readonly restorePolicy?: string;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecForProvider(obj: ProjectDefaultServiceAccountsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'project': obj.project,
    'projectRef': toJson_ProjectDefaultServiceAccountsSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectDefaultServiceAccountsSpecForProviderProjectSelector(obj.projectSelector),
    'restorePolicy': obj.restorePolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectDefaultServiceAccountsSpecInitProvider
 */
export interface ProjectDefaultServiceAccountsSpecInitProvider {
  /**
   * The action to be performed in the default service accounts. Valid values are: DEPRIVILEGE, DELETE, DISABLE. Note that DEPRIVILEGE action will ignore the REVERT configuration in the restore_policy
   *
   * @schema ProjectDefaultServiceAccountsSpecInitProvider#action
   */
  readonly action?: string;

  /**
   * The action to be performed in the default service accounts on the resource destroy. Valid values are NONE, REVERT and REVERT_AND_IGNORE_FAILURE. It is applied for any action but in the DEPRIVILEGE. If set to REVERT it attempts to restore all default SAs but the DEPRIVILEGE action. If set to REVERT_AND_IGNORE_FAILURE it is the same behavior as REVERT but ignores errors returned by the API.
   *
   * @schema ProjectDefaultServiceAccountsSpecInitProvider#restorePolicy
   */
  readonly restorePolicy?: string;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecInitProvider(obj: ProjectDefaultServiceAccountsSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'restorePolicy': obj.restorePolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectDefaultServiceAccountsSpecManagementPolicies
 */
export enum ProjectDefaultServiceAccountsSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectDefaultServiceAccountsSpecProviderConfigRef
 */
export interface ProjectDefaultServiceAccountsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectDefaultServiceAccountsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectDefaultServiceAccountsSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectDefaultServiceAccountsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecProviderConfigRef(obj: ProjectDefaultServiceAccountsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectDefaultServiceAccountsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsTo
 */
export interface ProjectDefaultServiceAccountsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecPublishConnectionDetailsTo(obj: ProjectDefaultServiceAccountsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectDefaultServiceAccountsSpecWriteConnectionSecretToRef
 */
export interface ProjectDefaultServiceAccountsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectDefaultServiceAccountsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectDefaultServiceAccountsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecWriteConnectionSecretToRef(obj: ProjectDefaultServiceAccountsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project to populate project.
 *
 * @schema ProjectDefaultServiceAccountsSpecForProviderProjectRef
 */
export interface ProjectDefaultServiceAccountsSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProviderProjectRef#policy
   */
  readonly policy?: ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecForProviderProjectRef(obj: ProjectDefaultServiceAccountsSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project to populate project.
 *
 * @schema ProjectDefaultServiceAccountsSpecForProviderProjectSelector
 */
export interface ProjectDefaultServiceAccountsSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProviderProjectSelector#policy
   */
  readonly policy?: ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecForProviderProjectSelector(obj: ProjectDefaultServiceAccountsSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectDefaultServiceAccountsSpecProviderConfigRefPolicy
 */
export interface ProjectDefaultServiceAccountsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectDefaultServiceAccountsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectDefaultServiceAccountsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectDefaultServiceAccountsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectDefaultServiceAccountsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecProviderConfigRefPolicy(obj: ProjectDefaultServiceAccountsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRef(obj: ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToMetadata(obj: ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicy
 */
export interface ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicy(obj: ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicy
 */
export interface ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicy(obj: ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectDefaultServiceAccountsSpecProviderConfigRefPolicyResolution
 */
export enum ProjectDefaultServiceAccountsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectDefaultServiceAccountsSpecProviderConfigRefPolicyResolve
 */
export enum ProjectDefaultServiceAccountsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicyResolution
 */
export enum ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicyResolve
 */
export enum ProjectDefaultServiceAccountsSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicyResolution
 */
export enum ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicyResolve
 */
export enum ProjectDefaultServiceAccountsSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectDefaultServiceAccountsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectIAMAuditConfig is the Schema for the ProjectIAMAuditConfigs API. <no value>
 *
 * @schema ProjectIAMAuditConfig
 */
export class ProjectIamAuditConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectIAMAuditConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ProjectIAMAuditConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectIAMAuditConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectIamAuditConfigProps): any {
    return {
      ...ProjectIamAuditConfig.GVK,
      ...toJson_ProjectIamAuditConfigProps(props),
    };
  }

  /**
   * Defines a "ProjectIAMAuditConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectIamAuditConfigProps) {
    super(scope, id, {
      ...ProjectIamAuditConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectIamAuditConfig.GVK,
      ...toJson_ProjectIamAuditConfigProps(resolved),
    };
  }
}

/**
 * ProjectIAMAuditConfig is the Schema for the ProjectIAMAuditConfigs API. <no value>
 *
 * @schema ProjectIAMAuditConfig
 */
export interface ProjectIamAuditConfigProps {
  /**
   * @schema ProjectIAMAuditConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectIAMAuditConfigSpec defines the desired state of ProjectIAMAuditConfig
   *
   * @schema ProjectIAMAuditConfig#spec
   */
  readonly spec: ProjectIamAuditConfigSpec;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigProps(obj: ProjectIamAuditConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectIamAuditConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectIAMAuditConfigSpec defines the desired state of ProjectIAMAuditConfig
 *
 * @schema ProjectIamAuditConfigSpec
 */
export interface ProjectIamAuditConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectIamAuditConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectIamAuditConfigSpecDeletionPolicy;

  /**
   * @schema ProjectIamAuditConfigSpec#forProvider
   */
  readonly forProvider: ProjectIamAuditConfigSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectIamAuditConfigSpec#initProvider
   */
  readonly initProvider?: ProjectIamAuditConfigSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectIamAuditConfigSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectIamAuditConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectIamAuditConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectIamAuditConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectIamAuditConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectIamAuditConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectIamAuditConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectIamAuditConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpec(obj: ProjectIamAuditConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectIamAuditConfigSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectIamAuditConfigSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectIamAuditConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectIamAuditConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectIamAuditConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectIamAuditConfigSpecDeletionPolicy
 */
export enum ProjectIamAuditConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectIamAuditConfigSpecForProvider
 */
export interface ProjectIamAuditConfigSpecForProvider {
  /**
   * @schema ProjectIamAuditConfigSpecForProvider#auditLogConfig
   */
  readonly auditLogConfig?: ProjectIamAuditConfigSpecForProviderAuditLogConfig[];

  /**
   * @schema ProjectIamAuditConfigSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project to populate project.
   *
   * @schema ProjectIamAuditConfigSpecForProvider#projectRef
   */
  readonly projectRef?: ProjectIamAuditConfigSpecForProviderProjectRef;

  /**
   * Selector for a Project to populate project.
   *
   * @schema ProjectIamAuditConfigSpecForProvider#projectSelector
   */
  readonly projectSelector?: ProjectIamAuditConfigSpecForProviderProjectSelector;

  /**
   * @schema ProjectIamAuditConfigSpecForProvider#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecForProvider(obj: ProjectIamAuditConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auditLogConfig': obj.auditLogConfig?.map(y => toJson_ProjectIamAuditConfigSpecForProviderAuditLogConfig(y)),
    'project': obj.project,
    'projectRef': toJson_ProjectIamAuditConfigSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectIamAuditConfigSpecForProviderProjectSelector(obj.projectSelector),
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectIamAuditConfigSpecInitProvider
 */
export interface ProjectIamAuditConfigSpecInitProvider {
  /**
   * @schema ProjectIamAuditConfigSpecInitProvider#auditLogConfig
   */
  readonly auditLogConfig?: ProjectIamAuditConfigSpecInitProviderAuditLogConfig[];

  /**
   * @schema ProjectIamAuditConfigSpecInitProvider#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecInitProvider(obj: ProjectIamAuditConfigSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auditLogConfig': obj.auditLogConfig?.map(y => toJson_ProjectIamAuditConfigSpecInitProviderAuditLogConfig(y)),
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectIamAuditConfigSpecManagementPolicies
 */
export enum ProjectIamAuditConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectIamAuditConfigSpecProviderConfigRef
 */
export interface ProjectIamAuditConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamAuditConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamAuditConfigSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectIamAuditConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecProviderConfigRef(obj: ProjectIamAuditConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamAuditConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsTo
 */
export interface ProjectIamAuditConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectIamAuditConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecPublishConnectionDetailsTo(obj: ProjectIamAuditConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectIamAuditConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectIamAuditConfigSpecWriteConnectionSecretToRef
 */
export interface ProjectIamAuditConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectIamAuditConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectIamAuditConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecWriteConnectionSecretToRef(obj: ProjectIamAuditConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectIamAuditConfigSpecForProviderAuditLogConfig
 */
export interface ProjectIamAuditConfigSpecForProviderAuditLogConfig {
  /**
   * @schema ProjectIamAuditConfigSpecForProviderAuditLogConfig#exemptedMembers
   */
  readonly exemptedMembers?: string[];

  /**
   * @schema ProjectIamAuditConfigSpecForProviderAuditLogConfig#logType
   */
  readonly logType?: string;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecForProviderAuditLogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecForProviderAuditLogConfig(obj: ProjectIamAuditConfigSpecForProviderAuditLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exemptedMembers': obj.exemptedMembers?.map(y => y),
    'logType': obj.logType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project to populate project.
 *
 * @schema ProjectIamAuditConfigSpecForProviderProjectRef
 */
export interface ProjectIamAuditConfigSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamAuditConfigSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamAuditConfigSpecForProviderProjectRef#policy
   */
  readonly policy?: ProjectIamAuditConfigSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecForProviderProjectRef(obj: ProjectIamAuditConfigSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamAuditConfigSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project to populate project.
 *
 * @schema ProjectIamAuditConfigSpecForProviderProjectSelector
 */
export interface ProjectIamAuditConfigSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectIamAuditConfigSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectIamAuditConfigSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectIamAuditConfigSpecForProviderProjectSelector#policy
   */
  readonly policy?: ProjectIamAuditConfigSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecForProviderProjectSelector(obj: ProjectIamAuditConfigSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectIamAuditConfigSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectIamAuditConfigSpecInitProviderAuditLogConfig
 */
export interface ProjectIamAuditConfigSpecInitProviderAuditLogConfig {
  /**
   * @schema ProjectIamAuditConfigSpecInitProviderAuditLogConfig#exemptedMembers
   */
  readonly exemptedMembers?: string[];

  /**
   * @schema ProjectIamAuditConfigSpecInitProviderAuditLogConfig#logType
   */
  readonly logType?: string;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecInitProviderAuditLogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecInitProviderAuditLogConfig(obj: ProjectIamAuditConfigSpecInitProviderAuditLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exemptedMembers': obj.exemptedMembers?.map(y => y),
    'logType': obj.logType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamAuditConfigSpecProviderConfigRefPolicy
 */
export interface ProjectIamAuditConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectIamAuditConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamAuditConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectIamAuditConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamAuditConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecProviderConfigRefPolicy(obj: ProjectIamAuditConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRef(obj: ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectIamAuditConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecPublishConnectionDetailsToMetadata(obj: ProjectIamAuditConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamAuditConfigSpecForProviderProjectRefPolicy
 */
export interface ProjectIamAuditConfigSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectIamAuditConfigSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectIamAuditConfigSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectIamAuditConfigSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectIamAuditConfigSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecForProviderProjectRefPolicy(obj: ProjectIamAuditConfigSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectIamAuditConfigSpecForProviderProjectSelectorPolicy
 */
export interface ProjectIamAuditConfigSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectIamAuditConfigSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectIamAuditConfigSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectIamAuditConfigSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectIamAuditConfigSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecForProviderProjectSelectorPolicy(obj: ProjectIamAuditConfigSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectIamAuditConfigSpecProviderConfigRefPolicyResolution
 */
export enum ProjectIamAuditConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectIamAuditConfigSpecProviderConfigRefPolicyResolve
 */
export enum ProjectIamAuditConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectIamAuditConfigSpecForProviderProjectRefPolicyResolution
 */
export enum ProjectIamAuditConfigSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectIamAuditConfigSpecForProviderProjectRefPolicyResolve
 */
export enum ProjectIamAuditConfigSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectIamAuditConfigSpecForProviderProjectSelectorPolicyResolution
 */
export enum ProjectIamAuditConfigSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectIamAuditConfigSpecForProviderProjectSelectorPolicyResolve
 */
export enum ProjectIamAuditConfigSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectIamAuditConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectIAMCustomRole is the Schema for the ProjectIAMCustomRoles API. Allows management of a customized Cloud IAM project role.
 *
 * @schema ProjectIAMCustomRole
 */
export class ProjectIamCustomRole extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectIAMCustomRole"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ProjectIAMCustomRole',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectIAMCustomRole".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectIamCustomRoleProps): any {
    return {
      ...ProjectIamCustomRole.GVK,
      ...toJson_ProjectIamCustomRoleProps(props),
    };
  }

  /**
   * Defines a "ProjectIAMCustomRole" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectIamCustomRoleProps) {
    super(scope, id, {
      ...ProjectIamCustomRole.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectIamCustomRole.GVK,
      ...toJson_ProjectIamCustomRoleProps(resolved),
    };
  }
}

/**
 * ProjectIAMCustomRole is the Schema for the ProjectIAMCustomRoles API. Allows management of a customized Cloud IAM project role.
 *
 * @schema ProjectIAMCustomRole
 */
export interface ProjectIamCustomRoleProps {
  /**
   * @schema ProjectIAMCustomRole#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectIAMCustomRoleSpec defines the desired state of ProjectIAMCustomRole
   *
   * @schema ProjectIAMCustomRole#spec
   */
  readonly spec: ProjectIamCustomRoleSpec;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleProps(obj: ProjectIamCustomRoleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectIamCustomRoleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectIAMCustomRoleSpec defines the desired state of ProjectIAMCustomRole
 *
 * @schema ProjectIamCustomRoleSpec
 */
export interface ProjectIamCustomRoleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectIamCustomRoleSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectIamCustomRoleSpecDeletionPolicy;

  /**
   * @schema ProjectIamCustomRoleSpec#forProvider
   */
  readonly forProvider: ProjectIamCustomRoleSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectIamCustomRoleSpec#initProvider
   */
  readonly initProvider?: ProjectIamCustomRoleSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectIamCustomRoleSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectIamCustomRoleSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectIamCustomRoleSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectIamCustomRoleSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectIamCustomRoleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectIamCustomRoleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectIamCustomRoleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectIamCustomRoleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleSpec(obj: ProjectIamCustomRoleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectIamCustomRoleSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectIamCustomRoleSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectIamCustomRoleSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectIamCustomRoleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectIamCustomRoleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectIamCustomRoleSpecDeletionPolicy
 */
export enum ProjectIamCustomRoleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectIamCustomRoleSpecForProvider
 */
export interface ProjectIamCustomRoleSpecForProvider {
  /**
   * A human-readable description for the role.
   *
   * @schema ProjectIamCustomRoleSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The names of the permissions this role grants when bound in an IAM policy. At least one permission must be specified.
   *
   * @schema ProjectIamCustomRoleSpecForProvider#permissions
   */
  readonly permissions?: string[];

  /**
   * The project that the service account will be created in. Defaults to the provider project configuration.
   *
   * @default the provider project configuration.
   * @schema ProjectIamCustomRoleSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The current launch stage of the role. Defaults to GA. List of possible stages is here.
   *
   * @default GA. List of possible stages is here.
   * @schema ProjectIamCustomRoleSpecForProvider#stage
   */
  readonly stage?: string;

  /**
   * A human-readable title for the role.
   *
   * @schema ProjectIamCustomRoleSpecForProvider#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleSpecForProvider(obj: ProjectIamCustomRoleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'permissions': obj.permissions?.map(y => y),
    'project': obj.project,
    'stage': obj.stage,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectIamCustomRoleSpecInitProvider
 */
export interface ProjectIamCustomRoleSpecInitProvider {
  /**
   * A human-readable description for the role.
   *
   * @schema ProjectIamCustomRoleSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The names of the permissions this role grants when bound in an IAM policy. At least one permission must be specified.
   *
   * @schema ProjectIamCustomRoleSpecInitProvider#permissions
   */
  readonly permissions?: string[];

  /**
   * The project that the service account will be created in. Defaults to the provider project configuration.
   *
   * @default the provider project configuration.
   * @schema ProjectIamCustomRoleSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The current launch stage of the role. Defaults to GA. List of possible stages is here.
   *
   * @default GA. List of possible stages is here.
   * @schema ProjectIamCustomRoleSpecInitProvider#stage
   */
  readonly stage?: string;

  /**
   * A human-readable title for the role.
   *
   * @schema ProjectIamCustomRoleSpecInitProvider#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleSpecInitProvider(obj: ProjectIamCustomRoleSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'permissions': obj.permissions?.map(y => y),
    'project': obj.project,
    'stage': obj.stage,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectIamCustomRoleSpecManagementPolicies
 */
export enum ProjectIamCustomRoleSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectIamCustomRoleSpecProviderConfigRef
 */
export interface ProjectIamCustomRoleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamCustomRoleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamCustomRoleSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectIamCustomRoleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleSpecProviderConfigRef(obj: ProjectIamCustomRoleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamCustomRoleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsTo
 */
export interface ProjectIamCustomRoleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectIamCustomRoleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleSpecPublishConnectionDetailsTo(obj: ProjectIamCustomRoleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectIamCustomRoleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectIamCustomRoleSpecWriteConnectionSecretToRef
 */
export interface ProjectIamCustomRoleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectIamCustomRoleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectIamCustomRoleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleSpecWriteConnectionSecretToRef(obj: ProjectIamCustomRoleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamCustomRoleSpecProviderConfigRefPolicy
 */
export interface ProjectIamCustomRoleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectIamCustomRoleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamCustomRoleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectIamCustomRoleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamCustomRoleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleSpecProviderConfigRefPolicy(obj: ProjectIamCustomRoleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRef(obj: ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectIamCustomRoleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleSpecPublishConnectionDetailsToMetadata(obj: ProjectIamCustomRoleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectIamCustomRoleSpecProviderConfigRefPolicyResolution
 */
export enum ProjectIamCustomRoleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectIamCustomRoleSpecProviderConfigRefPolicyResolve
 */
export enum ProjectIamCustomRoleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectIamCustomRoleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectIAMMember is the Schema for the ProjectIAMMembers API. <no value>
 *
 * @schema ProjectIAMMember
 */
export class ProjectIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ProjectIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectIamMemberProps): any {
    return {
      ...ProjectIamMember.GVK,
      ...toJson_ProjectIamMemberProps(props),
    };
  }

  /**
   * Defines a "ProjectIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectIamMemberProps) {
    super(scope, id, {
      ...ProjectIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectIamMember.GVK,
      ...toJson_ProjectIamMemberProps(resolved),
    };
  }
}

/**
 * ProjectIAMMember is the Schema for the ProjectIAMMembers API. <no value>
 *
 * @schema ProjectIAMMember
 */
export interface ProjectIamMemberProps {
  /**
   * @schema ProjectIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectIAMMemberSpec defines the desired state of ProjectIAMMember
   *
   * @schema ProjectIAMMember#spec
   */
  readonly spec: ProjectIamMemberSpec;

}

/**
 * Converts an object of type 'ProjectIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberProps(obj: ProjectIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectIAMMemberSpec defines the desired state of ProjectIAMMember
 *
 * @schema ProjectIamMemberSpec
 */
export interface ProjectIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectIamMemberSpecDeletionPolicy;

  /**
   * @schema ProjectIamMemberSpec#forProvider
   */
  readonly forProvider: ProjectIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectIamMemberSpec#initProvider
   */
  readonly initProvider?: ProjectIamMemberSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpec(obj: ProjectIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectIamMemberSpecDeletionPolicy
 */
export enum ProjectIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectIamMemberSpecForProvider
 */
export interface ProjectIamMemberSpecForProvider {
  /**
   * @schema ProjectIamMemberSpecForProvider#condition
   */
  readonly condition?: ProjectIamMemberSpecForProviderCondition[];

  /**
   * @schema ProjectIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ProjectIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project to populate project.
   *
   * @schema ProjectIamMemberSpecForProvider#projectRef
   */
  readonly projectRef?: ProjectIamMemberSpecForProviderProjectRef;

  /**
   * Selector for a Project to populate project.
   *
   * @schema ProjectIamMemberSpecForProvider#projectSelector
   */
  readonly projectSelector?: ProjectIamMemberSpecForProviderProjectSelector;

  /**
   * @schema ProjectIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecForProvider(obj: ProjectIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ProjectIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'projectRef': toJson_ProjectIamMemberSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectIamMemberSpecForProviderProjectSelector(obj.projectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectIamMemberSpecInitProvider
 */
export interface ProjectIamMemberSpecInitProvider {
  /**
   * @schema ProjectIamMemberSpecInitProvider#condition
   */
  readonly condition?: ProjectIamMemberSpecInitProviderCondition[];

  /**
   * @schema ProjectIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema ProjectIamMemberSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecInitProvider(obj: ProjectIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ProjectIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectIamMemberSpecManagementPolicies
 */
export enum ProjectIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectIamMemberSpecProviderConfigRef
 */
export interface ProjectIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecProviderConfigRef(obj: ProjectIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsTo
 */
export interface ProjectIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecPublishConnectionDetailsTo(obj: ProjectIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectIamMemberSpecWriteConnectionSecretToRef
 */
export interface ProjectIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecWriteConnectionSecretToRef(obj: ProjectIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectIamMemberSpecForProviderCondition
 */
export interface ProjectIamMemberSpecForProviderCondition {
  /**
   * @schema ProjectIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ProjectIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ProjectIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecForProviderCondition(obj: ProjectIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project to populate project.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRef
 */
export interface ProjectIamMemberSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRef#policy
   */
  readonly policy?: ProjectIamMemberSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectRef(obj: ProjectIamMemberSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project to populate project.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelector
 */
export interface ProjectIamMemberSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelector#policy
   */
  readonly policy?: ProjectIamMemberSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectSelector(obj: ProjectIamMemberSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectIamMemberSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectIamMemberSpecInitProviderCondition
 */
export interface ProjectIamMemberSpecInitProviderCondition {
  /**
   * @schema ProjectIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ProjectIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ProjectIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecInitProviderCondition(obj: ProjectIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberSpecProviderConfigRefPolicy
 */
export interface ProjectIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecProviderConfigRefPolicy(obj: ProjectIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecPublishConnectionDetailsToConfigRef(obj: ProjectIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecPublishConnectionDetailsToMetadata(obj: ProjectIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRefPolicy
 */
export interface ProjectIamMemberSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectRefPolicy(obj: ProjectIamMemberSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicy
 */
export interface ProjectIamMemberSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectSelectorPolicy(obj: ProjectIamMemberSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum ProjectIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum ProjectIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRefPolicyResolution
 */
export enum ProjectIamMemberSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRefPolicyResolve
 */
export enum ProjectIamMemberSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicyResolution
 */
export enum ProjectIamMemberSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicyResolve
 */
export enum ProjectIamMemberSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectService is the Schema for the ProjectServices API. Allows management of a single API service for a Google Cloud Platform project.
 *
 * @schema ProjectService
 */
export class ProjectService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ProjectService',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectServiceProps): any {
    return {
      ...ProjectService.GVK,
      ...toJson_ProjectServiceProps(props),
    };
  }

  /**
   * Defines a "ProjectService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectServiceProps) {
    super(scope, id, {
      ...ProjectService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectService.GVK,
      ...toJson_ProjectServiceProps(resolved),
    };
  }
}

/**
 * ProjectService is the Schema for the ProjectServices API. Allows management of a single API service for a Google Cloud Platform project.
 *
 * @schema ProjectService
 */
export interface ProjectServiceProps {
  /**
   * @schema ProjectService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectServiceSpec defines the desired state of ProjectService
   *
   * @schema ProjectService#spec
   */
  readonly spec: ProjectServiceSpec;

}

/**
 * Converts an object of type 'ProjectServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceProps(obj: ProjectServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectServiceSpec defines the desired state of ProjectService
 *
 * @schema ProjectServiceSpec
 */
export interface ProjectServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectServiceSpecDeletionPolicy;

  /**
   * @schema ProjectServiceSpec#forProvider
   */
  readonly forProvider: ProjectServiceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectServiceSpec#initProvider
   */
  readonly initProvider?: ProjectServiceSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectServiceSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectServiceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectServiceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpec(obj: ProjectServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectServiceSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectServiceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectServiceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectServiceSpecDeletionPolicy
 */
export enum ProjectServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectServiceSpecForProvider
 */
export interface ProjectServiceSpecForProvider {
  /**
   * If true, services that are enabled and which depend on this service should also be disabled when this service is destroyed. If false or unset, an error will be generated if any enabled services depend on this service when destroying it.
   *
   * @schema ProjectServiceSpecForProvider#disableDependentServices
   */
  readonly disableDependentServices?: boolean;

  /**
   * Defaults to true. May be useful in the event that a project is long-lived but the infrastructure running in that project changes frequently.
   *
   * @default true. May be useful in the event that a project is long-lived but the infrastructure running in that project changes frequently.
   * @schema ProjectServiceSpecForProvider#disableOnDestroy
   */
  readonly disableOnDestroy?: boolean;

  /**
   * The project ID. If not provided, the provider project is used.
   *
   * @schema ProjectServiceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project to populate project.
   *
   * @schema ProjectServiceSpecForProvider#projectRef
   */
  readonly projectRef?: ProjectServiceSpecForProviderProjectRef;

  /**
   * Selector for a Project to populate project.
   *
   * @schema ProjectServiceSpecForProvider#projectSelector
   */
  readonly projectSelector?: ProjectServiceSpecForProviderProjectSelector;

  /**
   * The service to enable.
   *
   * @schema ProjectServiceSpecForProvider#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ProjectServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecForProvider(obj: ProjectServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableDependentServices': obj.disableDependentServices,
    'disableOnDestroy': obj.disableOnDestroy,
    'project': obj.project,
    'projectRef': toJson_ProjectServiceSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectServiceSpecForProviderProjectSelector(obj.projectSelector),
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectServiceSpecInitProvider
 */
export interface ProjectServiceSpecInitProvider {
  /**
   * If true, services that are enabled and which depend on this service should also be disabled when this service is destroyed. If false or unset, an error will be generated if any enabled services depend on this service when destroying it.
   *
   * @schema ProjectServiceSpecInitProvider#disableDependentServices
   */
  readonly disableDependentServices?: boolean;

  /**
   * Defaults to true. May be useful in the event that a project is long-lived but the infrastructure running in that project changes frequently.
   *
   * @default true. May be useful in the event that a project is long-lived but the infrastructure running in that project changes frequently.
   * @schema ProjectServiceSpecInitProvider#disableOnDestroy
   */
  readonly disableOnDestroy?: boolean;

  /**
   * The service to enable.
   *
   * @schema ProjectServiceSpecInitProvider#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ProjectServiceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecInitProvider(obj: ProjectServiceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableDependentServices': obj.disableDependentServices,
    'disableOnDestroy': obj.disableOnDestroy,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectServiceSpecManagementPolicies
 */
export enum ProjectServiceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectServiceSpecProviderConfigRef
 */
export interface ProjectServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectServiceSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecProviderConfigRef(obj: ProjectServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectServiceSpecPublishConnectionDetailsTo
 */
export interface ProjectServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecPublishConnectionDetailsTo(obj: ProjectServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectServiceSpecWriteConnectionSecretToRef
 */
export interface ProjectServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecWriteConnectionSecretToRef(obj: ProjectServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project to populate project.
 *
 * @schema ProjectServiceSpecForProviderProjectRef
 */
export interface ProjectServiceSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectServiceSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectServiceSpecForProviderProjectRef#policy
   */
  readonly policy?: ProjectServiceSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'ProjectServiceSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecForProviderProjectRef(obj: ProjectServiceSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectServiceSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project to populate project.
 *
 * @schema ProjectServiceSpecForProviderProjectSelector
 */
export interface ProjectServiceSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectServiceSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectServiceSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectServiceSpecForProviderProjectSelector#policy
   */
  readonly policy?: ProjectServiceSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectServiceSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecForProviderProjectSelector(obj: ProjectServiceSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectServiceSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectServiceSpecProviderConfigRefPolicy
 */
export interface ProjectServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecProviderConfigRefPolicy(obj: ProjectServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecPublishConnectionDetailsToConfigRef(obj: ProjectServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectServiceSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecPublishConnectionDetailsToMetadata(obj: ProjectServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectServiceSpecForProviderProjectRefPolicy
 */
export interface ProjectServiceSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectServiceSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectServiceSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectServiceSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectServiceSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectServiceSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecForProviderProjectRefPolicy(obj: ProjectServiceSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectServiceSpecForProviderProjectSelectorPolicy
 */
export interface ProjectServiceSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectServiceSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectServiceSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectServiceSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectServiceSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectServiceSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecForProviderProjectSelectorPolicy(obj: ProjectServiceSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectServiceSpecProviderConfigRefPolicyResolution
 */
export enum ProjectServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectServiceSpecProviderConfigRefPolicyResolve
 */
export enum ProjectServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectServiceSpecForProviderProjectRefPolicyResolution
 */
export enum ProjectServiceSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectServiceSpecForProviderProjectRefPolicyResolve
 */
export enum ProjectServiceSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectServiceSpecForProviderProjectSelectorPolicyResolution
 */
export enum ProjectServiceSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectServiceSpecForProviderProjectSelectorPolicyResolve
 */
export enum ProjectServiceSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectUsageExportBucket is the Schema for the ProjectUsageExportBuckets API. Manages a project's usage export bucket.
 *
 * @schema ProjectUsageExportBucket
 */
export class ProjectUsageExportBucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectUsageExportBucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ProjectUsageExportBucket',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectUsageExportBucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectUsageExportBucketProps): any {
    return {
      ...ProjectUsageExportBucket.GVK,
      ...toJson_ProjectUsageExportBucketProps(props),
    };
  }

  /**
   * Defines a "ProjectUsageExportBucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectUsageExportBucketProps) {
    super(scope, id, {
      ...ProjectUsageExportBucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectUsageExportBucket.GVK,
      ...toJson_ProjectUsageExportBucketProps(resolved),
    };
  }
}

/**
 * ProjectUsageExportBucket is the Schema for the ProjectUsageExportBuckets API. Manages a project's usage export bucket.
 *
 * @schema ProjectUsageExportBucket
 */
export interface ProjectUsageExportBucketProps {
  /**
   * @schema ProjectUsageExportBucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectUsageExportBucketSpec defines the desired state of ProjectUsageExportBucket
   *
   * @schema ProjectUsageExportBucket#spec
   */
  readonly spec: ProjectUsageExportBucketSpec;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketProps(obj: ProjectUsageExportBucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectUsageExportBucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectUsageExportBucketSpec defines the desired state of ProjectUsageExportBucket
 *
 * @schema ProjectUsageExportBucketSpec
 */
export interface ProjectUsageExportBucketSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectUsageExportBucketSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectUsageExportBucketSpecDeletionPolicy;

  /**
   * @schema ProjectUsageExportBucketSpec#forProvider
   */
  readonly forProvider: ProjectUsageExportBucketSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectUsageExportBucketSpec#initProvider
   */
  readonly initProvider?: ProjectUsageExportBucketSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectUsageExportBucketSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectUsageExportBucketSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectUsageExportBucketSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectUsageExportBucketSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectUsageExportBucketSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectUsageExportBucketSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectUsageExportBucketSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectUsageExportBucketSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpec(obj: ProjectUsageExportBucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectUsageExportBucketSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectUsageExportBucketSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectUsageExportBucketSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectUsageExportBucketSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectUsageExportBucketSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectUsageExportBucketSpecDeletionPolicy
 */
export enum ProjectUsageExportBucketSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectUsageExportBucketSpecForProvider
 */
export interface ProjectUsageExportBucketSpecForProvider {
  /**
   * :  The bucket to store reports in.
   *
   * @schema ProjectUsageExportBucketSpecForProvider#bucketName
   */
  readonly bucketName?: string;

  /**
   * Reference to a Bucket in storage to populate bucketName.
   *
   * @schema ProjectUsageExportBucketSpecForProvider#bucketNameRef
   */
  readonly bucketNameRef?: ProjectUsageExportBucketSpecForProviderBucketNameRef;

  /**
   * Selector for a Bucket in storage to populate bucketName.
   *
   * @schema ProjectUsageExportBucketSpecForProvider#bucketNameSelector
   */
  readonly bucketNameSelector?: ProjectUsageExportBucketSpecForProviderBucketNameSelector;

  /**
   * :  A prefix for the reports, for instance, the project name.
   *
   * @schema ProjectUsageExportBucketSpecForProvider#prefix
   */
  readonly prefix?: string;

  /**
   * :  The project to set the export bucket on. If it is not provided, the provider project is used.
   *
   * @schema ProjectUsageExportBucketSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project to populate project.
   *
   * @schema ProjectUsageExportBucketSpecForProvider#projectRef
   */
  readonly projectRef?: ProjectUsageExportBucketSpecForProviderProjectRef;

  /**
   * Selector for a Project to populate project.
   *
   * @schema ProjectUsageExportBucketSpecForProvider#projectSelector
   */
  readonly projectSelector?: ProjectUsageExportBucketSpecForProviderProjectSelector;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecForProvider(obj: ProjectUsageExportBucketSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketNameRef': toJson_ProjectUsageExportBucketSpecForProviderBucketNameRef(obj.bucketNameRef),
    'bucketNameSelector': toJson_ProjectUsageExportBucketSpecForProviderBucketNameSelector(obj.bucketNameSelector),
    'prefix': obj.prefix,
    'project': obj.project,
    'projectRef': toJson_ProjectUsageExportBucketSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectUsageExportBucketSpecForProviderProjectSelector(obj.projectSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectUsageExportBucketSpecInitProvider
 */
export interface ProjectUsageExportBucketSpecInitProvider {
  /**
   * :  A prefix for the reports, for instance, the project name.
   *
   * @schema ProjectUsageExportBucketSpecInitProvider#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecInitProvider(obj: ProjectUsageExportBucketSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectUsageExportBucketSpecManagementPolicies
 */
export enum ProjectUsageExportBucketSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectUsageExportBucketSpecProviderConfigRef
 */
export interface ProjectUsageExportBucketSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectUsageExportBucketSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectUsageExportBucketSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectUsageExportBucketSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecProviderConfigRef(obj: ProjectUsageExportBucketSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectUsageExportBucketSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsTo
 */
export interface ProjectUsageExportBucketSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectUsageExportBucketSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecPublishConnectionDetailsTo(obj: ProjectUsageExportBucketSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectUsageExportBucketSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectUsageExportBucketSpecWriteConnectionSecretToRef
 */
export interface ProjectUsageExportBucketSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectUsageExportBucketSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectUsageExportBucketSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecWriteConnectionSecretToRef(obj: ProjectUsageExportBucketSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in storage to populate bucketName.
 *
 * @schema ProjectUsageExportBucketSpecForProviderBucketNameRef
 */
export interface ProjectUsageExportBucketSpecForProviderBucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectUsageExportBucketSpecForProviderBucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectUsageExportBucketSpecForProviderBucketNameRef#policy
   */
  readonly policy?: ProjectUsageExportBucketSpecForProviderBucketNameRefPolicy;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecForProviderBucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecForProviderBucketNameRef(obj: ProjectUsageExportBucketSpecForProviderBucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectUsageExportBucketSpecForProviderBucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in storage to populate bucketName.
 *
 * @schema ProjectUsageExportBucketSpecForProviderBucketNameSelector
 */
export interface ProjectUsageExportBucketSpecForProviderBucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectUsageExportBucketSpecForProviderBucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectUsageExportBucketSpecForProviderBucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectUsageExportBucketSpecForProviderBucketNameSelector#policy
   */
  readonly policy?: ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecForProviderBucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecForProviderBucketNameSelector(obj: ProjectUsageExportBucketSpecForProviderBucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project to populate project.
 *
 * @schema ProjectUsageExportBucketSpecForProviderProjectRef
 */
export interface ProjectUsageExportBucketSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectUsageExportBucketSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectUsageExportBucketSpecForProviderProjectRef#policy
   */
  readonly policy?: ProjectUsageExportBucketSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecForProviderProjectRef(obj: ProjectUsageExportBucketSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectUsageExportBucketSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project to populate project.
 *
 * @schema ProjectUsageExportBucketSpecForProviderProjectSelector
 */
export interface ProjectUsageExportBucketSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectUsageExportBucketSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectUsageExportBucketSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectUsageExportBucketSpecForProviderProjectSelector#policy
   */
  readonly policy?: ProjectUsageExportBucketSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecForProviderProjectSelector(obj: ProjectUsageExportBucketSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectUsageExportBucketSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectUsageExportBucketSpecProviderConfigRefPolicy
 */
export interface ProjectUsageExportBucketSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectUsageExportBucketSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectUsageExportBucketSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectUsageExportBucketSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectUsageExportBucketSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecProviderConfigRefPolicy(obj: ProjectUsageExportBucketSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRef(obj: ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectUsageExportBucketSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecPublishConnectionDetailsToMetadata(obj: ProjectUsageExportBucketSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectUsageExportBucketSpecForProviderBucketNameRefPolicy
 */
export interface ProjectUsageExportBucketSpecForProviderBucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectUsageExportBucketSpecForProviderBucketNameRefPolicy#resolution
   */
  readonly resolution?: ProjectUsageExportBucketSpecForProviderBucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectUsageExportBucketSpecForProviderBucketNameRefPolicy#resolve
   */
  readonly resolve?: ProjectUsageExportBucketSpecForProviderBucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecForProviderBucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecForProviderBucketNameRefPolicy(obj: ProjectUsageExportBucketSpecForProviderBucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicy
 */
export interface ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicy#resolution
   */
  readonly resolution?: ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicy#resolve
   */
  readonly resolve?: ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicy(obj: ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectUsageExportBucketSpecForProviderProjectRefPolicy
 */
export interface ProjectUsageExportBucketSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectUsageExportBucketSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectUsageExportBucketSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectUsageExportBucketSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectUsageExportBucketSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecForProviderProjectRefPolicy(obj: ProjectUsageExportBucketSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectUsageExportBucketSpecForProviderProjectSelectorPolicy
 */
export interface ProjectUsageExportBucketSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectUsageExportBucketSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectUsageExportBucketSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectUsageExportBucketSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectUsageExportBucketSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecForProviderProjectSelectorPolicy(obj: ProjectUsageExportBucketSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectUsageExportBucketSpecProviderConfigRefPolicyResolution
 */
export enum ProjectUsageExportBucketSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectUsageExportBucketSpecProviderConfigRefPolicyResolve
 */
export enum ProjectUsageExportBucketSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectUsageExportBucketSpecForProviderBucketNameRefPolicyResolution
 */
export enum ProjectUsageExportBucketSpecForProviderBucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectUsageExportBucketSpecForProviderBucketNameRefPolicyResolve
 */
export enum ProjectUsageExportBucketSpecForProviderBucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicyResolution
 */
export enum ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicyResolve
 */
export enum ProjectUsageExportBucketSpecForProviderBucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectUsageExportBucketSpecForProviderProjectRefPolicyResolution
 */
export enum ProjectUsageExportBucketSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectUsageExportBucketSpecForProviderProjectRefPolicyResolve
 */
export enum ProjectUsageExportBucketSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectUsageExportBucketSpecForProviderProjectSelectorPolicyResolution
 */
export enum ProjectUsageExportBucketSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectUsageExportBucketSpecForProviderProjectSelectorPolicyResolve
 */
export enum ProjectUsageExportBucketSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectUsageExportBucketSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceAccount is the Schema for the ServiceAccounts API. Allows management of a Google Cloud Platform service account.
 *
 * @schema ServiceAccount
 */
export class ServiceAccount extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAccount"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ServiceAccount',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAccount".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceAccountProps): any {
    return {
      ...ServiceAccount.GVK,
      ...toJson_ServiceAccountProps(props),
    };
  }

  /**
   * Defines a "ServiceAccount" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceAccountProps) {
    super(scope, id, {
      ...ServiceAccount.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAccount.GVK,
      ...toJson_ServiceAccountProps(resolved),
    };
  }
}

/**
 * ServiceAccount is the Schema for the ServiceAccounts API. Allows management of a Google Cloud Platform service account.
 *
 * @schema ServiceAccount
 */
export interface ServiceAccountProps {
  /**
   * @schema ServiceAccount#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceAccountSpec defines the desired state of ServiceAccount
   *
   * @schema ServiceAccount#spec
   */
  readonly spec: ServiceAccountSpec;

}

/**
 * Converts an object of type 'ServiceAccountProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountProps(obj: ServiceAccountProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceAccountSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceAccountSpec defines the desired state of ServiceAccount
 *
 * @schema ServiceAccountSpec
 */
export interface ServiceAccountSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceAccountSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceAccountSpecDeletionPolicy;

  /**
   * @schema ServiceAccountSpec#forProvider
   */
  readonly forProvider: ServiceAccountSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ServiceAccountSpec#initProvider
   */
  readonly initProvider?: ServiceAccountSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceAccountSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceAccountSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceAccountSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceAccountSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceAccountSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceAccountSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceAccountSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceAccountSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceAccountSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountSpec(obj: ServiceAccountSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceAccountSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceAccountSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceAccountSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceAccountSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceAccountSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceAccountSpecDeletionPolicy
 */
export enum ServiceAccountSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceAccountSpecForProvider
 */
export interface ServiceAccountSpecForProvider {
  /**
   * A text description of the service account. Must be less than or equal to 256 UTF-8 bytes.
   *
   * @schema ServiceAccountSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether a service account is disabled or not. Defaults to false. This field has no effect during creation. Must be set after creation to disable a service account.
   *
   * @default false. This field has no effect during creation. Must be set after creation to disable a service account.
   * @schema ServiceAccountSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * The display name for the service account. Can be updated without creating a new resource.
   *
   * @schema ServiceAccountSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The ID of the project that the service account will be created in. Defaults to the provider project configuration.
   *
   * @default the provider project configuration.
   * @schema ServiceAccountSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ServiceAccountSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountSpecForProvider(obj: ServiceAccountSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'disabled': obj.disabled,
    'displayName': obj.displayName,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ServiceAccountSpecInitProvider
 */
export interface ServiceAccountSpecInitProvider {
  /**
   * A text description of the service account. Must be less than or equal to 256 UTF-8 bytes.
   *
   * @schema ServiceAccountSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Whether a service account is disabled or not. Defaults to false. This field has no effect during creation. Must be set after creation to disable a service account.
   *
   * @default false. This field has no effect during creation. Must be set after creation to disable a service account.
   * @schema ServiceAccountSpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * The display name for the service account. Can be updated without creating a new resource.
   *
   * @schema ServiceAccountSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The ID of the project that the service account will be created in. Defaults to the provider project configuration.
   *
   * @default the provider project configuration.
   * @schema ServiceAccountSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ServiceAccountSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountSpecInitProvider(obj: ServiceAccountSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'disabled': obj.disabled,
    'displayName': obj.displayName,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServiceAccountSpecManagementPolicies
 */
export enum ServiceAccountSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceAccountSpecProviderConfigRef
 */
export interface ServiceAccountSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceAccountSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceAccountSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountSpecProviderConfigRef(obj: ServiceAccountSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsTo
 */
export interface ServiceAccountSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceAccountSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceAccountSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceAccountSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountSpecPublishConnectionDetailsTo(obj: ServiceAccountSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceAccountSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceAccountSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceAccountSpecWriteConnectionSecretToRef
 */
export interface ServiceAccountSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceAccountSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceAccountSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceAccountSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountSpecWriteConnectionSecretToRef(obj: ServiceAccountSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountSpecProviderConfigRefPolicy
 */
export interface ServiceAccountSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceAccountSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceAccountSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountSpecProviderConfigRefPolicy(obj: ServiceAccountSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceAccountSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceAccountSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountSpecPublishConnectionDetailsToConfigRef(obj: ServiceAccountSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceAccountSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceAccountSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountSpecPublishConnectionDetailsToMetadata(obj: ServiceAccountSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountSpecProviderConfigRefPolicyResolution
 */
export enum ServiceAccountSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceAccountSpecProviderConfigRefPolicyResolve
 */
export enum ServiceAccountSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceAccountIAMMember is the Schema for the ServiceAccountIAMMembers API. <no value>
 *
 * @schema ServiceAccountIAMMember
 */
export class ServiceAccountIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAccountIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ServiceAccountIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAccountIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceAccountIamMemberProps): any {
    return {
      ...ServiceAccountIamMember.GVK,
      ...toJson_ServiceAccountIamMemberProps(props),
    };
  }

  /**
   * Defines a "ServiceAccountIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceAccountIamMemberProps) {
    super(scope, id, {
      ...ServiceAccountIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAccountIamMember.GVK,
      ...toJson_ServiceAccountIamMemberProps(resolved),
    };
  }
}

/**
 * ServiceAccountIAMMember is the Schema for the ServiceAccountIAMMembers API. <no value>
 *
 * @schema ServiceAccountIAMMember
 */
export interface ServiceAccountIamMemberProps {
  /**
   * @schema ServiceAccountIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceAccountIAMMemberSpec defines the desired state of ServiceAccountIAMMember
   *
   * @schema ServiceAccountIAMMember#spec
   */
  readonly spec: ServiceAccountIamMemberSpec;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberProps(obj: ServiceAccountIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceAccountIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceAccountIAMMemberSpec defines the desired state of ServiceAccountIAMMember
 *
 * @schema ServiceAccountIamMemberSpec
 */
export interface ServiceAccountIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceAccountIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceAccountIamMemberSpecDeletionPolicy;

  /**
   * @schema ServiceAccountIamMemberSpec#forProvider
   */
  readonly forProvider: ServiceAccountIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ServiceAccountIamMemberSpec#initProvider
   */
  readonly initProvider?: ServiceAccountIamMemberSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceAccountIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceAccountIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceAccountIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceAccountIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceAccountIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceAccountIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceAccountIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceAccountIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpec(obj: ServiceAccountIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceAccountIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceAccountIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceAccountIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceAccountIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceAccountIamMemberSpecDeletionPolicy
 */
export enum ServiceAccountIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceAccountIamMemberSpecForProvider
 */
export interface ServiceAccountIamMemberSpecForProvider {
  /**
   * @schema ServiceAccountIamMemberSpecForProvider#condition
   */
  readonly condition?: ServiceAccountIamMemberSpecForProviderCondition[];

  /**
   * @schema ServiceAccountIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProvider#role
   */
  readonly role?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberSpecForProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberSpecForProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecForProvider(obj: ServiceAccountIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ServiceAccountIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ServiceAccountIamMemberSpecInitProvider
 */
export interface ServiceAccountIamMemberSpecInitProvider {
  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#condition
   */
  readonly condition?: ServiceAccountIamMemberSpecInitProviderCondition[];

  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProvider(obj: ServiceAccountIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ServiceAccountIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServiceAccountIamMemberSpecManagementPolicies
 */
export enum ServiceAccountIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRef
 */
export interface ServiceAccountIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecProviderConfigRef(obj: ServiceAccountIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsTo
 */
export interface ServiceAccountIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsTo(obj: ServiceAccountIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceAccountIamMemberSpecWriteConnectionSecretToRef
 */
export interface ServiceAccountIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceAccountIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceAccountIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecWriteConnectionSecretToRef(obj: ServiceAccountIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceAccountIamMemberSpecForProviderCondition
 */
export interface ServiceAccountIamMemberSpecForProviderCondition {
  /**
   * @schema ServiceAccountIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderCondition(obj: ServiceAccountIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRef
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRef(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceAccountIamMemberSpecInitProviderCondition
 */
export interface ServiceAccountIamMemberSpecInitProviderCondition {
  /**
   * @schema ServiceAccountIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderCondition(obj: ServiceAccountIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicy
 */
export interface ServiceAccountIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecProviderConfigRefPolicy(obj: ServiceAccountIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef(obj: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata(obj: ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum ServiceAccountIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum ServiceAccountIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceAccountKey is the Schema for the ServiceAccountKeys API. Allows management of a Google Cloud Platform service account Key
 *
 * @schema ServiceAccountKey
 */
export class ServiceAccountKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAccountKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ServiceAccountKey',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAccountKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceAccountKeyProps): any {
    return {
      ...ServiceAccountKey.GVK,
      ...toJson_ServiceAccountKeyProps(props),
    };
  }

  /**
   * Defines a "ServiceAccountKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceAccountKeyProps) {
    super(scope, id, {
      ...ServiceAccountKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAccountKey.GVK,
      ...toJson_ServiceAccountKeyProps(resolved),
    };
  }
}

/**
 * ServiceAccountKey is the Schema for the ServiceAccountKeys API. Allows management of a Google Cloud Platform service account Key
 *
 * @schema ServiceAccountKey
 */
export interface ServiceAccountKeyProps {
  /**
   * @schema ServiceAccountKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceAccountKeySpec defines the desired state of ServiceAccountKey
   *
   * @schema ServiceAccountKey#spec
   */
  readonly spec: ServiceAccountKeySpec;

}

/**
 * Converts an object of type 'ServiceAccountKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeyProps(obj: ServiceAccountKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceAccountKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceAccountKeySpec defines the desired state of ServiceAccountKey
 *
 * @schema ServiceAccountKeySpec
 */
export interface ServiceAccountKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceAccountKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceAccountKeySpecDeletionPolicy;

  /**
   * @schema ServiceAccountKeySpec#forProvider
   */
  readonly forProvider: ServiceAccountKeySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ServiceAccountKeySpec#initProvider
   */
  readonly initProvider?: ServiceAccountKeySpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceAccountKeySpec#managementPolicies
   */
  readonly managementPolicies?: ServiceAccountKeySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceAccountKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceAccountKeySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceAccountKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceAccountKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceAccountKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceAccountKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceAccountKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpec(obj: ServiceAccountKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceAccountKeySpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceAccountKeySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceAccountKeySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceAccountKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceAccountKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceAccountKeySpecDeletionPolicy
 */
export enum ServiceAccountKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceAccountKeySpecForProvider
 */
export interface ServiceAccountKeySpecForProvider {
  /**
   * Arbitrary map of values that, when changed, will trigger a new key to be generated.
   *
   * @schema ServiceAccountKeySpecForProvider#keepers
   */
  readonly keepers?: { [key: string]: string };

  /**
   * The algorithm used to generate the key. KEY_ALG_RSA_2048 is the default algorithm. Valid values are listed at ServiceAccountPrivateKeyType (only used on create)
   *
   * @schema ServiceAccountKeySpecForProvider#keyAlgorithm
   */
  readonly keyAlgorithm?: string;

  /**
   * The output format of the private key. TYPE_GOOGLE_CREDENTIALS_FILE is the default output format.
   *
   * @schema ServiceAccountKeySpecForProvider#privateKeyType
   */
  readonly privateKeyType?: string;

  /**
   * Public key data to create a service account key for given service account. The expected format for this field is a base64 encoded X509_PEM and it conflicts with public_key_type and private_key_type.
   *
   * @schema ServiceAccountKeySpecForProvider#publicKeyData
   */
  readonly publicKeyData?: string;

  /**
   * The output format of the public key requested. TYPE_X509_PEM_FILE is the default output format.
   *
   * @schema ServiceAccountKeySpecForProvider#publicKeyType
   */
  readonly publicKeyType?: string;

  /**
   * The Service account id of the Key. This can be a string in the format {ACCOUNT} or projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}. If the {ACCOUNT}-only syntax is used, either the full email address of the service account or its name can be specified as a value, in which case the project will automatically be inferred from the account. Otherwise, if the projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT} syntax is used, the {ACCOUNT} specified can be the full email address of the service account or the service account's unique id. Substituting - as a wildcard for the {PROJECT_ID} will infer the project from the account.
   *
   * @schema ServiceAccountKeySpecForProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount to populate serviceAccountId.
   *
   * @schema ServiceAccountKeySpecForProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountKeySpecForProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount to populate serviceAccountId.
   *
   * @schema ServiceAccountKeySpecForProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountKeySpecForProviderServiceAccountIdSelector;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecForProvider(obj: ServiceAccountKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keepers': ((obj.keepers) === undefined) ? undefined : (Object.entries(obj.keepers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'keyAlgorithm': obj.keyAlgorithm,
    'privateKeyType': obj.privateKeyType,
    'publicKeyData': obj.publicKeyData,
    'publicKeyType': obj.publicKeyType,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountKeySpecForProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountKeySpecForProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ServiceAccountKeySpecInitProvider
 */
export interface ServiceAccountKeySpecInitProvider {
  /**
   * Arbitrary map of values that, when changed, will trigger a new key to be generated.
   *
   * @schema ServiceAccountKeySpecInitProvider#keepers
   */
  readonly keepers?: { [key: string]: string };

  /**
   * The algorithm used to generate the key. KEY_ALG_RSA_2048 is the default algorithm. Valid values are listed at ServiceAccountPrivateKeyType (only used on create)
   *
   * @schema ServiceAccountKeySpecInitProvider#keyAlgorithm
   */
  readonly keyAlgorithm?: string;

  /**
   * The output format of the private key. TYPE_GOOGLE_CREDENTIALS_FILE is the default output format.
   *
   * @schema ServiceAccountKeySpecInitProvider#privateKeyType
   */
  readonly privateKeyType?: string;

  /**
   * Public key data to create a service account key for given service account. The expected format for this field is a base64 encoded X509_PEM and it conflicts with public_key_type and private_key_type.
   *
   * @schema ServiceAccountKeySpecInitProvider#publicKeyData
   */
  readonly publicKeyData?: string;

  /**
   * The output format of the public key requested. TYPE_X509_PEM_FILE is the default output format.
   *
   * @schema ServiceAccountKeySpecInitProvider#publicKeyType
   */
  readonly publicKeyType?: string;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecInitProvider(obj: ServiceAccountKeySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keepers': ((obj.keepers) === undefined) ? undefined : (Object.entries(obj.keepers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'keyAlgorithm': obj.keyAlgorithm,
    'privateKeyType': obj.privateKeyType,
    'publicKeyData': obj.publicKeyData,
    'publicKeyType': obj.publicKeyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServiceAccountKeySpecManagementPolicies
 */
export enum ServiceAccountKeySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceAccountKeySpecProviderConfigRef
 */
export interface ServiceAccountKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountKeySpecProviderConfigRef#policy
   */
  readonly policy?: ServiceAccountKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecProviderConfigRef(obj: ServiceAccountKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceAccountKeySpecPublishConnectionDetailsTo
 */
export interface ServiceAccountKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceAccountKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceAccountKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceAccountKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceAccountKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceAccountKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecPublishConnectionDetailsTo(obj: ServiceAccountKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceAccountKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceAccountKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceAccountKeySpecWriteConnectionSecretToRef
 */
export interface ServiceAccountKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceAccountKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceAccountKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecWriteConnectionSecretToRef(obj: ServiceAccountKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount to populate serviceAccountId.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdRef
 */
export interface ServiceAccountKeySpecForProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecForProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecForProviderServiceAccountIdRef(obj: ServiceAccountKeySpecForProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount to populate serviceAccountId.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelector
 */
export interface ServiceAccountKeySpecForProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecForProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecForProviderServiceAccountIdSelector(obj: ServiceAccountKeySpecForProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountKeySpecProviderConfigRefPolicy
 */
export interface ServiceAccountKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceAccountKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecProviderConfigRefPolicy(obj: ServiceAccountKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceAccountKeySpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceAccountKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecPublishConnectionDetailsToConfigRef(obj: ServiceAccountKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceAccountKeySpecPublishConnectionDetailsToMetadata
 */
export interface ServiceAccountKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceAccountKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecPublishConnectionDetailsToMetadata(obj: ServiceAccountKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy(obj: ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountKeySpecProviderConfigRefPolicyResolution
 */
export enum ServiceAccountKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceAccountKeySpecProviderConfigRefPolicyResolve
 */
export enum ServiceAccountKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceAccountKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceNetworkingPeeredDNSDomain is the Schema for the ServiceNetworkingPeeredDNSDomains API. Allows management of a single peered DNS domain on a project.
 *
 * @schema ServiceNetworkingPeeredDNSDomain
 */
export class ServiceNetworkingPeeredDnsDomain extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceNetworkingPeeredDNSDomain"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ServiceNetworkingPeeredDNSDomain',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceNetworkingPeeredDNSDomain".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceNetworkingPeeredDnsDomainProps): any {
    return {
      ...ServiceNetworkingPeeredDnsDomain.GVK,
      ...toJson_ServiceNetworkingPeeredDnsDomainProps(props),
    };
  }

  /**
   * Defines a "ServiceNetworkingPeeredDNSDomain" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceNetworkingPeeredDnsDomainProps) {
    super(scope, id, {
      ...ServiceNetworkingPeeredDnsDomain.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceNetworkingPeeredDnsDomain.GVK,
      ...toJson_ServiceNetworkingPeeredDnsDomainProps(resolved),
    };
  }
}

/**
 * ServiceNetworkingPeeredDNSDomain is the Schema for the ServiceNetworkingPeeredDNSDomains API. Allows management of a single peered DNS domain on a project.
 *
 * @schema ServiceNetworkingPeeredDNSDomain
 */
export interface ServiceNetworkingPeeredDnsDomainProps {
  /**
   * @schema ServiceNetworkingPeeredDNSDomain#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceNetworkingPeeredDNSDomainSpec defines the desired state of ServiceNetworkingPeeredDNSDomain
   *
   * @schema ServiceNetworkingPeeredDNSDomain#spec
   */
  readonly spec: ServiceNetworkingPeeredDnsDomainSpec;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainProps(obj: ServiceNetworkingPeeredDnsDomainProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceNetworkingPeeredDnsDomainSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceNetworkingPeeredDNSDomainSpec defines the desired state of ServiceNetworkingPeeredDNSDomain
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpec
 */
export interface ServiceNetworkingPeeredDnsDomainSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceNetworkingPeeredDnsDomainSpecDeletionPolicy;

  /**
   * @schema ServiceNetworkingPeeredDnsDomainSpec#forProvider
   */
  readonly forProvider: ServiceNetworkingPeeredDnsDomainSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpec#initProvider
   */
  readonly initProvider?: ServiceNetworkingPeeredDnsDomainSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceNetworkingPeeredDnsDomainSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceNetworkingPeeredDnsDomainSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceNetworkingPeeredDnsDomainSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainSpec(obj: ServiceNetworkingPeeredDnsDomainSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceNetworkingPeeredDnsDomainSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceNetworkingPeeredDnsDomainSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceNetworkingPeeredDnsDomainSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceNetworkingPeeredDnsDomainSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecDeletionPolicy
 */
export enum ServiceNetworkingPeeredDnsDomainSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceNetworkingPeeredDnsDomainSpecForProvider
 */
export interface ServiceNetworkingPeeredDnsDomainSpecForProvider {
  /**
   * The DNS domain suffix of the peered DNS domain. Make sure to suffix with a . (dot).
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecForProvider#dnsSuffix
   */
  readonly dnsSuffix?: string;

  /**
   * The network in the consumer project.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecForProvider#network
   */
  readonly network: string;

  /**
   * The producer project number. If not provided, the provider project is used.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Private service connection between service and consumer network, defaults to servicenetworking.googleapis.com
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecForProvider#service
   */
  readonly service: string;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainSpecForProvider(obj: ServiceNetworkingPeeredDnsDomainSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsSuffix': obj.dnsSuffix,
    'network': obj.network,
    'project': obj.project,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecInitProvider
 */
export interface ServiceNetworkingPeeredDnsDomainSpecInitProvider {
  /**
   * The DNS domain suffix of the peered DNS domain. Make sure to suffix with a . (dot).
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecInitProvider#dnsSuffix
   */
  readonly dnsSuffix?: string;

  /**
   * The producer project number. If not provided, the provider project is used.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainSpecInitProvider(obj: ServiceNetworkingPeeredDnsDomainSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsSuffix': obj.dnsSuffix,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecManagementPolicies
 */
export enum ServiceNetworkingPeeredDnsDomainSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecProviderConfigRef
 */
export interface ServiceNetworkingPeeredDnsDomainSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainSpecProviderConfigRef(obj: ServiceNetworkingPeeredDnsDomainSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsTo
 */
export interface ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsTo(obj: ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecWriteConnectionSecretToRef
 */
export interface ServiceNetworkingPeeredDnsDomainSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainSpecWriteConnectionSecretToRef(obj: ServiceNetworkingPeeredDnsDomainSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicy
 */
export interface ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicy(obj: ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRef(obj: ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToMetadata(obj: ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicyResolution
 */
export enum ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicyResolve
 */
export enum ServiceNetworkingPeeredDnsDomainSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceNetworkingPeeredDnsDomainSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

