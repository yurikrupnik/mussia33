// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AlertManagerDefinition is the Schema for the AlertManagerDefinitions API. Manages an Amazon Managed Service for Prometheus (AMP) Alert Manager Definition
 *
 * @schema AlertManagerDefinition
 */
export class AlertManagerDefinition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AlertManagerDefinition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'amp.aws.upbound.io/v1beta1',
    kind: 'AlertManagerDefinition',
  }

  /**
   * Renders a Kubernetes manifest for "AlertManagerDefinition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertManagerDefinitionProps): any {
    return {
      ...AlertManagerDefinition.GVK,
      ...toJson_AlertManagerDefinitionProps(props),
    };
  }

  /**
   * Defines a "AlertManagerDefinition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AlertManagerDefinitionProps) {
    super(scope, id, {
      ...AlertManagerDefinition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AlertManagerDefinition.GVK,
      ...toJson_AlertManagerDefinitionProps(resolved),
    };
  }
}

/**
 * AlertManagerDefinition is the Schema for the AlertManagerDefinitions API. Manages an Amazon Managed Service for Prometheus (AMP) Alert Manager Definition
 *
 * @schema AlertManagerDefinition
 */
export interface AlertManagerDefinitionProps {
  /**
   * @schema AlertManagerDefinition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AlertManagerDefinitionSpec defines the desired state of AlertManagerDefinition
   *
   * @schema AlertManagerDefinition#spec
   */
  readonly spec: AlertManagerDefinitionSpec;

}

/**
 * Converts an object of type 'AlertManagerDefinitionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionProps(obj: AlertManagerDefinitionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AlertManagerDefinitionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AlertManagerDefinitionSpec defines the desired state of AlertManagerDefinition
 *
 * @schema AlertManagerDefinitionSpec
 */
export interface AlertManagerDefinitionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AlertManagerDefinitionSpec#deletionPolicy
   */
  readonly deletionPolicy?: AlertManagerDefinitionSpecDeletionPolicy;

  /**
   * @schema AlertManagerDefinitionSpec#forProvider
   */
  readonly forProvider: AlertManagerDefinitionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AlertManagerDefinitionSpec#initProvider
   */
  readonly initProvider?: AlertManagerDefinitionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AlertManagerDefinitionSpec#managementPolicies
   */
  readonly managementPolicies?: AlertManagerDefinitionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AlertManagerDefinitionSpec#providerConfigRef
   */
  readonly providerConfigRef?: AlertManagerDefinitionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AlertManagerDefinitionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AlertManagerDefinitionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AlertManagerDefinitionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AlertManagerDefinitionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpec(obj: AlertManagerDefinitionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AlertManagerDefinitionSpecForProvider(obj.forProvider),
    'initProvider': toJson_AlertManagerDefinitionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AlertManagerDefinitionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AlertManagerDefinitionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AlertManagerDefinitionSpecDeletionPolicy
 */
export enum AlertManagerDefinitionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AlertManagerDefinitionSpecForProvider
 */
export interface AlertManagerDefinitionSpecForProvider {
  /**
   * the alert manager definition that you want to be applied. See more in AWS Docs.
   *
   * @schema AlertManagerDefinitionSpecForProvider#definition
   */
  readonly definition?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AlertManagerDefinitionSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the prometheus workspace the alert manager definition should be linked to
   *
   * @schema AlertManagerDefinitionSpecForProvider#workspaceId
   */
  readonly workspaceId?: string;

  /**
   * Reference to a Workspace in amp to populate workspaceId.
   *
   * @schema AlertManagerDefinitionSpecForProvider#workspaceIdRef
   */
  readonly workspaceIdRef?: AlertManagerDefinitionSpecForProviderWorkspaceIdRef;

  /**
   * Selector for a Workspace in amp to populate workspaceId.
   *
   * @schema AlertManagerDefinitionSpecForProvider#workspaceIdSelector
   */
  readonly workspaceIdSelector?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelector;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProvider(obj: AlertManagerDefinitionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definition': obj.definition,
    'region': obj.region,
    'workspaceId': obj.workspaceId,
    'workspaceIdRef': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRef(obj.workspaceIdRef),
    'workspaceIdSelector': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelector(obj.workspaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AlertManagerDefinitionSpecInitProvider
 */
export interface AlertManagerDefinitionSpecInitProvider {
  /**
   * the alert manager definition that you want to be applied. See more in AWS Docs.
   *
   * @schema AlertManagerDefinitionSpecInitProvider#definition
   */
  readonly definition?: string;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecInitProvider(obj: AlertManagerDefinitionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definition': obj.definition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AlertManagerDefinitionSpecManagementPolicies
 */
export enum AlertManagerDefinitionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRef
 */
export interface AlertManagerDefinitionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRef#policy
   */
  readonly policy?: AlertManagerDefinitionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecProviderConfigRef(obj: AlertManagerDefinitionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertManagerDefinitionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsTo(obj: AlertManagerDefinitionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AlertManagerDefinitionSpecWriteConnectionSecretToRef
 */
export interface AlertManagerDefinitionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AlertManagerDefinitionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AlertManagerDefinitionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecWriteConnectionSecretToRef(obj: AlertManagerDefinitionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workspace in amp to populate workspaceId.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRef
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRef#policy
   */
  readonly policy?: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRef(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workspace in amp to populate workspaceId.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector#policy
   */
  readonly policy?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelector(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRefPolicy
 */
export interface AlertManagerDefinitionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecProviderConfigRefPolicy(obj: AlertManagerDefinitionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef(obj: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata(obj: AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRefPolicyResolution
 */
export enum AlertManagerDefinitionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRefPolicyResolve
 */
export enum AlertManagerDefinitionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy(obj: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolution
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolve
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolution
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolve
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RuleGroupNamespace is the Schema for the RuleGroupNamespaces API. Manages an Amazon Managed Service for Prometheus (AMP) Rule Group Namespace
 *
 * @schema RuleGroupNamespace
 */
export class RuleGroupNamespace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RuleGroupNamespace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'amp.aws.upbound.io/v1beta1',
    kind: 'RuleGroupNamespace',
  }

  /**
   * Renders a Kubernetes manifest for "RuleGroupNamespace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuleGroupNamespaceProps): any {
    return {
      ...RuleGroupNamespace.GVK,
      ...toJson_RuleGroupNamespaceProps(props),
    };
  }

  /**
   * Defines a "RuleGroupNamespace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuleGroupNamespaceProps) {
    super(scope, id, {
      ...RuleGroupNamespace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RuleGroupNamespace.GVK,
      ...toJson_RuleGroupNamespaceProps(resolved),
    };
  }
}

/**
 * RuleGroupNamespace is the Schema for the RuleGroupNamespaces API. Manages an Amazon Managed Service for Prometheus (AMP) Rule Group Namespace
 *
 * @schema RuleGroupNamespace
 */
export interface RuleGroupNamespaceProps {
  /**
   * @schema RuleGroupNamespace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuleGroupNamespaceSpec defines the desired state of RuleGroupNamespace
   *
   * @schema RuleGroupNamespace#spec
   */
  readonly spec: RuleGroupNamespaceSpec;

}

/**
 * Converts an object of type 'RuleGroupNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceProps(obj: RuleGroupNamespaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuleGroupNamespaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuleGroupNamespaceSpec defines the desired state of RuleGroupNamespace
 *
 * @schema RuleGroupNamespaceSpec
 */
export interface RuleGroupNamespaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleGroupNamespaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuleGroupNamespaceSpecDeletionPolicy;

  /**
   * @schema RuleGroupNamespaceSpec#forProvider
   */
  readonly forProvider: RuleGroupNamespaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RuleGroupNamespaceSpec#initProvider
   */
  readonly initProvider?: RuleGroupNamespaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RuleGroupNamespaceSpec#managementPolicies
   */
  readonly managementPolicies?: RuleGroupNamespaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuleGroupNamespaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuleGroupNamespaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuleGroupNamespaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuleGroupNamespaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuleGroupNamespaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuleGroupNamespaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpec(obj: RuleGroupNamespaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuleGroupNamespaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_RuleGroupNamespaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RuleGroupNamespaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RuleGroupNamespaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuleGroupNamespaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleGroupNamespaceSpecDeletionPolicy
 */
export enum RuleGroupNamespaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RuleGroupNamespaceSpecForProvider
 */
export interface RuleGroupNamespaceSpecForProvider {
  /**
   * the rule group namespace data that you want to be applied. See more in AWS Docs.
   *
   * @schema RuleGroupNamespaceSpecForProvider#data
   */
  readonly data?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RuleGroupNamespaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the prometheus workspace the rule group namespace should be linked to
   *
   * @schema RuleGroupNamespaceSpecForProvider#workspaceId
   */
  readonly workspaceId?: string;

  /**
   * Reference to a Workspace in amp to populate workspaceId.
   *
   * @schema RuleGroupNamespaceSpecForProvider#workspaceIdRef
   */
  readonly workspaceIdRef?: RuleGroupNamespaceSpecForProviderWorkspaceIdRef;

  /**
   * Selector for a Workspace in amp to populate workspaceId.
   *
   * @schema RuleGroupNamespaceSpecForProvider#workspaceIdSelector
   */
  readonly workspaceIdSelector?: RuleGroupNamespaceSpecForProviderWorkspaceIdSelector;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecForProvider(obj: RuleGroupNamespaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'region': obj.region,
    'workspaceId': obj.workspaceId,
    'workspaceIdRef': toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdRef(obj.workspaceIdRef),
    'workspaceIdSelector': toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdSelector(obj.workspaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RuleGroupNamespaceSpecInitProvider
 */
export interface RuleGroupNamespaceSpecInitProvider {
  /**
   * the rule group namespace data that you want to be applied. See more in AWS Docs.
   *
   * @schema RuleGroupNamespaceSpecInitProvider#data
   */
  readonly data?: string;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecInitProvider(obj: RuleGroupNamespaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RuleGroupNamespaceSpecManagementPolicies
 */
export enum RuleGroupNamespaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuleGroupNamespaceSpecProviderConfigRef
 */
export interface RuleGroupNamespaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupNamespaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupNamespaceSpecProviderConfigRef#policy
   */
  readonly policy?: RuleGroupNamespaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecProviderConfigRef(obj: RuleGroupNamespaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupNamespaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsTo
 */
export interface RuleGroupNamespaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecPublishConnectionDetailsTo(obj: RuleGroupNamespaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuleGroupNamespaceSpecWriteConnectionSecretToRef
 */
export interface RuleGroupNamespaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuleGroupNamespaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuleGroupNamespaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecWriteConnectionSecretToRef(obj: RuleGroupNamespaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workspace in amp to populate workspaceId.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRef
 */
export interface RuleGroupNamespaceSpecForProviderWorkspaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRef#policy
   */
  readonly policy?: RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecForProviderWorkspaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdRef(obj: RuleGroupNamespaceSpecForProviderWorkspaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workspace in amp to populate workspaceId.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelector
 */
export interface RuleGroupNamespaceSpecForProviderWorkspaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelector#policy
   */
  readonly policy?: RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecForProviderWorkspaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdSelector(obj: RuleGroupNamespaceSpecForProviderWorkspaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupNamespaceSpecProviderConfigRefPolicy
 */
export interface RuleGroupNamespaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupNamespaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuleGroupNamespaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupNamespaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuleGroupNamespaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecProviderConfigRefPolicy(obj: RuleGroupNamespaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef
 */
export interface RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef(obj: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata
 */
export interface RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata(obj: RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy
 */
export interface RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy#resolution
   */
  readonly resolution?: RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy#resolve
   */
  readonly resolve?: RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy(obj: RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy
 */
export interface RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy#resolution
   */
  readonly resolution?: RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy#resolve
   */
  readonly resolve?: RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy(obj: RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupNamespaceSpecProviderConfigRefPolicyResolution
 */
export enum RuleGroupNamespaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupNamespaceSpecProviderConfigRefPolicyResolve
 */
export enum RuleGroupNamespaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolution
 */
export enum RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolve
 */
export enum RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolution
 */
export enum RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolve
 */
export enum RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Workspace is the Schema for the Workspaces API. Manages an Amazon Managed Service for Prometheus (AMP) Workspace
 *
 * @schema Workspace
 */
export class Workspace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Workspace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'amp.aws.upbound.io/v1beta1',
    kind: 'Workspace',
  }

  /**
   * Renders a Kubernetes manifest for "Workspace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkspaceProps): any {
    return {
      ...Workspace.GVK,
      ...toJson_WorkspaceProps(props),
    };
  }

  /**
   * Defines a "Workspace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkspaceProps) {
    super(scope, id, {
      ...Workspace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Workspace.GVK,
      ...toJson_WorkspaceProps(resolved),
    };
  }
}

/**
 * Workspace is the Schema for the Workspaces API. Manages an Amazon Managed Service for Prometheus (AMP) Workspace
 *
 * @schema Workspace
 */
export interface WorkspaceProps {
  /**
   * @schema Workspace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkspaceSpec defines the desired state of Workspace
   *
   * @schema Workspace#spec
   */
  readonly spec: WorkspaceSpec;

}

/**
 * Converts an object of type 'WorkspaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceProps(obj: WorkspaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkspaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkspaceSpec defines the desired state of Workspace
 *
 * @schema WorkspaceSpec
 */
export interface WorkspaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkspaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkspaceSpecDeletionPolicy;

  /**
   * @schema WorkspaceSpec#forProvider
   */
  readonly forProvider: WorkspaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema WorkspaceSpec#initProvider
   */
  readonly initProvider?: WorkspaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkspaceSpec#managementPolicies
   */
  readonly managementPolicies?: WorkspaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkspaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkspaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkspaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkspaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkspaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkspaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkspaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpec(obj: WorkspaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkspaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_WorkspaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkspaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkspaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkspaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkspaceSpecDeletionPolicy
 */
export enum WorkspaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkspaceSpecForProvider
 */
export interface WorkspaceSpecForProvider {
  /**
   * The alias of the prometheus workspace. See more in AWS Docs.
   *
   * @schema WorkspaceSpecForProvider#alias
   */
  readonly alias?: string;

  /**
   * Logging configuration for the workspace. See Logging Configuration below for details.
   *
   * @schema WorkspaceSpecForProvider#loggingConfiguration
   */
  readonly loggingConfiguration?: WorkspaceSpecForProviderLoggingConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkspaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkspaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkspaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProvider(obj: WorkspaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'loggingConfiguration': obj.loggingConfiguration?.map(y => toJson_WorkspaceSpecForProviderLoggingConfiguration(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema WorkspaceSpecInitProvider
 */
export interface WorkspaceSpecInitProvider {
  /**
   * The alias of the prometheus workspace. See more in AWS Docs.
   *
   * @schema WorkspaceSpecInitProvider#alias
   */
  readonly alias?: string;

  /**
   * Logging configuration for the workspace. See Logging Configuration below for details.
   *
   * @schema WorkspaceSpecInitProvider#loggingConfiguration
   */
  readonly loggingConfiguration?: WorkspaceSpecInitProviderLoggingConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkspaceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkspaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecInitProvider(obj: WorkspaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'loggingConfiguration': obj.loggingConfiguration?.map(y => toJson_WorkspaceSpecInitProviderLoggingConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkspaceSpecManagementPolicies
 */
export enum WorkspaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkspaceSpecProviderConfigRef
 */
export interface WorkspaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSpecProviderConfigRef#policy
   */
  readonly policy?: WorkspaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecProviderConfigRef(obj: WorkspaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsTo
 */
export interface WorkspaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkspaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkspaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsTo(obj: WorkspaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkspaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkspaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkspaceSpecWriteConnectionSecretToRef
 */
export interface WorkspaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkspaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkspaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkspaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecWriteConnectionSecretToRef(obj: WorkspaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkspaceSpecForProviderLoggingConfiguration
 */
export interface WorkspaceSpecForProviderLoggingConfiguration {
  /**
   * The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist.
   *
   * @schema WorkspaceSpecForProviderLoggingConfiguration#logGroupArn
   */
  readonly logGroupArn?: string;

}

/**
 * Converts an object of type 'WorkspaceSpecForProviderLoggingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProviderLoggingConfiguration(obj: WorkspaceSpecForProviderLoggingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logGroupArn': obj.logGroupArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkspaceSpecInitProviderLoggingConfiguration
 */
export interface WorkspaceSpecInitProviderLoggingConfiguration {
  /**
   * The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist.
   *
   * @schema WorkspaceSpecInitProviderLoggingConfiguration#logGroupArn
   */
  readonly logGroupArn?: string;

}

/**
 * Converts an object of type 'WorkspaceSpecInitProviderLoggingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecInitProviderLoggingConfiguration(obj: WorkspaceSpecInitProviderLoggingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logGroupArn': obj.logGroupArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicy
 */
export interface WorkspaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecProviderConfigRefPolicy(obj: WorkspaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkspaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToConfigRef(obj: WorkspaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToMetadata
 */
export interface WorkspaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToMetadata(obj: WorkspaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicyResolution
 */
export enum WorkspaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicyResolve
 */
export enum WorkspaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

