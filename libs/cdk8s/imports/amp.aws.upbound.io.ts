// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AlertManagerDefinition is the Schema for the AlertManagerDefinitions API. Manages an Amazon Managed Service for Prometheus (AMP) Alert Manager Definition
 *
 * @schema AlertManagerDefinition
 */
export class AlertManagerDefinition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AlertManagerDefinition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'amp.aws.upbound.io/v1beta1',
    kind: 'AlertManagerDefinition',
  }

  /**
   * Renders a Kubernetes manifest for "AlertManagerDefinition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertManagerDefinitionProps): any {
    return {
      ...AlertManagerDefinition.GVK,
      ...toJson_AlertManagerDefinitionProps(props),
    };
  }

  /**
   * Defines a "AlertManagerDefinition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AlertManagerDefinitionProps) {
    super(scope, id, {
      ...AlertManagerDefinition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AlertManagerDefinition.GVK,
      ...toJson_AlertManagerDefinitionProps(resolved),
    };
  }
}

/**
 * AlertManagerDefinition is the Schema for the AlertManagerDefinitions API. Manages an Amazon Managed Service for Prometheus (AMP) Alert Manager Definition
 *
 * @schema AlertManagerDefinition
 */
export interface AlertManagerDefinitionProps {
  /**
   * @schema AlertManagerDefinition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AlertManagerDefinitionSpec defines the desired state of AlertManagerDefinition
   *
   * @schema AlertManagerDefinition#spec
   */
  readonly spec: AlertManagerDefinitionSpec;

}

/**
 * Converts an object of type 'AlertManagerDefinitionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionProps(obj: AlertManagerDefinitionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AlertManagerDefinitionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AlertManagerDefinitionSpec defines the desired state of AlertManagerDefinition
 *
 * @schema AlertManagerDefinitionSpec
 */
export interface AlertManagerDefinitionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AlertManagerDefinitionSpec#deletionPolicy
   */
  readonly deletionPolicy?: AlertManagerDefinitionSpecDeletionPolicy;

  /**
   * @schema AlertManagerDefinitionSpec#forProvider
   */
  readonly forProvider: AlertManagerDefinitionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AlertManagerDefinitionSpec#providerConfigRef
   */
  readonly providerConfigRef?: AlertManagerDefinitionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AlertManagerDefinitionSpec#providerRef
   */
  readonly providerRef?: AlertManagerDefinitionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AlertManagerDefinitionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AlertManagerDefinitionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AlertManagerDefinitionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AlertManagerDefinitionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpec(obj: AlertManagerDefinitionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AlertManagerDefinitionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AlertManagerDefinitionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AlertManagerDefinitionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AlertManagerDefinitionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AlertManagerDefinitionSpecDeletionPolicy
 */
export enum AlertManagerDefinitionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AlertManagerDefinitionSpecForProvider
 */
export interface AlertManagerDefinitionSpecForProvider {
  /**
   * the alert manager definition that you want to be applied. See more in AWS Docs.
   *
   * @schema AlertManagerDefinitionSpecForProvider#definition
   */
  readonly definition: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AlertManagerDefinitionSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the prometheus workspace the alert manager definition should be linked to
   *
   * @schema AlertManagerDefinitionSpecForProvider#workspaceId
   */
  readonly workspaceId?: string;

  /**
   * Reference to a Workspace in amp to populate workspaceId.
   *
   * @schema AlertManagerDefinitionSpecForProvider#workspaceIdRef
   */
  readonly workspaceIdRef?: AlertManagerDefinitionSpecForProviderWorkspaceIdRef;

  /**
   * Selector for a Workspace in amp to populate workspaceId.
   *
   * @schema AlertManagerDefinitionSpecForProvider#workspaceIdSelector
   */
  readonly workspaceIdSelector?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelector;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProvider(obj: AlertManagerDefinitionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definition': obj.definition,
    'region': obj.region,
    'workspaceId': obj.workspaceId,
    'workspaceIdRef': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRef(obj.workspaceIdRef),
    'workspaceIdSelector': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelector(obj.workspaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRef
 */
export interface AlertManagerDefinitionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRef#policy
   */
  readonly policy?: AlertManagerDefinitionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecProviderConfigRef(obj: AlertManagerDefinitionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertManagerDefinitionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AlertManagerDefinitionSpecProviderRef
 */
export interface AlertManagerDefinitionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertManagerDefinitionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertManagerDefinitionSpecProviderRef#policy
   */
  readonly policy?: AlertManagerDefinitionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecProviderRef(obj: AlertManagerDefinitionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertManagerDefinitionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsTo(obj: AlertManagerDefinitionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AlertManagerDefinitionSpecWriteConnectionSecretToRef
 */
export interface AlertManagerDefinitionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AlertManagerDefinitionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AlertManagerDefinitionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecWriteConnectionSecretToRef(obj: AlertManagerDefinitionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workspace in amp to populate workspaceId.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRef
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRef#policy
   */
  readonly policy?: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRef(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workspace in amp to populate workspaceId.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelector#policy
   */
  readonly policy?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelector(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRefPolicy
 */
export interface AlertManagerDefinitionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecProviderConfigRefPolicy(obj: AlertManagerDefinitionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AlertManagerDefinitionSpecProviderRefPolicy
 */
export interface AlertManagerDefinitionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecProviderRefPolicy(obj: AlertManagerDefinitionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef(obj: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata(obj: AlertManagerDefinitionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy
 */
export interface AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy(obj: AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRefPolicyResolution
 */
export enum AlertManagerDefinitionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecProviderConfigRefPolicyResolve
 */
export enum AlertManagerDefinitionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecProviderRefPolicyResolution
 */
export enum AlertManagerDefinitionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecProviderRefPolicyResolve
 */
export enum AlertManagerDefinitionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy(obj: AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolution
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolve
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolution
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolve
 */
export enum AlertManagerDefinitionSpecForProviderWorkspaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AlertManagerDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RuleGroupNamespace is the Schema for the RuleGroupNamespaces API. Manages an Amazon Managed Service for Prometheus (AMP) Rule Group Namespace
 *
 * @schema RuleGroupNamespace
 */
export class RuleGroupNamespace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RuleGroupNamespace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'amp.aws.upbound.io/v1beta1',
    kind: 'RuleGroupNamespace',
  }

  /**
   * Renders a Kubernetes manifest for "RuleGroupNamespace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuleGroupNamespaceProps): any {
    return {
      ...RuleGroupNamespace.GVK,
      ...toJson_RuleGroupNamespaceProps(props),
    };
  }

  /**
   * Defines a "RuleGroupNamespace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuleGroupNamespaceProps) {
    super(scope, id, {
      ...RuleGroupNamespace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RuleGroupNamespace.GVK,
      ...toJson_RuleGroupNamespaceProps(resolved),
    };
  }
}

/**
 * RuleGroupNamespace is the Schema for the RuleGroupNamespaces API. Manages an Amazon Managed Service for Prometheus (AMP) Rule Group Namespace
 *
 * @schema RuleGroupNamespace
 */
export interface RuleGroupNamespaceProps {
  /**
   * @schema RuleGroupNamespace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuleGroupNamespaceSpec defines the desired state of RuleGroupNamespace
   *
   * @schema RuleGroupNamespace#spec
   */
  readonly spec: RuleGroupNamespaceSpec;

}

/**
 * Converts an object of type 'RuleGroupNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceProps(obj: RuleGroupNamespaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuleGroupNamespaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuleGroupNamespaceSpec defines the desired state of RuleGroupNamespace
 *
 * @schema RuleGroupNamespaceSpec
 */
export interface RuleGroupNamespaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RuleGroupNamespaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuleGroupNamespaceSpecDeletionPolicy;

  /**
   * @schema RuleGroupNamespaceSpec#forProvider
   */
  readonly forProvider: RuleGroupNamespaceSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuleGroupNamespaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuleGroupNamespaceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RuleGroupNamespaceSpec#providerRef
   */
  readonly providerRef?: RuleGroupNamespaceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuleGroupNamespaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuleGroupNamespaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuleGroupNamespaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuleGroupNamespaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpec(obj: RuleGroupNamespaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuleGroupNamespaceSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RuleGroupNamespaceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RuleGroupNamespaceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RuleGroupNamespaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuleGroupNamespaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RuleGroupNamespaceSpecDeletionPolicy
 */
export enum RuleGroupNamespaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RuleGroupNamespaceSpecForProvider
 */
export interface RuleGroupNamespaceSpecForProvider {
  /**
   * the rule group namespace data that you want to be applied. See more in AWS Docs.
   *
   * @schema RuleGroupNamespaceSpecForProvider#data
   */
  readonly data: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RuleGroupNamespaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the prometheus workspace the rule group namespace should be linked to
   *
   * @schema RuleGroupNamespaceSpecForProvider#workspaceId
   */
  readonly workspaceId?: string;

  /**
   * Reference to a Workspace in amp to populate workspaceId.
   *
   * @schema RuleGroupNamespaceSpecForProvider#workspaceIdRef
   */
  readonly workspaceIdRef?: RuleGroupNamespaceSpecForProviderWorkspaceIdRef;

  /**
   * Selector for a Workspace in amp to populate workspaceId.
   *
   * @schema RuleGroupNamespaceSpecForProvider#workspaceIdSelector
   */
  readonly workspaceIdSelector?: RuleGroupNamespaceSpecForProviderWorkspaceIdSelector;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecForProvider(obj: RuleGroupNamespaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'region': obj.region,
    'workspaceId': obj.workspaceId,
    'workspaceIdRef': toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdRef(obj.workspaceIdRef),
    'workspaceIdSelector': toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdSelector(obj.workspaceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuleGroupNamespaceSpecProviderConfigRef
 */
export interface RuleGroupNamespaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupNamespaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupNamespaceSpecProviderConfigRef#policy
   */
  readonly policy?: RuleGroupNamespaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecProviderConfigRef(obj: RuleGroupNamespaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupNamespaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RuleGroupNamespaceSpecProviderRef
 */
export interface RuleGroupNamespaceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupNamespaceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupNamespaceSpecProviderRef#policy
   */
  readonly policy?: RuleGroupNamespaceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecProviderRef(obj: RuleGroupNamespaceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupNamespaceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsTo
 */
export interface RuleGroupNamespaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecPublishConnectionDetailsTo(obj: RuleGroupNamespaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuleGroupNamespaceSpecWriteConnectionSecretToRef
 */
export interface RuleGroupNamespaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuleGroupNamespaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuleGroupNamespaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecWriteConnectionSecretToRef(obj: RuleGroupNamespaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workspace in amp to populate workspaceId.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRef
 */
export interface RuleGroupNamespaceSpecForProviderWorkspaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRef#policy
   */
  readonly policy?: RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecForProviderWorkspaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdRef(obj: RuleGroupNamespaceSpecForProviderWorkspaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workspace in amp to populate workspaceId.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelector
 */
export interface RuleGroupNamespaceSpecForProviderWorkspaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelector#policy
   */
  readonly policy?: RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecForProviderWorkspaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdSelector(obj: RuleGroupNamespaceSpecForProviderWorkspaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupNamespaceSpecProviderConfigRefPolicy
 */
export interface RuleGroupNamespaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupNamespaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuleGroupNamespaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupNamespaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuleGroupNamespaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecProviderConfigRefPolicy(obj: RuleGroupNamespaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupNamespaceSpecProviderRefPolicy
 */
export interface RuleGroupNamespaceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupNamespaceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RuleGroupNamespaceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupNamespaceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RuleGroupNamespaceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecProviderRefPolicy(obj: RuleGroupNamespaceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef
 */
export interface RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef(obj: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata
 */
export interface RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata(obj: RuleGroupNamespaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy
 */
export interface RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy#resolution
   */
  readonly resolution?: RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy#resolve
   */
  readonly resolve?: RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy(obj: RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy
 */
export interface RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy#resolution
   */
  readonly resolution?: RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy#resolve
   */
  readonly resolve?: RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy(obj: RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupNamespaceSpecProviderConfigRefPolicyResolution
 */
export enum RuleGroupNamespaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupNamespaceSpecProviderConfigRefPolicyResolve
 */
export enum RuleGroupNamespaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupNamespaceSpecProviderRefPolicyResolution
 */
export enum RuleGroupNamespaceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupNamespaceSpecProviderRefPolicyResolve
 */
export enum RuleGroupNamespaceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolution
 */
export enum RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolve
 */
export enum RuleGroupNamespaceSpecForProviderWorkspaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolution
 */
export enum RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolve
 */
export enum RuleGroupNamespaceSpecForProviderWorkspaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuleGroupNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Workspace is the Schema for the Workspaces API. Manages an Amazon Managed Service for Prometheus (AMP) Workspace
 *
 * @schema Workspace
 */
export class Workspace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Workspace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'amp.aws.upbound.io/v1beta1',
    kind: 'Workspace',
  }

  /**
   * Renders a Kubernetes manifest for "Workspace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkspaceProps): any {
    return {
      ...Workspace.GVK,
      ...toJson_WorkspaceProps(props),
    };
  }

  /**
   * Defines a "Workspace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkspaceProps) {
    super(scope, id, {
      ...Workspace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Workspace.GVK,
      ...toJson_WorkspaceProps(resolved),
    };
  }
}

/**
 * Workspace is the Schema for the Workspaces API. Manages an Amazon Managed Service for Prometheus (AMP) Workspace
 *
 * @schema Workspace
 */
export interface WorkspaceProps {
  /**
   * @schema Workspace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkspaceSpec defines the desired state of Workspace
   *
   * @schema Workspace#spec
   */
  readonly spec: WorkspaceSpec;

}

/**
 * Converts an object of type 'WorkspaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceProps(obj: WorkspaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkspaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkspaceSpec defines the desired state of Workspace
 *
 * @schema WorkspaceSpec
 */
export interface WorkspaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema WorkspaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkspaceSpecDeletionPolicy;

  /**
   * @schema WorkspaceSpec#forProvider
   */
  readonly forProvider: WorkspaceSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkspaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkspaceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WorkspaceSpec#providerRef
   */
  readonly providerRef?: WorkspaceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkspaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkspaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkspaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkspaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkspaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpec(obj: WorkspaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkspaceSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_WorkspaceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WorkspaceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WorkspaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkspaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema WorkspaceSpecDeletionPolicy
 */
export enum WorkspaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkspaceSpecForProvider
 */
export interface WorkspaceSpecForProvider {
  /**
   * The alias of the prometheus workspace. See more in AWS Docs.
   *
   * @schema WorkspaceSpecForProvider#alias
   */
  readonly alias?: string;

  /**
   * Logging configuration for the workspace. See Logging Configuration below for details.
   *
   * @schema WorkspaceSpecForProvider#loggingConfiguration
   */
  readonly loggingConfiguration?: WorkspaceSpecForProviderLoggingConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkspaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkspaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkspaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProvider(obj: WorkspaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'loggingConfiguration': obj.loggingConfiguration?.map(y => toJson_WorkspaceSpecForProviderLoggingConfiguration(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkspaceSpecProviderConfigRef
 */
export interface WorkspaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSpecProviderConfigRef#policy
   */
  readonly policy?: WorkspaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecProviderConfigRef(obj: WorkspaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WorkspaceSpecProviderRef
 */
export interface WorkspaceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSpecProviderRef#policy
   */
  readonly policy?: WorkspaceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecProviderRef(obj: WorkspaceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsTo
 */
export interface WorkspaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkspaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkspaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsTo(obj: WorkspaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkspaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkspaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkspaceSpecWriteConnectionSecretToRef
 */
export interface WorkspaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkspaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkspaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkspaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecWriteConnectionSecretToRef(obj: WorkspaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkspaceSpecForProviderLoggingConfiguration
 */
export interface WorkspaceSpecForProviderLoggingConfiguration {
  /**
   * The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist.
   *
   * @schema WorkspaceSpecForProviderLoggingConfiguration#logGroupArn
   */
  readonly logGroupArn: string;

}

/**
 * Converts an object of type 'WorkspaceSpecForProviderLoggingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecForProviderLoggingConfiguration(obj: WorkspaceSpecForProviderLoggingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logGroupArn': obj.logGroupArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicy
 */
export interface WorkspaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecProviderConfigRefPolicy(obj: WorkspaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSpecProviderRefPolicy
 */
export interface WorkspaceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecProviderRefPolicy(obj: WorkspaceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkspaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToConfigRef(obj: WorkspaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToMetadata
 */
export interface WorkspaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToMetadata(obj: WorkspaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicyResolution
 */
export enum WorkspaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecProviderConfigRefPolicyResolve
 */
export enum WorkspaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecProviderRefPolicyResolution
 */
export enum WorkspaceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecProviderRefPolicyResolve
 */
export enum WorkspaceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkspaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkspaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

