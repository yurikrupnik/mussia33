// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Repository is the Schema for the Repositorys API. A repository (or repo) is a Git repository storing versioned source content.
 *
 * @schema Repository
 */
export class Repository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Repository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sourcerepo.gcp.upbound.io/v1beta1',
    kind: 'Repository',
  }

  /**
   * Renders a Kubernetes manifest for "Repository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RepositoryProps): any {
    return {
      ...Repository.GVK,
      ...toJson_RepositoryProps(props),
    };
  }

  /**
   * Defines a "Repository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RepositoryProps) {
    super(scope, id, {
      ...Repository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Repository.GVK,
      ...toJson_RepositoryProps(resolved),
    };
  }
}

/**
 * Repository is the Schema for the Repositorys API. A repository (or repo) is a Git repository storing versioned source content.
 *
 * @schema Repository
 */
export interface RepositoryProps {
  /**
   * @schema Repository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RepositorySpec defines the desired state of Repository
   *
   * @schema Repository#spec
   */
  readonly spec: RepositorySpec;

}

/**
 * Converts an object of type 'RepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryProps(obj: RepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepositorySpec defines the desired state of Repository
 *
 * @schema RepositorySpec
 */
export interface RepositorySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RepositorySpec#deletionPolicy
   */
  readonly deletionPolicy?: RepositorySpecDeletionPolicy;

  /**
   * @schema RepositorySpec#forProvider
   */
  readonly forProvider: RepositorySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RepositorySpec#providerConfigRef
   */
  readonly providerConfigRef?: RepositorySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RepositorySpec#providerRef
   */
  readonly providerRef?: RepositorySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RepositorySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RepositorySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RepositorySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RepositorySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpec(obj: RepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RepositorySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RepositorySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RepositorySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RepositorySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RepositorySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RepositorySpecDeletionPolicy
 */
export enum RepositorySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RepositorySpecForProvider
 */
export interface RepositorySpecForProvider {
  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema RepositorySpecForProvider#project
   */
  readonly project?: string;

  /**
   * How this repository publishes a change in the repository through Cloud Pub/Sub. Keyed by the topic names. Structure is documented below.
   *
   * @schema RepositorySpecForProvider#pubsubConfigs
   */
  readonly pubsubConfigs?: RepositorySpecForProviderPubsubConfigs[];

}

/**
 * Converts an object of type 'RepositorySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProvider(obj: RepositorySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'project': obj.project,
    'pubsubConfigs': obj.pubsubConfigs?.map(y => toJson_RepositorySpecForProviderPubsubConfigs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RepositorySpecProviderConfigRef
 */
export interface RepositorySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecProviderConfigRef#policy
   */
  readonly policy?: RepositorySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderConfigRef(obj: RepositorySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RepositorySpecProviderRef
 */
export interface RepositorySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecProviderRef#policy
   */
  readonly policy?: RepositorySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderRef(obj: RepositorySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RepositorySpecPublishConnectionDetailsTo
 */
export interface RepositorySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RepositorySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RepositorySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsTo(obj: RepositorySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RepositorySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RepositorySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RepositorySpecWriteConnectionSecretToRef
 */
export interface RepositorySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RepositorySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositorySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositorySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecWriteConnectionSecretToRef(obj: RepositorySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RepositorySpecForProviderPubsubConfigs
 */
export interface RepositorySpecForProviderPubsubConfigs {
  /**
   * The format of the Cloud Pub/Sub messages.
   *
   * @schema RepositorySpecForProviderPubsubConfigs#messageFormat
   */
  readonly messageFormat: string;

  /**
   * Email address of the service account used for publishing Cloud Pub/Sub messages. This service account needs to be in the same project as the PubsubConfig. When added, the caller needs to have iam.serviceAccounts.actAs permission on this service account. If unspecified, it defaults to the compute engine default service account.
   *
   * @schema RepositorySpecForProviderPubsubConfigs#serviceAccountEmail
   */
  readonly serviceAccountEmail?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
   *
   * @schema RepositorySpecForProviderPubsubConfigs#serviceAccountEmailRef
   */
  readonly serviceAccountEmailRef?: RepositorySpecForProviderPubsubConfigsServiceAccountEmailRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
   *
   * @schema RepositorySpecForProviderPubsubConfigs#serviceAccountEmailSelector
   */
  readonly serviceAccountEmailSelector?: RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelector;

  /**
   * The identifier for this object. Format specified above.
   *
   * @schema RepositorySpecForProviderPubsubConfigs#topic
   */
  readonly topic?: string;

  /**
   * Reference to a Topic in pubsub to populate topic.
   *
   * @schema RepositorySpecForProviderPubsubConfigs#topicRef
   */
  readonly topicRef?: RepositorySpecForProviderPubsubConfigsTopicRef;

  /**
   * Selector for a Topic in pubsub to populate topic.
   *
   * @schema RepositorySpecForProviderPubsubConfigs#topicSelector
   */
  readonly topicSelector?: RepositorySpecForProviderPubsubConfigsTopicSelector;

}

/**
 * Converts an object of type 'RepositorySpecForProviderPubsubConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderPubsubConfigs(obj: RepositorySpecForProviderPubsubConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messageFormat': obj.messageFormat,
    'serviceAccountEmail': obj.serviceAccountEmail,
    'serviceAccountEmailRef': toJson_RepositorySpecForProviderPubsubConfigsServiceAccountEmailRef(obj.serviceAccountEmailRef),
    'serviceAccountEmailSelector': toJson_RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelector(obj.serviceAccountEmailSelector),
    'topic': obj.topic,
    'topicRef': toJson_RepositorySpecForProviderPubsubConfigsTopicRef(obj.topicRef),
    'topicSelector': toJson_RepositorySpecForProviderPubsubConfigsTopicSelector(obj.topicSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecProviderConfigRefPolicy
 */
export interface RepositorySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderConfigRefPolicy(obj: RepositorySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecProviderRefPolicy
 */
export interface RepositorySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecProviderRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecProviderRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderRefPolicy(obj: RepositorySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRef
 */
export interface RepositorySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RepositorySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToConfigRef(obj: RepositorySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RepositorySpecPublishConnectionDetailsToMetadata
 */
export interface RepositorySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToMetadata(obj: RepositorySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountEmail.
 *
 * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailRef
 */
export interface RepositorySpecForProviderPubsubConfigsServiceAccountEmailRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailRef#policy
   */
  readonly policy?: RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecForProviderPubsubConfigsServiceAccountEmailRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderPubsubConfigsServiceAccountEmailRef(obj: RepositorySpecForProviderPubsubConfigsServiceAccountEmailRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountEmail.
 *
 * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelector
 */
export interface RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelector#policy
   */
  readonly policy?: RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicy;

}

/**
 * Converts an object of type 'RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelector(obj: RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in pubsub to populate topic.
 *
 * @schema RepositorySpecForProviderPubsubConfigsTopicRef
 */
export interface RepositorySpecForProviderPubsubConfigsTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecForProviderPubsubConfigsTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecForProviderPubsubConfigsTopicRef#policy
   */
  readonly policy?: RepositorySpecForProviderPubsubConfigsTopicRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecForProviderPubsubConfigsTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderPubsubConfigsTopicRef(obj: RepositorySpecForProviderPubsubConfigsTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecForProviderPubsubConfigsTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in pubsub to populate topic.
 *
 * @schema RepositorySpecForProviderPubsubConfigsTopicSelector
 */
export interface RepositorySpecForProviderPubsubConfigsTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositorySpecForProviderPubsubConfigsTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositorySpecForProviderPubsubConfigsTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositorySpecForProviderPubsubConfigsTopicSelector#policy
   */
  readonly policy?: RepositorySpecForProviderPubsubConfigsTopicSelectorPolicy;

}

/**
 * Converts an object of type 'RepositorySpecForProviderPubsubConfigsTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderPubsubConfigsTopicSelector(obj: RepositorySpecForProviderPubsubConfigsTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositorySpecForProviderPubsubConfigsTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecProviderConfigRefPolicyResolution
 */
export enum RepositorySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecProviderConfigRefPolicyResolve
 */
export enum RepositorySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecProviderRefPolicyResolution
 */
export enum RepositorySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecProviderRefPolicyResolve
 */
export enum RepositorySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RepositorySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj: RepositorySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicy
 */
export interface RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicy(obj: RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicy
 */
export interface RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicy#resolution
   */
  readonly resolution?: RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicy#resolve
   */
  readonly resolve?: RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicy(obj: RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecForProviderPubsubConfigsTopicRefPolicy
 */
export interface RepositorySpecForProviderPubsubConfigsTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecForProviderPubsubConfigsTopicRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecForProviderPubsubConfigsTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecForProviderPubsubConfigsTopicRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecForProviderPubsubConfigsTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecForProviderPubsubConfigsTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderPubsubConfigsTopicRefPolicy(obj: RepositorySpecForProviderPubsubConfigsTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositorySpecForProviderPubsubConfigsTopicSelectorPolicy
 */
export interface RepositorySpecForProviderPubsubConfigsTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecForProviderPubsubConfigsTopicSelectorPolicy#resolution
   */
  readonly resolution?: RepositorySpecForProviderPubsubConfigsTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecForProviderPubsubConfigsTopicSelectorPolicy#resolve
   */
  readonly resolve?: RepositorySpecForProviderPubsubConfigsTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecForProviderPubsubConfigsTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderPubsubConfigsTopicSelectorPolicy(obj: RepositorySpecForProviderPubsubConfigsTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicyResolution
 */
export enum RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicyResolve
 */
export enum RepositorySpecForProviderPubsubConfigsServiceAccountEmailRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicyResolution
 */
export enum RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicyResolve
 */
export enum RepositorySpecForProviderPubsubConfigsServiceAccountEmailSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecForProviderPubsubConfigsTopicRefPolicyResolution
 */
export enum RepositorySpecForProviderPubsubConfigsTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecForProviderPubsubConfigsTopicRefPolicyResolve
 */
export enum RepositorySpecForProviderPubsubConfigsTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecForProviderPubsubConfigsTopicSelectorPolicyResolution
 */
export enum RepositorySpecForProviderPubsubConfigsTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecForProviderPubsubConfigsTopicSelectorPolicyResolve
 */
export enum RepositorySpecForProviderPubsubConfigsTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RepositoryIAMMember is the Schema for the RepositoryIAMMembers API. <no value>
 *
 * @schema RepositoryIAMMember
 */
export class RepositoryIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RepositoryIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sourcerepo.gcp.upbound.io/v1beta1',
    kind: 'RepositoryIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "RepositoryIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RepositoryIamMemberProps): any {
    return {
      ...RepositoryIamMember.GVK,
      ...toJson_RepositoryIamMemberProps(props),
    };
  }

  /**
   * Defines a "RepositoryIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RepositoryIamMemberProps) {
    super(scope, id, {
      ...RepositoryIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RepositoryIamMember.GVK,
      ...toJson_RepositoryIamMemberProps(resolved),
    };
  }
}

/**
 * RepositoryIAMMember is the Schema for the RepositoryIAMMembers API. <no value>
 *
 * @schema RepositoryIAMMember
 */
export interface RepositoryIamMemberProps {
  /**
   * @schema RepositoryIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RepositoryIAMMemberSpec defines the desired state of RepositoryIAMMember
   *
   * @schema RepositoryIAMMember#spec
   */
  readonly spec: RepositoryIamMemberSpec;

}

/**
 * Converts an object of type 'RepositoryIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberProps(obj: RepositoryIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RepositoryIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepositoryIAMMemberSpec defines the desired state of RepositoryIAMMember
 *
 * @schema RepositoryIamMemberSpec
 */
export interface RepositoryIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RepositoryIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: RepositoryIamMemberSpecDeletionPolicy;

  /**
   * @schema RepositoryIamMemberSpec#forProvider
   */
  readonly forProvider: RepositoryIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RepositoryIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: RepositoryIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RepositoryIamMemberSpec#providerRef
   */
  readonly providerRef?: RepositoryIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RepositoryIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RepositoryIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RepositoryIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RepositoryIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpec(obj: RepositoryIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RepositoryIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RepositoryIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RepositoryIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RepositoryIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RepositoryIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RepositoryIamMemberSpecDeletionPolicy
 */
export enum RepositoryIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RepositoryIamMemberSpecForProvider
 */
export interface RepositoryIamMemberSpecForProvider {
  /**
   * @schema RepositoryIamMemberSpecForProvider#condition
   */
  readonly condition?: RepositoryIamMemberSpecForProviderCondition[];

  /**
   * @schema RepositoryIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema RepositoryIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema RepositoryIamMemberSpecForProvider#repository
   */
  readonly repository?: string;

  /**
   * Reference to a Repository to populate repository.
   *
   * @schema RepositoryIamMemberSpecForProvider#repositoryRef
   */
  readonly repositoryRef?: RepositoryIamMemberSpecForProviderRepositoryRef;

  /**
   * Selector for a Repository to populate repository.
   *
   * @schema RepositoryIamMemberSpecForProvider#repositorySelector
   */
  readonly repositorySelector?: RepositoryIamMemberSpecForProviderRepositorySelector;

  /**
   * @schema RepositoryIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecForProvider(obj: RepositoryIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_RepositoryIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'repository': obj.repository,
    'repositoryRef': toJson_RepositoryIamMemberSpecForProviderRepositoryRef(obj.repositoryRef),
    'repositorySelector': toJson_RepositoryIamMemberSpecForProviderRepositorySelector(obj.repositorySelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RepositoryIamMemberSpecProviderConfigRef
 */
export interface RepositoryIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: RepositoryIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecProviderConfigRef(obj: RepositoryIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RepositoryIamMemberSpecProviderRef
 */
export interface RepositoryIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryIamMemberSpecProviderRef#policy
   */
  readonly policy?: RepositoryIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecProviderRef(obj: RepositoryIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RepositoryIamMemberSpecPublishConnectionDetailsTo
 */
export interface RepositoryIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RepositoryIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RepositoryIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RepositoryIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RepositoryIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RepositoryIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecPublishConnectionDetailsTo(obj: RepositoryIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RepositoryIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RepositoryIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RepositoryIamMemberSpecWriteConnectionSecretToRef
 */
export interface RepositoryIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RepositoryIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositoryIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecWriteConnectionSecretToRef(obj: RepositoryIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RepositoryIamMemberSpecForProviderCondition
 */
export interface RepositoryIamMemberSpecForProviderCondition {
  /**
   * @schema RepositoryIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema RepositoryIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema RepositoryIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecForProviderCondition(obj: RepositoryIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Repository to populate repository.
 *
 * @schema RepositoryIamMemberSpecForProviderRepositoryRef
 */
export interface RepositoryIamMemberSpecForProviderRepositoryRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryIamMemberSpecForProviderRepositoryRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryIamMemberSpecForProviderRepositoryRef#policy
   */
  readonly policy?: RepositoryIamMemberSpecForProviderRepositoryRefPolicy;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecForProviderRepositoryRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecForProviderRepositoryRef(obj: RepositoryIamMemberSpecForProviderRepositoryRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryIamMemberSpecForProviderRepositoryRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Repository to populate repository.
 *
 * @schema RepositoryIamMemberSpecForProviderRepositorySelector
 */
export interface RepositoryIamMemberSpecForProviderRepositorySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryIamMemberSpecForProviderRepositorySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryIamMemberSpecForProviderRepositorySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryIamMemberSpecForProviderRepositorySelector#policy
   */
  readonly policy?: RepositoryIamMemberSpecForProviderRepositorySelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecForProviderRepositorySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecForProviderRepositorySelector(obj: RepositoryIamMemberSpecForProviderRepositorySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryIamMemberSpecForProviderRepositorySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryIamMemberSpecProviderConfigRefPolicy
 */
export interface RepositoryIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RepositoryIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RepositoryIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecProviderConfigRefPolicy(obj: RepositoryIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryIamMemberSpecProviderRefPolicy
 */
export interface RepositoryIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RepositoryIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RepositoryIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecProviderRefPolicy(obj: RepositoryIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RepositoryIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface RepositoryIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecPublishConnectionDetailsToConfigRef(obj: RepositoryIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RepositoryIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface RepositoryIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositoryIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositoryIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RepositoryIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecPublishConnectionDetailsToMetadata(obj: RepositoryIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryIamMemberSpecForProviderRepositoryRefPolicy
 */
export interface RepositoryIamMemberSpecForProviderRepositoryRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryIamMemberSpecForProviderRepositoryRefPolicy#resolution
   */
  readonly resolution?: RepositoryIamMemberSpecForProviderRepositoryRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryIamMemberSpecForProviderRepositoryRefPolicy#resolve
   */
  readonly resolve?: RepositoryIamMemberSpecForProviderRepositoryRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecForProviderRepositoryRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecForProviderRepositoryRefPolicy(obj: RepositoryIamMemberSpecForProviderRepositoryRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryIamMemberSpecForProviderRepositorySelectorPolicy
 */
export interface RepositoryIamMemberSpecForProviderRepositorySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryIamMemberSpecForProviderRepositorySelectorPolicy#resolution
   */
  readonly resolution?: RepositoryIamMemberSpecForProviderRepositorySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryIamMemberSpecForProviderRepositorySelectorPolicy#resolve
   */
  readonly resolve?: RepositoryIamMemberSpecForProviderRepositorySelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecForProviderRepositorySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecForProviderRepositorySelectorPolicy(obj: RepositoryIamMemberSpecForProviderRepositorySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum RepositoryIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum RepositoryIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryIamMemberSpecProviderRefPolicyResolution
 */
export enum RepositoryIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryIamMemberSpecProviderRefPolicyResolve
 */
export enum RepositoryIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryIamMemberSpecForProviderRepositoryRefPolicyResolution
 */
export enum RepositoryIamMemberSpecForProviderRepositoryRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryIamMemberSpecForProviderRepositoryRefPolicyResolve
 */
export enum RepositoryIamMemberSpecForProviderRepositoryRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryIamMemberSpecForProviderRepositorySelectorPolicyResolution
 */
export enum RepositoryIamMemberSpecForProviderRepositorySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryIamMemberSpecForProviderRepositorySelectorPolicyResolve
 */
export enum RepositoryIamMemberSpecForProviderRepositorySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RepositoryIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

