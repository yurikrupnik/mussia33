// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Note is the Schema for the Notes API. A Container Analysis note is a high-level piece of metadata that describes a type of analysis that can be done for a resource.
 *
 * @schema Note
 */
export class Note extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Note"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'containeranalysis.gcp.upbound.io/v1beta1',
    kind: 'Note',
  }

  /**
   * Renders a Kubernetes manifest for "Note".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NoteProps): any {
    return {
      ...Note.GVK,
      ...toJson_NoteProps(props),
    };
  }

  /**
   * Defines a "Note" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NoteProps) {
    super(scope, id, {
      ...Note.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Note.GVK,
      ...toJson_NoteProps(resolved),
    };
  }
}

/**
 * Note is the Schema for the Notes API. A Container Analysis note is a high-level piece of metadata that describes a type of analysis that can be done for a resource.
 *
 * @schema Note
 */
export interface NoteProps {
  /**
   * @schema Note#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NoteSpec defines the desired state of Note
   *
   * @schema Note#spec
   */
  readonly spec: NoteSpec;

}

/**
 * Converts an object of type 'NoteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteProps(obj: NoteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NoteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NoteSpec defines the desired state of Note
 *
 * @schema NoteSpec
 */
export interface NoteSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NoteSpec#deletionPolicy
   */
  readonly deletionPolicy?: NoteSpecDeletionPolicy;

  /**
   * @schema NoteSpec#forProvider
   */
  readonly forProvider: NoteSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema NoteSpec#initProvider
   */
  readonly initProvider?: NoteSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NoteSpec#managementPolicies
   */
  readonly managementPolicies?: NoteSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NoteSpec#providerConfigRef
   */
  readonly providerConfigRef?: NoteSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NoteSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NoteSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NoteSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NoteSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NoteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpec(obj: NoteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NoteSpecForProvider(obj.forProvider),
    'initProvider': toJson_NoteSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NoteSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_NoteSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NoteSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NoteSpecDeletionPolicy
 */
export enum NoteSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NoteSpecForProvider
 */
export interface NoteSpecForProvider {
  /**
   * Note kind that represents a logical attestation "role" or "authority". For example, an organization might have one AttestationAuthority for "QA" and one for "build". This Note is intended to act strictly as a grouping mechanism for the attached Occurrences (Attestations). This grouping mechanism also provides a security boundary, since IAM ACLs gate the ability for a principle to attach an Occurrence to a given Note. It also provides a single point of lookup to find all attached Attestation Occurrences, even if they don't all live in the same project. Structure is documented below.
   *
   * @schema NoteSpecForProvider#attestationAuthority
   */
  readonly attestationAuthority?: NoteSpecForProviderAttestationAuthority[];

  /**
   * Time of expiration for this note. Leave empty if note does not expire.
   *
   * @schema NoteSpecForProvider#expirationTime
   */
  readonly expirationTime?: string;

  /**
   * A detailed description of the note
   *
   * @schema NoteSpecForProvider#longDescription
   */
  readonly longDescription?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema NoteSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Names of other notes related to this note.
   *
   * @schema NoteSpecForProvider#relatedNoteNames
   */
  readonly relatedNoteNames?: string[];

  /**
   * URLs associated with this note and related metadata. Structure is documented below.
   *
   * @schema NoteSpecForProvider#relatedUrl
   */
  readonly relatedUrl?: NoteSpecForProviderRelatedUrl[];

  /**
   * A one sentence description of the note.
   *
   * @schema NoteSpecForProvider#shortDescription
   */
  readonly shortDescription?: string;

}

/**
 * Converts an object of type 'NoteSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecForProvider(obj: NoteSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attestationAuthority': obj.attestationAuthority?.map(y => toJson_NoteSpecForProviderAttestationAuthority(y)),
    'expirationTime': obj.expirationTime,
    'longDescription': obj.longDescription,
    'project': obj.project,
    'relatedNoteNames': obj.relatedNoteNames?.map(y => y),
    'relatedUrl': obj.relatedUrl?.map(y => toJson_NoteSpecForProviderRelatedUrl(y)),
    'shortDescription': obj.shortDescription,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema NoteSpecInitProvider
 */
export interface NoteSpecInitProvider {
  /**
   * Note kind that represents a logical attestation "role" or "authority". For example, an organization might have one AttestationAuthority for "QA" and one for "build". This Note is intended to act strictly as a grouping mechanism for the attached Occurrences (Attestations). This grouping mechanism also provides a security boundary, since IAM ACLs gate the ability for a principle to attach an Occurrence to a given Note. It also provides a single point of lookup to find all attached Attestation Occurrences, even if they don't all live in the same project. Structure is documented below.
   *
   * @schema NoteSpecInitProvider#attestationAuthority
   */
  readonly attestationAuthority?: NoteSpecInitProviderAttestationAuthority[];

  /**
   * Time of expiration for this note. Leave empty if note does not expire.
   *
   * @schema NoteSpecInitProvider#expirationTime
   */
  readonly expirationTime?: string;

  /**
   * A detailed description of the note
   *
   * @schema NoteSpecInitProvider#longDescription
   */
  readonly longDescription?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema NoteSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Names of other notes related to this note.
   *
   * @schema NoteSpecInitProvider#relatedNoteNames
   */
  readonly relatedNoteNames?: string[];

  /**
   * URLs associated with this note and related metadata. Structure is documented below.
   *
   * @schema NoteSpecInitProvider#relatedUrl
   */
  readonly relatedUrl?: NoteSpecInitProviderRelatedUrl[];

  /**
   * A one sentence description of the note.
   *
   * @schema NoteSpecInitProvider#shortDescription
   */
  readonly shortDescription?: string;

}

/**
 * Converts an object of type 'NoteSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecInitProvider(obj: NoteSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attestationAuthority': obj.attestationAuthority?.map(y => toJson_NoteSpecInitProviderAttestationAuthority(y)),
    'expirationTime': obj.expirationTime,
    'longDescription': obj.longDescription,
    'project': obj.project,
    'relatedNoteNames': obj.relatedNoteNames?.map(y => y),
    'relatedUrl': obj.relatedUrl?.map(y => toJson_NoteSpecInitProviderRelatedUrl(y)),
    'shortDescription': obj.shortDescription,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema NoteSpecManagementPolicies
 */
export enum NoteSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NoteSpecProviderConfigRef
 */
export interface NoteSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NoteSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NoteSpecProviderConfigRef#policy
   */
  readonly policy?: NoteSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NoteSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecProviderConfigRef(obj: NoteSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NoteSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NoteSpecPublishConnectionDetailsTo
 */
export interface NoteSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NoteSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NoteSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NoteSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NoteSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NoteSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NoteSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecPublishConnectionDetailsTo(obj: NoteSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NoteSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NoteSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NoteSpecWriteConnectionSecretToRef
 */
export interface NoteSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NoteSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NoteSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NoteSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecWriteConnectionSecretToRef(obj: NoteSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NoteSpecForProviderAttestationAuthority
 */
export interface NoteSpecForProviderAttestationAuthority {
  /**
   * This submessage provides human-readable hints about the purpose of the AttestationAuthority. Because the name of a Note acts as its resource reference, it is important to disambiguate the canonical name of the Note (which might be a UUID for security purposes) from "readable" names more suitable for debug output. Note that these hints should NOT be used to look up AttestationAuthorities in security sensitive contexts, such as when looking up Attestations to verify. Structure is documented below.
   *
   * @schema NoteSpecForProviderAttestationAuthority#hint
   */
  readonly hint?: NoteSpecForProviderAttestationAuthorityHint[];

}

/**
 * Converts an object of type 'NoteSpecForProviderAttestationAuthority' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecForProviderAttestationAuthority(obj: NoteSpecForProviderAttestationAuthority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hint': obj.hint?.map(y => toJson_NoteSpecForProviderAttestationAuthorityHint(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NoteSpecForProviderRelatedUrl
 */
export interface NoteSpecForProviderRelatedUrl {
  /**
   * Label to describe usage of the URL
   *
   * @schema NoteSpecForProviderRelatedUrl#label
   */
  readonly label?: string;

  /**
   * Specific URL associated with the resource.
   *
   * @schema NoteSpecForProviderRelatedUrl#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'NoteSpecForProviderRelatedUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecForProviderRelatedUrl(obj: NoteSpecForProviderRelatedUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NoteSpecInitProviderAttestationAuthority
 */
export interface NoteSpecInitProviderAttestationAuthority {
  /**
   * This submessage provides human-readable hints about the purpose of the AttestationAuthority. Because the name of a Note acts as its resource reference, it is important to disambiguate the canonical name of the Note (which might be a UUID for security purposes) from "readable" names more suitable for debug output. Note that these hints should NOT be used to look up AttestationAuthorities in security sensitive contexts, such as when looking up Attestations to verify. Structure is documented below.
   *
   * @schema NoteSpecInitProviderAttestationAuthority#hint
   */
  readonly hint?: NoteSpecInitProviderAttestationAuthorityHint[];

}

/**
 * Converts an object of type 'NoteSpecInitProviderAttestationAuthority' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecInitProviderAttestationAuthority(obj: NoteSpecInitProviderAttestationAuthority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hint': obj.hint?.map(y => toJson_NoteSpecInitProviderAttestationAuthorityHint(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NoteSpecInitProviderRelatedUrl
 */
export interface NoteSpecInitProviderRelatedUrl {
  /**
   * Label to describe usage of the URL
   *
   * @schema NoteSpecInitProviderRelatedUrl#label
   */
  readonly label?: string;

  /**
   * Specific URL associated with the resource.
   *
   * @schema NoteSpecInitProviderRelatedUrl#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'NoteSpecInitProviderRelatedUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecInitProviderRelatedUrl(obj: NoteSpecInitProviderRelatedUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NoteSpecProviderConfigRefPolicy
 */
export interface NoteSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NoteSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NoteSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NoteSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NoteSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NoteSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecProviderConfigRefPolicy(obj: NoteSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NoteSpecPublishConnectionDetailsToConfigRef
 */
export interface NoteSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NoteSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NoteSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NoteSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NoteSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecPublishConnectionDetailsToConfigRef(obj: NoteSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NoteSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NoteSpecPublishConnectionDetailsToMetadata
 */
export interface NoteSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NoteSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NoteSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NoteSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NoteSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecPublishConnectionDetailsToMetadata(obj: NoteSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NoteSpecForProviderAttestationAuthorityHint
 */
export interface NoteSpecForProviderAttestationAuthorityHint {
  /**
   * The human readable name of this Attestation Authority, for example "qa".
   *
   * @schema NoteSpecForProviderAttestationAuthorityHint#humanReadableName
   */
  readonly humanReadableName?: string;

}

/**
 * Converts an object of type 'NoteSpecForProviderAttestationAuthorityHint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecForProviderAttestationAuthorityHint(obj: NoteSpecForProviderAttestationAuthorityHint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'humanReadableName': obj.humanReadableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NoteSpecInitProviderAttestationAuthorityHint
 */
export interface NoteSpecInitProviderAttestationAuthorityHint {
  /**
   * The human readable name of this Attestation Authority, for example "qa".
   *
   * @schema NoteSpecInitProviderAttestationAuthorityHint#humanReadableName
   */
  readonly humanReadableName?: string;

}

/**
 * Converts an object of type 'NoteSpecInitProviderAttestationAuthorityHint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecInitProviderAttestationAuthorityHint(obj: NoteSpecInitProviderAttestationAuthorityHint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'humanReadableName': obj.humanReadableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NoteSpecProviderConfigRefPolicyResolution
 */
export enum NoteSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NoteSpecProviderConfigRefPolicyResolve
 */
export enum NoteSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NoteSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NoteSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NoteSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NoteSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NoteSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NoteSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NoteSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NoteSpecPublishConnectionDetailsToConfigRefPolicy(obj: NoteSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NoteSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NoteSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NoteSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NoteSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

