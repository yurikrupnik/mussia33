// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * APIDestination is the Schema for the APIDestinations API. Provides an EventBridge event API Destination resource.
 *
 * @schema APIDestination
 */
export class ApiDestination extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIDestination"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatchevents.aws.upbound.io/v1beta1',
    kind: 'APIDestination',
  }

  /**
   * Renders a Kubernetes manifest for "APIDestination".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiDestinationProps): any {
    return {
      ...ApiDestination.GVK,
      ...toJson_ApiDestinationProps(props),
    };
  }

  /**
   * Defines a "APIDestination" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiDestinationProps) {
    super(scope, id, {
      ...ApiDestination.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiDestination.GVK,
      ...toJson_ApiDestinationProps(resolved),
    };
  }
}

/**
 * APIDestination is the Schema for the APIDestinations API. Provides an EventBridge event API Destination resource.
 *
 * @schema APIDestination
 */
export interface ApiDestinationProps {
  /**
   * @schema APIDestination#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APIDestinationSpec defines the desired state of APIDestination
   *
   * @schema APIDestination#spec
   */
  readonly spec: ApiDestinationSpec;

}

/**
 * Converts an object of type 'ApiDestinationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationProps(obj: ApiDestinationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiDestinationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIDestinationSpec defines the desired state of APIDestination
 *
 * @schema ApiDestinationSpec
 */
export interface ApiDestinationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiDestinationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApiDestinationSpecDeletionPolicy;

  /**
   * @schema ApiDestinationSpec#forProvider
   */
  readonly forProvider: ApiDestinationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiDestinationSpec#managementPolicy
   */
  readonly managementPolicy?: ApiDestinationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApiDestinationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApiDestinationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApiDestinationSpec#providerRef
   */
  readonly providerRef?: ApiDestinationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApiDestinationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApiDestinationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApiDestinationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApiDestinationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApiDestinationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpec(obj: ApiDestinationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApiDestinationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ApiDestinationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApiDestinationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApiDestinationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApiDestinationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiDestinationSpecDeletionPolicy
 */
export enum ApiDestinationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApiDestinationSpecForProvider
 */
export interface ApiDestinationSpecForProvider {
  /**
   * ARN of the EventBridge Connection to use for the API Destination.
   *
   * @schema ApiDestinationSpecForProvider#connectionArn
   */
  readonly connectionArn?: string;

  /**
   * Reference to a Connection in cloudwatchevents to populate connectionArn.
   *
   * @schema ApiDestinationSpecForProvider#connectionArnRef
   */
  readonly connectionArnRef?: ApiDestinationSpecForProviderConnectionArnRef;

  /**
   * Selector for a Connection in cloudwatchevents to populate connectionArn.
   *
   * @schema ApiDestinationSpecForProvider#connectionArnSelector
   */
  readonly connectionArnSelector?: ApiDestinationSpecForProviderConnectionArnSelector;

  /**
   * The description of the new API Destination. Maximum of 512 characters.
   *
   * @schema ApiDestinationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Select the HTTP method used for the invocation endpoint, such as GET, POST, PUT, etc.
   *
   * @schema ApiDestinationSpecForProvider#httpMethod
   */
  readonly httpMethod?: string;

  /**
   * URL endpoint to invoke as a target. This could be a valid endpoint generated by a partner service. You can include "*" as path parameters wildcards to be set from the Target HttpParameters.
   *
   * @schema ApiDestinationSpecForProvider#invocationEndpoint
   */
  readonly invocationEndpoint?: string;

  /**
   * Enter the maximum number of invocations per second to allow for this destination. Enter a value greater than 0 (default 300).
   *
   * @schema ApiDestinationSpecForProvider#invocationRateLimitPerSecond
   */
  readonly invocationRateLimitPerSecond?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApiDestinationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ApiDestinationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecForProvider(obj: ApiDestinationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionArn': obj.connectionArn,
    'connectionArnRef': toJson_ApiDestinationSpecForProviderConnectionArnRef(obj.connectionArnRef),
    'connectionArnSelector': toJson_ApiDestinationSpecForProviderConnectionArnSelector(obj.connectionArnSelector),
    'description': obj.description,
    'httpMethod': obj.httpMethod,
    'invocationEndpoint': obj.invocationEndpoint,
    'invocationRateLimitPerSecond': obj.invocationRateLimitPerSecond,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiDestinationSpecManagementPolicy
 */
export enum ApiDestinationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApiDestinationSpecProviderConfigRef
 */
export interface ApiDestinationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiDestinationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiDestinationSpecProviderConfigRef#policy
   */
  readonly policy?: ApiDestinationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiDestinationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecProviderConfigRef(obj: ApiDestinationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiDestinationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApiDestinationSpecProviderRef
 */
export interface ApiDestinationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiDestinationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiDestinationSpecProviderRef#policy
   */
  readonly policy?: ApiDestinationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApiDestinationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecProviderRef(obj: ApiDestinationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiDestinationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApiDestinationSpecPublishConnectionDetailsTo
 */
export interface ApiDestinationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApiDestinationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApiDestinationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApiDestinationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApiDestinationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApiDestinationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiDestinationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecPublishConnectionDetailsTo(obj: ApiDestinationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApiDestinationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApiDestinationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApiDestinationSpecWriteConnectionSecretToRef
 */
export interface ApiDestinationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApiDestinationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApiDestinationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApiDestinationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecWriteConnectionSecretToRef(obj: ApiDestinationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection in cloudwatchevents to populate connectionArn.
 *
 * @schema ApiDestinationSpecForProviderConnectionArnRef
 */
export interface ApiDestinationSpecForProviderConnectionArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiDestinationSpecForProviderConnectionArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiDestinationSpecForProviderConnectionArnRef#policy
   */
  readonly policy?: ApiDestinationSpecForProviderConnectionArnRefPolicy;

}

/**
 * Converts an object of type 'ApiDestinationSpecForProviderConnectionArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecForProviderConnectionArnRef(obj: ApiDestinationSpecForProviderConnectionArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiDestinationSpecForProviderConnectionArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection in cloudwatchevents to populate connectionArn.
 *
 * @schema ApiDestinationSpecForProviderConnectionArnSelector
 */
export interface ApiDestinationSpecForProviderConnectionArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApiDestinationSpecForProviderConnectionArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApiDestinationSpecForProviderConnectionArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApiDestinationSpecForProviderConnectionArnSelector#policy
   */
  readonly policy?: ApiDestinationSpecForProviderConnectionArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApiDestinationSpecForProviderConnectionArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecForProviderConnectionArnSelector(obj: ApiDestinationSpecForProviderConnectionArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApiDestinationSpecForProviderConnectionArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiDestinationSpecProviderConfigRefPolicy
 */
export interface ApiDestinationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiDestinationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApiDestinationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiDestinationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApiDestinationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiDestinationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecProviderConfigRefPolicy(obj: ApiDestinationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiDestinationSpecProviderRefPolicy
 */
export interface ApiDestinationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiDestinationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApiDestinationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiDestinationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApiDestinationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiDestinationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecProviderRefPolicy(obj: ApiDestinationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApiDestinationSpecPublishConnectionDetailsToConfigRef
 */
export interface ApiDestinationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiDestinationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiDestinationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiDestinationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecPublishConnectionDetailsToConfigRef(obj: ApiDestinationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApiDestinationSpecPublishConnectionDetailsToMetadata
 */
export interface ApiDestinationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiDestinationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiDestinationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApiDestinationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApiDestinationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecPublishConnectionDetailsToMetadata(obj: ApiDestinationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiDestinationSpecForProviderConnectionArnRefPolicy
 */
export interface ApiDestinationSpecForProviderConnectionArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiDestinationSpecForProviderConnectionArnRefPolicy#resolution
   */
  readonly resolution?: ApiDestinationSpecForProviderConnectionArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiDestinationSpecForProviderConnectionArnRefPolicy#resolve
   */
  readonly resolve?: ApiDestinationSpecForProviderConnectionArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiDestinationSpecForProviderConnectionArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecForProviderConnectionArnRefPolicy(obj: ApiDestinationSpecForProviderConnectionArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApiDestinationSpecForProviderConnectionArnSelectorPolicy
 */
export interface ApiDestinationSpecForProviderConnectionArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiDestinationSpecForProviderConnectionArnSelectorPolicy#resolution
   */
  readonly resolution?: ApiDestinationSpecForProviderConnectionArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiDestinationSpecForProviderConnectionArnSelectorPolicy#resolve
   */
  readonly resolve?: ApiDestinationSpecForProviderConnectionArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApiDestinationSpecForProviderConnectionArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecForProviderConnectionArnSelectorPolicy(obj: ApiDestinationSpecForProviderConnectionArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiDestinationSpecProviderConfigRefPolicyResolution
 */
export enum ApiDestinationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiDestinationSpecProviderConfigRefPolicyResolve
 */
export enum ApiDestinationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiDestinationSpecProviderRefPolicyResolution
 */
export enum ApiDestinationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiDestinationSpecProviderRefPolicyResolve
 */
export enum ApiDestinationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiDestinationSpecForProviderConnectionArnRefPolicyResolution
 */
export enum ApiDestinationSpecForProviderConnectionArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiDestinationSpecForProviderConnectionArnRefPolicyResolve
 */
export enum ApiDestinationSpecForProviderConnectionArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiDestinationSpecForProviderConnectionArnSelectorPolicyResolution
 */
export enum ApiDestinationSpecForProviderConnectionArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiDestinationSpecForProviderConnectionArnSelectorPolicyResolve
 */
export enum ApiDestinationSpecForProviderConnectionArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApiDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Archive is the Schema for the Archives API. Provides an EventBridge event archive resource.
 *
 * @schema Archive
 */
export class Archive extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Archive"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatchevents.aws.upbound.io/v1beta1',
    kind: 'Archive',
  }

  /**
   * Renders a Kubernetes manifest for "Archive".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ArchiveProps): any {
    return {
      ...Archive.GVK,
      ...toJson_ArchiveProps(props),
    };
  }

  /**
   * Defines a "Archive" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ArchiveProps) {
    super(scope, id, {
      ...Archive.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Archive.GVK,
      ...toJson_ArchiveProps(resolved),
    };
  }
}

/**
 * Archive is the Schema for the Archives API. Provides an EventBridge event archive resource.
 *
 * @schema Archive
 */
export interface ArchiveProps {
  /**
   * @schema Archive#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ArchiveSpec defines the desired state of Archive
   *
   * @schema Archive#spec
   */
  readonly spec: ArchiveSpec;

}

/**
 * Converts an object of type 'ArchiveProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveProps(obj: ArchiveProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ArchiveSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ArchiveSpec defines the desired state of Archive
 *
 * @schema ArchiveSpec
 */
export interface ArchiveSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ArchiveSpec#deletionPolicy
   */
  readonly deletionPolicy?: ArchiveSpecDeletionPolicy;

  /**
   * @schema ArchiveSpec#forProvider
   */
  readonly forProvider: ArchiveSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ArchiveSpec#managementPolicy
   */
  readonly managementPolicy?: ArchiveSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ArchiveSpec#providerConfigRef
   */
  readonly providerConfigRef?: ArchiveSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ArchiveSpec#providerRef
   */
  readonly providerRef?: ArchiveSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ArchiveSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ArchiveSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ArchiveSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ArchiveSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ArchiveSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpec(obj: ArchiveSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ArchiveSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ArchiveSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ArchiveSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ArchiveSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ArchiveSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ArchiveSpecDeletionPolicy
 */
export enum ArchiveSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ArchiveSpecForProvider
 */
export interface ArchiveSpecForProvider {
  /**
   * The description of the new event archive.
   *
   * @schema ArchiveSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Instructs the new event archive to only capture events matched by this pattern. By default, it attempts to archive every event received in the event_source_arn.
   *
   * @schema ArchiveSpecForProvider#eventPattern
   */
  readonly eventPattern?: string;

  /**
   * Event bus source ARN from where these events should be archived.
   *
   * @schema ArchiveSpecForProvider#eventSourceArn
   */
  readonly eventSourceArn?: string;

  /**
   * Reference to a Bus in cloudwatchevents to populate eventSourceArn.
   *
   * @schema ArchiveSpecForProvider#eventSourceArnRef
   */
  readonly eventSourceArnRef?: ArchiveSpecForProviderEventSourceArnRef;

  /**
   * Selector for a Bus in cloudwatchevents to populate eventSourceArn.
   *
   * @schema ArchiveSpecForProvider#eventSourceArnSelector
   */
  readonly eventSourceArnSelector?: ArchiveSpecForProviderEventSourceArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ArchiveSpecForProvider#region
   */
  readonly region: string;

  /**
   * The maximum number of days to retain events in the new event archive. By default, it archives indefinitely.
   *
   * @schema ArchiveSpecForProvider#retentionDays
   */
  readonly retentionDays?: number;

}

/**
 * Converts an object of type 'ArchiveSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecForProvider(obj: ArchiveSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'eventPattern': obj.eventPattern,
    'eventSourceArn': obj.eventSourceArn,
    'eventSourceArnRef': toJson_ArchiveSpecForProviderEventSourceArnRef(obj.eventSourceArnRef),
    'eventSourceArnSelector': toJson_ArchiveSpecForProviderEventSourceArnSelector(obj.eventSourceArnSelector),
    'region': obj.region,
    'retentionDays': obj.retentionDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ArchiveSpecManagementPolicy
 */
export enum ArchiveSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ArchiveSpecProviderConfigRef
 */
export interface ArchiveSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ArchiveSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ArchiveSpecProviderConfigRef#policy
   */
  readonly policy?: ArchiveSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ArchiveSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecProviderConfigRef(obj: ArchiveSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ArchiveSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ArchiveSpecProviderRef
 */
export interface ArchiveSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ArchiveSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ArchiveSpecProviderRef#policy
   */
  readonly policy?: ArchiveSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ArchiveSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecProviderRef(obj: ArchiveSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ArchiveSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ArchiveSpecPublishConnectionDetailsTo
 */
export interface ArchiveSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ArchiveSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ArchiveSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ArchiveSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ArchiveSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ArchiveSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ArchiveSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecPublishConnectionDetailsTo(obj: ArchiveSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ArchiveSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ArchiveSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ArchiveSpecWriteConnectionSecretToRef
 */
export interface ArchiveSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ArchiveSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ArchiveSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ArchiveSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecWriteConnectionSecretToRef(obj: ArchiveSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bus in cloudwatchevents to populate eventSourceArn.
 *
 * @schema ArchiveSpecForProviderEventSourceArnRef
 */
export interface ArchiveSpecForProviderEventSourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ArchiveSpecForProviderEventSourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ArchiveSpecForProviderEventSourceArnRef#policy
   */
  readonly policy?: ArchiveSpecForProviderEventSourceArnRefPolicy;

}

/**
 * Converts an object of type 'ArchiveSpecForProviderEventSourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecForProviderEventSourceArnRef(obj: ArchiveSpecForProviderEventSourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ArchiveSpecForProviderEventSourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bus in cloudwatchevents to populate eventSourceArn.
 *
 * @schema ArchiveSpecForProviderEventSourceArnSelector
 */
export interface ArchiveSpecForProviderEventSourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ArchiveSpecForProviderEventSourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ArchiveSpecForProviderEventSourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ArchiveSpecForProviderEventSourceArnSelector#policy
   */
  readonly policy?: ArchiveSpecForProviderEventSourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'ArchiveSpecForProviderEventSourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecForProviderEventSourceArnSelector(obj: ArchiveSpecForProviderEventSourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ArchiveSpecForProviderEventSourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ArchiveSpecProviderConfigRefPolicy
 */
export interface ArchiveSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ArchiveSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ArchiveSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ArchiveSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ArchiveSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ArchiveSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecProviderConfigRefPolicy(obj: ArchiveSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ArchiveSpecProviderRefPolicy
 */
export interface ArchiveSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ArchiveSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ArchiveSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ArchiveSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ArchiveSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ArchiveSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecProviderRefPolicy(obj: ArchiveSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ArchiveSpecPublishConnectionDetailsToConfigRef
 */
export interface ArchiveSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ArchiveSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ArchiveSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ArchiveSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ArchiveSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecPublishConnectionDetailsToConfigRef(obj: ArchiveSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ArchiveSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ArchiveSpecPublishConnectionDetailsToMetadata
 */
export interface ArchiveSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ArchiveSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ArchiveSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ArchiveSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ArchiveSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecPublishConnectionDetailsToMetadata(obj: ArchiveSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ArchiveSpecForProviderEventSourceArnRefPolicy
 */
export interface ArchiveSpecForProviderEventSourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ArchiveSpecForProviderEventSourceArnRefPolicy#resolution
   */
  readonly resolution?: ArchiveSpecForProviderEventSourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ArchiveSpecForProviderEventSourceArnRefPolicy#resolve
   */
  readonly resolve?: ArchiveSpecForProviderEventSourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ArchiveSpecForProviderEventSourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecForProviderEventSourceArnRefPolicy(obj: ArchiveSpecForProviderEventSourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ArchiveSpecForProviderEventSourceArnSelectorPolicy
 */
export interface ArchiveSpecForProviderEventSourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ArchiveSpecForProviderEventSourceArnSelectorPolicy#resolution
   */
  readonly resolution?: ArchiveSpecForProviderEventSourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ArchiveSpecForProviderEventSourceArnSelectorPolicy#resolve
   */
  readonly resolve?: ArchiveSpecForProviderEventSourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ArchiveSpecForProviderEventSourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecForProviderEventSourceArnSelectorPolicy(obj: ArchiveSpecForProviderEventSourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ArchiveSpecProviderConfigRefPolicyResolution
 */
export enum ArchiveSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ArchiveSpecProviderConfigRefPolicyResolve
 */
export enum ArchiveSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ArchiveSpecProviderRefPolicyResolution
 */
export enum ArchiveSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ArchiveSpecProviderRefPolicyResolve
 */
export enum ArchiveSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ArchiveSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ArchiveSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ArchiveSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ArchiveSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ArchiveSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ArchiveSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ArchiveSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveSpecPublishConnectionDetailsToConfigRefPolicy(obj: ArchiveSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ArchiveSpecForProviderEventSourceArnRefPolicyResolution
 */
export enum ArchiveSpecForProviderEventSourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ArchiveSpecForProviderEventSourceArnRefPolicyResolve
 */
export enum ArchiveSpecForProviderEventSourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ArchiveSpecForProviderEventSourceArnSelectorPolicyResolution
 */
export enum ArchiveSpecForProviderEventSourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ArchiveSpecForProviderEventSourceArnSelectorPolicyResolve
 */
export enum ArchiveSpecForProviderEventSourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ArchiveSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ArchiveSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ArchiveSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ArchiveSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Bus is the Schema for the Buss API. Provides an EventBridge event bus resource.
 *
 * @schema Bus
 */
export class Bus extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bus"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatchevents.aws.upbound.io/v1beta1',
    kind: 'Bus',
  }

  /**
   * Renders a Kubernetes manifest for "Bus".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BusProps): any {
    return {
      ...Bus.GVK,
      ...toJson_BusProps(props),
    };
  }

  /**
   * Defines a "Bus" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BusProps) {
    super(scope, id, {
      ...Bus.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bus.GVK,
      ...toJson_BusProps(resolved),
    };
  }
}

/**
 * Bus is the Schema for the Buss API. Provides an EventBridge event bus resource.
 *
 * @schema Bus
 */
export interface BusProps {
  /**
   * @schema Bus#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BusSpec defines the desired state of Bus
   *
   * @schema Bus#spec
   */
  readonly spec: BusSpec;

}

/**
 * Converts an object of type 'BusProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusProps(obj: BusProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BusSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BusSpec defines the desired state of Bus
 *
 * @schema BusSpec
 */
export interface BusSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BusSpec#deletionPolicy
   */
  readonly deletionPolicy?: BusSpecDeletionPolicy;

  /**
   * @schema BusSpec#forProvider
   */
  readonly forProvider: BusSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BusSpec#managementPolicy
   */
  readonly managementPolicy?: BusSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BusSpec#providerConfigRef
   */
  readonly providerConfigRef?: BusSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BusSpec#providerRef
   */
  readonly providerRef?: BusSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BusSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BusSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BusSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BusSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BusSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpec(obj: BusSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BusSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_BusSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BusSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BusSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BusSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BusSpecDeletionPolicy
 */
export enum BusSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BusSpecForProvider
 */
export interface BusSpecForProvider {
  /**
   * The partner event source that the new event bus will be matched with. Must match name.
   *
   * @schema BusSpecForProvider#eventSourceName
   */
  readonly eventSourceName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BusSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema BusSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'BusSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpecForProvider(obj: BusSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventSourceName': obj.eventSourceName,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BusSpecManagementPolicy
 */
export enum BusSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BusSpecProviderConfigRef
 */
export interface BusSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BusSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BusSpecProviderConfigRef#policy
   */
  readonly policy?: BusSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BusSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpecProviderConfigRef(obj: BusSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BusSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BusSpecProviderRef
 */
export interface BusSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BusSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BusSpecProviderRef#policy
   */
  readonly policy?: BusSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BusSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpecProviderRef(obj: BusSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BusSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BusSpecPublishConnectionDetailsTo
 */
export interface BusSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BusSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BusSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BusSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BusSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BusSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BusSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpecPublishConnectionDetailsTo(obj: BusSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BusSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BusSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BusSpecWriteConnectionSecretToRef
 */
export interface BusSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BusSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BusSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BusSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpecWriteConnectionSecretToRef(obj: BusSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BusSpecProviderConfigRefPolicy
 */
export interface BusSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BusSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BusSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BusSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BusSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BusSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpecProviderConfigRefPolicy(obj: BusSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BusSpecProviderRefPolicy
 */
export interface BusSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BusSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BusSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BusSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BusSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BusSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpecProviderRefPolicy(obj: BusSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BusSpecPublishConnectionDetailsToConfigRef
 */
export interface BusSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BusSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BusSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BusSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BusSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpecPublishConnectionDetailsToConfigRef(obj: BusSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BusSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BusSpecPublishConnectionDetailsToMetadata
 */
export interface BusSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BusSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BusSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BusSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BusSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpecPublishConnectionDetailsToMetadata(obj: BusSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BusSpecProviderConfigRefPolicyResolution
 */
export enum BusSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BusSpecProviderConfigRefPolicyResolve
 */
export enum BusSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BusSpecProviderRefPolicyResolution
 */
export enum BusSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BusSpecProviderRefPolicyResolve
 */
export enum BusSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BusSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BusSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BusSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BusSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BusSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BusSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BusSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusSpecPublishConnectionDetailsToConfigRefPolicy(obj: BusSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BusSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BusSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BusSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BusSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BusPolicy is the Schema for the BusPolicys API. Provides a resource to create an EventBridge policy to support cross-account events.
 *
 * @schema BusPolicy
 */
export class BusPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BusPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatchevents.aws.upbound.io/v1beta1',
    kind: 'BusPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "BusPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BusPolicyProps): any {
    return {
      ...BusPolicy.GVK,
      ...toJson_BusPolicyProps(props),
    };
  }

  /**
   * Defines a "BusPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BusPolicyProps) {
    super(scope, id, {
      ...BusPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BusPolicy.GVK,
      ...toJson_BusPolicyProps(resolved),
    };
  }
}

/**
 * BusPolicy is the Schema for the BusPolicys API. Provides a resource to create an EventBridge policy to support cross-account events.
 *
 * @schema BusPolicy
 */
export interface BusPolicyProps {
  /**
   * @schema BusPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BusPolicySpec defines the desired state of BusPolicy
   *
   * @schema BusPolicy#spec
   */
  readonly spec: BusPolicySpec;

}

/**
 * Converts an object of type 'BusPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicyProps(obj: BusPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BusPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BusPolicySpec defines the desired state of BusPolicy
 *
 * @schema BusPolicySpec
 */
export interface BusPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BusPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: BusPolicySpecDeletionPolicy;

  /**
   * @schema BusPolicySpec#forProvider
   */
  readonly forProvider: BusPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BusPolicySpec#managementPolicy
   */
  readonly managementPolicy?: BusPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BusPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: BusPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BusPolicySpec#providerRef
   */
  readonly providerRef?: BusPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BusPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BusPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BusPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BusPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BusPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpec(obj: BusPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BusPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_BusPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BusPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BusPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BusPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BusPolicySpecDeletionPolicy
 */
export enum BusPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BusPolicySpecForProvider
 */
export interface BusPolicySpecForProvider {
  /**
   * The name of the event bus to set the permissions on. If you omit this, the permissions are set on the default event bus.
   *
   * @schema BusPolicySpecForProvider#eventBusName
   */
  readonly eventBusName?: string;

  /**
   * Reference to a Bus in cloudwatchevents to populate eventBusName.
   *
   * @schema BusPolicySpecForProvider#eventBusNameRef
   */
  readonly eventBusNameRef?: BusPolicySpecForProviderEventBusNameRef;

  /**
   * Selector for a Bus in cloudwatchevents to populate eventBusName.
   *
   * @schema BusPolicySpecForProvider#eventBusNameSelector
   */
  readonly eventBusNameSelector?: BusPolicySpecForProviderEventBusNameSelector;

  /**
   * The text of the policy.
   *
   * @schema BusPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BusPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BusPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecForProvider(obj: BusPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventBusName': obj.eventBusName,
    'eventBusNameRef': toJson_BusPolicySpecForProviderEventBusNameRef(obj.eventBusNameRef),
    'eventBusNameSelector': toJson_BusPolicySpecForProviderEventBusNameSelector(obj.eventBusNameSelector),
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BusPolicySpecManagementPolicy
 */
export enum BusPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BusPolicySpecProviderConfigRef
 */
export interface BusPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BusPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BusPolicySpecProviderConfigRef#policy
   */
  readonly policy?: BusPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BusPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecProviderConfigRef(obj: BusPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BusPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BusPolicySpecProviderRef
 */
export interface BusPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BusPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BusPolicySpecProviderRef#policy
   */
  readonly policy?: BusPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BusPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecProviderRef(obj: BusPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BusPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BusPolicySpecPublishConnectionDetailsTo
 */
export interface BusPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BusPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BusPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BusPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BusPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BusPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BusPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecPublishConnectionDetailsTo(obj: BusPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BusPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BusPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BusPolicySpecWriteConnectionSecretToRef
 */
export interface BusPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BusPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BusPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BusPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecWriteConnectionSecretToRef(obj: BusPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bus in cloudwatchevents to populate eventBusName.
 *
 * @schema BusPolicySpecForProviderEventBusNameRef
 */
export interface BusPolicySpecForProviderEventBusNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema BusPolicySpecForProviderEventBusNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BusPolicySpecForProviderEventBusNameRef#policy
   */
  readonly policy?: BusPolicySpecForProviderEventBusNameRefPolicy;

}

/**
 * Converts an object of type 'BusPolicySpecForProviderEventBusNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecForProviderEventBusNameRef(obj: BusPolicySpecForProviderEventBusNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BusPolicySpecForProviderEventBusNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bus in cloudwatchevents to populate eventBusName.
 *
 * @schema BusPolicySpecForProviderEventBusNameSelector
 */
export interface BusPolicySpecForProviderEventBusNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BusPolicySpecForProviderEventBusNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BusPolicySpecForProviderEventBusNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BusPolicySpecForProviderEventBusNameSelector#policy
   */
  readonly policy?: BusPolicySpecForProviderEventBusNameSelectorPolicy;

}

/**
 * Converts an object of type 'BusPolicySpecForProviderEventBusNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecForProviderEventBusNameSelector(obj: BusPolicySpecForProviderEventBusNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BusPolicySpecForProviderEventBusNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BusPolicySpecProviderConfigRefPolicy
 */
export interface BusPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BusPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BusPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BusPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BusPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BusPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecProviderConfigRefPolicy(obj: BusPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BusPolicySpecProviderRefPolicy
 */
export interface BusPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BusPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: BusPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BusPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: BusPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BusPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecProviderRefPolicy(obj: BusPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BusPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface BusPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BusPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BusPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BusPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BusPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecPublishConnectionDetailsToConfigRef(obj: BusPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BusPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BusPolicySpecPublishConnectionDetailsToMetadata
 */
export interface BusPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BusPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BusPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BusPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BusPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecPublishConnectionDetailsToMetadata(obj: BusPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BusPolicySpecForProviderEventBusNameRefPolicy
 */
export interface BusPolicySpecForProviderEventBusNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BusPolicySpecForProviderEventBusNameRefPolicy#resolution
   */
  readonly resolution?: BusPolicySpecForProviderEventBusNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BusPolicySpecForProviderEventBusNameRefPolicy#resolve
   */
  readonly resolve?: BusPolicySpecForProviderEventBusNameRefPolicyResolve;

}

/**
 * Converts an object of type 'BusPolicySpecForProviderEventBusNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecForProviderEventBusNameRefPolicy(obj: BusPolicySpecForProviderEventBusNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BusPolicySpecForProviderEventBusNameSelectorPolicy
 */
export interface BusPolicySpecForProviderEventBusNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BusPolicySpecForProviderEventBusNameSelectorPolicy#resolution
   */
  readonly resolution?: BusPolicySpecForProviderEventBusNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BusPolicySpecForProviderEventBusNameSelectorPolicy#resolve
   */
  readonly resolve?: BusPolicySpecForProviderEventBusNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BusPolicySpecForProviderEventBusNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecForProviderEventBusNameSelectorPolicy(obj: BusPolicySpecForProviderEventBusNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BusPolicySpecProviderConfigRefPolicyResolution
 */
export enum BusPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BusPolicySpecProviderConfigRefPolicyResolve
 */
export enum BusPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BusPolicySpecProviderRefPolicyResolution
 */
export enum BusPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BusPolicySpecProviderRefPolicyResolve
 */
export enum BusPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BusPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BusPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BusPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BusPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BusPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BusPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BusPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BusPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: BusPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BusPolicySpecForProviderEventBusNameRefPolicyResolution
 */
export enum BusPolicySpecForProviderEventBusNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BusPolicySpecForProviderEventBusNameRefPolicyResolve
 */
export enum BusPolicySpecForProviderEventBusNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BusPolicySpecForProviderEventBusNameSelectorPolicyResolution
 */
export enum BusPolicySpecForProviderEventBusNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BusPolicySpecForProviderEventBusNameSelectorPolicyResolve
 */
export enum BusPolicySpecForProviderEventBusNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BusPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BusPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BusPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BusPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Connection is the Schema for the Connections API. Provides an EventBridge connection resource.
 *
 * @schema Connection
 */
export class Connection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Connection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatchevents.aws.upbound.io/v1beta1',
    kind: 'Connection',
  }

  /**
   * Renders a Kubernetes manifest for "Connection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectionProps): any {
    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(props),
    };
  }

  /**
   * Defines a "Connection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectionProps) {
    super(scope, id, {
      ...Connection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(resolved),
    };
  }
}

/**
 * Connection is the Schema for the Connections API. Provides an EventBridge connection resource.
 *
 * @schema Connection
 */
export interface ConnectionProps {
  /**
   * @schema Connection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectionSpec defines the desired state of Connection
   *
   * @schema Connection#spec
   */
  readonly spec: ConnectionSpec;

}

/**
 * Converts an object of type 'ConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProps(obj: ConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionSpec defines the desired state of Connection
 *
 * @schema ConnectionSpec
 */
export interface ConnectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectionSpecDeletionPolicy;

  /**
   * @schema ConnectionSpec#forProvider
   */
  readonly forProvider: ConnectionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectionSpec#managementPolicy
   */
  readonly managementPolicy?: ConnectionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConnectionSpec#providerRef
   */
  readonly providerRef?: ConnectionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpec(obj: ConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ConnectionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConnectionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConnectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectionSpecDeletionPolicy
 */
export enum ConnectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConnectionSpecForProvider
 */
export interface ConnectionSpecForProvider {
  /**
   * Parameters used for authorization. A maximum of 1 are allowed. Documented below.
   *
   * @schema ConnectionSpecForProvider#authParameters
   */
  readonly authParameters?: ConnectionSpecForProviderAuthParameters[];

  /**
   * Choose the type of authorization to use for the connection. One of API_KEY,BASIC,OAUTH_CLIENT_CREDENTIALS.
   *
   * @schema ConnectionSpecForProvider#authorizationType
   */
  readonly authorizationType?: string;

  /**
   * Enter a description for the connection. Maximum of 512 characters.
   *
   * @schema ConnectionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConnectionSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProvider(obj: ConnectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authParameters': obj.authParameters?.map(y => toJson_ConnectionSpecForProviderAuthParameters(y)),
    'authorizationType': obj.authorizationType,
    'description': obj.description,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectionSpecManagementPolicy
 */
export enum ConnectionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectionSpecProviderConfigRef
 */
export interface ConnectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRef(obj: ConnectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConnectionSpecProviderRef
 */
export interface ConnectionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecProviderRef#policy
   */
  readonly policy?: ConnectionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderRef(obj: ConnectionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectionSpecPublishConnectionDetailsTo
 */
export interface ConnectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsTo(obj: ConnectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectionSpecWriteConnectionSecretToRef
 */
export interface ConnectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecWriteConnectionSecretToRef(obj: ConnectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParameters
 */
export interface ConnectionSpecForProviderAuthParameters {
  /**
   * Parameters used for API_KEY authorization. An API key to include in the header for each authentication request. A maximum of 1 are allowed. Conflicts with basic and oauth. Documented below.
   *
   * @schema ConnectionSpecForProviderAuthParameters#apiKey
   */
  readonly apiKey?: ConnectionSpecForProviderAuthParametersApiKey[];

  /**
   * Parameters used for BASIC authorization. A maximum of 1 are allowed. Conflicts with api_key and oauth. Documented below.
   *
   * @schema ConnectionSpecForProviderAuthParameters#basic
   */
  readonly basic?: ConnectionSpecForProviderAuthParametersBasic[];

  /**
   * Invocation Http Parameters are additional credentials used to sign each Invocation of the ApiDestination created from this Connection. If the ApiDestination Rule Target has additional HttpParameters, the values will be merged together, with the Connection Invocation Http Parameters taking precedence. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
   *
   * @schema ConnectionSpecForProviderAuthParameters#invocationHttpParameters
   */
  readonly invocationHttpParameters?: ConnectionSpecForProviderAuthParametersInvocationHttpParameters[];

  /**
   * Parameters used for OAUTH_CLIENT_CREDENTIALS authorization. A maximum of 1 are allowed. Conflicts with basic and api_key. Documented below.
   *
   * @schema ConnectionSpecForProviderAuthParameters#oauth
   */
  readonly oauth?: ConnectionSpecForProviderAuthParametersOauth[];

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParameters(obj: ConnectionSpecForProviderAuthParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey?.map(y => toJson_ConnectionSpecForProviderAuthParametersApiKey(y)),
    'basic': obj.basic?.map(y => toJson_ConnectionSpecForProviderAuthParametersBasic(y)),
    'invocationHttpParameters': obj.invocationHttpParameters?.map(y => toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParameters(y)),
    'oauth': obj.oauth?.map(y => toJson_ConnectionSpecForProviderAuthParametersOauth(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecProviderConfigRefPolicy
 */
export interface ConnectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRefPolicy(obj: ConnectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecProviderRefPolicy
 */
export interface ConnectionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderRefPolicy(obj: ConnectionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj: ConnectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj: ConnectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersApiKey
 */
export interface ConnectionSpecForProviderAuthParametersApiKey {
  /**
   * Header Name.
   *
   * @schema ConnectionSpecForProviderAuthParametersApiKey#key
   */
  readonly key: string;

  /**
   * Header Value. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersApiKey#valueSecretRef
   */
  readonly valueSecretRef: ConnectionSpecForProviderAuthParametersApiKeyValueSecretRef;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersApiKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersApiKey(obj: ConnectionSpecForProviderAuthParametersApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'valueSecretRef': toJson_ConnectionSpecForProviderAuthParametersApiKeyValueSecretRef(obj.valueSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersBasic
 */
export interface ConnectionSpecForProviderAuthParametersBasic {
  /**
   * A password for the authorization. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersBasic#passwordSecretRef
   */
  readonly passwordSecretRef: ConnectionSpecForProviderAuthParametersBasicPasswordSecretRef;

  /**
   * A username for the authorization.
   *
   * @schema ConnectionSpecForProviderAuthParametersBasic#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersBasic' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersBasic(obj: ConnectionSpecForProviderAuthParametersBasic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretRef': toJson_ConnectionSpecForProviderAuthParametersBasicPasswordSecretRef(obj.passwordSecretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParameters
 */
export interface ConnectionSpecForProviderAuthParametersInvocationHttpParameters {
  /**
   * Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParameters#body
   */
  readonly body?: ConnectionSpecForProviderAuthParametersInvocationHttpParametersBody[];

  /**
   * Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParameters#header
   */
  readonly header?: ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeader[];

  /**
   * Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParameters#queryString
   */
  readonly queryString?: ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryString[];

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersInvocationHttpParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParameters(obj: ConnectionSpecForProviderAuthParametersInvocationHttpParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body?.map(y => toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersBody(y)),
    'header': obj.header?.map(y => toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeader(y)),
    'queryString': obj.queryString?.map(y => toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryString(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersOauth
 */
export interface ConnectionSpecForProviderAuthParametersOauth {
  /**
   * The URL to the authorization endpoint.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauth#authorizationEndpoint
   */
  readonly authorizationEndpoint: string;

  /**
   * Contains the client parameters for OAuth authorization. Contains the following two parameters.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauth#clientParameters
   */
  readonly clientParameters?: ConnectionSpecForProviderAuthParametersOauthClientParameters[];

  /**
   * A password for the authorization. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauth#httpMethod
   */
  readonly httpMethod: string;

  /**
   * OAuth Http Parameters are additional credentials used to sign the request to the authorization endpoint to exchange the OAuth Client information for an access token. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauth#oauthHttpParameters
   */
  readonly oauthHttpParameters: ConnectionSpecForProviderAuthParametersOauthOauthHttpParameters[];

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersOauth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersOauth(obj: ConnectionSpecForProviderAuthParametersOauth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationEndpoint': obj.authorizationEndpoint,
    'clientParameters': obj.clientParameters?.map(y => toJson_ConnectionSpecForProviderAuthParametersOauthClientParameters(y)),
    'httpMethod': obj.httpMethod,
    'oauthHttpParameters': obj.oauthHttpParameters?.map(y => toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolution
 */
export enum ConnectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolve
 */
export enum ConnectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecProviderRefPolicyResolution
 */
export enum ConnectionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecProviderRefPolicyResolve
 */
export enum ConnectionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header Value. Created and stored in AWS Secrets Manager.
 *
 * @schema ConnectionSpecForProviderAuthParametersApiKeyValueSecretRef
 */
export interface ConnectionSpecForProviderAuthParametersApiKeyValueSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionSpecForProviderAuthParametersApiKeyValueSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersApiKeyValueSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersApiKeyValueSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersApiKeyValueSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersApiKeyValueSecretRef(obj: ConnectionSpecForProviderAuthParametersApiKeyValueSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A password for the authorization. Created and stored in AWS Secrets Manager.
 *
 * @schema ConnectionSpecForProviderAuthParametersBasicPasswordSecretRef
 */
export interface ConnectionSpecForProviderAuthParametersBasicPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionSpecForProviderAuthParametersBasicPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersBasicPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersBasicPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersBasicPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersBasicPasswordSecretRef(obj: ConnectionSpecForProviderAuthParametersBasicPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersBody
 */
export interface ConnectionSpecForProviderAuthParametersInvocationHttpParametersBody {
  /**
   * Specified whether the value is secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersBody#isValueSecret
   */
  readonly isValueSecret?: boolean;

  /**
   * Header Name.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersBody#key
   */
  readonly key?: string;

  /**
   * Header Value. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersBody#valueSecretRef
   */
  readonly valueSecretRef?: ConnectionSpecForProviderAuthParametersInvocationHttpParametersBodyValueSecretRef;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersInvocationHttpParametersBody' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersBody(obj: ConnectionSpecForProviderAuthParametersInvocationHttpParametersBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isValueSecret': obj.isValueSecret,
    'key': obj.key,
    'valueSecretRef': toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersBodyValueSecretRef(obj.valueSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeader
 */
export interface ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeader {
  /**
   * Specified whether the value is secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeader#isValueSecret
   */
  readonly isValueSecret?: boolean;

  /**
   * Header Name.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeader#key
   */
  readonly key?: string;

  /**
   * Header Value. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeader#valueSecretRef
   */
  readonly valueSecretRef?: ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeaderValueSecretRef;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeader(obj: ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isValueSecret': obj.isValueSecret,
    'key': obj.key,
    'valueSecretRef': toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeaderValueSecretRef(obj.valueSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryString
 */
export interface ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryString {
  /**
   * Specified whether the value is secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryString#isValueSecret
   */
  readonly isValueSecret?: boolean;

  /**
   * Header Name.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryString#key
   */
  readonly key?: string;

  /**
   * Header Value. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryString#valueSecretRef
   */
  readonly valueSecretRef?: ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryStringValueSecretRef;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryString(obj: ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isValueSecret': obj.isValueSecret,
    'key': obj.key,
    'valueSecretRef': toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryStringValueSecretRef(obj.valueSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersOauthClientParameters
 */
export interface ConnectionSpecForProviderAuthParametersOauthClientParameters {
  /**
   * The client ID for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthClientParameters#clientId
   */
  readonly clientId: string;

  /**
   * The client secret for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthClientParameters#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: ConnectionSpecForProviderAuthParametersOauthClientParametersClientSecretSecretRef;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersOauthClientParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersOauthClientParameters(obj: ConnectionSpecForProviderAuthParametersOauthClientParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientSecretSecretRef': toJson_ConnectionSpecForProviderAuthParametersOauthClientParametersClientSecretSecretRef(obj.clientSecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParameters
 */
export interface ConnectionSpecForProviderAuthParametersOauthOauthHttpParameters {
  /**
   * Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParameters#body
   */
  readonly body?: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBody[];

  /**
   * Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParameters#header
   */
  readonly header?: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeader[];

  /**
   * Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParameters#queryString
   */
  readonly queryString?: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryString[];

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersOauthOauthHttpParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParameters(obj: ConnectionSpecForProviderAuthParametersOauthOauthHttpParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body?.map(y => toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBody(y)),
    'header': obj.header?.map(y => toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeader(y)),
    'queryString': obj.queryString?.map(y => toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryString(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Header Value. Created and stored in AWS Secrets Manager.
 *
 * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersBodyValueSecretRef
 */
export interface ConnectionSpecForProviderAuthParametersInvocationHttpParametersBodyValueSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersBodyValueSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersBodyValueSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersBodyValueSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersInvocationHttpParametersBodyValueSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersBodyValueSecretRef(obj: ConnectionSpecForProviderAuthParametersInvocationHttpParametersBodyValueSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header Value. Created and stored in AWS Secrets Manager.
 *
 * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeaderValueSecretRef
 */
export interface ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeaderValueSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeaderValueSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeaderValueSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeaderValueSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeaderValueSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeaderValueSecretRef(obj: ConnectionSpecForProviderAuthParametersInvocationHttpParametersHeaderValueSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header Value. Created and stored in AWS Secrets Manager.
 *
 * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryStringValueSecretRef
 */
export interface ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryStringValueSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryStringValueSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryStringValueSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryStringValueSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryStringValueSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryStringValueSecretRef(obj: ConnectionSpecForProviderAuthParametersInvocationHttpParametersQueryStringValueSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The client secret for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
 *
 * @schema ConnectionSpecForProviderAuthParametersOauthClientParametersClientSecretSecretRef
 */
export interface ConnectionSpecForProviderAuthParametersOauthClientParametersClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthClientParametersClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthClientParametersClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthClientParametersClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersOauthClientParametersClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersOauthClientParametersClientSecretSecretRef(obj: ConnectionSpecForProviderAuthParametersOauthClientParametersClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBody
 */
export interface ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBody {
  /**
   * Specified whether the value is secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBody#isValueSecret
   */
  readonly isValueSecret?: boolean;

  /**
   * Header Name.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBody#key
   */
  readonly key?: string;

  /**
   * Header Value. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBody#valueSecretRef
   */
  readonly valueSecretRef?: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBodyValueSecretRef;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBody' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBody(obj: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isValueSecret': obj.isValueSecret,
    'key': obj.key,
    'valueSecretRef': toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBodyValueSecretRef(obj.valueSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeader
 */
export interface ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeader {
  /**
   * Specified whether the value is secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeader#isValueSecret
   */
  readonly isValueSecret?: boolean;

  /**
   * Header Name.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeader#key
   */
  readonly key?: string;

  /**
   * Header Value. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeader#valueSecretRef
   */
  readonly valueSecretRef?: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeaderValueSecretRef;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeader(obj: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isValueSecret': obj.isValueSecret,
    'key': obj.key,
    'valueSecretRef': toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeaderValueSecretRef(obj.valueSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryString
 */
export interface ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryString {
  /**
   * Specified whether the value is secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryString#isValueSecret
   */
  readonly isValueSecret?: boolean;

  /**
   * Header Name.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryString#key
   */
  readonly key?: string;

  /**
   * Header Value. Created and stored in AWS Secrets Manager.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryString#valueSecretRef
   */
  readonly valueSecretRef?: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryStringValueSecretRef;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryString(obj: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isValueSecret': obj.isValueSecret,
    'key': obj.key,
    'valueSecretRef': toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryStringValueSecretRef(obj.valueSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header Value. Created and stored in AWS Secrets Manager.
 *
 * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBodyValueSecretRef
 */
export interface ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBodyValueSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBodyValueSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBodyValueSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBodyValueSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBodyValueSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBodyValueSecretRef(obj: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersBodyValueSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header Value. Created and stored in AWS Secrets Manager.
 *
 * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeaderValueSecretRef
 */
export interface ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeaderValueSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeaderValueSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeaderValueSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeaderValueSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeaderValueSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeaderValueSecretRef(obj: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersHeaderValueSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header Value. Created and stored in AWS Secrets Manager.
 *
 * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryStringValueSecretRef
 */
export interface ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryStringValueSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryStringValueSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryStringValueSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryStringValueSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryStringValueSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryStringValueSecretRef(obj: ConnectionSpecForProviderAuthParametersOauthOauthHttpParametersQueryStringValueSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Permission is the Schema for the Permissions API. Provides a resource to create an EventBridge permission to support cross-account events in the current account default event bus.
 *
 * @schema Permission
 */
export class Permission extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Permission"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatchevents.aws.upbound.io/v1beta1',
    kind: 'Permission',
  }

  /**
   * Renders a Kubernetes manifest for "Permission".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionProps): any {
    return {
      ...Permission.GVK,
      ...toJson_PermissionProps(props),
    };
  }

  /**
   * Defines a "Permission" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionProps) {
    super(scope, id, {
      ...Permission.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Permission.GVK,
      ...toJson_PermissionProps(resolved),
    };
  }
}

/**
 * Permission is the Schema for the Permissions API. Provides a resource to create an EventBridge permission to support cross-account events in the current account default event bus.
 *
 * @schema Permission
 */
export interface PermissionProps {
  /**
   * @schema Permission#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionSpec defines the desired state of Permission
   *
   * @schema Permission#spec
   */
  readonly spec: PermissionSpec;

}

/**
 * Converts an object of type 'PermissionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionProps(obj: PermissionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionSpec defines the desired state of Permission
 *
 * @schema PermissionSpec
 */
export interface PermissionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionSpecDeletionPolicy;

  /**
   * @schema PermissionSpec#forProvider
   */
  readonly forProvider: PermissionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSpec#managementPolicy
   */
  readonly managementPolicy?: PermissionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PermissionSpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PermissionSpec#providerRef
   */
  readonly providerRef?: PermissionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PermissionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PermissionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpec(obj: PermissionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PermissionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PermissionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PermissionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSpecDeletionPolicy
 */
export enum PermissionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionSpecForProvider
 */
export interface PermissionSpecForProvider {
  /**
   * The action that you are enabling the other account to perform. Defaults to events:PutEvents.
   *
   * @default events:PutEvents.
   * @schema PermissionSpecForProvider#action
   */
  readonly action?: string;

  /**
   * Configuration block to limit the event bus permissions you are granting to only accounts that fulfill the condition. Specified below.
   *
   * @schema PermissionSpecForProvider#condition
   */
  readonly condition?: PermissionSpecForProviderCondition[];

  /**
   * The name of the event bus to set the permissions on. If you omit this, the permissions are set on the default event bus.
   *
   * @schema PermissionSpecForProvider#eventBusName
   */
  readonly eventBusName?: string;

  /**
   * Reference to a Bus to populate eventBusName.
   *
   * @schema PermissionSpecForProvider#eventBusNameRef
   */
  readonly eventBusNameRef?: PermissionSpecForProviderEventBusNameRef;

  /**
   * Selector for a Bus to populate eventBusName.
   *
   * @schema PermissionSpecForProvider#eventBusNameSelector
   */
  readonly eventBusNameSelector?: PermissionSpecForProviderEventBusNameSelector;

  /**
   * The 12-digit AWS account ID that you are permitting to put events to your default event bus. Specify * to permit any account to put events to your default event bus, optionally limited by condition.
   *
   * @schema PermissionSpecForProvider#principal
   */
  readonly principal?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PermissionSpecForProvider#region
   */
  readonly region: string;

  /**
   * An identifier string for the external account that you are granting permissions to.
   *
   * @schema PermissionSpecForProvider#statementId
   */
  readonly statementId?: string;

}

/**
 * Converts an object of type 'PermissionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProvider(obj: PermissionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'condition': obj.condition?.map(y => toJson_PermissionSpecForProviderCondition(y)),
    'eventBusName': obj.eventBusName,
    'eventBusNameRef': toJson_PermissionSpecForProviderEventBusNameRef(obj.eventBusNameRef),
    'eventBusNameSelector': toJson_PermissionSpecForProviderEventBusNameSelector(obj.eventBusNameSelector),
    'principal': obj.principal,
    'region': obj.region,
    'statementId': obj.statementId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSpecManagementPolicy
 */
export enum PermissionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PermissionSpecProviderConfigRef
 */
export interface PermissionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecProviderConfigRef#policy
   */
  readonly policy?: PermissionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderConfigRef(obj: PermissionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PermissionSpecProviderRef
 */
export interface PermissionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecProviderRef#policy
   */
  readonly policy?: PermissionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderRef(obj: PermissionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PermissionSpecPublishConnectionDetailsTo
 */
export interface PermissionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsTo(obj: PermissionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PermissionSpecWriteConnectionSecretToRef
 */
export interface PermissionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecWriteConnectionSecretToRef(obj: PermissionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionSpecForProviderCondition
 */
export interface PermissionSpecForProviderCondition {
  /**
   * Key for the condition. Valid values: aws:PrincipalOrgID.
   *
   * @schema PermissionSpecForProviderCondition#key
   */
  readonly key: string;

  /**
   * Type of condition. Value values: StringEquals.
   *
   * @schema PermissionSpecForProviderCondition#type
   */
  readonly type: string;

  /**
   * Value for the key.
   *
   * @schema PermissionSpecForProviderCondition#value
   */
  readonly value?: string;

  /**
   * Reference to a Organization in organizations to populate value.
   *
   * @schema PermissionSpecForProviderCondition#valueRef
   */
  readonly valueRef?: PermissionSpecForProviderConditionValueRef;

  /**
   * Selector for a Organization in organizations to populate value.
   *
   * @schema PermissionSpecForProviderCondition#valueSelector
   */
  readonly valueSelector?: PermissionSpecForProviderConditionValueSelector;

}

/**
 * Converts an object of type 'PermissionSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderCondition(obj: PermissionSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'type': obj.type,
    'value': obj.value,
    'valueRef': toJson_PermissionSpecForProviderConditionValueRef(obj.valueRef),
    'valueSelector': toJson_PermissionSpecForProviderConditionValueSelector(obj.valueSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bus to populate eventBusName.
 *
 * @schema PermissionSpecForProviderEventBusNameRef
 */
export interface PermissionSpecForProviderEventBusNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecForProviderEventBusNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecForProviderEventBusNameRef#policy
   */
  readonly policy?: PermissionSpecForProviderEventBusNameRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderEventBusNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderEventBusNameRef(obj: PermissionSpecForProviderEventBusNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecForProviderEventBusNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bus to populate eventBusName.
 *
 * @schema PermissionSpecForProviderEventBusNameSelector
 */
export interface PermissionSpecForProviderEventBusNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionSpecForProviderEventBusNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionSpecForProviderEventBusNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionSpecForProviderEventBusNameSelector#policy
   */
  readonly policy?: PermissionSpecForProviderEventBusNameSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderEventBusNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderEventBusNameSelector(obj: PermissionSpecForProviderEventBusNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionSpecForProviderEventBusNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecProviderConfigRefPolicy
 */
export interface PermissionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderConfigRefPolicy(obj: PermissionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecProviderRefPolicy
 */
export interface PermissionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderRefPolicy(obj: PermissionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToConfigRef(obj: PermissionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionSpecPublishConnectionDetailsToMetadata
 */
export interface PermissionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToMetadata(obj: PermissionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Organization in organizations to populate value.
 *
 * @schema PermissionSpecForProviderConditionValueRef
 */
export interface PermissionSpecForProviderConditionValueRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecForProviderConditionValueRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecForProviderConditionValueRef#policy
   */
  readonly policy?: PermissionSpecForProviderConditionValueRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderConditionValueRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderConditionValueRef(obj: PermissionSpecForProviderConditionValueRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecForProviderConditionValueRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Organization in organizations to populate value.
 *
 * @schema PermissionSpecForProviderConditionValueSelector
 */
export interface PermissionSpecForProviderConditionValueSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionSpecForProviderConditionValueSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionSpecForProviderConditionValueSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionSpecForProviderConditionValueSelector#policy
   */
  readonly policy?: PermissionSpecForProviderConditionValueSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderConditionValueSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderConditionValueSelector(obj: PermissionSpecForProviderConditionValueSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionSpecForProviderConditionValueSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecForProviderEventBusNameRefPolicy
 */
export interface PermissionSpecForProviderEventBusNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderEventBusNameRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderEventBusNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderEventBusNameRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderEventBusNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderEventBusNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderEventBusNameRefPolicy(obj: PermissionSpecForProviderEventBusNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionSpecForProviderEventBusNameSelectorPolicy
 */
export interface PermissionSpecForProviderEventBusNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderEventBusNameSelectorPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderEventBusNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderEventBusNameSelectorPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderEventBusNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderEventBusNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderEventBusNameSelectorPolicy(obj: PermissionSpecForProviderEventBusNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecProviderConfigRefPolicyResolution
 */
export enum PermissionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecProviderConfigRefPolicyResolve
 */
export enum PermissionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecProviderRefPolicyResolution
 */
export enum PermissionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecProviderRefPolicyResolve
 */
export enum PermissionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecForProviderConditionValueRefPolicy
 */
export interface PermissionSpecForProviderConditionValueRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderConditionValueRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderConditionValueRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderConditionValueRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderConditionValueRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderConditionValueRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderConditionValueRefPolicy(obj: PermissionSpecForProviderConditionValueRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionSpecForProviderConditionValueSelectorPolicy
 */
export interface PermissionSpecForProviderConditionValueSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderConditionValueSelectorPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderConditionValueSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderConditionValueSelectorPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderConditionValueSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderConditionValueSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderConditionValueSelectorPolicy(obj: PermissionSpecForProviderConditionValueSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderEventBusNameRefPolicyResolution
 */
export enum PermissionSpecForProviderEventBusNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderEventBusNameRefPolicyResolve
 */
export enum PermissionSpecForProviderEventBusNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderEventBusNameSelectorPolicyResolution
 */
export enum PermissionSpecForProviderEventBusNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderEventBusNameSelectorPolicyResolve
 */
export enum PermissionSpecForProviderEventBusNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderConditionValueRefPolicyResolution
 */
export enum PermissionSpecForProviderConditionValueRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderConditionValueRefPolicyResolve
 */
export enum PermissionSpecForProviderConditionValueRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderConditionValueSelectorPolicyResolution
 */
export enum PermissionSpecForProviderConditionValueSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderConditionValueSelectorPolicyResolve
 */
export enum PermissionSpecForProviderConditionValueSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Rule is the Schema for the Rules API. Provides an EventBridge Rule resource.
 *
 * @schema Rule
 */
export class Rule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Rule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatchevents.aws.upbound.io/v1beta1',
    kind: 'Rule',
  }

  /**
   * Renders a Kubernetes manifest for "Rule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuleProps): any {
    return {
      ...Rule.GVK,
      ...toJson_RuleProps(props),
    };
  }

  /**
   * Defines a "Rule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuleProps) {
    super(scope, id, {
      ...Rule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Rule.GVK,
      ...toJson_RuleProps(resolved),
    };
  }
}

/**
 * Rule is the Schema for the Rules API. Provides an EventBridge Rule resource.
 *
 * @schema Rule
 */
export interface RuleProps {
  /**
   * @schema Rule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuleSpec defines the desired state of Rule
   *
   * @schema Rule#spec
   */
  readonly spec: RuleSpec;

}

/**
 * Converts an object of type 'RuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleProps(obj: RuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuleSpec defines the desired state of Rule
 *
 * @schema RuleSpec
 */
export interface RuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuleSpecDeletionPolicy;

  /**
   * @schema RuleSpec#forProvider
   */
  readonly forProvider: RuleSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RuleSpec#managementPolicy
   */
  readonly managementPolicy?: RuleSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RuleSpec#providerRef
   */
  readonly providerRef?: RuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpec(obj: RuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuleSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleSpecDeletionPolicy
 */
export enum RuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RuleSpecForProvider
 */
export interface RuleSpecForProvider {
  /**
   * The description of the rule.
   *
   * @schema RuleSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name or ARN of the event bus to associate with this rule. If you omit this, the default event bus is used.
   *
   * @schema RuleSpecForProvider#eventBusName
   */
  readonly eventBusName?: string;

  /**
   * Reference to a Bus to populate eventBusName.
   *
   * @schema RuleSpecForProvider#eventBusNameRef
   */
  readonly eventBusNameRef?: RuleSpecForProviderEventBusNameRef;

  /**
   * Selector for a Bus to populate eventBusName.
   *
   * @schema RuleSpecForProvider#eventBusNameSelector
   */
  readonly eventBusNameSelector?: RuleSpecForProviderEventBusNameSelector;

  /**
   * The event pattern described a JSON object. At least one of schedule_expression or event_pattern is required. See full documentation of Events and Event Patterns in EventBridge for details.
   *
   * @schema RuleSpecForProvider#eventPattern
   */
  readonly eventPattern?: string;

  /**
   * Whether the rule should be enabled (defaults to true).
   *
   * @schema RuleSpecForProvider#isEnabled
   */
  readonly isEnabled?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) associated with the role that is used for target invocation.
   *
   * @schema RuleSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema RuleSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: RuleSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema RuleSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: RuleSpecForProviderRoleArnSelector;

  /**
   * The scheduling expression. For example, cron(0 20 * * ? *) or rate(5 minutes). At least one of schedule_expression or event_pattern is required. Can only be used on the default event bus. For more information, refer to the AWS documentation Schedule Expressions for Rules.
   *
   * @schema RuleSpecForProvider#scheduleExpression
   */
  readonly scheduleExpression?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RuleSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProvider(obj: RuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'eventBusName': obj.eventBusName,
    'eventBusNameRef': toJson_RuleSpecForProviderEventBusNameRef(obj.eventBusNameRef),
    'eventBusNameSelector': toJson_RuleSpecForProviderEventBusNameSelector(obj.eventBusNameSelector),
    'eventPattern': obj.eventPattern,
    'isEnabled': obj.isEnabled,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_RuleSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_RuleSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'scheduleExpression': obj.scheduleExpression,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RuleSpecManagementPolicy
 */
export enum RuleSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuleSpecProviderConfigRef
 */
export interface RuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecProviderConfigRef#policy
   */
  readonly policy?: RuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderConfigRef(obj: RuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RuleSpecProviderRef
 */
export interface RuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecProviderRef#policy
   */
  readonly policy?: RuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderRef(obj: RuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuleSpecPublishConnectionDetailsTo
 */
export interface RuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsTo(obj: RuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuleSpecWriteConnectionSecretToRef
 */
export interface RuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecWriteConnectionSecretToRef(obj: RuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bus to populate eventBusName.
 *
 * @schema RuleSpecForProviderEventBusNameRef
 */
export interface RuleSpecForProviderEventBusNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecForProviderEventBusNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecForProviderEventBusNameRef#policy
   */
  readonly policy?: RuleSpecForProviderEventBusNameRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecForProviderEventBusNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderEventBusNameRef(obj: RuleSpecForProviderEventBusNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecForProviderEventBusNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bus to populate eventBusName.
 *
 * @schema RuleSpecForProviderEventBusNameSelector
 */
export interface RuleSpecForProviderEventBusNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleSpecForProviderEventBusNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleSpecForProviderEventBusNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleSpecForProviderEventBusNameSelector#policy
   */
  readonly policy?: RuleSpecForProviderEventBusNameSelectorPolicy;

}

/**
 * Converts an object of type 'RuleSpecForProviderEventBusNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderEventBusNameSelector(obj: RuleSpecForProviderEventBusNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleSpecForProviderEventBusNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema RuleSpecForProviderRoleArnRef
 */
export interface RuleSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecForProviderRoleArnRef#policy
   */
  readonly policy?: RuleSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderRoleArnRef(obj: RuleSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema RuleSpecForProviderRoleArnSelector
 */
export interface RuleSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: RuleSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'RuleSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderRoleArnSelector(obj: RuleSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleSpecProviderConfigRefPolicy
 */
export interface RuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderConfigRefPolicy(obj: RuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleSpecProviderRefPolicy
 */
export interface RuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderRefPolicy(obj: RuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRef
 */
export interface RuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsToConfigRef(obj: RuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuleSpecPublishConnectionDetailsToMetadata
 */
export interface RuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsToMetadata(obj: RuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleSpecForProviderEventBusNameRefPolicy
 */
export interface RuleSpecForProviderEventBusNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecForProviderEventBusNameRefPolicy#resolution
   */
  readonly resolution?: RuleSpecForProviderEventBusNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecForProviderEventBusNameRefPolicy#resolve
   */
  readonly resolve?: RuleSpecForProviderEventBusNameRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecForProviderEventBusNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderEventBusNameRefPolicy(obj: RuleSpecForProviderEventBusNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleSpecForProviderEventBusNameSelectorPolicy
 */
export interface RuleSpecForProviderEventBusNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecForProviderEventBusNameSelectorPolicy#resolution
   */
  readonly resolution?: RuleSpecForProviderEventBusNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecForProviderEventBusNameSelectorPolicy#resolve
   */
  readonly resolve?: RuleSpecForProviderEventBusNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecForProviderEventBusNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderEventBusNameSelectorPolicy(obj: RuleSpecForProviderEventBusNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleSpecForProviderRoleArnRefPolicy
 */
export interface RuleSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: RuleSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: RuleSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderRoleArnRefPolicy(obj: RuleSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleSpecForProviderRoleArnSelectorPolicy
 */
export interface RuleSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: RuleSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: RuleSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderRoleArnSelectorPolicy(obj: RuleSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecProviderConfigRefPolicyResolution
 */
export enum RuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecProviderConfigRefPolicyResolve
 */
export enum RuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecProviderRefPolicyResolution
 */
export enum RuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecProviderRefPolicyResolve
 */
export enum RuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecForProviderEventBusNameRefPolicyResolution
 */
export enum RuleSpecForProviderEventBusNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecForProviderEventBusNameRefPolicyResolve
 */
export enum RuleSpecForProviderEventBusNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecForProviderEventBusNameSelectorPolicyResolution
 */
export enum RuleSpecForProviderEventBusNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecForProviderEventBusNameSelectorPolicyResolve
 */
export enum RuleSpecForProviderEventBusNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecForProviderRoleArnRefPolicyResolution
 */
export enum RuleSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecForProviderRoleArnRefPolicyResolve
 */
export enum RuleSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum RuleSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum RuleSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Target is the Schema for the Targets API. Provides an EventBridge Target resource.
 *
 * @schema Target
 */
export class Target extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Target"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudwatchevents.aws.upbound.io/v1beta1',
    kind: 'Target',
  }

  /**
   * Renders a Kubernetes manifest for "Target".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TargetProps): any {
    return {
      ...Target.GVK,
      ...toJson_TargetProps(props),
    };
  }

  /**
   * Defines a "Target" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TargetProps) {
    super(scope, id, {
      ...Target.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Target.GVK,
      ...toJson_TargetProps(resolved),
    };
  }
}

/**
 * Target is the Schema for the Targets API. Provides an EventBridge Target resource.
 *
 * @schema Target
 */
export interface TargetProps {
  /**
   * @schema Target#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TargetSpec defines the desired state of Target
   *
   * @schema Target#spec
   */
  readonly spec: TargetSpec;

}

/**
 * Converts an object of type 'TargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetProps(obj: TargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TargetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetSpec defines the desired state of Target
 *
 * @schema TargetSpec
 */
export interface TargetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TargetSpec#deletionPolicy
   */
  readonly deletionPolicy?: TargetSpecDeletionPolicy;

  /**
   * @schema TargetSpec#forProvider
   */
  readonly forProvider: TargetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TargetSpec#managementPolicy
   */
  readonly managementPolicy?: TargetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TargetSpec#providerConfigRef
   */
  readonly providerConfigRef?: TargetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TargetSpec#providerRef
   */
  readonly providerRef?: TargetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TargetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TargetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TargetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TargetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TargetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpec(obj: TargetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TargetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TargetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TargetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TargetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TargetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TargetSpecDeletionPolicy
 */
export enum TargetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TargetSpecForProvider
 */
export interface TargetSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the target.
   *
   * @schema TargetSpecForProvider#arn
   */
  readonly arn?: string;

  /**
   * Parameters used when you are using the rule to invoke an Amazon Batch Job. Documented below. A maximum of 1 are allowed.
   *
   * @schema TargetSpecForProvider#batchTarget
   */
  readonly batchTarget?: TargetSpecForProviderBatchTarget[];

  /**
   * Parameters used when you are providing a dead letter config. Documented below. A maximum of 1 are allowed.
   *
   * @schema TargetSpecForProvider#deadLetterConfig
   */
  readonly deadLetterConfig?: TargetSpecForProviderDeadLetterConfig[];

  /**
   * Parameters used when you are using the rule to invoke Amazon ECS Task. Documented below. A maximum of 1 are allowed.
   *
   * @schema TargetSpecForProvider#ecsTarget
   */
  readonly ecsTarget?: TargetSpecForProviderEcsTarget[];

  /**
   * The name or ARN of the event bus to associate with the rule. If you omit this, the default event bus is used.
   *
   * @schema TargetSpecForProvider#eventBusName
   */
  readonly eventBusName?: string;

  /**
   * Reference to a Bus to populate eventBusName.
   *
   * @schema TargetSpecForProvider#eventBusNameRef
   */
  readonly eventBusNameRef?: TargetSpecForProviderEventBusNameRef;

  /**
   * Selector for a Bus to populate eventBusName.
   *
   * @schema TargetSpecForProvider#eventBusNameSelector
   */
  readonly eventBusNameSelector?: TargetSpecForProviderEventBusNameSelector;

  /**
   * Parameters used when you are using the rule to invoke an API Gateway REST endpoint. Documented below. A maximum of 1 is allowed.
   *
   * @schema TargetSpecForProvider#httpTarget
   */
  readonly httpTarget?: TargetSpecForProviderHttpTarget[];

  /**
   * Valid JSON text passed to the target. Conflicts with input_path and input_transformer.
   *
   * @schema TargetSpecForProvider#input
   */
  readonly input?: string;

  /**
   * The value of the JSONPath that is used for extracting part of the matched event when passing it to the target. Conflicts with input and input_transformer.
   *
   * @schema TargetSpecForProvider#inputPath
   */
  readonly inputPath?: string;

  /**
   * Parameters used when you are providing a custom input to a target based on certain event data. Conflicts with input and input_path.
   *
   * @schema TargetSpecForProvider#inputTransformer
   */
  readonly inputTransformer?: TargetSpecForProviderInputTransformer[];

  /**
   * Parameters used when you are using the rule to invoke an Amazon Kinesis Stream. Documented below. A maximum of 1 are allowed.
   *
   * @schema TargetSpecForProvider#kinesisTarget
   */
  readonly kinesisTarget?: TargetSpecForProviderKinesisTarget[];

  /**
   * Parameters used when you are using the rule to invoke an Amazon Redshift Statement. Documented below. A maximum of 1 are allowed.
   *
   * @schema TargetSpecForProvider#redshiftTarget
   */
  readonly redshiftTarget?: TargetSpecForProviderRedshiftTarget[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TargetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Parameters used when you are providing retry policies. Documented below. A maximum of 1 are allowed.
   *
   * @schema TargetSpecForProvider#retryPolicy
   */
  readonly retryPolicy?: TargetSpecForProviderRetryPolicy[];

  /**
   * The Amazon Resource Name (ARN) of the IAM role to be used for this target when the rule is triggered. Required if ecs_target is used or target in arn is EC2 instance, Kinesis data stream, Step Functions state machine, or Event Bus in different account or region.
   *
   * @schema TargetSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema TargetSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: TargetSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema TargetSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: TargetSpecForProviderRoleArnSelector;

  /**
   * The name of the rule you want to add targets to.
   *
   * @schema TargetSpecForProvider#rule
   */
  readonly rule?: string;

  /**
   * Reference to a Rule in cloudwatchevents to populate rule.
   *
   * @schema TargetSpecForProvider#ruleRef
   */
  readonly ruleRef?: TargetSpecForProviderRuleRef;

  /**
   * Selector for a Rule in cloudwatchevents to populate rule.
   *
   * @schema TargetSpecForProvider#ruleSelector
   */
  readonly ruleSelector?: TargetSpecForProviderRuleSelector;

  /**
   * Parameters used when you are using the rule to invoke Amazon EC2 Run Command. Documented below. A maximum of 5 are allowed.
   *
   * @schema TargetSpecForProvider#runCommandTargets
   */
  readonly runCommandTargets?: TargetSpecForProviderRunCommandTargets[];

  /**
   * Parameters used when you are using the rule to invoke an Amazon SQS Queue. Documented below. A maximum of 1 are allowed.
   *
   * @schema TargetSpecForProvider#sqsTarget
   */
  readonly sqsTarget?: TargetSpecForProviderSqsTarget[];

  /**
   * The unique target assignment ID. If missing, will generate a random, unique id.
   *
   * @schema TargetSpecForProvider#targetId
   */
  readonly targetId?: string;

}

/**
 * Converts an object of type 'TargetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProvider(obj: TargetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'batchTarget': obj.batchTarget?.map(y => toJson_TargetSpecForProviderBatchTarget(y)),
    'deadLetterConfig': obj.deadLetterConfig?.map(y => toJson_TargetSpecForProviderDeadLetterConfig(y)),
    'ecsTarget': obj.ecsTarget?.map(y => toJson_TargetSpecForProviderEcsTarget(y)),
    'eventBusName': obj.eventBusName,
    'eventBusNameRef': toJson_TargetSpecForProviderEventBusNameRef(obj.eventBusNameRef),
    'eventBusNameSelector': toJson_TargetSpecForProviderEventBusNameSelector(obj.eventBusNameSelector),
    'httpTarget': obj.httpTarget?.map(y => toJson_TargetSpecForProviderHttpTarget(y)),
    'input': obj.input,
    'inputPath': obj.inputPath,
    'inputTransformer': obj.inputTransformer?.map(y => toJson_TargetSpecForProviderInputTransformer(y)),
    'kinesisTarget': obj.kinesisTarget?.map(y => toJson_TargetSpecForProviderKinesisTarget(y)),
    'redshiftTarget': obj.redshiftTarget?.map(y => toJson_TargetSpecForProviderRedshiftTarget(y)),
    'region': obj.region,
    'retryPolicy': obj.retryPolicy?.map(y => toJson_TargetSpecForProviderRetryPolicy(y)),
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_TargetSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_TargetSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'rule': obj.rule,
    'ruleRef': toJson_TargetSpecForProviderRuleRef(obj.ruleRef),
    'ruleSelector': toJson_TargetSpecForProviderRuleSelector(obj.ruleSelector),
    'runCommandTargets': obj.runCommandTargets?.map(y => toJson_TargetSpecForProviderRunCommandTargets(y)),
    'sqsTarget': obj.sqsTarget?.map(y => toJson_TargetSpecForProviderSqsTarget(y)),
    'targetId': obj.targetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TargetSpecManagementPolicy
 */
export enum TargetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TargetSpecProviderConfigRef
 */
export interface TargetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecProviderConfigRef#policy
   */
  readonly policy?: TargetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderConfigRef(obj: TargetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TargetSpecProviderRef
 */
export interface TargetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecProviderRef#policy
   */
  readonly policy?: TargetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderRef(obj: TargetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TargetSpecPublishConnectionDetailsTo
 */
export interface TargetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TargetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TargetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsTo(obj: TargetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TargetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TargetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TargetSpecWriteConnectionSecretToRef
 */
export interface TargetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TargetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TargetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TargetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecWriteConnectionSecretToRef(obj: TargetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderBatchTarget
 */
export interface TargetSpecForProviderBatchTarget {
  /**
   * The size of the array, if this is an array batch job. Valid values are integers between 2 and 10,000.
   *
   * @schema TargetSpecForProviderBatchTarget#arraySize
   */
  readonly arraySize?: number;

  /**
   * The number of times to attempt to retry, if the job fails. Valid values are 1 to 10.
   *
   * @schema TargetSpecForProviderBatchTarget#jobAttempts
   */
  readonly jobAttempts?: number;

  /**
   * The ARN or name of the job definition to use if the event target is an AWS Batch job. This job definition must already exist.
   *
   * @schema TargetSpecForProviderBatchTarget#jobDefinition
   */
  readonly jobDefinition: string;

  /**
   * The name to use for this execution of the job, if the target is an AWS Batch job.
   *
   * @schema TargetSpecForProviderBatchTarget#jobName
   */
  readonly jobName: string;

}

/**
 * Converts an object of type 'TargetSpecForProviderBatchTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderBatchTarget(obj: TargetSpecForProviderBatchTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arraySize': obj.arraySize,
    'jobAttempts': obj.jobAttempts,
    'jobDefinition': obj.jobDefinition,
    'jobName': obj.jobName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderDeadLetterConfig
 */
export interface TargetSpecForProviderDeadLetterConfig {
  /**
   * - ARN of the SQS queue specified as the target for the dead-letter queue.
   *
   * @schema TargetSpecForProviderDeadLetterConfig#arn
   */
  readonly arn?: string;

}

/**
 * Converts an object of type 'TargetSpecForProviderDeadLetterConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderDeadLetterConfig(obj: TargetSpecForProviderDeadLetterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderEcsTarget
 */
export interface TargetSpecForProviderEcsTarget {
  /**
   * The capacity provider strategy to use for the task. If a capacity_provider_strategy specified, the launch_type parameter must be omitted. If no capacity_provider_strategy or launch_type is specified, the default capacity provider strategy for the cluster is used. Can be one or more. See below.
   *
   * @schema TargetSpecForProviderEcsTarget#capacityProviderStrategy
   */
  readonly capacityProviderStrategy?: TargetSpecForProviderEcsTargetCapacityProviderStrategy[];

  /**
   * Specifies whether to enable Amazon ECS managed tags for the task.
   *
   * @schema TargetSpecForProviderEcsTarget#enableEcsManagedTags
   */
  readonly enableEcsManagedTags?: boolean;

  /**
   * Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
   *
   * @schema TargetSpecForProviderEcsTarget#enableExecuteCommand
   */
  readonly enableExecuteCommand?: boolean;

  /**
   * Specifies an ECS task group for the task. The maximum length is 255 characters.
   *
   * @schema TargetSpecForProviderEcsTarget#group
   */
  readonly group?: string;

  /**
   * Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. Valid values include: EC2, EXTERNAL, or FARGATE.
   *
   * @schema TargetSpecForProviderEcsTarget#launchType
   */
  readonly launchType?: string;

  /**
   * Use this if the ECS task uses the awsvpc network mode. This specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. Required if launch_type is FARGATE because the awsvpc mode is required for Fargate tasks.
   *
   * @schema TargetSpecForProviderEcsTarget#networkConfiguration
   */
  readonly networkConfiguration?: TargetSpecForProviderEcsTargetNetworkConfiguration[];

  /**
   * An array of placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.
   *
   * @schema TargetSpecForProviderEcsTarget#orderedPlacementStrategy
   */
  readonly orderedPlacementStrategy?: TargetSpecForProviderEcsTargetOrderedPlacementStrategy[];

  /**
   * An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime). See Below.
   *
   * @schema TargetSpecForProviderEcsTarget#placementConstraint
   */
  readonly placementConstraint?: TargetSpecForProviderEcsTargetPlacementConstraint[];

  /**
   * Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0. This is used only if LaunchType is FARGATE. For more information about valid platform versions, see AWS Fargate Platform Versions.
   *
   * @schema TargetSpecForProviderEcsTarget#platformVersion
   */
  readonly platformVersion?: string;

  /**
   * Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. The only valid value is: TASK_DEFINITION.
   *
   * @schema TargetSpecForProviderEcsTarget#propagateTags
   */
  readonly propagateTags?: string;

  /**
   * A map of tags to assign to ecs resources.
   *
   * @schema TargetSpecForProviderEcsTarget#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The number of tasks to create based on the TaskDefinition. Defaults to 1.
   *
   * @default 1.
   * @schema TargetSpecForProviderEcsTarget#taskCount
   */
  readonly taskCount?: number;

  /**
   * The ARN of the task definition to use if the event target is an Amazon ECS cluster.
   *
   * @schema TargetSpecForProviderEcsTarget#taskDefinitionArn
   */
  readonly taskDefinitionArn?: string;

  /**
   * Reference to a TaskDefinition in ecs to populate taskDefinitionArn.
   *
   * @schema TargetSpecForProviderEcsTarget#taskDefinitionArnRef
   */
  readonly taskDefinitionArnRef?: TargetSpecForProviderEcsTargetTaskDefinitionArnRef;

  /**
   * Selector for a TaskDefinition in ecs to populate taskDefinitionArn.
   *
   * @schema TargetSpecForProviderEcsTarget#taskDefinitionArnSelector
   */
  readonly taskDefinitionArnSelector?: TargetSpecForProviderEcsTargetTaskDefinitionArnSelector;

}

/**
 * Converts an object of type 'TargetSpecForProviderEcsTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEcsTarget(obj: TargetSpecForProviderEcsTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityProviderStrategy': obj.capacityProviderStrategy?.map(y => toJson_TargetSpecForProviderEcsTargetCapacityProviderStrategy(y)),
    'enableEcsManagedTags': obj.enableEcsManagedTags,
    'enableExecuteCommand': obj.enableExecuteCommand,
    'group': obj.group,
    'launchType': obj.launchType,
    'networkConfiguration': obj.networkConfiguration?.map(y => toJson_TargetSpecForProviderEcsTargetNetworkConfiguration(y)),
    'orderedPlacementStrategy': obj.orderedPlacementStrategy?.map(y => toJson_TargetSpecForProviderEcsTargetOrderedPlacementStrategy(y)),
    'placementConstraint': obj.placementConstraint?.map(y => toJson_TargetSpecForProviderEcsTargetPlacementConstraint(y)),
    'platformVersion': obj.platformVersion,
    'propagateTags': obj.propagateTags,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taskCount': obj.taskCount,
    'taskDefinitionArn': obj.taskDefinitionArn,
    'taskDefinitionArnRef': toJson_TargetSpecForProviderEcsTargetTaskDefinitionArnRef(obj.taskDefinitionArnRef),
    'taskDefinitionArnSelector': toJson_TargetSpecForProviderEcsTargetTaskDefinitionArnSelector(obj.taskDefinitionArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bus to populate eventBusName.
 *
 * @schema TargetSpecForProviderEventBusNameRef
 */
export interface TargetSpecForProviderEventBusNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecForProviderEventBusNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecForProviderEventBusNameRef#policy
   */
  readonly policy?: TargetSpecForProviderEventBusNameRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderEventBusNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEventBusNameRef(obj: TargetSpecForProviderEventBusNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecForProviderEventBusNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bus to populate eventBusName.
 *
 * @schema TargetSpecForProviderEventBusNameSelector
 */
export interface TargetSpecForProviderEventBusNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TargetSpecForProviderEventBusNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TargetSpecForProviderEventBusNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TargetSpecForProviderEventBusNameSelector#policy
   */
  readonly policy?: TargetSpecForProviderEventBusNameSelectorPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderEventBusNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEventBusNameSelector(obj: TargetSpecForProviderEventBusNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TargetSpecForProviderEventBusNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderHttpTarget
 */
export interface TargetSpecForProviderHttpTarget {
  /**
   * Enables you to specify HTTP headers to add to the request.
   *
   * @schema TargetSpecForProviderHttpTarget#headerParameters
   */
  readonly headerParameters?: { [key: string]: string };

  /**
   * The list of values that correspond sequentially to any path variables in your endpoint ARN (for example arn:aws:execute-api:us-east-1:123456:myapi/_/POST/pets/*).
   *
   * @schema TargetSpecForProviderHttpTarget#pathParameterValues
   */
  readonly pathParameterValues?: string[];

  /**
   * Represents keys/values of query string parameters that are appended to the invoked endpoint.
   *
   * @schema TargetSpecForProviderHttpTarget#queryStringParameters
   */
  readonly queryStringParameters?: { [key: string]: string };

}

/**
 * Converts an object of type 'TargetSpecForProviderHttpTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderHttpTarget(obj: TargetSpecForProviderHttpTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerParameters': ((obj.headerParameters) === undefined) ? undefined : (Object.entries(obj.headerParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'pathParameterValues': obj.pathParameterValues?.map(y => y),
    'queryStringParameters': ((obj.queryStringParameters) === undefined) ? undefined : (Object.entries(obj.queryStringParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderInputTransformer
 */
export interface TargetSpecForProviderInputTransformer {
  /**
   * Key value pairs specified in the form of JSONPath (for example, time = $.time)
   *
   * @schema TargetSpecForProviderInputTransformer#inputPaths
   */
  readonly inputPaths?: { [key: string]: string };

  /**
   * Template to customize data sent to the target. Must be valid JSON. To send a string value, the string value must include double quotes.g., "\"Your string goes here.\\nA new line.\""
   *
   * @schema TargetSpecForProviderInputTransformer#inputTemplate
   */
  readonly inputTemplate: string;

}

/**
 * Converts an object of type 'TargetSpecForProviderInputTransformer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderInputTransformer(obj: TargetSpecForProviderInputTransformer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputPaths': ((obj.inputPaths) === undefined) ? undefined : (Object.entries(obj.inputPaths).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'inputTemplate': obj.inputTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderKinesisTarget
 */
export interface TargetSpecForProviderKinesisTarget {
  /**
   * The JSON path to be extracted from the event and used as the partition key.
   *
   * @schema TargetSpecForProviderKinesisTarget#partitionKeyPath
   */
  readonly partitionKeyPath?: string;

}

/**
 * Converts an object of type 'TargetSpecForProviderKinesisTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderKinesisTarget(obj: TargetSpecForProviderKinesisTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitionKeyPath': obj.partitionKeyPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderRedshiftTarget
 */
export interface TargetSpecForProviderRedshiftTarget {
  /**
   * The name of the database.
   *
   * @schema TargetSpecForProviderRedshiftTarget#database
   */
  readonly database: string;

  /**
   * The database user name.
   *
   * @schema TargetSpecForProviderRedshiftTarget#dbUser
   */
  readonly dbUser?: string;

  /**
   * The name or ARN of the secret that enables access to the database.
   *
   * @schema TargetSpecForProviderRedshiftTarget#secretsManagerArn
   */
  readonly secretsManagerArn?: string;

  /**
   * The SQL statement text to run.
   *
   * @schema TargetSpecForProviderRedshiftTarget#sql
   */
  readonly sql?: string;

  /**
   * The name of the SQL statement.
   *
   * @schema TargetSpecForProviderRedshiftTarget#statementName
   */
  readonly statementName?: string;

  /**
   * Indicates whether to send an event back to EventBridge after the SQL statement runs.
   *
   * @schema TargetSpecForProviderRedshiftTarget#withEvent
   */
  readonly withEvent?: boolean;

}

/**
 * Converts an object of type 'TargetSpecForProviderRedshiftTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRedshiftTarget(obj: TargetSpecForProviderRedshiftTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'dbUser': obj.dbUser,
    'secretsManagerArn': obj.secretsManagerArn,
    'sql': obj.sql,
    'statementName': obj.statementName,
    'withEvent': obj.withEvent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderRetryPolicy
 */
export interface TargetSpecForProviderRetryPolicy {
  /**
   * The age in seconds to continue to make retry attempts.
   *
   * @schema TargetSpecForProviderRetryPolicy#maximumEventAgeInSeconds
   */
  readonly maximumEventAgeInSeconds?: number;

  /**
   * maximum number of retry attempts to make before the request fails
   *
   * @schema TargetSpecForProviderRetryPolicy#maximumRetryAttempts
   */
  readonly maximumRetryAttempts?: number;

}

/**
 * Converts an object of type 'TargetSpecForProviderRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRetryPolicy(obj: TargetSpecForProviderRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumEventAgeInSeconds': obj.maximumEventAgeInSeconds,
    'maximumRetryAttempts': obj.maximumRetryAttempts,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema TargetSpecForProviderRoleArnRef
 */
export interface TargetSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecForProviderRoleArnRef#policy
   */
  readonly policy?: TargetSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnRef(obj: TargetSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema TargetSpecForProviderRoleArnSelector
 */
export interface TargetSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TargetSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TargetSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TargetSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: TargetSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnSelector(obj: TargetSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TargetSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Rule in cloudwatchevents to populate rule.
 *
 * @schema TargetSpecForProviderRuleRef
 */
export interface TargetSpecForProviderRuleRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecForProviderRuleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecForProviderRuleRef#policy
   */
  readonly policy?: TargetSpecForProviderRuleRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderRuleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRuleRef(obj: TargetSpecForProviderRuleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecForProviderRuleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Rule in cloudwatchevents to populate rule.
 *
 * @schema TargetSpecForProviderRuleSelector
 */
export interface TargetSpecForProviderRuleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TargetSpecForProviderRuleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TargetSpecForProviderRuleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TargetSpecForProviderRuleSelector#policy
   */
  readonly policy?: TargetSpecForProviderRuleSelectorPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderRuleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRuleSelector(obj: TargetSpecForProviderRuleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TargetSpecForProviderRuleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderRunCommandTargets
 */
export interface TargetSpecForProviderRunCommandTargets {
  /**
   * Can be either tag:tag-key or InstanceIds.
   *
   * @schema TargetSpecForProviderRunCommandTargets#key
   */
  readonly key: string;

  /**
   * If Key is tag:tag-key, Values is a list of tag values. If Key is InstanceIds, Values is a list of Amazon EC2 instance IDs.
   *
   * @schema TargetSpecForProviderRunCommandTargets#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'TargetSpecForProviderRunCommandTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRunCommandTargets(obj: TargetSpecForProviderRunCommandTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderSqsTarget
 */
export interface TargetSpecForProviderSqsTarget {
  /**
   * The FIFO message group ID to use as the target.
   *
   * @schema TargetSpecForProviderSqsTarget#messageGroupId
   */
  readonly messageGroupId?: string;

}

/**
 * Converts an object of type 'TargetSpecForProviderSqsTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderSqsTarget(obj: TargetSpecForProviderSqsTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'messageGroupId': obj.messageGroupId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecProviderConfigRefPolicy
 */
export interface TargetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TargetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TargetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderConfigRefPolicy(obj: TargetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecProviderRefPolicy
 */
export interface TargetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TargetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TargetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderRefPolicy(obj: TargetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRef
 */
export interface TargetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TargetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToConfigRef(obj: TargetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TargetSpecPublishConnectionDetailsToMetadata
 */
export interface TargetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToMetadata(obj: TargetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderEcsTargetCapacityProviderStrategy
 */
export interface TargetSpecForProviderEcsTargetCapacityProviderStrategy {
  /**
   * The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to 0.
   *
   * @default 0.
   * @schema TargetSpecForProviderEcsTargetCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * Short name of the capacity provider.
   *
   * @schema TargetSpecForProviderEcsTargetCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider: string;

  /**
   * The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
   *
   * @schema TargetSpecForProviderEcsTargetCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'TargetSpecForProviderEcsTargetCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEcsTargetCapacityProviderStrategy(obj: TargetSpecForProviderEcsTargetCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderEcsTargetNetworkConfiguration
 */
export interface TargetSpecForProviderEcsTargetNetworkConfiguration {
  /**
   * Assign a public IP address to the ENI (Fargate launch type only). Valid values are true or false. Defaults to false.
   *
   * @default false.
   * @schema TargetSpecForProviderEcsTargetNetworkConfiguration#assignPublicIp
   */
  readonly assignPublicIp?: boolean;

  /**
   * The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
   *
   * @schema TargetSpecForProviderEcsTargetNetworkConfiguration#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * The subnets associated with the task or service.
   *
   * @schema TargetSpecForProviderEcsTargetNetworkConfiguration#subnets
   */
  readonly subnets: string[];

}

/**
 * Converts an object of type 'TargetSpecForProviderEcsTargetNetworkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEcsTargetNetworkConfiguration(obj: TargetSpecForProviderEcsTargetNetworkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assignPublicIp': obj.assignPublicIp,
    'securityGroups': obj.securityGroups?.map(y => y),
    'subnets': obj.subnets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderEcsTargetOrderedPlacementStrategy
 */
export interface TargetSpecForProviderEcsTargetOrderedPlacementStrategy {
  /**
   * The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used. For more information, see Amazon ECS task placement strategies.
   *
   * @schema TargetSpecForProviderEcsTargetOrderedPlacementStrategy#field
   */
  readonly field?: string;

  /**
   * Type of placement strategy. The only valid values at this time are binpack, random and spread.
   *
   * @schema TargetSpecForProviderEcsTargetOrderedPlacementStrategy#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TargetSpecForProviderEcsTargetOrderedPlacementStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEcsTargetOrderedPlacementStrategy(obj: TargetSpecForProviderEcsTargetOrderedPlacementStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetSpecForProviderEcsTargetPlacementConstraint
 */
export interface TargetSpecForProviderEcsTargetPlacementConstraint {
  /**
   * Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
   *
   * @schema TargetSpecForProviderEcsTargetPlacementConstraint#expression
   */
  readonly expression?: string;

  /**
   * Type of constraint. The only valid values at this time are memberOf and distinctInstance.
   *
   * @schema TargetSpecForProviderEcsTargetPlacementConstraint#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TargetSpecForProviderEcsTargetPlacementConstraint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEcsTargetPlacementConstraint(obj: TargetSpecForProviderEcsTargetPlacementConstraint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a TaskDefinition in ecs to populate taskDefinitionArn.
 *
 * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnRef
 */
export interface TargetSpecForProviderEcsTargetTaskDefinitionArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnRef#policy
   */
  readonly policy?: TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderEcsTargetTaskDefinitionArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEcsTargetTaskDefinitionArnRef(obj: TargetSpecForProviderEcsTargetTaskDefinitionArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a TaskDefinition in ecs to populate taskDefinitionArn.
 *
 * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnSelector
 */
export interface TargetSpecForProviderEcsTargetTaskDefinitionArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnSelector#policy
   */
  readonly policy?: TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderEcsTargetTaskDefinitionArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEcsTargetTaskDefinitionArnSelector(obj: TargetSpecForProviderEcsTargetTaskDefinitionArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecForProviderEventBusNameRefPolicy
 */
export interface TargetSpecForProviderEventBusNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderEventBusNameRefPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderEventBusNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderEventBusNameRefPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderEventBusNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderEventBusNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEventBusNameRefPolicy(obj: TargetSpecForProviderEventBusNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TargetSpecForProviderEventBusNameSelectorPolicy
 */
export interface TargetSpecForProviderEventBusNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderEventBusNameSelectorPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderEventBusNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderEventBusNameSelectorPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderEventBusNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderEventBusNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEventBusNameSelectorPolicy(obj: TargetSpecForProviderEventBusNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecForProviderRoleArnRefPolicy
 */
export interface TargetSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnRefPolicy(obj: TargetSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TargetSpecForProviderRoleArnSelectorPolicy
 */
export interface TargetSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnSelectorPolicy(obj: TargetSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecForProviderRuleRefPolicy
 */
export interface TargetSpecForProviderRuleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderRuleRefPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderRuleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderRuleRefPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderRuleRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderRuleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRuleRefPolicy(obj: TargetSpecForProviderRuleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TargetSpecForProviderRuleSelectorPolicy
 */
export interface TargetSpecForProviderRuleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderRuleSelectorPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderRuleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderRuleSelectorPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderRuleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderRuleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRuleSelectorPolicy(obj: TargetSpecForProviderRuleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecProviderConfigRefPolicyResolution
 */
export enum TargetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecProviderConfigRefPolicyResolve
 */
export enum TargetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecProviderRefPolicyResolution
 */
export enum TargetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecProviderRefPolicyResolve
 */
export enum TargetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TargetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToConfigRefPolicy(obj: TargetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicy
 */
export interface TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicy(obj: TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicy
 */
export interface TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicy(obj: TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderEventBusNameRefPolicyResolution
 */
export enum TargetSpecForProviderEventBusNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderEventBusNameRefPolicyResolve
 */
export enum TargetSpecForProviderEventBusNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderEventBusNameSelectorPolicyResolution
 */
export enum TargetSpecForProviderEventBusNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderEventBusNameSelectorPolicyResolve
 */
export enum TargetSpecForProviderEventBusNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderRoleArnRefPolicyResolution
 */
export enum TargetSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderRoleArnRefPolicyResolve
 */
export enum TargetSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum TargetSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum TargetSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderRuleRefPolicyResolution
 */
export enum TargetSpecForProviderRuleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderRuleRefPolicyResolve
 */
export enum TargetSpecForProviderRuleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderRuleSelectorPolicyResolution
 */
export enum TargetSpecForProviderRuleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderRuleSelectorPolicyResolve
 */
export enum TargetSpecForProviderRuleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicyResolution
 */
export enum TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicyResolve
 */
export enum TargetSpecForProviderEcsTargetTaskDefinitionArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicyResolution
 */
export enum TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicyResolve
 */
export enum TargetSpecForProviderEcsTargetTaskDefinitionArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

