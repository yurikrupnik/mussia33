// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Backup is the Schema for the Backups API. A Google Cloud Filestore backup.
 *
 * @schema Backup
 */
export class Backup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Backup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'filestore.gcp.upbound.io/v1beta1',
    kind: 'Backup',
  }

  /**
   * Renders a Kubernetes manifest for "Backup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupProps): any {
    return {
      ...Backup.GVK,
      ...toJson_BackupProps(props),
    };
  }

  /**
   * Defines a "Backup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupProps) {
    super(scope, id, {
      ...Backup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Backup.GVK,
      ...toJson_BackupProps(resolved),
    };
  }
}

/**
 * Backup is the Schema for the Backups API. A Google Cloud Filestore backup.
 *
 * @schema Backup
 */
export interface BackupProps {
  /**
   * @schema Backup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupSpec defines the desired state of Backup
   *
   * @schema Backup#spec
   */
  readonly spec: BackupSpec;

}

/**
 * Converts an object of type 'BackupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupProps(obj: BackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupSpec defines the desired state of Backup
 *
 * @schema BackupSpec
 */
export interface BackupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BackupSpec#deletionPolicy
   */
  readonly deletionPolicy?: BackupSpecDeletionPolicy;

  /**
   * @schema BackupSpec#forProvider
   */
  readonly forProvider: BackupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema BackupSpec#initProvider
   */
  readonly initProvider?: BackupSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BackupSpec#managementPolicies
   */
  readonly managementPolicies?: BackupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BackupSpec#providerConfigRef
   */
  readonly providerConfigRef?: BackupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BackupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BackupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BackupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BackupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BackupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpec(obj: BackupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BackupSpecForProvider(obj.forProvider),
    'initProvider': toJson_BackupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BackupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BackupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BackupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BackupSpecDeletionPolicy
 */
export enum BackupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BackupSpecForProvider
 */
export interface BackupSpecForProvider {
  /**
   * A description of the backup with 2048 characters or less. Requests with longer descriptions will be rejected.
   *
   * @schema BackupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Resource labels to represent user-provided metadata.
   *
   * @schema BackupSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of the location of the instance. This can be a region for ENTERPRISE tier instances.
   *
   * @schema BackupSpecForProvider#location
   */
  readonly location: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema BackupSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Name of the file share in the source Cloud Filestore instance that the backup is created from.
   *
   * @schema BackupSpecForProvider#sourceFileShare
   */
  readonly sourceFileShare?: string;

  /**
   * The resource name of the source Cloud Filestore instance, in the format projects/{projectId}/locations/{locationId}/instances/{instanceId}, used to create this backup.
   *
   * @schema BackupSpecForProvider#sourceInstance
   */
  readonly sourceInstance?: string;

  /**
   * Reference to a Instance in filestore to populate sourceInstance.
   *
   * @schema BackupSpecForProvider#sourceInstanceRef
   */
  readonly sourceInstanceRef?: BackupSpecForProviderSourceInstanceRef;

  /**
   * Selector for a Instance in filestore to populate sourceInstance.
   *
   * @schema BackupSpecForProvider#sourceInstanceSelector
   */
  readonly sourceInstanceSelector?: BackupSpecForProviderSourceInstanceSelector;

}

/**
 * Converts an object of type 'BackupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProvider(obj: BackupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'project': obj.project,
    'sourceFileShare': obj.sourceFileShare,
    'sourceInstance': obj.sourceInstance,
    'sourceInstanceRef': toJson_BackupSpecForProviderSourceInstanceRef(obj.sourceInstanceRef),
    'sourceInstanceSelector': toJson_BackupSpecForProviderSourceInstanceSelector(obj.sourceInstanceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema BackupSpecInitProvider
 */
export interface BackupSpecInitProvider {
  /**
   * A description of the backup with 2048 characters or less. Requests with longer descriptions will be rejected.
   *
   * @schema BackupSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Resource labels to represent user-provided metadata.
   *
   * @schema BackupSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema BackupSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Name of the file share in the source Cloud Filestore instance that the backup is created from.
   *
   * @schema BackupSpecInitProvider#sourceFileShare
   */
  readonly sourceFileShare?: string;

}

/**
 * Converts an object of type 'BackupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecInitProvider(obj: BackupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'sourceFileShare': obj.sourceFileShare,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BackupSpecManagementPolicies
 */
export enum BackupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BackupSpecProviderConfigRef
 */
export interface BackupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupSpecProviderConfigRef#policy
   */
  readonly policy?: BackupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BackupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecProviderConfigRef(obj: BackupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BackupSpecPublishConnectionDetailsTo
 */
export interface BackupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BackupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BackupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BackupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BackupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BackupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsTo(obj: BackupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BackupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BackupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BackupSpecWriteConnectionSecretToRef
 */
export interface BackupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BackupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BackupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BackupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecWriteConnectionSecretToRef(obj: BackupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in filestore to populate sourceInstance.
 *
 * @schema BackupSpecForProviderSourceInstanceRef
 */
export interface BackupSpecForProviderSourceInstanceRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupSpecForProviderSourceInstanceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupSpecForProviderSourceInstanceRef#policy
   */
  readonly policy?: BackupSpecForProviderSourceInstanceRefPolicy;

}

/**
 * Converts an object of type 'BackupSpecForProviderSourceInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderSourceInstanceRef(obj: BackupSpecForProviderSourceInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupSpecForProviderSourceInstanceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in filestore to populate sourceInstance.
 *
 * @schema BackupSpecForProviderSourceInstanceSelector
 */
export interface BackupSpecForProviderSourceInstanceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BackupSpecForProviderSourceInstanceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BackupSpecForProviderSourceInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BackupSpecForProviderSourceInstanceSelector#policy
   */
  readonly policy?: BackupSpecForProviderSourceInstanceSelectorPolicy;

}

/**
 * Converts an object of type 'BackupSpecForProviderSourceInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderSourceInstanceSelector(obj: BackupSpecForProviderSourceInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BackupSpecForProviderSourceInstanceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupSpecProviderConfigRefPolicy
 */
export interface BackupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BackupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BackupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecProviderConfigRefPolicy(obj: BackupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRef
 */
export interface BackupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BackupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsToConfigRef(obj: BackupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BackupSpecPublishConnectionDetailsToMetadata
 */
export interface BackupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BackupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsToMetadata(obj: BackupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupSpecForProviderSourceInstanceRefPolicy
 */
export interface BackupSpecForProviderSourceInstanceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecForProviderSourceInstanceRefPolicy#resolution
   */
  readonly resolution?: BackupSpecForProviderSourceInstanceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecForProviderSourceInstanceRefPolicy#resolve
   */
  readonly resolve?: BackupSpecForProviderSourceInstanceRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecForProviderSourceInstanceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderSourceInstanceRefPolicy(obj: BackupSpecForProviderSourceInstanceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BackupSpecForProviderSourceInstanceSelectorPolicy
 */
export interface BackupSpecForProviderSourceInstanceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecForProviderSourceInstanceSelectorPolicy#resolution
   */
  readonly resolution?: BackupSpecForProviderSourceInstanceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecForProviderSourceInstanceSelectorPolicy#resolve
   */
  readonly resolve?: BackupSpecForProviderSourceInstanceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecForProviderSourceInstanceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderSourceInstanceSelectorPolicy(obj: BackupSpecForProviderSourceInstanceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecProviderConfigRefPolicyResolution
 */
export enum BackupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecProviderConfigRefPolicyResolve
 */
export enum BackupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BackupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BackupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BackupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsToConfigRefPolicy(obj: BackupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecForProviderSourceInstanceRefPolicyResolution
 */
export enum BackupSpecForProviderSourceInstanceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecForProviderSourceInstanceRefPolicyResolve
 */
export enum BackupSpecForProviderSourceInstanceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecForProviderSourceInstanceSelectorPolicyResolution
 */
export enum BackupSpecForProviderSourceInstanceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecForProviderSourceInstanceSelectorPolicyResolve
 */
export enum BackupSpecForProviderSourceInstanceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BackupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BackupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Instance is the Schema for the Instances API. A Google Cloud Filestore instance.
 *
 * @schema Instance
 */
export class Instance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Instance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'filestore.gcp.upbound.io/v1beta1',
    kind: 'Instance',
  }

  /**
   * Renders a Kubernetes manifest for "Instance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProps): any {
    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(props),
    };
  }

  /**
   * Defines a "Instance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProps) {
    super(scope, id, {
      ...Instance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(resolved),
    };
  }
}

/**
 * Instance is the Schema for the Instances API. A Google Cloud Filestore instance.
 *
 * @schema Instance
 */
export interface InstanceProps {
  /**
   * @schema Instance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceSpec defines the desired state of Instance
   *
   * @schema Instance#spec
   */
  readonly spec: InstanceSpec;

}

/**
 * Converts an object of type 'InstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProps(obj: InstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSpec defines the desired state of Instance
 *
 * @schema InstanceSpec
 */
export interface InstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceSpecDeletionPolicy;

  /**
   * @schema InstanceSpec#forProvider
   */
  readonly forProvider: InstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InstanceSpec#initProvider
   */
  readonly initProvider?: InstanceSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InstanceSpec#managementPolicies
   */
  readonly managementPolicies?: InstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpec(obj: InstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_InstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecDeletionPolicy
 */
export enum InstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceSpecForProvider
 */
export interface InstanceSpecForProvider {
  /**
   * A description of the instance.
   *
   * @schema InstanceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * File system shares on the instance. For this version, only a single file share is supported. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#fileShares
   */
  readonly fileShares?: InstanceSpecForProviderFileShares[];

  /**
   * KMS key name used for data encryption.
   *
   * @schema InstanceSpecForProvider#kmsKeyName
   */
  readonly kmsKeyName?: string;

  /**
   * Reference to a CryptoKey in kms to populate kmsKeyName.
   *
   * @schema InstanceSpecForProvider#kmsKeyNameRef
   */
  readonly kmsKeyNameRef?: InstanceSpecForProviderKmsKeyNameRef;

  /**
   * Selector for a CryptoKey in kms to populate kmsKeyName.
   *
   * @schema InstanceSpecForProvider#kmsKeyNameSelector
   */
  readonly kmsKeyNameSelector?: InstanceSpecForProviderKmsKeyNameSelector;

  /**
   * Resource labels to represent user-provided metadata.
   *
   * @schema InstanceSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of the location of the instance. This can be a region for ENTERPRISE tier instances.
   *
   * @schema InstanceSpecForProvider#location
   */
  readonly location?: string;

  /**
   * VPC networks to which the instance is connected. For this version, only a single network is supported. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#networks
   */
  readonly networks?: InstanceSpecForProviderNetworks[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema InstanceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The service tier of the instance. Possible values include: STANDARD, PREMIUM, BASIC_HDD, BASIC_SSD, HIGH_SCALE_SSD and ENTERPRISE
   *
   * @schema InstanceSpecForProvider#tier
   */
  readonly tier?: string;

  /**
   * The name of the Filestore zone of the instance.
   *
   * @schema InstanceSpecForProvider#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProvider(obj: InstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'fileShares': obj.fileShares?.map(y => toJson_InstanceSpecForProviderFileShares(y)),
    'kmsKeyName': obj.kmsKeyName,
    'kmsKeyNameRef': toJson_InstanceSpecForProviderKmsKeyNameRef(obj.kmsKeyNameRef),
    'kmsKeyNameSelector': toJson_InstanceSpecForProviderKmsKeyNameSelector(obj.kmsKeyNameSelector),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'networks': obj.networks?.map(y => toJson_InstanceSpecForProviderNetworks(y)),
    'project': obj.project,
    'tier': obj.tier,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema InstanceSpecInitProvider
 */
export interface InstanceSpecInitProvider {
  /**
   * A description of the instance.
   *
   * @schema InstanceSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * File system shares on the instance. For this version, only a single file share is supported. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#fileShares
   */
  readonly fileShares?: InstanceSpecInitProviderFileShares[];

  /**
   * Resource labels to represent user-provided metadata.
   *
   * @schema InstanceSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * VPC networks to which the instance is connected. For this version, only a single network is supported. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#networks
   */
  readonly networks?: InstanceSpecInitProviderNetworks[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema InstanceSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The service tier of the instance. Possible values include: STANDARD, PREMIUM, BASIC_HDD, BASIC_SSD, HIGH_SCALE_SSD and ENTERPRISE
   *
   * @schema InstanceSpecInitProvider#tier
   */
  readonly tier?: string;

  /**
   * The name of the Filestore zone of the instance.
   *
   * @schema InstanceSpecInitProvider#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'InstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProvider(obj: InstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'fileShares': obj.fileShares?.map(y => toJson_InstanceSpecInitProviderFileShares(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'networks': obj.networks?.map(y => toJson_InstanceSpecInitProviderNetworks(y)),
    'project': obj.project,
    'tier': obj.tier,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InstanceSpecManagementPolicies
 */
export enum InstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceSpecProviderConfigRef
 */
export interface InstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRef(obj: InstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceSpecPublishConnectionDetailsTo
 */
export interface InstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsTo(obj: InstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceSpecWriteConnectionSecretToRef
 */
export interface InstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecWriteConnectionSecretToRef(obj: InstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderFileShares
 */
export interface InstanceSpecForProviderFileShares {
  /**
   * File share capacity in GiB. This must be at least 1024 GiB for the standard tier, or 2560 GiB for the premium tier.
   *
   * @schema InstanceSpecForProviderFileShares#capacityGb
   */
  readonly capacityGb?: number;

  /**
   * The name of the fileshare (16 characters or less)
   *
   * @schema InstanceSpecForProviderFileShares#name
   */
  readonly name?: string;

  /**
   * Nfs Export Options. There is a limit of 10 export options per file share. Structure is documented below.
   *
   * @schema InstanceSpecForProviderFileShares#nfsExportOptions
   */
  readonly nfsExportOptions?: InstanceSpecForProviderFileSharesNfsExportOptions[];

}

/**
 * Converts an object of type 'InstanceSpecForProviderFileShares' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderFileShares(obj: InstanceSpecForProviderFileShares | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityGb': obj.capacityGb,
    'name': obj.name,
    'nfsExportOptions': obj.nfsExportOptions?.map(y => toJson_InstanceSpecForProviderFileSharesNfsExportOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate kmsKeyName.
 *
 * @schema InstanceSpecForProviderKmsKeyNameRef
 */
export interface InstanceSpecForProviderKmsKeyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderKmsKeyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderKmsKeyNameRef#policy
   */
  readonly policy?: InstanceSpecForProviderKmsKeyNameRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderKmsKeyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderKmsKeyNameRef(obj: InstanceSpecForProviderKmsKeyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderKmsKeyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate kmsKeyName.
 *
 * @schema InstanceSpecForProviderKmsKeyNameSelector
 */
export interface InstanceSpecForProviderKmsKeyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderKmsKeyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderKmsKeyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderKmsKeyNameSelector#policy
   */
  readonly policy?: InstanceSpecForProviderKmsKeyNameSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderKmsKeyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderKmsKeyNameSelector(obj: InstanceSpecForProviderKmsKeyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderKmsKeyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderNetworks
 */
export interface InstanceSpecForProviderNetworks {
  /**
   * The network connect mode of the Filestore instance. If not provided, the connect mode defaults to DIRECT_PEERING. Default value is DIRECT_PEERING. Possible values are: DIRECT_PEERING, PRIVATE_SERVICE_ACCESS.
   *
   * @schema InstanceSpecForProviderNetworks#connectMode
   */
  readonly connectMode?: string;

  /**
   * IP versions for which the instance has IP addresses assigned. Each value may be one of: ADDRESS_MODE_UNSPECIFIED, MODE_IPV4, MODE_IPV6.
   *
   * @schema InstanceSpecForProviderNetworks#modes
   */
  readonly modes?: string[];

  /**
   * The name of the GCE VPC network to which the instance is connected.
   *
   * @schema InstanceSpecForProviderNetworks#network
   */
  readonly network?: string;

  /**
   * A /29 CIDR block that identifies the range of IP addresses reserved for this instance.
   *
   * @schema InstanceSpecForProviderNetworks#reservedIpRange
   */
  readonly reservedIpRange?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderNetworks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderNetworks(obj: InstanceSpecForProviderNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectMode': obj.connectMode,
    'modes': obj.modes?.map(y => y),
    'network': obj.network,
    'reservedIpRange': obj.reservedIpRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderFileShares
 */
export interface InstanceSpecInitProviderFileShares {
  /**
   * File share capacity in GiB. This must be at least 1024 GiB for the standard tier, or 2560 GiB for the premium tier.
   *
   * @schema InstanceSpecInitProviderFileShares#capacityGb
   */
  readonly capacityGb?: number;

  /**
   * The name of the fileshare (16 characters or less)
   *
   * @schema InstanceSpecInitProviderFileShares#name
   */
  readonly name?: string;

  /**
   * Nfs Export Options. There is a limit of 10 export options per file share. Structure is documented below.
   *
   * @schema InstanceSpecInitProviderFileShares#nfsExportOptions
   */
  readonly nfsExportOptions?: InstanceSpecInitProviderFileSharesNfsExportOptions[];

}

/**
 * Converts an object of type 'InstanceSpecInitProviderFileShares' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderFileShares(obj: InstanceSpecInitProviderFileShares | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityGb': obj.capacityGb,
    'name': obj.name,
    'nfsExportOptions': obj.nfsExportOptions?.map(y => toJson_InstanceSpecInitProviderFileSharesNfsExportOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderNetworks
 */
export interface InstanceSpecInitProviderNetworks {
  /**
   * The network connect mode of the Filestore instance. If not provided, the connect mode defaults to DIRECT_PEERING. Default value is DIRECT_PEERING. Possible values are: DIRECT_PEERING, PRIVATE_SERVICE_ACCESS.
   *
   * @schema InstanceSpecInitProviderNetworks#connectMode
   */
  readonly connectMode?: string;

  /**
   * IP versions for which the instance has IP addresses assigned. Each value may be one of: ADDRESS_MODE_UNSPECIFIED, MODE_IPV4, MODE_IPV6.
   *
   * @schema InstanceSpecInitProviderNetworks#modes
   */
  readonly modes?: string[];

  /**
   * The name of the GCE VPC network to which the instance is connected.
   *
   * @schema InstanceSpecInitProviderNetworks#network
   */
  readonly network?: string;

  /**
   * A /29 CIDR block that identifies the range of IP addresses reserved for this instance.
   *
   * @schema InstanceSpecInitProviderNetworks#reservedIpRange
   */
  readonly reservedIpRange?: string;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderNetworks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderNetworks(obj: InstanceSpecInitProviderNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectMode': obj.connectMode,
    'modes': obj.modes?.map(y => y),
    'network': obj.network,
    'reservedIpRange': obj.reservedIpRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderConfigRefPolicy
 */
export interface InstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRefPolicy(obj: InstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj: InstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj: InstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderFileSharesNfsExportOptions
 */
export interface InstanceSpecForProviderFileSharesNfsExportOptions {
  /**
   * Either READ_ONLY, for allowing only read requests on the exported directory, or READ_WRITE, for allowing both read and write requests. The default is READ_WRITE. Default value is READ_WRITE. Possible values are: READ_ONLY, READ_WRITE.
   *
   * @schema InstanceSpecForProviderFileSharesNfsExportOptions#accessMode
   */
  readonly accessMode?: string;

  /**
   * An integer representing the anonymous group id with a default value of 65534. Anon_gid may only be set with squashMode of ROOT_SQUASH. An error will be returned if this field is specified for other squashMode settings.
   *
   * @schema InstanceSpecForProviderFileSharesNfsExportOptions#anonGid
   */
  readonly anonGid?: number;

  /**
   * An integer representing the anonymous user id with a default value of 65534. Anon_uid may only be set with squashMode of ROOT_SQUASH. An error will be returned if this field is specified for other squashMode settings.
   *
   * @schema InstanceSpecForProviderFileSharesNfsExportOptions#anonUid
   */
  readonly anonUid?: number;

  /**
   * List of either IPv4 addresses, or ranges in CIDR notation which may mount the file share. Overlapping IP ranges are not allowed, both within and across NfsExportOptions. An error will be returned. The limit is 64 IP ranges/addresses for each FileShareConfig among all NfsExportOptions.
   *
   * @schema InstanceSpecForProviderFileSharesNfsExportOptions#ipRanges
   */
  readonly ipRanges?: string[];

  /**
   * Either NO_ROOT_SQUASH, for allowing root access on the exported directory, or ROOT_SQUASH, for not allowing root access. The default is NO_ROOT_SQUASH. Default value is NO_ROOT_SQUASH. Possible values are: NO_ROOT_SQUASH, ROOT_SQUASH.
   *
   * @schema InstanceSpecForProviderFileSharesNfsExportOptions#squashMode
   */
  readonly squashMode?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderFileSharesNfsExportOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderFileSharesNfsExportOptions(obj: InstanceSpecForProviderFileSharesNfsExportOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessMode': obj.accessMode,
    'anonGid': obj.anonGid,
    'anonUid': obj.anonUid,
    'ipRanges': obj.ipRanges?.map(y => y),
    'squashMode': obj.squashMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderKmsKeyNameRefPolicy
 */
export interface InstanceSpecForProviderKmsKeyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderKmsKeyNameRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderKmsKeyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderKmsKeyNameRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderKmsKeyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderKmsKeyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderKmsKeyNameRefPolicy(obj: InstanceSpecForProviderKmsKeyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderKmsKeyNameSelectorPolicy
 */
export interface InstanceSpecForProviderKmsKeyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderKmsKeyNameSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderKmsKeyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderKmsKeyNameSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderKmsKeyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderKmsKeyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderKmsKeyNameSelectorPolicy(obj: InstanceSpecForProviderKmsKeyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderFileSharesNfsExportOptions
 */
export interface InstanceSpecInitProviderFileSharesNfsExportOptions {
  /**
   * Either READ_ONLY, for allowing only read requests on the exported directory, or READ_WRITE, for allowing both read and write requests. The default is READ_WRITE. Default value is READ_WRITE. Possible values are: READ_ONLY, READ_WRITE.
   *
   * @schema InstanceSpecInitProviderFileSharesNfsExportOptions#accessMode
   */
  readonly accessMode?: string;

  /**
   * An integer representing the anonymous group id with a default value of 65534. Anon_gid may only be set with squashMode of ROOT_SQUASH. An error will be returned if this field is specified for other squashMode settings.
   *
   * @schema InstanceSpecInitProviderFileSharesNfsExportOptions#anonGid
   */
  readonly anonGid?: number;

  /**
   * An integer representing the anonymous user id with a default value of 65534. Anon_uid may only be set with squashMode of ROOT_SQUASH. An error will be returned if this field is specified for other squashMode settings.
   *
   * @schema InstanceSpecInitProviderFileSharesNfsExportOptions#anonUid
   */
  readonly anonUid?: number;

  /**
   * List of either IPv4 addresses, or ranges in CIDR notation which may mount the file share. Overlapping IP ranges are not allowed, both within and across NfsExportOptions. An error will be returned. The limit is 64 IP ranges/addresses for each FileShareConfig among all NfsExportOptions.
   *
   * @schema InstanceSpecInitProviderFileSharesNfsExportOptions#ipRanges
   */
  readonly ipRanges?: string[];

  /**
   * Either NO_ROOT_SQUASH, for allowing root access on the exported directory, or ROOT_SQUASH, for not allowing root access. The default is NO_ROOT_SQUASH. Default value is NO_ROOT_SQUASH. Possible values are: NO_ROOT_SQUASH, ROOT_SQUASH.
   *
   * @schema InstanceSpecInitProviderFileSharesNfsExportOptions#squashMode
   */
  readonly squashMode?: string;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderFileSharesNfsExportOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderFileSharesNfsExportOptions(obj: InstanceSpecInitProviderFileSharesNfsExportOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessMode': obj.accessMode,
    'anonGid': obj.anonGid,
    'anonUid': obj.anonUid,
    'ipRanges': obj.ipRanges?.map(y => y),
    'squashMode': obj.squashMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolution
 */
export enum InstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolve
 */
export enum InstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderKmsKeyNameRefPolicyResolution
 */
export enum InstanceSpecForProviderKmsKeyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderKmsKeyNameRefPolicyResolve
 */
export enum InstanceSpecForProviderKmsKeyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderKmsKeyNameSelectorPolicyResolution
 */
export enum InstanceSpecForProviderKmsKeyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderKmsKeyNameSelectorPolicyResolve
 */
export enum InstanceSpecForProviderKmsKeyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Snapshot is the Schema for the Snapshots API. A Google Cloud Filestore snapshot.
 *
 * @schema Snapshot
 */
export class Snapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Snapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'filestore.gcp.upbound.io/v1beta1',
    kind: 'Snapshot',
  }

  /**
   * Renders a Kubernetes manifest for "Snapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SnapshotProps): any {
    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(props),
    };
  }

  /**
   * Defines a "Snapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SnapshotProps) {
    super(scope, id, {
      ...Snapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(resolved),
    };
  }
}

/**
 * Snapshot is the Schema for the Snapshots API. A Google Cloud Filestore snapshot.
 *
 * @schema Snapshot
 */
export interface SnapshotProps {
  /**
   * @schema Snapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SnapshotSpec defines the desired state of Snapshot
   *
   * @schema Snapshot#spec
   */
  readonly spec: SnapshotSpec;

}

/**
 * Converts an object of type 'SnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotProps(obj: SnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SnapshotSpec defines the desired state of Snapshot
 *
 * @schema SnapshotSpec
 */
export interface SnapshotSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SnapshotSpec#deletionPolicy
   */
  readonly deletionPolicy?: SnapshotSpecDeletionPolicy;

  /**
   * @schema SnapshotSpec#forProvider
   */
  readonly forProvider: SnapshotSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SnapshotSpec#initProvider
   */
  readonly initProvider?: SnapshotSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SnapshotSpec#managementPolicies
   */
  readonly managementPolicies?: SnapshotSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SnapshotSpec#providerConfigRef
   */
  readonly providerConfigRef?: SnapshotSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SnapshotSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SnapshotSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SnapshotSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SnapshotSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpec(obj: SnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SnapshotSpecForProvider(obj.forProvider),
    'initProvider': toJson_SnapshotSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SnapshotSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SnapshotSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SnapshotSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SnapshotSpecDeletionPolicy
 */
export enum SnapshotSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SnapshotSpecForProvider
 */
export interface SnapshotSpecForProvider {
  /**
   * A description of the snapshot with 2048 characters or less. Requests with longer descriptions will be rejected.
   *
   * @schema SnapshotSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The resource name of the filestore instance.
   *
   * @schema SnapshotSpecForProvider#instance
   */
  readonly instance?: string;

  /**
   * Reference to a Instance in filestore to populate instance.
   *
   * @schema SnapshotSpecForProvider#instanceRef
   */
  readonly instanceRef?: SnapshotSpecForProviderInstanceRef;

  /**
   * Selector for a Instance in filestore to populate instance.
   *
   * @schema SnapshotSpecForProvider#instanceSelector
   */
  readonly instanceSelector?: SnapshotSpecForProviderInstanceSelector;

  /**
   * Resource labels to represent user-provided metadata.
   *
   * @schema SnapshotSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of the location of the instance. This can be a region for ENTERPRISE tier instances.
   *
   * @schema SnapshotSpecForProvider#location
   */
  readonly location: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SnapshotSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'SnapshotSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProvider(obj: SnapshotSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instance': obj.instance,
    'instanceRef': toJson_SnapshotSpecForProviderInstanceRef(obj.instanceRef),
    'instanceSelector': toJson_SnapshotSpecForProviderInstanceSelector(obj.instanceSelector),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SnapshotSpecInitProvider
 */
export interface SnapshotSpecInitProvider {
  /**
   * A description of the snapshot with 2048 characters or less. Requests with longer descriptions will be rejected.
   *
   * @schema SnapshotSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Resource labels to represent user-provided metadata.
   *
   * @schema SnapshotSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SnapshotSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'SnapshotSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecInitProvider(obj: SnapshotSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SnapshotSpecManagementPolicies
 */
export enum SnapshotSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SnapshotSpecProviderConfigRef
 */
export interface SnapshotSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotSpecProviderConfigRef#policy
   */
  readonly policy?: SnapshotSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecProviderConfigRef(obj: SnapshotSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SnapshotSpecPublishConnectionDetailsTo
 */
export interface SnapshotSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SnapshotSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SnapshotSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SnapshotSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SnapshotSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SnapshotSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsTo(obj: SnapshotSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SnapshotSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SnapshotSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SnapshotSpecWriteConnectionSecretToRef
 */
export interface SnapshotSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SnapshotSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SnapshotSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SnapshotSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecWriteConnectionSecretToRef(obj: SnapshotSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in filestore to populate instance.
 *
 * @schema SnapshotSpecForProviderInstanceRef
 */
export interface SnapshotSpecForProviderInstanceRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotSpecForProviderInstanceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotSpecForProviderInstanceRef#policy
   */
  readonly policy?: SnapshotSpecForProviderInstanceRefPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderInstanceRef(obj: SnapshotSpecForProviderInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotSpecForProviderInstanceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in filestore to populate instance.
 *
 * @schema SnapshotSpecForProviderInstanceSelector
 */
export interface SnapshotSpecForProviderInstanceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SnapshotSpecForProviderInstanceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SnapshotSpecForProviderInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SnapshotSpecForProviderInstanceSelector#policy
   */
  readonly policy?: SnapshotSpecForProviderInstanceSelectorPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderInstanceSelector(obj: SnapshotSpecForProviderInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SnapshotSpecForProviderInstanceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotSpecProviderConfigRefPolicy
 */
export interface SnapshotSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecProviderConfigRefPolicy(obj: SnapshotSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRef
 */
export interface SnapshotSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SnapshotSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsToConfigRef(obj: SnapshotSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToMetadata
 */
export interface SnapshotSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsToMetadata(obj: SnapshotSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotSpecForProviderInstanceRefPolicy
 */
export interface SnapshotSpecForProviderInstanceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecForProviderInstanceRefPolicy#resolution
   */
  readonly resolution?: SnapshotSpecForProviderInstanceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecForProviderInstanceRefPolicy#resolve
   */
  readonly resolve?: SnapshotSpecForProviderInstanceRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderInstanceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderInstanceRefPolicy(obj: SnapshotSpecForProviderInstanceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SnapshotSpecForProviderInstanceSelectorPolicy
 */
export interface SnapshotSpecForProviderInstanceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecForProviderInstanceSelectorPolicy#resolution
   */
  readonly resolution?: SnapshotSpecForProviderInstanceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecForProviderInstanceSelectorPolicy#resolve
   */
  readonly resolve?: SnapshotSpecForProviderInstanceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderInstanceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderInstanceSelectorPolicy(obj: SnapshotSpecForProviderInstanceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecProviderConfigRefPolicyResolution
 */
export enum SnapshotSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecProviderConfigRefPolicyResolve
 */
export enum SnapshotSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SnapshotSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj: SnapshotSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecForProviderInstanceRefPolicyResolution
 */
export enum SnapshotSpecForProviderInstanceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecForProviderInstanceRefPolicyResolve
 */
export enum SnapshotSpecForProviderInstanceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecForProviderInstanceSelectorPolicyResolution
 */
export enum SnapshotSpecForProviderInstanceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecForProviderInstanceSelectorPolicyResolve
 */
export enum SnapshotSpecForProviderInstanceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

