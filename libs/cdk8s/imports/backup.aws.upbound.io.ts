// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Framework is the Schema for the Frameworks API. Provides an AWS Backup Framework resource.
 *
 * @schema Framework
 */
export class Framework extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Framework"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'backup.aws.upbound.io/v1beta1',
    kind: 'Framework',
  }

  /**
   * Renders a Kubernetes manifest for "Framework".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FrameworkProps): any {
    return {
      ...Framework.GVK,
      ...toJson_FrameworkProps(props),
    };
  }

  /**
   * Defines a "Framework" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FrameworkProps) {
    super(scope, id, {
      ...Framework.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Framework.GVK,
      ...toJson_FrameworkProps(resolved),
    };
  }
}

/**
 * Framework is the Schema for the Frameworks API. Provides an AWS Backup Framework resource.
 *
 * @schema Framework
 */
export interface FrameworkProps {
  /**
   * @schema Framework#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FrameworkSpec defines the desired state of Framework
   *
   * @schema Framework#spec
   */
  readonly spec: FrameworkSpec;

}

/**
 * Converts an object of type 'FrameworkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkProps(obj: FrameworkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FrameworkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FrameworkSpec defines the desired state of Framework
 *
 * @schema FrameworkSpec
 */
export interface FrameworkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FrameworkSpec#deletionPolicy
   */
  readonly deletionPolicy?: FrameworkSpecDeletionPolicy;

  /**
   * @schema FrameworkSpec#forProvider
   */
  readonly forProvider: FrameworkSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema FrameworkSpec#initProvider
   */
  readonly initProvider?: FrameworkSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FrameworkSpec#managementPolicies
   */
  readonly managementPolicies?: FrameworkSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FrameworkSpec#providerConfigRef
   */
  readonly providerConfigRef?: FrameworkSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FrameworkSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FrameworkSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FrameworkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FrameworkSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FrameworkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpec(obj: FrameworkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FrameworkSpecForProvider(obj.forProvider),
    'initProvider': toJson_FrameworkSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FrameworkSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FrameworkSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FrameworkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FrameworkSpecDeletionPolicy
 */
export enum FrameworkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FrameworkSpecForProvider
 */
export interface FrameworkSpecForProvider {
  /**
   * One or more control blocks that make up the framework. Each control in the list has a name, input parameters, and scope. Detailed below.
   *
   * @schema FrameworkSpecForProvider#control
   */
  readonly control?: FrameworkSpecForProviderControl[];

  /**
   * The description of the framework with a maximum of 1,024 characters
   *
   * @schema FrameworkSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters, numbers, and underscores.
   *
   * @schema FrameworkSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FrameworkSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FrameworkSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FrameworkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecForProvider(obj: FrameworkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'control': obj.control?.map(y => toJson_FrameworkSpecForProviderControl(y)),
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema FrameworkSpecInitProvider
 */
export interface FrameworkSpecInitProvider {
  /**
   * One or more control blocks that make up the framework. Each control in the list has a name, input parameters, and scope. Detailed below.
   *
   * @schema FrameworkSpecInitProvider#control
   */
  readonly control?: FrameworkSpecInitProviderControl[];

  /**
   * The description of the framework with a maximum of 1,024 characters
   *
   * @schema FrameworkSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters, numbers, and underscores.
   *
   * @schema FrameworkSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FrameworkSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FrameworkSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecInitProvider(obj: FrameworkSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'control': obj.control?.map(y => toJson_FrameworkSpecInitProviderControl(y)),
    'description': obj.description,
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FrameworkSpecManagementPolicies
 */
export enum FrameworkSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FrameworkSpecProviderConfigRef
 */
export interface FrameworkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FrameworkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FrameworkSpecProviderConfigRef#policy
   */
  readonly policy?: FrameworkSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FrameworkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecProviderConfigRef(obj: FrameworkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FrameworkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FrameworkSpecPublishConnectionDetailsTo
 */
export interface FrameworkSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FrameworkSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FrameworkSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FrameworkSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FrameworkSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FrameworkSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FrameworkSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecPublishConnectionDetailsTo(obj: FrameworkSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FrameworkSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FrameworkSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FrameworkSpecWriteConnectionSecretToRef
 */
export interface FrameworkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FrameworkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FrameworkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FrameworkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecWriteConnectionSecretToRef(obj: FrameworkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FrameworkSpecForProviderControl
 */
export interface FrameworkSpecForProviderControl {
  /**
   * One or more input parameter blocks. An example of a control with two parameters is: "backup plan frequency is at least daily and the retention period is at least 1 year". The first parameter is daily. The second parameter is 1 year. Detailed below.
   *
   * @schema FrameworkSpecForProviderControl#inputParameter
   */
  readonly inputParameter?: FrameworkSpecForProviderControlInputParameter[];

  /**
   * The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters, numbers, and underscores.
   *
   * @schema FrameworkSpecForProviderControl#name
   */
  readonly name?: string;

  /**
   * The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. Detailed below.
   *
   * @schema FrameworkSpecForProviderControl#scope
   */
  readonly scope?: FrameworkSpecForProviderControlScope[];

}

/**
 * Converts an object of type 'FrameworkSpecForProviderControl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecForProviderControl(obj: FrameworkSpecForProviderControl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputParameter': obj.inputParameter?.map(y => toJson_FrameworkSpecForProviderControlInputParameter(y)),
    'name': obj.name,
    'scope': obj.scope?.map(y => toJson_FrameworkSpecForProviderControlScope(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FrameworkSpecInitProviderControl
 */
export interface FrameworkSpecInitProviderControl {
  /**
   * One or more input parameter blocks. An example of a control with two parameters is: "backup plan frequency is at least daily and the retention period is at least 1 year". The first parameter is daily. The second parameter is 1 year. Detailed below.
   *
   * @schema FrameworkSpecInitProviderControl#inputParameter
   */
  readonly inputParameter?: FrameworkSpecInitProviderControlInputParameter[];

  /**
   * The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters, numbers, and underscores.
   *
   * @schema FrameworkSpecInitProviderControl#name
   */
  readonly name?: string;

  /**
   * The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. Detailed below.
   *
   * @schema FrameworkSpecInitProviderControl#scope
   */
  readonly scope?: FrameworkSpecInitProviderControlScope[];

}

/**
 * Converts an object of type 'FrameworkSpecInitProviderControl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecInitProviderControl(obj: FrameworkSpecInitProviderControl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputParameter': obj.inputParameter?.map(y => toJson_FrameworkSpecInitProviderControlInputParameter(y)),
    'name': obj.name,
    'scope': obj.scope?.map(y => toJson_FrameworkSpecInitProviderControlScope(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FrameworkSpecProviderConfigRefPolicy
 */
export interface FrameworkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FrameworkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FrameworkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FrameworkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FrameworkSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FrameworkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecProviderConfigRefPolicy(obj: FrameworkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FrameworkSpecPublishConnectionDetailsToConfigRef
 */
export interface FrameworkSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FrameworkSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FrameworkSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FrameworkSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FrameworkSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecPublishConnectionDetailsToConfigRef(obj: FrameworkSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FrameworkSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FrameworkSpecPublishConnectionDetailsToMetadata
 */
export interface FrameworkSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FrameworkSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FrameworkSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FrameworkSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FrameworkSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecPublishConnectionDetailsToMetadata(obj: FrameworkSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FrameworkSpecForProviderControlInputParameter
 */
export interface FrameworkSpecForProviderControlInputParameter {
  /**
   * The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters, numbers, and underscores.
   *
   * @schema FrameworkSpecForProviderControlInputParameter#name
   */
  readonly name?: string;

  /**
   * The value of parameter, for example, hourly.
   *
   * @schema FrameworkSpecForProviderControlInputParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'FrameworkSpecForProviderControlInputParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecForProviderControlInputParameter(obj: FrameworkSpecForProviderControlInputParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FrameworkSpecForProviderControlScope
 */
export interface FrameworkSpecForProviderControlScope {
  /**
   * The ID of the only AWS resource that you want your control scope to contain. Minimum number of 1 item. Maximum number of 100 items.
   *
   * @schema FrameworkSpecForProviderControlScope#complianceResourceIds
   */
  readonly complianceResourceIds?: string[];

  /**
   * Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
   *
   * @schema FrameworkSpecForProviderControlScope#complianceResourceTypes
   */
  readonly complianceResourceTypes?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema FrameworkSpecForProviderControlScope#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FrameworkSpecForProviderControlScope' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecForProviderControlScope(obj: FrameworkSpecForProviderControlScope | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'complianceResourceIds': obj.complianceResourceIds?.map(y => y),
    'complianceResourceTypes': obj.complianceResourceTypes?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FrameworkSpecInitProviderControlInputParameter
 */
export interface FrameworkSpecInitProviderControlInputParameter {
  /**
   * The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters, numbers, and underscores.
   *
   * @schema FrameworkSpecInitProviderControlInputParameter#name
   */
  readonly name?: string;

  /**
   * The value of parameter, for example, hourly.
   *
   * @schema FrameworkSpecInitProviderControlInputParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'FrameworkSpecInitProviderControlInputParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecInitProviderControlInputParameter(obj: FrameworkSpecInitProviderControlInputParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FrameworkSpecInitProviderControlScope
 */
export interface FrameworkSpecInitProviderControlScope {
  /**
   * The ID of the only AWS resource that you want your control scope to contain. Minimum number of 1 item. Maximum number of 100 items.
   *
   * @schema FrameworkSpecInitProviderControlScope#complianceResourceIds
   */
  readonly complianceResourceIds?: string[];

  /**
   * Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
   *
   * @schema FrameworkSpecInitProviderControlScope#complianceResourceTypes
   */
  readonly complianceResourceTypes?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema FrameworkSpecInitProviderControlScope#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'FrameworkSpecInitProviderControlScope' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecInitProviderControlScope(obj: FrameworkSpecInitProviderControlScope | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'complianceResourceIds': obj.complianceResourceIds?.map(y => y),
    'complianceResourceTypes': obj.complianceResourceTypes?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FrameworkSpecProviderConfigRefPolicyResolution
 */
export enum FrameworkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FrameworkSpecProviderConfigRefPolicyResolve
 */
export enum FrameworkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FrameworkSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FrameworkSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FrameworkSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FrameworkSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FrameworkSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FrameworkSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FrameworkSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FrameworkSpecPublishConnectionDetailsToConfigRefPolicy(obj: FrameworkSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FrameworkSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FrameworkSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FrameworkSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FrameworkSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GlobalSettings is the Schema for the GlobalSettingss API. Provides an AWS Backup Global Settings resource.
 *
 * @schema GlobalSettings
 */
export class GlobalSettings extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GlobalSettings"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'backup.aws.upbound.io/v1beta1',
    kind: 'GlobalSettings',
  }

  /**
   * Renders a Kubernetes manifest for "GlobalSettings".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GlobalSettingsProps): any {
    return {
      ...GlobalSettings.GVK,
      ...toJson_GlobalSettingsProps(props),
    };
  }

  /**
   * Defines a "GlobalSettings" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GlobalSettingsProps) {
    super(scope, id, {
      ...GlobalSettings.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GlobalSettings.GVK,
      ...toJson_GlobalSettingsProps(resolved),
    };
  }
}

/**
 * GlobalSettings is the Schema for the GlobalSettingss API. Provides an AWS Backup Global Settings resource.
 *
 * @schema GlobalSettings
 */
export interface GlobalSettingsProps {
  /**
   * @schema GlobalSettings#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GlobalSettingsSpec defines the desired state of GlobalSettings
   *
   * @schema GlobalSettings#spec
   */
  readonly spec: GlobalSettingsSpec;

}

/**
 * Converts an object of type 'GlobalSettingsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsProps(obj: GlobalSettingsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GlobalSettingsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalSettingsSpec defines the desired state of GlobalSettings
 *
 * @schema GlobalSettingsSpec
 */
export interface GlobalSettingsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GlobalSettingsSpec#deletionPolicy
   */
  readonly deletionPolicy?: GlobalSettingsSpecDeletionPolicy;

  /**
   * @schema GlobalSettingsSpec#forProvider
   */
  readonly forProvider: GlobalSettingsSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema GlobalSettingsSpec#initProvider
   */
  readonly initProvider?: GlobalSettingsSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GlobalSettingsSpec#managementPolicies
   */
  readonly managementPolicies?: GlobalSettingsSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GlobalSettingsSpec#providerConfigRef
   */
  readonly providerConfigRef?: GlobalSettingsSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GlobalSettingsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GlobalSettingsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GlobalSettingsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GlobalSettingsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GlobalSettingsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsSpec(obj: GlobalSettingsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GlobalSettingsSpecForProvider(obj.forProvider),
    'initProvider': toJson_GlobalSettingsSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GlobalSettingsSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GlobalSettingsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GlobalSettingsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GlobalSettingsSpecDeletionPolicy
 */
export enum GlobalSettingsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GlobalSettingsSpecForProvider
 */
export interface GlobalSettingsSpecForProvider {
  /**
   * A list of resources along with the opt-in preferences for the account.
   *
   * @schema GlobalSettingsSpecForProvider#globalSettings
   */
  readonly globalSettings?: { [key: string]: string };

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GlobalSettingsSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'GlobalSettingsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsSpecForProvider(obj: GlobalSettingsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'globalSettings': ((obj.globalSettings) === undefined) ? undefined : (Object.entries(obj.globalSettings).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema GlobalSettingsSpecInitProvider
 */
export interface GlobalSettingsSpecInitProvider {
  /**
   * A list of resources along with the opt-in preferences for the account.
   *
   * @schema GlobalSettingsSpecInitProvider#globalSettings
   */
  readonly globalSettings?: { [key: string]: string };

}

/**
 * Converts an object of type 'GlobalSettingsSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsSpecInitProvider(obj: GlobalSettingsSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'globalSettings': ((obj.globalSettings) === undefined) ? undefined : (Object.entries(obj.globalSettings).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GlobalSettingsSpecManagementPolicies
 */
export enum GlobalSettingsSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GlobalSettingsSpecProviderConfigRef
 */
export interface GlobalSettingsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalSettingsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalSettingsSpecProviderConfigRef#policy
   */
  readonly policy?: GlobalSettingsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalSettingsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsSpecProviderConfigRef(obj: GlobalSettingsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalSettingsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GlobalSettingsSpecPublishConnectionDetailsTo
 */
export interface GlobalSettingsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GlobalSettingsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GlobalSettingsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GlobalSettingsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GlobalSettingsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GlobalSettingsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GlobalSettingsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsSpecPublishConnectionDetailsTo(obj: GlobalSettingsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GlobalSettingsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GlobalSettingsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GlobalSettingsSpecWriteConnectionSecretToRef
 */
export interface GlobalSettingsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GlobalSettingsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GlobalSettingsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GlobalSettingsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsSpecWriteConnectionSecretToRef(obj: GlobalSettingsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalSettingsSpecProviderConfigRefPolicy
 */
export interface GlobalSettingsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalSettingsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalSettingsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalSettingsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalSettingsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalSettingsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsSpecProviderConfigRefPolicy(obj: GlobalSettingsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GlobalSettingsSpecPublishConnectionDetailsToConfigRef
 */
export interface GlobalSettingsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalSettingsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalSettingsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalSettingsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsSpecPublishConnectionDetailsToConfigRef(obj: GlobalSettingsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GlobalSettingsSpecPublishConnectionDetailsToMetadata
 */
export interface GlobalSettingsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalSettingsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalSettingsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GlobalSettingsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GlobalSettingsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsSpecPublishConnectionDetailsToMetadata(obj: GlobalSettingsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalSettingsSpecProviderConfigRefPolicyResolution
 */
export enum GlobalSettingsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalSettingsSpecProviderConfigRefPolicyResolve
 */
export enum GlobalSettingsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj: GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GlobalSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Plan is the Schema for the Plans API. Provides an AWS Backup plan resource.
 *
 * @schema Plan
 */
export class Plan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Plan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'backup.aws.upbound.io/v1beta1',
    kind: 'Plan',
  }

  /**
   * Renders a Kubernetes manifest for "Plan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PlanProps): any {
    return {
      ...Plan.GVK,
      ...toJson_PlanProps(props),
    };
  }

  /**
   * Defines a "Plan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PlanProps) {
    super(scope, id, {
      ...Plan.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Plan.GVK,
      ...toJson_PlanProps(resolved),
    };
  }
}

/**
 * Plan is the Schema for the Plans API. Provides an AWS Backup plan resource.
 *
 * @schema Plan
 */
export interface PlanProps {
  /**
   * @schema Plan#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PlanSpec defines the desired state of Plan
   *
   * @schema Plan#spec
   */
  readonly spec: PlanSpec;

}

/**
 * Converts an object of type 'PlanProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanProps(obj: PlanProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PlanSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PlanSpec defines the desired state of Plan
 *
 * @schema PlanSpec
 */
export interface PlanSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PlanSpec#deletionPolicy
   */
  readonly deletionPolicy?: PlanSpecDeletionPolicy;

  /**
   * @schema PlanSpec#forProvider
   */
  readonly forProvider: PlanSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PlanSpec#initProvider
   */
  readonly initProvider?: PlanSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PlanSpec#managementPolicies
   */
  readonly managementPolicies?: PlanSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PlanSpec#providerConfigRef
   */
  readonly providerConfigRef?: PlanSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PlanSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PlanSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PlanSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PlanSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PlanSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpec(obj: PlanSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PlanSpecForProvider(obj.forProvider),
    'initProvider': toJson_PlanSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PlanSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PlanSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PlanSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PlanSpecDeletionPolicy
 */
export enum PlanSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PlanSpecForProvider
 */
export interface PlanSpecForProvider {
  /**
   * An object that specifies backup options for each resource type.
   *
   * @schema PlanSpecForProvider#advancedBackupSetting
   */
  readonly advancedBackupSetting?: PlanSpecForProviderAdvancedBackupSetting[];

  /**
   * The display name of a backup plan.
   *
   * @schema PlanSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PlanSpecForProvider#region
   */
  readonly region: string;

  /**
   * A rule object that specifies a scheduled task that is used to back up a selection of resources.
   *
   * @schema PlanSpecForProvider#rule
   */
  readonly rule?: PlanSpecForProviderRule[];

  /**
   * Key-value map of resource tags.
   *
   * @schema PlanSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PlanSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecForProvider(obj: PlanSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedBackupSetting': obj.advancedBackupSetting?.map(y => toJson_PlanSpecForProviderAdvancedBackupSetting(y)),
    'name': obj.name,
    'region': obj.region,
    'rule': obj.rule?.map(y => toJson_PlanSpecForProviderRule(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PlanSpecInitProvider
 */
export interface PlanSpecInitProvider {
  /**
   * An object that specifies backup options for each resource type.
   *
   * @schema PlanSpecInitProvider#advancedBackupSetting
   */
  readonly advancedBackupSetting?: PlanSpecInitProviderAdvancedBackupSetting[];

  /**
   * The display name of a backup plan.
   *
   * @schema PlanSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * A rule object that specifies a scheduled task that is used to back up a selection of resources.
   *
   * @schema PlanSpecInitProvider#rule
   */
  readonly rule?: PlanSpecInitProviderRule[];

  /**
   * Key-value map of resource tags.
   *
   * @schema PlanSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PlanSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecInitProvider(obj: PlanSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedBackupSetting': obj.advancedBackupSetting?.map(y => toJson_PlanSpecInitProviderAdvancedBackupSetting(y)),
    'name': obj.name,
    'rule': obj.rule?.map(y => toJson_PlanSpecInitProviderRule(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PlanSpecManagementPolicies
 */
export enum PlanSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PlanSpecProviderConfigRef
 */
export interface PlanSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlanSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlanSpecProviderConfigRef#policy
   */
  readonly policy?: PlanSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PlanSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecProviderConfigRef(obj: PlanSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlanSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PlanSpecPublishConnectionDetailsTo
 */
export interface PlanSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PlanSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PlanSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PlanSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PlanSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PlanSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PlanSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecPublishConnectionDetailsTo(obj: PlanSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PlanSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PlanSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PlanSpecWriteConnectionSecretToRef
 */
export interface PlanSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PlanSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PlanSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PlanSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecWriteConnectionSecretToRef(obj: PlanSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlanSpecForProviderAdvancedBackupSetting
 */
export interface PlanSpecForProviderAdvancedBackupSetting {
  /**
   * Specifies the backup option for a selected resource. This option is only available for Windows VSS backup jobs. Set to { WindowsVSS = "enabled" } to enable Windows VSS backup option and create a VSS Windows backup.
   *
   * @schema PlanSpecForProviderAdvancedBackupSetting#backupOptions
   */
  readonly backupOptions?: { [key: string]: string };

  /**
   * The type of AWS resource to be backed up. For VSS Windows backups, the only supported resource type is Amazon EC2. Valid values: EC2.
   *
   * @schema PlanSpecForProviderAdvancedBackupSetting#resourceType
   */
  readonly resourceType?: string;

}

/**
 * Converts an object of type 'PlanSpecForProviderAdvancedBackupSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecForProviderAdvancedBackupSetting(obj: PlanSpecForProviderAdvancedBackupSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupOptions': ((obj.backupOptions) === undefined) ? undefined : (Object.entries(obj.backupOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceType': obj.resourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlanSpecForProviderRule
 */
export interface PlanSpecForProviderRule {
  /**
   * The amount of time in minutes AWS Backup attempts a backup before canceling the job and returning an error.
   *
   * @schema PlanSpecForProviderRule#completionWindow
   */
  readonly completionWindow?: number;

  /**
   * Configuration block(s) with copy operation settings. Detailed below.
   *
   * @schema PlanSpecForProviderRule#copyAction
   */
  readonly copyAction?: PlanSpecForProviderRuleCopyAction[];

  /**
   * Enable continuous backups for supported resources.
   *
   * @schema PlanSpecForProviderRule#enableContinuousBackup
   */
  readonly enableContinuousBackup?: boolean;

  /**
   * The lifecycle defines when a protected resource is transitioned to cold storage and when it expires.  Fields documented below.
   *
   * @schema PlanSpecForProviderRule#lifecycle
   */
  readonly lifecycle?: PlanSpecForProviderRuleLifecycle[];

  /**
   * Metadata that you can assign to help organize the resources that you create.
   *
   * @schema PlanSpecForProviderRule#recoveryPointTags
   */
  readonly recoveryPointTags?: { [key: string]: string };

  /**
   * An display name for a backup rule.
   *
   * @schema PlanSpecForProviderRule#ruleName
   */
  readonly ruleName?: string;

  /**
   * A CRON expression specifying when AWS Backup initiates a backup job.
   *
   * @schema PlanSpecForProviderRule#schedule
   */
  readonly schedule?: string;

  /**
   * The amount of time in minutes before beginning a backup.
   *
   * @schema PlanSpecForProviderRule#startWindow
   */
  readonly startWindow?: number;

  /**
   * The name of a logical container where backups are stored.
   *
   * @schema PlanSpecForProviderRule#targetVaultName
   */
  readonly targetVaultName?: string;

  /**
   * Reference to a Vault in backup to populate targetVaultName.
   *
   * @schema PlanSpecForProviderRule#targetVaultNameRef
   */
  readonly targetVaultNameRef?: PlanSpecForProviderRuleTargetVaultNameRef;

  /**
   * Selector for a Vault in backup to populate targetVaultName.
   *
   * @schema PlanSpecForProviderRule#targetVaultNameSelector
   */
  readonly targetVaultNameSelector?: PlanSpecForProviderRuleTargetVaultNameSelector;

}

/**
 * Converts an object of type 'PlanSpecForProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecForProviderRule(obj: PlanSpecForProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'completionWindow': obj.completionWindow,
    'copyAction': obj.copyAction?.map(y => toJson_PlanSpecForProviderRuleCopyAction(y)),
    'enableContinuousBackup': obj.enableContinuousBackup,
    'lifecycle': obj.lifecycle?.map(y => toJson_PlanSpecForProviderRuleLifecycle(y)),
    'recoveryPointTags': ((obj.recoveryPointTags) === undefined) ? undefined : (Object.entries(obj.recoveryPointTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ruleName': obj.ruleName,
    'schedule': obj.schedule,
    'startWindow': obj.startWindow,
    'targetVaultName': obj.targetVaultName,
    'targetVaultNameRef': toJson_PlanSpecForProviderRuleTargetVaultNameRef(obj.targetVaultNameRef),
    'targetVaultNameSelector': toJson_PlanSpecForProviderRuleTargetVaultNameSelector(obj.targetVaultNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlanSpecInitProviderAdvancedBackupSetting
 */
export interface PlanSpecInitProviderAdvancedBackupSetting {
  /**
   * Specifies the backup option for a selected resource. This option is only available for Windows VSS backup jobs. Set to { WindowsVSS = "enabled" } to enable Windows VSS backup option and create a VSS Windows backup.
   *
   * @schema PlanSpecInitProviderAdvancedBackupSetting#backupOptions
   */
  readonly backupOptions?: { [key: string]: string };

  /**
   * The type of AWS resource to be backed up. For VSS Windows backups, the only supported resource type is Amazon EC2. Valid values: EC2.
   *
   * @schema PlanSpecInitProviderAdvancedBackupSetting#resourceType
   */
  readonly resourceType?: string;

}

/**
 * Converts an object of type 'PlanSpecInitProviderAdvancedBackupSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecInitProviderAdvancedBackupSetting(obj: PlanSpecInitProviderAdvancedBackupSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupOptions': ((obj.backupOptions) === undefined) ? undefined : (Object.entries(obj.backupOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceType': obj.resourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlanSpecInitProviderRule
 */
export interface PlanSpecInitProviderRule {
  /**
   * The amount of time in minutes AWS Backup attempts a backup before canceling the job and returning an error.
   *
   * @schema PlanSpecInitProviderRule#completionWindow
   */
  readonly completionWindow?: number;

  /**
   * Configuration block(s) with copy operation settings. Detailed below.
   *
   * @schema PlanSpecInitProviderRule#copyAction
   */
  readonly copyAction?: PlanSpecInitProviderRuleCopyAction[];

  /**
   * Enable continuous backups for supported resources.
   *
   * @schema PlanSpecInitProviderRule#enableContinuousBackup
   */
  readonly enableContinuousBackup?: boolean;

  /**
   * The lifecycle defines when a protected resource is transitioned to cold storage and when it expires.  Fields documented below.
   *
   * @schema PlanSpecInitProviderRule#lifecycle
   */
  readonly lifecycle?: PlanSpecInitProviderRuleLifecycle[];

  /**
   * Metadata that you can assign to help organize the resources that you create.
   *
   * @schema PlanSpecInitProviderRule#recoveryPointTags
   */
  readonly recoveryPointTags?: { [key: string]: string };

  /**
   * An display name for a backup rule.
   *
   * @schema PlanSpecInitProviderRule#ruleName
   */
  readonly ruleName?: string;

  /**
   * A CRON expression specifying when AWS Backup initiates a backup job.
   *
   * @schema PlanSpecInitProviderRule#schedule
   */
  readonly schedule?: string;

  /**
   * The amount of time in minutes before beginning a backup.
   *
   * @schema PlanSpecInitProviderRule#startWindow
   */
  readonly startWindow?: number;

}

/**
 * Converts an object of type 'PlanSpecInitProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecInitProviderRule(obj: PlanSpecInitProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'completionWindow': obj.completionWindow,
    'copyAction': obj.copyAction?.map(y => toJson_PlanSpecInitProviderRuleCopyAction(y)),
    'enableContinuousBackup': obj.enableContinuousBackup,
    'lifecycle': obj.lifecycle?.map(y => toJson_PlanSpecInitProviderRuleLifecycle(y)),
    'recoveryPointTags': ((obj.recoveryPointTags) === undefined) ? undefined : (Object.entries(obj.recoveryPointTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ruleName': obj.ruleName,
    'schedule': obj.schedule,
    'startWindow': obj.startWindow,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PlanSpecProviderConfigRefPolicy
 */
export interface PlanSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlanSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PlanSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlanSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PlanSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PlanSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecProviderConfigRefPolicy(obj: PlanSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PlanSpecPublishConnectionDetailsToConfigRef
 */
export interface PlanSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlanSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlanSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PlanSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PlanSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecPublishConnectionDetailsToConfigRef(obj: PlanSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlanSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PlanSpecPublishConnectionDetailsToMetadata
 */
export interface PlanSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PlanSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PlanSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PlanSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PlanSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecPublishConnectionDetailsToMetadata(obj: PlanSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlanSpecForProviderRuleCopyAction
 */
export interface PlanSpecForProviderRuleCopyAction {
  /**
   * An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup.
   *
   * @schema PlanSpecForProviderRuleCopyAction#destinationVaultArn
   */
  readonly destinationVaultArn?: string;

  /**
   * The lifecycle defines when a protected resource is transitioned to cold storage and when it expires.  Fields documented below.
   *
   * @schema PlanSpecForProviderRuleCopyAction#lifecycle
   */
  readonly lifecycle?: PlanSpecForProviderRuleCopyActionLifecycle[];

}

/**
 * Converts an object of type 'PlanSpecForProviderRuleCopyAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecForProviderRuleCopyAction(obj: PlanSpecForProviderRuleCopyAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationVaultArn': obj.destinationVaultArn,
    'lifecycle': obj.lifecycle?.map(y => toJson_PlanSpecForProviderRuleCopyActionLifecycle(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlanSpecForProviderRuleLifecycle
 */
export interface PlanSpecForProviderRuleLifecycle {
  /**
   * Specifies the number of days after creation that a recovery point is moved to cold storage.
   *
   * @schema PlanSpecForProviderRuleLifecycle#coldStorageAfter
   */
  readonly coldStorageAfter?: number;

  /**
   * Specifies the number of days after creation that a recovery point is deleted. Must be 90 days greater than cold_storage_after.
   *
   * @schema PlanSpecForProviderRuleLifecycle#deleteAfter
   */
  readonly deleteAfter?: number;

}

/**
 * Converts an object of type 'PlanSpecForProviderRuleLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecForProviderRuleLifecycle(obj: PlanSpecForProviderRuleLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coldStorageAfter': obj.coldStorageAfter,
    'deleteAfter': obj.deleteAfter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Vault in backup to populate targetVaultName.
 *
 * @schema PlanSpecForProviderRuleTargetVaultNameRef
 */
export interface PlanSpecForProviderRuleTargetVaultNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlanSpecForProviderRuleTargetVaultNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlanSpecForProviderRuleTargetVaultNameRef#policy
   */
  readonly policy?: PlanSpecForProviderRuleTargetVaultNameRefPolicy;

}

/**
 * Converts an object of type 'PlanSpecForProviderRuleTargetVaultNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecForProviderRuleTargetVaultNameRef(obj: PlanSpecForProviderRuleTargetVaultNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlanSpecForProviderRuleTargetVaultNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Vault in backup to populate targetVaultName.
 *
 * @schema PlanSpecForProviderRuleTargetVaultNameSelector
 */
export interface PlanSpecForProviderRuleTargetVaultNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PlanSpecForProviderRuleTargetVaultNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PlanSpecForProviderRuleTargetVaultNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PlanSpecForProviderRuleTargetVaultNameSelector#policy
   */
  readonly policy?: PlanSpecForProviderRuleTargetVaultNameSelectorPolicy;

}

/**
 * Converts an object of type 'PlanSpecForProviderRuleTargetVaultNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecForProviderRuleTargetVaultNameSelector(obj: PlanSpecForProviderRuleTargetVaultNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PlanSpecForProviderRuleTargetVaultNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlanSpecInitProviderRuleCopyAction
 */
export interface PlanSpecInitProviderRuleCopyAction {
  /**
   * An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup.
   *
   * @schema PlanSpecInitProviderRuleCopyAction#destinationVaultArn
   */
  readonly destinationVaultArn?: string;

  /**
   * The lifecycle defines when a protected resource is transitioned to cold storage and when it expires.  Fields documented below.
   *
   * @schema PlanSpecInitProviderRuleCopyAction#lifecycle
   */
  readonly lifecycle?: PlanSpecInitProviderRuleCopyActionLifecycle[];

}

/**
 * Converts an object of type 'PlanSpecInitProviderRuleCopyAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecInitProviderRuleCopyAction(obj: PlanSpecInitProviderRuleCopyAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationVaultArn': obj.destinationVaultArn,
    'lifecycle': obj.lifecycle?.map(y => toJson_PlanSpecInitProviderRuleCopyActionLifecycle(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlanSpecInitProviderRuleLifecycle
 */
export interface PlanSpecInitProviderRuleLifecycle {
  /**
   * Specifies the number of days after creation that a recovery point is moved to cold storage.
   *
   * @schema PlanSpecInitProviderRuleLifecycle#coldStorageAfter
   */
  readonly coldStorageAfter?: number;

  /**
   * Specifies the number of days after creation that a recovery point is deleted. Must be 90 days greater than cold_storage_after.
   *
   * @schema PlanSpecInitProviderRuleLifecycle#deleteAfter
   */
  readonly deleteAfter?: number;

}

/**
 * Converts an object of type 'PlanSpecInitProviderRuleLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecInitProviderRuleLifecycle(obj: PlanSpecInitProviderRuleLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coldStorageAfter': obj.coldStorageAfter,
    'deleteAfter': obj.deleteAfter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlanSpecProviderConfigRefPolicyResolution
 */
export enum PlanSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlanSpecProviderConfigRefPolicyResolve
 */
export enum PlanSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PlanSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PlanSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlanSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PlanSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlanSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PlanSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PlanSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecPublishConnectionDetailsToConfigRefPolicy(obj: PlanSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlanSpecForProviderRuleCopyActionLifecycle
 */
export interface PlanSpecForProviderRuleCopyActionLifecycle {
  /**
   * Specifies the number of days after creation that a recovery point is moved to cold storage.
   *
   * @schema PlanSpecForProviderRuleCopyActionLifecycle#coldStorageAfter
   */
  readonly coldStorageAfter?: number;

  /**
   * Specifies the number of days after creation that a recovery point is deleted. Must be 90 days greater than cold_storage_after.
   *
   * @schema PlanSpecForProviderRuleCopyActionLifecycle#deleteAfter
   */
  readonly deleteAfter?: number;

}

/**
 * Converts an object of type 'PlanSpecForProviderRuleCopyActionLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecForProviderRuleCopyActionLifecycle(obj: PlanSpecForProviderRuleCopyActionLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coldStorageAfter': obj.coldStorageAfter,
    'deleteAfter': obj.deleteAfter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PlanSpecForProviderRuleTargetVaultNameRefPolicy
 */
export interface PlanSpecForProviderRuleTargetVaultNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlanSpecForProviderRuleTargetVaultNameRefPolicy#resolution
   */
  readonly resolution?: PlanSpecForProviderRuleTargetVaultNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlanSpecForProviderRuleTargetVaultNameRefPolicy#resolve
   */
  readonly resolve?: PlanSpecForProviderRuleTargetVaultNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PlanSpecForProviderRuleTargetVaultNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecForProviderRuleTargetVaultNameRefPolicy(obj: PlanSpecForProviderRuleTargetVaultNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PlanSpecForProviderRuleTargetVaultNameSelectorPolicy
 */
export interface PlanSpecForProviderRuleTargetVaultNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlanSpecForProviderRuleTargetVaultNameSelectorPolicy#resolution
   */
  readonly resolution?: PlanSpecForProviderRuleTargetVaultNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlanSpecForProviderRuleTargetVaultNameSelectorPolicy#resolve
   */
  readonly resolve?: PlanSpecForProviderRuleTargetVaultNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PlanSpecForProviderRuleTargetVaultNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecForProviderRuleTargetVaultNameSelectorPolicy(obj: PlanSpecForProviderRuleTargetVaultNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PlanSpecInitProviderRuleCopyActionLifecycle
 */
export interface PlanSpecInitProviderRuleCopyActionLifecycle {
  /**
   * Specifies the number of days after creation that a recovery point is moved to cold storage.
   *
   * @schema PlanSpecInitProviderRuleCopyActionLifecycle#coldStorageAfter
   */
  readonly coldStorageAfter?: number;

  /**
   * Specifies the number of days after creation that a recovery point is deleted. Must be 90 days greater than cold_storage_after.
   *
   * @schema PlanSpecInitProviderRuleCopyActionLifecycle#deleteAfter
   */
  readonly deleteAfter?: number;

}

/**
 * Converts an object of type 'PlanSpecInitProviderRuleCopyActionLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlanSpecInitProviderRuleCopyActionLifecycle(obj: PlanSpecInitProviderRuleCopyActionLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coldStorageAfter': obj.coldStorageAfter,
    'deleteAfter': obj.deleteAfter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlanSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PlanSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlanSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PlanSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlanSpecForProviderRuleTargetVaultNameRefPolicyResolution
 */
export enum PlanSpecForProviderRuleTargetVaultNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlanSpecForProviderRuleTargetVaultNameRefPolicyResolve
 */
export enum PlanSpecForProviderRuleTargetVaultNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlanSpecForProviderRuleTargetVaultNameSelectorPolicyResolution
 */
export enum PlanSpecForProviderRuleTargetVaultNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlanSpecForProviderRuleTargetVaultNameSelectorPolicyResolve
 */
export enum PlanSpecForProviderRuleTargetVaultNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RegionSettings is the Schema for the RegionSettingss API. Provides an AWS Backup Region Settings resource.
 *
 * @schema RegionSettings
 */
export class RegionSettings extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RegionSettings"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'backup.aws.upbound.io/v1beta1',
    kind: 'RegionSettings',
  }

  /**
   * Renders a Kubernetes manifest for "RegionSettings".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RegionSettingsProps): any {
    return {
      ...RegionSettings.GVK,
      ...toJson_RegionSettingsProps(props),
    };
  }

  /**
   * Defines a "RegionSettings" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RegionSettingsProps) {
    super(scope, id, {
      ...RegionSettings.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RegionSettings.GVK,
      ...toJson_RegionSettingsProps(resolved),
    };
  }
}

/**
 * RegionSettings is the Schema for the RegionSettingss API. Provides an AWS Backup Region Settings resource.
 *
 * @schema RegionSettings
 */
export interface RegionSettingsProps {
  /**
   * @schema RegionSettings#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RegionSettingsSpec defines the desired state of RegionSettings
   *
   * @schema RegionSettings#spec
   */
  readonly spec: RegionSettingsSpec;

}

/**
 * Converts an object of type 'RegionSettingsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsProps(obj: RegionSettingsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RegionSettingsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RegionSettingsSpec defines the desired state of RegionSettings
 *
 * @schema RegionSettingsSpec
 */
export interface RegionSettingsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RegionSettingsSpec#deletionPolicy
   */
  readonly deletionPolicy?: RegionSettingsSpecDeletionPolicy;

  /**
   * @schema RegionSettingsSpec#forProvider
   */
  readonly forProvider: RegionSettingsSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RegionSettingsSpec#initProvider
   */
  readonly initProvider?: RegionSettingsSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RegionSettingsSpec#managementPolicies
   */
  readonly managementPolicies?: RegionSettingsSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RegionSettingsSpec#providerConfigRef
   */
  readonly providerConfigRef?: RegionSettingsSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RegionSettingsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RegionSettingsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RegionSettingsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RegionSettingsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RegionSettingsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsSpec(obj: RegionSettingsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RegionSettingsSpecForProvider(obj.forProvider),
    'initProvider': toJson_RegionSettingsSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RegionSettingsSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RegionSettingsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RegionSettingsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RegionSettingsSpecDeletionPolicy
 */
export enum RegionSettingsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RegionSettingsSpecForProvider
 */
export interface RegionSettingsSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RegionSettingsSpecForProvider#region
   */
  readonly region: string;

  /**
   * A map of services along with the management preferences for the Region.
   * WARNING: All parameters are required to be given: EFS, DynamoDB
   *
   * @schema RegionSettingsSpecForProvider#resourceTypeManagementPreference
   */
  readonly resourceTypeManagementPreference?: { [key: string]: boolean };

  /**
   * A map of services along with the opt-in preferences for the Region.
   * WARNING: All parameters are required to be given: EFS, DynamoDB, EBS, EC2, FSx, S3, Aurora, RDS, Storage Gateway, VirtualMachine
   *
   * @schema RegionSettingsSpecForProvider#resourceTypeOptInPreference
   */
  readonly resourceTypeOptInPreference?: { [key: string]: boolean };

}

/**
 * Converts an object of type 'RegionSettingsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsSpecForProvider(obj: RegionSettingsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'resourceTypeManagementPreference': ((obj.resourceTypeManagementPreference) === undefined) ? undefined : (Object.entries(obj.resourceTypeManagementPreference).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceTypeOptInPreference': ((obj.resourceTypeOptInPreference) === undefined) ? undefined : (Object.entries(obj.resourceTypeOptInPreference).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RegionSettingsSpecInitProvider
 */
export interface RegionSettingsSpecInitProvider {
  /**
   * A map of services along with the management preferences for the Region.
   * WARNING: All parameters are required to be given: EFS, DynamoDB
   *
   * @schema RegionSettingsSpecInitProvider#resourceTypeManagementPreference
   */
  readonly resourceTypeManagementPreference?: { [key: string]: boolean };

  /**
   * A map of services along with the opt-in preferences for the Region.
   * WARNING: All parameters are required to be given: EFS, DynamoDB, EBS, EC2, FSx, S3, Aurora, RDS, Storage Gateway, VirtualMachine
   *
   * @schema RegionSettingsSpecInitProvider#resourceTypeOptInPreference
   */
  readonly resourceTypeOptInPreference?: { [key: string]: boolean };

}

/**
 * Converts an object of type 'RegionSettingsSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsSpecInitProvider(obj: RegionSettingsSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceTypeManagementPreference': ((obj.resourceTypeManagementPreference) === undefined) ? undefined : (Object.entries(obj.resourceTypeManagementPreference).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceTypeOptInPreference': ((obj.resourceTypeOptInPreference) === undefined) ? undefined : (Object.entries(obj.resourceTypeOptInPreference).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RegionSettingsSpecManagementPolicies
 */
export enum RegionSettingsSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RegionSettingsSpecProviderConfigRef
 */
export interface RegionSettingsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegionSettingsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegionSettingsSpecProviderConfigRef#policy
   */
  readonly policy?: RegionSettingsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RegionSettingsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsSpecProviderConfigRef(obj: RegionSettingsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegionSettingsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RegionSettingsSpecPublishConnectionDetailsTo
 */
export interface RegionSettingsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RegionSettingsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RegionSettingsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RegionSettingsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RegionSettingsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RegionSettingsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RegionSettingsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsSpecPublishConnectionDetailsTo(obj: RegionSettingsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RegionSettingsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RegionSettingsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RegionSettingsSpecWriteConnectionSecretToRef
 */
export interface RegionSettingsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RegionSettingsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RegionSettingsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RegionSettingsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsSpecWriteConnectionSecretToRef(obj: RegionSettingsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegionSettingsSpecProviderConfigRefPolicy
 */
export interface RegionSettingsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegionSettingsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RegionSettingsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegionSettingsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RegionSettingsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegionSettingsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsSpecProviderConfigRefPolicy(obj: RegionSettingsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RegionSettingsSpecPublishConnectionDetailsToConfigRef
 */
export interface RegionSettingsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegionSettingsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegionSettingsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RegionSettingsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsSpecPublishConnectionDetailsToConfigRef(obj: RegionSettingsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RegionSettingsSpecPublishConnectionDetailsToMetadata
 */
export interface RegionSettingsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegionSettingsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegionSettingsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RegionSettingsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RegionSettingsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsSpecPublishConnectionDetailsToMetadata(obj: RegionSettingsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegionSettingsSpecProviderConfigRefPolicyResolution
 */
export enum RegionSettingsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegionSettingsSpecProviderConfigRefPolicyResolve
 */
export enum RegionSettingsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj: RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RegionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReportPlan is the Schema for the ReportPlans API. Provides an AWS Backup Report Plan resource.
 *
 * @schema ReportPlan
 */
export class ReportPlan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReportPlan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'backup.aws.upbound.io/v1beta1',
    kind: 'ReportPlan',
  }

  /**
   * Renders a Kubernetes manifest for "ReportPlan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReportPlanProps): any {
    return {
      ...ReportPlan.GVK,
      ...toJson_ReportPlanProps(props),
    };
  }

  /**
   * Defines a "ReportPlan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReportPlanProps) {
    super(scope, id, {
      ...ReportPlan.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReportPlan.GVK,
      ...toJson_ReportPlanProps(resolved),
    };
  }
}

/**
 * ReportPlan is the Schema for the ReportPlans API. Provides an AWS Backup Report Plan resource.
 *
 * @schema ReportPlan
 */
export interface ReportPlanProps {
  /**
   * @schema ReportPlan#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReportPlanSpec defines the desired state of ReportPlan
   *
   * @schema ReportPlan#spec
   */
  readonly spec: ReportPlanSpec;

}

/**
 * Converts an object of type 'ReportPlanProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanProps(obj: ReportPlanProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReportPlanSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReportPlanSpec defines the desired state of ReportPlan
 *
 * @schema ReportPlanSpec
 */
export interface ReportPlanSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReportPlanSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReportPlanSpecDeletionPolicy;

  /**
   * @schema ReportPlanSpec#forProvider
   */
  readonly forProvider: ReportPlanSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ReportPlanSpec#initProvider
   */
  readonly initProvider?: ReportPlanSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ReportPlanSpec#managementPolicies
   */
  readonly managementPolicies?: ReportPlanSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReportPlanSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReportPlanSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReportPlanSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReportPlanSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReportPlanSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReportPlanSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReportPlanSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpec(obj: ReportPlanSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReportPlanSpecForProvider(obj.forProvider),
    'initProvider': toJson_ReportPlanSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ReportPlanSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ReportPlanSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReportPlanSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReportPlanSpecDeletionPolicy
 */
export enum ReportPlanSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReportPlanSpecForProvider
 */
export interface ReportPlanSpecForProvider {
  /**
   * The description of the report plan with a maximum of 1,024 characters
   *
   * @schema ReportPlanSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The unique name of the report plan. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters, numbers, and underscores.
   *
   * @schema ReportPlanSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ReportPlanSpecForProvider#region
   */
  readonly region: string;

  /**
   * An object that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports. Detailed below.
   *
   * @schema ReportPlanSpecForProvider#reportDeliveryChannel
   */
  readonly reportDeliveryChannel?: ReportPlanSpecForProviderReportDeliveryChannel[];

  /**
   * An object that identifies the report template for the report. Reports are built using a report template. Detailed below.
   *
   * @schema ReportPlanSpecForProvider#reportSetting
   */
  readonly reportSetting?: ReportPlanSpecForProviderReportSetting[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ReportPlanSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ReportPlanSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecForProvider(obj: ReportPlanSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'reportDeliveryChannel': obj.reportDeliveryChannel?.map(y => toJson_ReportPlanSpecForProviderReportDeliveryChannel(y)),
    'reportSetting': obj.reportSetting?.map(y => toJson_ReportPlanSpecForProviderReportSetting(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ReportPlanSpecInitProvider
 */
export interface ReportPlanSpecInitProvider {
  /**
   * The description of the report plan with a maximum of 1,024 characters
   *
   * @schema ReportPlanSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The unique name of the report plan. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters, numbers, and underscores.
   *
   * @schema ReportPlanSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * An object that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports. Detailed below.
   *
   * @schema ReportPlanSpecInitProvider#reportDeliveryChannel
   */
  readonly reportDeliveryChannel?: ReportPlanSpecInitProviderReportDeliveryChannel[];

  /**
   * An object that identifies the report template for the report. Reports are built using a report template. Detailed below.
   *
   * @schema ReportPlanSpecInitProvider#reportSetting
   */
  readonly reportSetting?: ReportPlanSpecInitProviderReportSetting[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ReportPlanSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ReportPlanSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecInitProvider(obj: ReportPlanSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'reportDeliveryChannel': obj.reportDeliveryChannel?.map(y => toJson_ReportPlanSpecInitProviderReportDeliveryChannel(y)),
    'reportSetting': obj.reportSetting?.map(y => toJson_ReportPlanSpecInitProviderReportSetting(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ReportPlanSpecManagementPolicies
 */
export enum ReportPlanSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReportPlanSpecProviderConfigRef
 */
export interface ReportPlanSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReportPlanSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReportPlanSpecProviderConfigRef#policy
   */
  readonly policy?: ReportPlanSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReportPlanSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecProviderConfigRef(obj: ReportPlanSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReportPlanSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReportPlanSpecPublishConnectionDetailsTo
 */
export interface ReportPlanSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReportPlanSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReportPlanSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReportPlanSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReportPlanSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReportPlanSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReportPlanSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecPublishConnectionDetailsTo(obj: ReportPlanSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReportPlanSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReportPlanSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReportPlanSpecWriteConnectionSecretToRef
 */
export interface ReportPlanSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReportPlanSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReportPlanSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReportPlanSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecWriteConnectionSecretToRef(obj: ReportPlanSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReportPlanSpecForProviderReportDeliveryChannel
 */
export interface ReportPlanSpecForProviderReportDeliveryChannel {
  /**
   * A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
   *
   * @schema ReportPlanSpecForProviderReportDeliveryChannel#formats
   */
  readonly formats?: string[];

  /**
   * The unique name of the S3 bucket that receives your reports.
   *
   * @schema ReportPlanSpecForProviderReportDeliveryChannel#s3BucketName
   */
  readonly s3BucketName?: string;

  /**
   * The prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
   *
   * @schema ReportPlanSpecForProviderReportDeliveryChannel#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

}

/**
 * Converts an object of type 'ReportPlanSpecForProviderReportDeliveryChannel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecForProviderReportDeliveryChannel(obj: ReportPlanSpecForProviderReportDeliveryChannel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'formats': obj.formats?.map(y => y),
    's3BucketName': obj.s3BucketName,
    's3KeyPrefix': obj.s3KeyPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReportPlanSpecForProviderReportSetting
 */
export interface ReportPlanSpecForProviderReportSetting {
  /**
   * Specifies the list of accounts a report covers.
   *
   * @schema ReportPlanSpecForProviderReportSetting#accounts
   */
  readonly accounts?: string[];

  /**
   * Specifies the Amazon Resource Names (ARNs) of the frameworks a report covers.
   *
   * @schema ReportPlanSpecForProviderReportSetting#frameworkArns
   */
  readonly frameworkArns?: string[];

  /**
   * Specifies the number of frameworks a report covers.
   *
   * @schema ReportPlanSpecForProviderReportSetting#numberOfFrameworks
   */
  readonly numberOfFrameworks?: number;

  /**
   * Specifies the list of Organizational Units a report covers.
   *
   * @schema ReportPlanSpecForProviderReportSetting#organizationUnits
   */
  readonly organizationUnits?: string[];

  /**
   * Specifies the list of regions a report covers.
   *
   * @schema ReportPlanSpecForProviderReportSetting#regions
   */
  readonly regions?: string[];

  /**
   * Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT.
   *
   * @schema ReportPlanSpecForProviderReportSetting#reportTemplate
   */
  readonly reportTemplate?: string;

}

/**
 * Converts an object of type 'ReportPlanSpecForProviderReportSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecForProviderReportSetting(obj: ReportPlanSpecForProviderReportSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accounts': obj.accounts?.map(y => y),
    'frameworkArns': obj.frameworkArns?.map(y => y),
    'numberOfFrameworks': obj.numberOfFrameworks,
    'organizationUnits': obj.organizationUnits?.map(y => y),
    'regions': obj.regions?.map(y => y),
    'reportTemplate': obj.reportTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReportPlanSpecInitProviderReportDeliveryChannel
 */
export interface ReportPlanSpecInitProviderReportDeliveryChannel {
  /**
   * A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
   *
   * @schema ReportPlanSpecInitProviderReportDeliveryChannel#formats
   */
  readonly formats?: string[];

  /**
   * The unique name of the S3 bucket that receives your reports.
   *
   * @schema ReportPlanSpecInitProviderReportDeliveryChannel#s3BucketName
   */
  readonly s3BucketName?: string;

  /**
   * The prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
   *
   * @schema ReportPlanSpecInitProviderReportDeliveryChannel#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

}

/**
 * Converts an object of type 'ReportPlanSpecInitProviderReportDeliveryChannel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecInitProviderReportDeliveryChannel(obj: ReportPlanSpecInitProviderReportDeliveryChannel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'formats': obj.formats?.map(y => y),
    's3BucketName': obj.s3BucketName,
    's3KeyPrefix': obj.s3KeyPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReportPlanSpecInitProviderReportSetting
 */
export interface ReportPlanSpecInitProviderReportSetting {
  /**
   * Specifies the list of accounts a report covers.
   *
   * @schema ReportPlanSpecInitProviderReportSetting#accounts
   */
  readonly accounts?: string[];

  /**
   * Specifies the Amazon Resource Names (ARNs) of the frameworks a report covers.
   *
   * @schema ReportPlanSpecInitProviderReportSetting#frameworkArns
   */
  readonly frameworkArns?: string[];

  /**
   * Specifies the number of frameworks a report covers.
   *
   * @schema ReportPlanSpecInitProviderReportSetting#numberOfFrameworks
   */
  readonly numberOfFrameworks?: number;

  /**
   * Specifies the list of Organizational Units a report covers.
   *
   * @schema ReportPlanSpecInitProviderReportSetting#organizationUnits
   */
  readonly organizationUnits?: string[];

  /**
   * Specifies the list of regions a report covers.
   *
   * @schema ReportPlanSpecInitProviderReportSetting#regions
   */
  readonly regions?: string[];

  /**
   * Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT.
   *
   * @schema ReportPlanSpecInitProviderReportSetting#reportTemplate
   */
  readonly reportTemplate?: string;

}

/**
 * Converts an object of type 'ReportPlanSpecInitProviderReportSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecInitProviderReportSetting(obj: ReportPlanSpecInitProviderReportSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accounts': obj.accounts?.map(y => y),
    'frameworkArns': obj.frameworkArns?.map(y => y),
    'numberOfFrameworks': obj.numberOfFrameworks,
    'organizationUnits': obj.organizationUnits?.map(y => y),
    'regions': obj.regions?.map(y => y),
    'reportTemplate': obj.reportTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReportPlanSpecProviderConfigRefPolicy
 */
export interface ReportPlanSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReportPlanSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReportPlanSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReportPlanSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReportPlanSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReportPlanSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecProviderConfigRefPolicy(obj: ReportPlanSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReportPlanSpecPublishConnectionDetailsToConfigRef
 */
export interface ReportPlanSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReportPlanSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReportPlanSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReportPlanSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReportPlanSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecPublishConnectionDetailsToConfigRef(obj: ReportPlanSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReportPlanSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReportPlanSpecPublishConnectionDetailsToMetadata
 */
export interface ReportPlanSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReportPlanSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReportPlanSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReportPlanSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReportPlanSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecPublishConnectionDetailsToMetadata(obj: ReportPlanSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReportPlanSpecProviderConfigRefPolicyResolution
 */
export enum ReportPlanSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReportPlanSpecProviderConfigRefPolicyResolve
 */
export enum ReportPlanSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReportPlanSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReportPlanSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReportPlanSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReportPlanSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReportPlanSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReportPlanSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReportPlanSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReportPlanSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReportPlanSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReportPlanSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReportPlanSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReportPlanSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReportPlanSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Selection is the Schema for the Selections API. Manages selection conditions for AWS Backup plan resources.
 *
 * @schema Selection
 */
export class Selection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Selection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'backup.aws.upbound.io/v1beta1',
    kind: 'Selection',
  }

  /**
   * Renders a Kubernetes manifest for "Selection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SelectionProps): any {
    return {
      ...Selection.GVK,
      ...toJson_SelectionProps(props),
    };
  }

  /**
   * Defines a "Selection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SelectionProps) {
    super(scope, id, {
      ...Selection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Selection.GVK,
      ...toJson_SelectionProps(resolved),
    };
  }
}

/**
 * Selection is the Schema for the Selections API. Manages selection conditions for AWS Backup plan resources.
 *
 * @schema Selection
 */
export interface SelectionProps {
  /**
   * @schema Selection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SelectionSpec defines the desired state of Selection
   *
   * @schema Selection#spec
   */
  readonly spec: SelectionSpec;

}

/**
 * Converts an object of type 'SelectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionProps(obj: SelectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SelectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SelectionSpec defines the desired state of Selection
 *
 * @schema SelectionSpec
 */
export interface SelectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SelectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: SelectionSpecDeletionPolicy;

  /**
   * @schema SelectionSpec#forProvider
   */
  readonly forProvider: SelectionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SelectionSpec#initProvider
   */
  readonly initProvider?: SelectionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SelectionSpec#managementPolicies
   */
  readonly managementPolicies?: SelectionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SelectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: SelectionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SelectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SelectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SelectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SelectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SelectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpec(obj: SelectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SelectionSpecForProvider(obj.forProvider),
    'initProvider': toJson_SelectionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SelectionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SelectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SelectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SelectionSpecDeletionPolicy
 */
export enum SelectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SelectionSpecForProvider
 */
export interface SelectionSpecForProvider {
  /**
   * A list of conditions that you define to assign resources to your backup plans using tags.
   *
   * @schema SelectionSpecForProvider#condition
   */
  readonly condition?: SelectionSpecForProviderCondition[];

  /**
   * The ARN of the IAM role that AWS Backup uses to authenticate when restoring and backing up the target resource. See the AWS Backup Developer Guide for additional information about using AWS managed policies or creating custom policies attached to the IAM role.
   *
   * @schema SelectionSpecForProvider#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate iamRoleArn.
   *
   * @schema SelectionSpecForProvider#iamRoleArnRef
   */
  readonly iamRoleArnRef?: SelectionSpecForProviderIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate iamRoleArn.
   *
   * @schema SelectionSpecForProvider#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: SelectionSpecForProviderIamRoleArnSelector;

  /**
   * The display name of a resource selection document.
   *
   * @schema SelectionSpecForProvider#name
   */
  readonly name?: string;

  /**
   * An array of strings that either contain Amazon Resource Names (ARNs) or match patterns of resources to exclude from a backup plan.
   *
   * @schema SelectionSpecForProvider#notResources
   */
  readonly notResources?: string[];

  /**
   * The backup plan ID to be associated with the selection of resources.
   *
   * @schema SelectionSpecForProvider#planId
   */
  readonly planId?: string;

  /**
   * Reference to a Plan to populate planId.
   *
   * @schema SelectionSpecForProvider#planIdRef
   */
  readonly planIdRef?: SelectionSpecForProviderPlanIdRef;

  /**
   * Selector for a Plan to populate planId.
   *
   * @schema SelectionSpecForProvider#planIdSelector
   */
  readonly planIdSelector?: SelectionSpecForProviderPlanIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SelectionSpecForProvider#region
   */
  readonly region: string;

  /**
   * An array of strings that either contain Amazon Resource Names (ARNs) or match patterns of resources to assign to a backup plan.
   *
   * @schema SelectionSpecForProvider#resources
   */
  readonly resources?: string[];

  /**
   * Tag-based conditions used to specify a set of resources to assign to a backup plan.
   *
   * @schema SelectionSpecForProvider#selectionTag
   */
  readonly selectionTag?: SelectionSpecForProviderSelectionTag[];

}

/**
 * Converts an object of type 'SelectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProvider(obj: SelectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_SelectionSpecForProviderCondition(y)),
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_SelectionSpecForProviderIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_SelectionSpecForProviderIamRoleArnSelector(obj.iamRoleArnSelector),
    'name': obj.name,
    'notResources': obj.notResources?.map(y => y),
    'planId': obj.planId,
    'planIdRef': toJson_SelectionSpecForProviderPlanIdRef(obj.planIdRef),
    'planIdSelector': toJson_SelectionSpecForProviderPlanIdSelector(obj.planIdSelector),
    'region': obj.region,
    'resources': obj.resources?.map(y => y),
    'selectionTag': obj.selectionTag?.map(y => toJson_SelectionSpecForProviderSelectionTag(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SelectionSpecInitProvider
 */
export interface SelectionSpecInitProvider {
  /**
   * A list of conditions that you define to assign resources to your backup plans using tags.
   *
   * @schema SelectionSpecInitProvider#condition
   */
  readonly condition?: SelectionSpecInitProviderCondition[];

  /**
   * The display name of a resource selection document.
   *
   * @schema SelectionSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * An array of strings that either contain Amazon Resource Names (ARNs) or match patterns of resources to exclude from a backup plan.
   *
   * @schema SelectionSpecInitProvider#notResources
   */
  readonly notResources?: string[];

  /**
   * An array of strings that either contain Amazon Resource Names (ARNs) or match patterns of resources to assign to a backup plan.
   *
   * @schema SelectionSpecInitProvider#resources
   */
  readonly resources?: string[];

  /**
   * Tag-based conditions used to specify a set of resources to assign to a backup plan.
   *
   * @schema SelectionSpecInitProvider#selectionTag
   */
  readonly selectionTag?: SelectionSpecInitProviderSelectionTag[];

}

/**
 * Converts an object of type 'SelectionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecInitProvider(obj: SelectionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_SelectionSpecInitProviderCondition(y)),
    'name': obj.name,
    'notResources': obj.notResources?.map(y => y),
    'resources': obj.resources?.map(y => y),
    'selectionTag': obj.selectionTag?.map(y => toJson_SelectionSpecInitProviderSelectionTag(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SelectionSpecManagementPolicies
 */
export enum SelectionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SelectionSpecProviderConfigRef
 */
export interface SelectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SelectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SelectionSpecProviderConfigRef#policy
   */
  readonly policy?: SelectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SelectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecProviderConfigRef(obj: SelectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SelectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SelectionSpecPublishConnectionDetailsTo
 */
export interface SelectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SelectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SelectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SelectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SelectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SelectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SelectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecPublishConnectionDetailsTo(obj: SelectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SelectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SelectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SelectionSpecWriteConnectionSecretToRef
 */
export interface SelectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SelectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SelectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SelectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecWriteConnectionSecretToRef(obj: SelectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecForProviderCondition
 */
export interface SelectionSpecForProviderCondition {
  /**
   * @schema SelectionSpecForProviderCondition#stringEquals
   */
  readonly stringEquals?: SelectionSpecForProviderConditionStringEquals[];

  /**
   * @schema SelectionSpecForProviderCondition#stringLike
   */
  readonly stringLike?: SelectionSpecForProviderConditionStringLike[];

  /**
   * @schema SelectionSpecForProviderCondition#stringNotEquals
   */
  readonly stringNotEquals?: SelectionSpecForProviderConditionStringNotEquals[];

  /**
   * @schema SelectionSpecForProviderCondition#stringNotLike
   */
  readonly stringNotLike?: SelectionSpecForProviderConditionStringNotLike[];

}

/**
 * Converts an object of type 'SelectionSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderCondition(obj: SelectionSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'stringEquals': obj.stringEquals?.map(y => toJson_SelectionSpecForProviderConditionStringEquals(y)),
    'stringLike': obj.stringLike?.map(y => toJson_SelectionSpecForProviderConditionStringLike(y)),
    'stringNotEquals': obj.stringNotEquals?.map(y => toJson_SelectionSpecForProviderConditionStringNotEquals(y)),
    'stringNotLike': obj.stringNotLike?.map(y => toJson_SelectionSpecForProviderConditionStringNotLike(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRoleArn.
 *
 * @schema SelectionSpecForProviderIamRoleArnRef
 */
export interface SelectionSpecForProviderIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SelectionSpecForProviderIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SelectionSpecForProviderIamRoleArnRef#policy
   */
  readonly policy?: SelectionSpecForProviderIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'SelectionSpecForProviderIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderIamRoleArnRef(obj: SelectionSpecForProviderIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SelectionSpecForProviderIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRoleArn.
 *
 * @schema SelectionSpecForProviderIamRoleArnSelector
 */
export interface SelectionSpecForProviderIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SelectionSpecForProviderIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SelectionSpecForProviderIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SelectionSpecForProviderIamRoleArnSelector#policy
   */
  readonly policy?: SelectionSpecForProviderIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'SelectionSpecForProviderIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderIamRoleArnSelector(obj: SelectionSpecForProviderIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SelectionSpecForProviderIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Plan to populate planId.
 *
 * @schema SelectionSpecForProviderPlanIdRef
 */
export interface SelectionSpecForProviderPlanIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SelectionSpecForProviderPlanIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SelectionSpecForProviderPlanIdRef#policy
   */
  readonly policy?: SelectionSpecForProviderPlanIdRefPolicy;

}

/**
 * Converts an object of type 'SelectionSpecForProviderPlanIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderPlanIdRef(obj: SelectionSpecForProviderPlanIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SelectionSpecForProviderPlanIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Plan to populate planId.
 *
 * @schema SelectionSpecForProviderPlanIdSelector
 */
export interface SelectionSpecForProviderPlanIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SelectionSpecForProviderPlanIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SelectionSpecForProviderPlanIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SelectionSpecForProviderPlanIdSelector#policy
   */
  readonly policy?: SelectionSpecForProviderPlanIdSelectorPolicy;

}

/**
 * Converts an object of type 'SelectionSpecForProviderPlanIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderPlanIdSelector(obj: SelectionSpecForProviderPlanIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SelectionSpecForProviderPlanIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecForProviderSelectionTag
 */
export interface SelectionSpecForProviderSelectionTag {
  /**
   * The key in a key-value pair.
   *
   * @schema SelectionSpecForProviderSelectionTag#key
   */
  readonly key?: string;

  /**
   * An operation, such as StringEquals, that is applied to a key-value pair used to filter resources in a selection.
   *
   * @schema SelectionSpecForProviderSelectionTag#type
   */
  readonly type?: string;

  /**
   * The value in a key-value pair.
   *
   * @schema SelectionSpecForProviderSelectionTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SelectionSpecForProviderSelectionTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderSelectionTag(obj: SelectionSpecForProviderSelectionTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecInitProviderCondition
 */
export interface SelectionSpecInitProviderCondition {
  /**
   * @schema SelectionSpecInitProviderCondition#stringEquals
   */
  readonly stringEquals?: SelectionSpecInitProviderConditionStringEquals[];

  /**
   * @schema SelectionSpecInitProviderCondition#stringLike
   */
  readonly stringLike?: SelectionSpecInitProviderConditionStringLike[];

  /**
   * @schema SelectionSpecInitProviderCondition#stringNotEquals
   */
  readonly stringNotEquals?: SelectionSpecInitProviderConditionStringNotEquals[];

  /**
   * @schema SelectionSpecInitProviderCondition#stringNotLike
   */
  readonly stringNotLike?: SelectionSpecInitProviderConditionStringNotLike[];

}

/**
 * Converts an object of type 'SelectionSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecInitProviderCondition(obj: SelectionSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'stringEquals': obj.stringEquals?.map(y => toJson_SelectionSpecInitProviderConditionStringEquals(y)),
    'stringLike': obj.stringLike?.map(y => toJson_SelectionSpecInitProviderConditionStringLike(y)),
    'stringNotEquals': obj.stringNotEquals?.map(y => toJson_SelectionSpecInitProviderConditionStringNotEquals(y)),
    'stringNotLike': obj.stringNotLike?.map(y => toJson_SelectionSpecInitProviderConditionStringNotLike(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecInitProviderSelectionTag
 */
export interface SelectionSpecInitProviderSelectionTag {
  /**
   * The key in a key-value pair.
   *
   * @schema SelectionSpecInitProviderSelectionTag#key
   */
  readonly key?: string;

  /**
   * An operation, such as StringEquals, that is applied to a key-value pair used to filter resources in a selection.
   *
   * @schema SelectionSpecInitProviderSelectionTag#type
   */
  readonly type?: string;

  /**
   * The value in a key-value pair.
   *
   * @schema SelectionSpecInitProviderSelectionTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SelectionSpecInitProviderSelectionTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecInitProviderSelectionTag(obj: SelectionSpecInitProviderSelectionTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SelectionSpecProviderConfigRefPolicy
 */
export interface SelectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SelectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SelectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SelectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SelectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SelectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecProviderConfigRefPolicy(obj: SelectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SelectionSpecPublishConnectionDetailsToConfigRef
 */
export interface SelectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SelectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SelectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SelectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SelectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecPublishConnectionDetailsToConfigRef(obj: SelectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SelectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SelectionSpecPublishConnectionDetailsToMetadata
 */
export interface SelectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SelectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SelectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SelectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SelectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecPublishConnectionDetailsToMetadata(obj: SelectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecForProviderConditionStringEquals
 */
export interface SelectionSpecForProviderConditionStringEquals {
  /**
   * The key in a key-value pair.
   *
   * @schema SelectionSpecForProviderConditionStringEquals#key
   */
  readonly key?: string;

  /**
   * The value in a key-value pair.
   *
   * @schema SelectionSpecForProviderConditionStringEquals#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SelectionSpecForProviderConditionStringEquals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderConditionStringEquals(obj: SelectionSpecForProviderConditionStringEquals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecForProviderConditionStringLike
 */
export interface SelectionSpecForProviderConditionStringLike {
  /**
   * The key in a key-value pair.
   *
   * @schema SelectionSpecForProviderConditionStringLike#key
   */
  readonly key?: string;

  /**
   * The value in a key-value pair.
   *
   * @schema SelectionSpecForProviderConditionStringLike#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SelectionSpecForProviderConditionStringLike' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderConditionStringLike(obj: SelectionSpecForProviderConditionStringLike | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecForProviderConditionStringNotEquals
 */
export interface SelectionSpecForProviderConditionStringNotEquals {
  /**
   * The key in a key-value pair.
   *
   * @schema SelectionSpecForProviderConditionStringNotEquals#key
   */
  readonly key?: string;

  /**
   * The value in a key-value pair.
   *
   * @schema SelectionSpecForProviderConditionStringNotEquals#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SelectionSpecForProviderConditionStringNotEquals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderConditionStringNotEquals(obj: SelectionSpecForProviderConditionStringNotEquals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecForProviderConditionStringNotLike
 */
export interface SelectionSpecForProviderConditionStringNotLike {
  /**
   * The key in a key-value pair.
   *
   * @schema SelectionSpecForProviderConditionStringNotLike#key
   */
  readonly key?: string;

  /**
   * The value in a key-value pair.
   *
   * @schema SelectionSpecForProviderConditionStringNotLike#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SelectionSpecForProviderConditionStringNotLike' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderConditionStringNotLike(obj: SelectionSpecForProviderConditionStringNotLike | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SelectionSpecForProviderIamRoleArnRefPolicy
 */
export interface SelectionSpecForProviderIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SelectionSpecForProviderIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: SelectionSpecForProviderIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SelectionSpecForProviderIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: SelectionSpecForProviderIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SelectionSpecForProviderIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderIamRoleArnRefPolicy(obj: SelectionSpecForProviderIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SelectionSpecForProviderIamRoleArnSelectorPolicy
 */
export interface SelectionSpecForProviderIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SelectionSpecForProviderIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: SelectionSpecForProviderIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SelectionSpecForProviderIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: SelectionSpecForProviderIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SelectionSpecForProviderIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderIamRoleArnSelectorPolicy(obj: SelectionSpecForProviderIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SelectionSpecForProviderPlanIdRefPolicy
 */
export interface SelectionSpecForProviderPlanIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SelectionSpecForProviderPlanIdRefPolicy#resolution
   */
  readonly resolution?: SelectionSpecForProviderPlanIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SelectionSpecForProviderPlanIdRefPolicy#resolve
   */
  readonly resolve?: SelectionSpecForProviderPlanIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SelectionSpecForProviderPlanIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderPlanIdRefPolicy(obj: SelectionSpecForProviderPlanIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SelectionSpecForProviderPlanIdSelectorPolicy
 */
export interface SelectionSpecForProviderPlanIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SelectionSpecForProviderPlanIdSelectorPolicy#resolution
   */
  readonly resolution?: SelectionSpecForProviderPlanIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SelectionSpecForProviderPlanIdSelectorPolicy#resolve
   */
  readonly resolve?: SelectionSpecForProviderPlanIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SelectionSpecForProviderPlanIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecForProviderPlanIdSelectorPolicy(obj: SelectionSpecForProviderPlanIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecInitProviderConditionStringEquals
 */
export interface SelectionSpecInitProviderConditionStringEquals {
  /**
   * The key in a key-value pair.
   *
   * @schema SelectionSpecInitProviderConditionStringEquals#key
   */
  readonly key?: string;

  /**
   * The value in a key-value pair.
   *
   * @schema SelectionSpecInitProviderConditionStringEquals#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SelectionSpecInitProviderConditionStringEquals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecInitProviderConditionStringEquals(obj: SelectionSpecInitProviderConditionStringEquals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecInitProviderConditionStringLike
 */
export interface SelectionSpecInitProviderConditionStringLike {
  /**
   * The key in a key-value pair.
   *
   * @schema SelectionSpecInitProviderConditionStringLike#key
   */
  readonly key?: string;

  /**
   * The value in a key-value pair.
   *
   * @schema SelectionSpecInitProviderConditionStringLike#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SelectionSpecInitProviderConditionStringLike' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecInitProviderConditionStringLike(obj: SelectionSpecInitProviderConditionStringLike | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecInitProviderConditionStringNotEquals
 */
export interface SelectionSpecInitProviderConditionStringNotEquals {
  /**
   * The key in a key-value pair.
   *
   * @schema SelectionSpecInitProviderConditionStringNotEquals#key
   */
  readonly key?: string;

  /**
   * The value in a key-value pair.
   *
   * @schema SelectionSpecInitProviderConditionStringNotEquals#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SelectionSpecInitProviderConditionStringNotEquals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecInitProviderConditionStringNotEquals(obj: SelectionSpecInitProviderConditionStringNotEquals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SelectionSpecInitProviderConditionStringNotLike
 */
export interface SelectionSpecInitProviderConditionStringNotLike {
  /**
   * The key in a key-value pair.
   *
   * @schema SelectionSpecInitProviderConditionStringNotLike#key
   */
  readonly key?: string;

  /**
   * The value in a key-value pair.
   *
   * @schema SelectionSpecInitProviderConditionStringNotLike#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SelectionSpecInitProviderConditionStringNotLike' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecInitProviderConditionStringNotLike(obj: SelectionSpecInitProviderConditionStringNotLike | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SelectionSpecProviderConfigRefPolicyResolution
 */
export enum SelectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SelectionSpecProviderConfigRefPolicyResolve
 */
export enum SelectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SelectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SelectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SelectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SelectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SelectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SelectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SelectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SelectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: SelectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SelectionSpecForProviderIamRoleArnRefPolicyResolution
 */
export enum SelectionSpecForProviderIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SelectionSpecForProviderIamRoleArnRefPolicyResolve
 */
export enum SelectionSpecForProviderIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SelectionSpecForProviderIamRoleArnSelectorPolicyResolution
 */
export enum SelectionSpecForProviderIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SelectionSpecForProviderIamRoleArnSelectorPolicyResolve
 */
export enum SelectionSpecForProviderIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SelectionSpecForProviderPlanIdRefPolicyResolution
 */
export enum SelectionSpecForProviderPlanIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SelectionSpecForProviderPlanIdRefPolicyResolve
 */
export enum SelectionSpecForProviderPlanIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SelectionSpecForProviderPlanIdSelectorPolicyResolution
 */
export enum SelectionSpecForProviderPlanIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SelectionSpecForProviderPlanIdSelectorPolicyResolve
 */
export enum SelectionSpecForProviderPlanIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SelectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SelectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SelectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SelectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Vault is the Schema for the Vaults API. Provides an AWS Backup vault resource.
 *
 * @schema Vault
 */
export class Vault extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Vault"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'backup.aws.upbound.io/v1beta1',
    kind: 'Vault',
  }

  /**
   * Renders a Kubernetes manifest for "Vault".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultProps): any {
    return {
      ...Vault.GVK,
      ...toJson_VaultProps(props),
    };
  }

  /**
   * Defines a "Vault" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultProps) {
    super(scope, id, {
      ...Vault.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Vault.GVK,
      ...toJson_VaultProps(resolved),
    };
  }
}

/**
 * Vault is the Schema for the Vaults API. Provides an AWS Backup vault resource.
 *
 * @schema Vault
 */
export interface VaultProps {
  /**
   * @schema Vault#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultSpec defines the desired state of Vault
   *
   * @schema Vault#spec
   */
  readonly spec: VaultSpec;

}

/**
 * Converts an object of type 'VaultProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultProps(obj: VaultProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VaultSpec defines the desired state of Vault
 *
 * @schema VaultSpec
 */
export interface VaultSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VaultSpec#deletionPolicy
   */
  readonly deletionPolicy?: VaultSpecDeletionPolicy;

  /**
   * @schema VaultSpec#forProvider
   */
  readonly forProvider: VaultSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VaultSpec#initProvider
   */
  readonly initProvider?: VaultSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VaultSpec#managementPolicies
   */
  readonly managementPolicies?: VaultSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VaultSpec#providerConfigRef
   */
  readonly providerConfigRef?: VaultSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VaultSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VaultSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VaultSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VaultSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VaultSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpec(obj: VaultSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VaultSpecForProvider(obj.forProvider),
    'initProvider': toJson_VaultSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VaultSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VaultSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VaultSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VaultSpecDeletionPolicy
 */
export enum VaultSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VaultSpecForProvider
 */
export interface VaultSpecForProvider {
  /**
   * A boolean that indicates that all recovery points stored in the vault are deleted so that the vault can be destroyed without error.
   *
   * @schema VaultSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The server-side encryption key that is used to protect your backups.
   *
   * @schema VaultSpecForProvider#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema VaultSpecForProvider#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: VaultSpecForProviderKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema VaultSpecForProvider#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: VaultSpecForProviderKmsKeyArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VaultSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema VaultSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VaultSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProvider(obj: VaultSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceDestroy': obj.forceDestroy,
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_VaultSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_VaultSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VaultSpecInitProvider
 */
export interface VaultSpecInitProvider {
  /**
   * A boolean that indicates that all recovery points stored in the vault are deleted so that the vault can be destroyed without error.
   *
   * @schema VaultSpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema VaultSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VaultSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecInitProvider(obj: VaultSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceDestroy': obj.forceDestroy,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VaultSpecManagementPolicies
 */
export enum VaultSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VaultSpecProviderConfigRef
 */
export interface VaultSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultSpecProviderConfigRef#policy
   */
  readonly policy?: VaultSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecProviderConfigRef(obj: VaultSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VaultSpecPublishConnectionDetailsTo
 */
export interface VaultSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VaultSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VaultSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VaultSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VaultSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VaultSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VaultSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecPublishConnectionDetailsTo(obj: VaultSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VaultSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VaultSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VaultSpecWriteConnectionSecretToRef
 */
export interface VaultSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VaultSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VaultSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VaultSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecWriteConnectionSecretToRef(obj: VaultSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema VaultSpecForProviderKmsKeyArnRef
 */
export interface VaultSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: VaultSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'VaultSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProviderKmsKeyArnRef(obj: VaultSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema VaultSpecForProviderKmsKeyArnSelector
 */
export interface VaultSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VaultSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VaultSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VaultSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: VaultSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'VaultSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProviderKmsKeyArnSelector(obj: VaultSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VaultSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultSpecProviderConfigRefPolicy
 */
export interface VaultSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VaultSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VaultSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecProviderConfigRefPolicy(obj: VaultSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VaultSpecPublishConnectionDetailsToConfigRef
 */
export interface VaultSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VaultSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecPublishConnectionDetailsToConfigRef(obj: VaultSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VaultSpecPublishConnectionDetailsToMetadata
 */
export interface VaultSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VaultSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VaultSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecPublishConnectionDetailsToMetadata(obj: VaultSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultSpecForProviderKmsKeyArnRefPolicy
 */
export interface VaultSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: VaultSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: VaultSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProviderKmsKeyArnRefPolicy(obj: VaultSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VaultSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface VaultSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: VaultSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: VaultSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VaultSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProviderKmsKeyArnSelectorPolicy(obj: VaultSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultSpecProviderConfigRefPolicyResolution
 */
export enum VaultSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultSpecProviderConfigRefPolicyResolve
 */
export enum VaultSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VaultSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VaultSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VaultSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VaultSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecPublishConnectionDetailsToConfigRefPolicy(obj: VaultSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum VaultSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum VaultSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum VaultSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum VaultSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VaultSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VaultSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VaultLockConfiguration is the Schema for the VaultLockConfigurations API. Provides an AWS Backup vault lock configuration resource.
 *
 * @schema VaultLockConfiguration
 */
export class VaultLockConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultLockConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'backup.aws.upbound.io/v1beta1',
    kind: 'VaultLockConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "VaultLockConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultLockConfigurationProps): any {
    return {
      ...VaultLockConfiguration.GVK,
      ...toJson_VaultLockConfigurationProps(props),
    };
  }

  /**
   * Defines a "VaultLockConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultLockConfigurationProps) {
    super(scope, id, {
      ...VaultLockConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultLockConfiguration.GVK,
      ...toJson_VaultLockConfigurationProps(resolved),
    };
  }
}

/**
 * VaultLockConfiguration is the Schema for the VaultLockConfigurations API. Provides an AWS Backup vault lock configuration resource.
 *
 * @schema VaultLockConfiguration
 */
export interface VaultLockConfigurationProps {
  /**
   * @schema VaultLockConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultLockConfigurationSpec defines the desired state of VaultLockConfiguration
   *
   * @schema VaultLockConfiguration#spec
   */
  readonly spec: VaultLockConfigurationSpec;

}

/**
 * Converts an object of type 'VaultLockConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationProps(obj: VaultLockConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultLockConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VaultLockConfigurationSpec defines the desired state of VaultLockConfiguration
 *
 * @schema VaultLockConfigurationSpec
 */
export interface VaultLockConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VaultLockConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: VaultLockConfigurationSpecDeletionPolicy;

  /**
   * @schema VaultLockConfigurationSpec#forProvider
   */
  readonly forProvider: VaultLockConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VaultLockConfigurationSpec#initProvider
   */
  readonly initProvider?: VaultLockConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VaultLockConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: VaultLockConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VaultLockConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: VaultLockConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VaultLockConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VaultLockConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VaultLockConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VaultLockConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpec(obj: VaultLockConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VaultLockConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_VaultLockConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VaultLockConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VaultLockConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VaultLockConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VaultLockConfigurationSpecDeletionPolicy
 */
export enum VaultLockConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VaultLockConfigurationSpecForProvider
 */
export interface VaultLockConfigurationSpecForProvider {
  /**
   * Name of the backup vault to add a lock configuration for.
   *
   * @schema VaultLockConfigurationSpecForProvider#backupVaultName
   */
  readonly backupVaultName?: string;

  /**
   * Reference to a Vault to populate backupVaultName.
   *
   * @schema VaultLockConfigurationSpecForProvider#backupVaultNameRef
   */
  readonly backupVaultNameRef?: VaultLockConfigurationSpecForProviderBackupVaultNameRef;

  /**
   * Selector for a Vault to populate backupVaultName.
   *
   * @schema VaultLockConfigurationSpecForProvider#backupVaultNameSelector
   */
  readonly backupVaultNameSelector?: VaultLockConfigurationSpecForProviderBackupVaultNameSelector;

  /**
   * The number of days before the lock date. If omitted creates a vault lock in governance mode, otherwise it will create a vault lock in compliance mode.
   *
   * @schema VaultLockConfigurationSpecForProvider#changeableForDays
   */
  readonly changeableForDays?: number;

  /**
   * The maximum retention period that the vault retains its recovery points.
   *
   * @schema VaultLockConfigurationSpecForProvider#maxRetentionDays
   */
  readonly maxRetentionDays?: number;

  /**
   * The minimum retention period that the vault retains its recovery points.
   *
   * @schema VaultLockConfigurationSpecForProvider#minRetentionDays
   */
  readonly minRetentionDays?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VaultLockConfigurationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecForProvider(obj: VaultLockConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupVaultName': obj.backupVaultName,
    'backupVaultNameRef': toJson_VaultLockConfigurationSpecForProviderBackupVaultNameRef(obj.backupVaultNameRef),
    'backupVaultNameSelector': toJson_VaultLockConfigurationSpecForProviderBackupVaultNameSelector(obj.backupVaultNameSelector),
    'changeableForDays': obj.changeableForDays,
    'maxRetentionDays': obj.maxRetentionDays,
    'minRetentionDays': obj.minRetentionDays,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VaultLockConfigurationSpecInitProvider
 */
export interface VaultLockConfigurationSpecInitProvider {
  /**
   * The number of days before the lock date. If omitted creates a vault lock in governance mode, otherwise it will create a vault lock in compliance mode.
   *
   * @schema VaultLockConfigurationSpecInitProvider#changeableForDays
   */
  readonly changeableForDays?: number;

  /**
   * The maximum retention period that the vault retains its recovery points.
   *
   * @schema VaultLockConfigurationSpecInitProvider#maxRetentionDays
   */
  readonly maxRetentionDays?: number;

  /**
   * The minimum retention period that the vault retains its recovery points.
   *
   * @schema VaultLockConfigurationSpecInitProvider#minRetentionDays
   */
  readonly minRetentionDays?: number;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecInitProvider(obj: VaultLockConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'changeableForDays': obj.changeableForDays,
    'maxRetentionDays': obj.maxRetentionDays,
    'minRetentionDays': obj.minRetentionDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VaultLockConfigurationSpecManagementPolicies
 */
export enum VaultLockConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VaultLockConfigurationSpecProviderConfigRef
 */
export interface VaultLockConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultLockConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultLockConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: VaultLockConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecProviderConfigRef(obj: VaultLockConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultLockConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VaultLockConfigurationSpecPublishConnectionDetailsTo
 */
export interface VaultLockConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VaultLockConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VaultLockConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VaultLockConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VaultLockConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VaultLockConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecPublishConnectionDetailsTo(obj: VaultLockConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VaultLockConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VaultLockConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VaultLockConfigurationSpecWriteConnectionSecretToRef
 */
export interface VaultLockConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VaultLockConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VaultLockConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecWriteConnectionSecretToRef(obj: VaultLockConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Vault to populate backupVaultName.
 *
 * @schema VaultLockConfigurationSpecForProviderBackupVaultNameRef
 */
export interface VaultLockConfigurationSpecForProviderBackupVaultNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultLockConfigurationSpecForProviderBackupVaultNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultLockConfigurationSpecForProviderBackupVaultNameRef#policy
   */
  readonly policy?: VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicy;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecForProviderBackupVaultNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecForProviderBackupVaultNameRef(obj: VaultLockConfigurationSpecForProviderBackupVaultNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Vault to populate backupVaultName.
 *
 * @schema VaultLockConfigurationSpecForProviderBackupVaultNameSelector
 */
export interface VaultLockConfigurationSpecForProviderBackupVaultNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VaultLockConfigurationSpecForProviderBackupVaultNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VaultLockConfigurationSpecForProviderBackupVaultNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VaultLockConfigurationSpecForProviderBackupVaultNameSelector#policy
   */
  readonly policy?: VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicy;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecForProviderBackupVaultNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecForProviderBackupVaultNameSelector(obj: VaultLockConfigurationSpecForProviderBackupVaultNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultLockConfigurationSpecProviderConfigRefPolicy
 */
export interface VaultLockConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultLockConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VaultLockConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultLockConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VaultLockConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecProviderConfigRefPolicy(obj: VaultLockConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VaultLockConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface VaultLockConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultLockConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultLockConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecPublishConnectionDetailsToConfigRef(obj: VaultLockConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VaultLockConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface VaultLockConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultLockConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultLockConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VaultLockConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecPublishConnectionDetailsToMetadata(obj: VaultLockConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicy
 */
export interface VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicy#resolution
   */
  readonly resolution?: VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicy#resolve
   */
  readonly resolve?: VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicy(obj: VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicy
 */
export interface VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicy#resolution
   */
  readonly resolution?: VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicy#resolve
   */
  readonly resolve?: VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicy(obj: VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultLockConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum VaultLockConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultLockConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum VaultLockConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicyResolution
 */
export enum VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicyResolve
 */
export enum VaultLockConfigurationSpecForProviderBackupVaultNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicyResolution
 */
export enum VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicyResolve
 */
export enum VaultLockConfigurationSpecForProviderBackupVaultNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VaultLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VaultNotifications is the Schema for the VaultNotificationss API. Provides an AWS Backup vault notifications resource.
 *
 * @schema VaultNotifications
 */
export class VaultNotifications extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultNotifications"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'backup.aws.upbound.io/v1beta1',
    kind: 'VaultNotifications',
  }

  /**
   * Renders a Kubernetes manifest for "VaultNotifications".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultNotificationsProps): any {
    return {
      ...VaultNotifications.GVK,
      ...toJson_VaultNotificationsProps(props),
    };
  }

  /**
   * Defines a "VaultNotifications" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultNotificationsProps) {
    super(scope, id, {
      ...VaultNotifications.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultNotifications.GVK,
      ...toJson_VaultNotificationsProps(resolved),
    };
  }
}

/**
 * VaultNotifications is the Schema for the VaultNotificationss API. Provides an AWS Backup vault notifications resource.
 *
 * @schema VaultNotifications
 */
export interface VaultNotificationsProps {
  /**
   * @schema VaultNotifications#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultNotificationsSpec defines the desired state of VaultNotifications
   *
   * @schema VaultNotifications#spec
   */
  readonly spec: VaultNotificationsSpec;

}

/**
 * Converts an object of type 'VaultNotificationsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsProps(obj: VaultNotificationsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultNotificationsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VaultNotificationsSpec defines the desired state of VaultNotifications
 *
 * @schema VaultNotificationsSpec
 */
export interface VaultNotificationsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VaultNotificationsSpec#deletionPolicy
   */
  readonly deletionPolicy?: VaultNotificationsSpecDeletionPolicy;

  /**
   * @schema VaultNotificationsSpec#forProvider
   */
  readonly forProvider: VaultNotificationsSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VaultNotificationsSpec#initProvider
   */
  readonly initProvider?: VaultNotificationsSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VaultNotificationsSpec#managementPolicies
   */
  readonly managementPolicies?: VaultNotificationsSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VaultNotificationsSpec#providerConfigRef
   */
  readonly providerConfigRef?: VaultNotificationsSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VaultNotificationsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VaultNotificationsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VaultNotificationsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VaultNotificationsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VaultNotificationsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpec(obj: VaultNotificationsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VaultNotificationsSpecForProvider(obj.forProvider),
    'initProvider': toJson_VaultNotificationsSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VaultNotificationsSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VaultNotificationsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VaultNotificationsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VaultNotificationsSpecDeletionPolicy
 */
export enum VaultNotificationsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VaultNotificationsSpecForProvider
 */
export interface VaultNotificationsSpecForProvider {
  /**
   * An array of events that indicate the status of jobs to back up resources to the backup vault.
   *
   * @schema VaultNotificationsSpecForProvider#backupVaultEvents
   */
  readonly backupVaultEvents?: string[];

  /**
   * Name of the backup vault to add notifications for.
   *
   * @schema VaultNotificationsSpecForProvider#backupVaultName
   */
  readonly backupVaultName?: string;

  /**
   * Reference to a Vault to populate backupVaultName.
   *
   * @schema VaultNotificationsSpecForProvider#backupVaultNameRef
   */
  readonly backupVaultNameRef?: VaultNotificationsSpecForProviderBackupVaultNameRef;

  /**
   * Selector for a Vault to populate backupVaultName.
   *
   * @schema VaultNotificationsSpecForProvider#backupVaultNameSelector
   */
  readonly backupVaultNameSelector?: VaultNotificationsSpecForProviderBackupVaultNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VaultNotificationsSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) that specifies the topic for a backup vault’s events
   *
   * @schema VaultNotificationsSpecForProvider#snsTopicArn
   */
  readonly snsTopicArn?: string;

  /**
   * Reference to a Topic in sns to populate snsTopicArn.
   *
   * @schema VaultNotificationsSpecForProvider#snsTopicArnRef
   */
  readonly snsTopicArnRef?: VaultNotificationsSpecForProviderSnsTopicArnRef;

  /**
   * Selector for a Topic in sns to populate snsTopicArn.
   *
   * @schema VaultNotificationsSpecForProvider#snsTopicArnSelector
   */
  readonly snsTopicArnSelector?: VaultNotificationsSpecForProviderSnsTopicArnSelector;

}

/**
 * Converts an object of type 'VaultNotificationsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecForProvider(obj: VaultNotificationsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupVaultEvents': obj.backupVaultEvents?.map(y => y),
    'backupVaultName': obj.backupVaultName,
    'backupVaultNameRef': toJson_VaultNotificationsSpecForProviderBackupVaultNameRef(obj.backupVaultNameRef),
    'backupVaultNameSelector': toJson_VaultNotificationsSpecForProviderBackupVaultNameSelector(obj.backupVaultNameSelector),
    'region': obj.region,
    'snsTopicArn': obj.snsTopicArn,
    'snsTopicArnRef': toJson_VaultNotificationsSpecForProviderSnsTopicArnRef(obj.snsTopicArnRef),
    'snsTopicArnSelector': toJson_VaultNotificationsSpecForProviderSnsTopicArnSelector(obj.snsTopicArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VaultNotificationsSpecInitProvider
 */
export interface VaultNotificationsSpecInitProvider {
  /**
   * An array of events that indicate the status of jobs to back up resources to the backup vault.
   *
   * @schema VaultNotificationsSpecInitProvider#backupVaultEvents
   */
  readonly backupVaultEvents?: string[];

}

/**
 * Converts an object of type 'VaultNotificationsSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecInitProvider(obj: VaultNotificationsSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupVaultEvents': obj.backupVaultEvents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VaultNotificationsSpecManagementPolicies
 */
export enum VaultNotificationsSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VaultNotificationsSpecProviderConfigRef
 */
export interface VaultNotificationsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultNotificationsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultNotificationsSpecProviderConfigRef#policy
   */
  readonly policy?: VaultNotificationsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultNotificationsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecProviderConfigRef(obj: VaultNotificationsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultNotificationsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VaultNotificationsSpecPublishConnectionDetailsTo
 */
export interface VaultNotificationsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VaultNotificationsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VaultNotificationsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VaultNotificationsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VaultNotificationsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VaultNotificationsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VaultNotificationsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecPublishConnectionDetailsTo(obj: VaultNotificationsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VaultNotificationsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VaultNotificationsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VaultNotificationsSpecWriteConnectionSecretToRef
 */
export interface VaultNotificationsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VaultNotificationsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VaultNotificationsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VaultNotificationsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecWriteConnectionSecretToRef(obj: VaultNotificationsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Vault to populate backupVaultName.
 *
 * @schema VaultNotificationsSpecForProviderBackupVaultNameRef
 */
export interface VaultNotificationsSpecForProviderBackupVaultNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultNotificationsSpecForProviderBackupVaultNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultNotificationsSpecForProviderBackupVaultNameRef#policy
   */
  readonly policy?: VaultNotificationsSpecForProviderBackupVaultNameRefPolicy;

}

/**
 * Converts an object of type 'VaultNotificationsSpecForProviderBackupVaultNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecForProviderBackupVaultNameRef(obj: VaultNotificationsSpecForProviderBackupVaultNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultNotificationsSpecForProviderBackupVaultNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Vault to populate backupVaultName.
 *
 * @schema VaultNotificationsSpecForProviderBackupVaultNameSelector
 */
export interface VaultNotificationsSpecForProviderBackupVaultNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VaultNotificationsSpecForProviderBackupVaultNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VaultNotificationsSpecForProviderBackupVaultNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VaultNotificationsSpecForProviderBackupVaultNameSelector#policy
   */
  readonly policy?: VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicy;

}

/**
 * Converts an object of type 'VaultNotificationsSpecForProviderBackupVaultNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecForProviderBackupVaultNameSelector(obj: VaultNotificationsSpecForProviderBackupVaultNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate snsTopicArn.
 *
 * @schema VaultNotificationsSpecForProviderSnsTopicArnRef
 */
export interface VaultNotificationsSpecForProviderSnsTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultNotificationsSpecForProviderSnsTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultNotificationsSpecForProviderSnsTopicArnRef#policy
   */
  readonly policy?: VaultNotificationsSpecForProviderSnsTopicArnRefPolicy;

}

/**
 * Converts an object of type 'VaultNotificationsSpecForProviderSnsTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecForProviderSnsTopicArnRef(obj: VaultNotificationsSpecForProviderSnsTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultNotificationsSpecForProviderSnsTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate snsTopicArn.
 *
 * @schema VaultNotificationsSpecForProviderSnsTopicArnSelector
 */
export interface VaultNotificationsSpecForProviderSnsTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VaultNotificationsSpecForProviderSnsTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VaultNotificationsSpecForProviderSnsTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VaultNotificationsSpecForProviderSnsTopicArnSelector#policy
   */
  readonly policy?: VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'VaultNotificationsSpecForProviderSnsTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecForProviderSnsTopicArnSelector(obj: VaultNotificationsSpecForProviderSnsTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultNotificationsSpecProviderConfigRefPolicy
 */
export interface VaultNotificationsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultNotificationsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VaultNotificationsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultNotificationsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VaultNotificationsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultNotificationsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecProviderConfigRefPolicy(obj: VaultNotificationsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VaultNotificationsSpecPublishConnectionDetailsToConfigRef
 */
export interface VaultNotificationsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultNotificationsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultNotificationsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultNotificationsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecPublishConnectionDetailsToConfigRef(obj: VaultNotificationsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VaultNotificationsSpecPublishConnectionDetailsToMetadata
 */
export interface VaultNotificationsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultNotificationsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultNotificationsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VaultNotificationsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VaultNotificationsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecPublishConnectionDetailsToMetadata(obj: VaultNotificationsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultNotificationsSpecForProviderBackupVaultNameRefPolicy
 */
export interface VaultNotificationsSpecForProviderBackupVaultNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultNotificationsSpecForProviderBackupVaultNameRefPolicy#resolution
   */
  readonly resolution?: VaultNotificationsSpecForProviderBackupVaultNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultNotificationsSpecForProviderBackupVaultNameRefPolicy#resolve
   */
  readonly resolve?: VaultNotificationsSpecForProviderBackupVaultNameRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultNotificationsSpecForProviderBackupVaultNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecForProviderBackupVaultNameRefPolicy(obj: VaultNotificationsSpecForProviderBackupVaultNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicy
 */
export interface VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicy#resolution
   */
  readonly resolution?: VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicy#resolve
   */
  readonly resolve?: VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicy(obj: VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultNotificationsSpecForProviderSnsTopicArnRefPolicy
 */
export interface VaultNotificationsSpecForProviderSnsTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultNotificationsSpecForProviderSnsTopicArnRefPolicy#resolution
   */
  readonly resolution?: VaultNotificationsSpecForProviderSnsTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultNotificationsSpecForProviderSnsTopicArnRefPolicy#resolve
   */
  readonly resolve?: VaultNotificationsSpecForProviderSnsTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultNotificationsSpecForProviderSnsTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecForProviderSnsTopicArnRefPolicy(obj: VaultNotificationsSpecForProviderSnsTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicy
 */
export interface VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicy(obj: VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultNotificationsSpecProviderConfigRefPolicyResolution
 */
export enum VaultNotificationsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultNotificationsSpecProviderConfigRefPolicyResolve
 */
export enum VaultNotificationsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicy(obj: VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultNotificationsSpecForProviderBackupVaultNameRefPolicyResolution
 */
export enum VaultNotificationsSpecForProviderBackupVaultNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultNotificationsSpecForProviderBackupVaultNameRefPolicyResolve
 */
export enum VaultNotificationsSpecForProviderBackupVaultNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicyResolution
 */
export enum VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicyResolve
 */
export enum VaultNotificationsSpecForProviderBackupVaultNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultNotificationsSpecForProviderSnsTopicArnRefPolicyResolution
 */
export enum VaultNotificationsSpecForProviderSnsTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultNotificationsSpecForProviderSnsTopicArnRefPolicyResolve
 */
export enum VaultNotificationsSpecForProviderSnsTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicyResolution
 */
export enum VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicyResolve
 */
export enum VaultNotificationsSpecForProviderSnsTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VaultNotificationsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VaultPolicy is the Schema for the VaultPolicys API. Provides an AWS Backup vault policy resource.
 *
 * @schema VaultPolicy
 */
export class VaultPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'backup.aws.upbound.io/v1beta1',
    kind: 'VaultPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "VaultPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultPolicyProps): any {
    return {
      ...VaultPolicy.GVK,
      ...toJson_VaultPolicyProps(props),
    };
  }

  /**
   * Defines a "VaultPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultPolicyProps) {
    super(scope, id, {
      ...VaultPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultPolicy.GVK,
      ...toJson_VaultPolicyProps(resolved),
    };
  }
}

/**
 * VaultPolicy is the Schema for the VaultPolicys API. Provides an AWS Backup vault policy resource.
 *
 * @schema VaultPolicy
 */
export interface VaultPolicyProps {
  /**
   * @schema VaultPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultPolicySpec defines the desired state of VaultPolicy
   *
   * @schema VaultPolicy#spec
   */
  readonly spec: VaultPolicySpec;

}

/**
 * Converts an object of type 'VaultPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicyProps(obj: VaultPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VaultPolicySpec defines the desired state of VaultPolicy
 *
 * @schema VaultPolicySpec
 */
export interface VaultPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VaultPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: VaultPolicySpecDeletionPolicy;

  /**
   * @schema VaultPolicySpec#forProvider
   */
  readonly forProvider: VaultPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VaultPolicySpec#initProvider
   */
  readonly initProvider?: VaultPolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VaultPolicySpec#managementPolicies
   */
  readonly managementPolicies?: VaultPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VaultPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: VaultPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VaultPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VaultPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VaultPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VaultPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VaultPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpec(obj: VaultPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VaultPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_VaultPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VaultPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VaultPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VaultPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VaultPolicySpecDeletionPolicy
 */
export enum VaultPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VaultPolicySpecForProvider
 */
export interface VaultPolicySpecForProvider {
  /**
   * Name of the backup vault to add policy for.
   *
   * @schema VaultPolicySpecForProvider#backupVaultName
   */
  readonly backupVaultName?: string;

  /**
   * Reference to a Vault in backup to populate backupVaultName.
   *
   * @schema VaultPolicySpecForProvider#backupVaultNameRef
   */
  readonly backupVaultNameRef?: VaultPolicySpecForProviderBackupVaultNameRef;

  /**
   * Selector for a Vault in backup to populate backupVaultName.
   *
   * @schema VaultPolicySpecForProvider#backupVaultNameSelector
   */
  readonly backupVaultNameSelector?: VaultPolicySpecForProviderBackupVaultNameSelector;

  /**
   * The backup vault access policy document in JSON format.
   *
   * @schema VaultPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VaultPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'VaultPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecForProvider(obj: VaultPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupVaultName': obj.backupVaultName,
    'backupVaultNameRef': toJson_VaultPolicySpecForProviderBackupVaultNameRef(obj.backupVaultNameRef),
    'backupVaultNameSelector': toJson_VaultPolicySpecForProviderBackupVaultNameSelector(obj.backupVaultNameSelector),
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VaultPolicySpecInitProvider
 */
export interface VaultPolicySpecInitProvider {
  /**
   * The backup vault access policy document in JSON format.
   *
   * @schema VaultPolicySpecInitProvider#policy
   */
  readonly policy?: string;

}

/**
 * Converts an object of type 'VaultPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecInitProvider(obj: VaultPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VaultPolicySpecManagementPolicies
 */
export enum VaultPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VaultPolicySpecProviderConfigRef
 */
export interface VaultPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultPolicySpecProviderConfigRef#policy
   */
  readonly policy?: VaultPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecProviderConfigRef(obj: VaultPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VaultPolicySpecPublishConnectionDetailsTo
 */
export interface VaultPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VaultPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VaultPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VaultPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VaultPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VaultPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VaultPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecPublishConnectionDetailsTo(obj: VaultPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VaultPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VaultPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VaultPolicySpecWriteConnectionSecretToRef
 */
export interface VaultPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VaultPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VaultPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VaultPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecWriteConnectionSecretToRef(obj: VaultPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Vault in backup to populate backupVaultName.
 *
 * @schema VaultPolicySpecForProviderBackupVaultNameRef
 */
export interface VaultPolicySpecForProviderBackupVaultNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultPolicySpecForProviderBackupVaultNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultPolicySpecForProviderBackupVaultNameRef#policy
   */
  readonly policy?: VaultPolicySpecForProviderBackupVaultNameRefPolicy;

}

/**
 * Converts an object of type 'VaultPolicySpecForProviderBackupVaultNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecForProviderBackupVaultNameRef(obj: VaultPolicySpecForProviderBackupVaultNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultPolicySpecForProviderBackupVaultNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Vault in backup to populate backupVaultName.
 *
 * @schema VaultPolicySpecForProviderBackupVaultNameSelector
 */
export interface VaultPolicySpecForProviderBackupVaultNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VaultPolicySpecForProviderBackupVaultNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VaultPolicySpecForProviderBackupVaultNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VaultPolicySpecForProviderBackupVaultNameSelector#policy
   */
  readonly policy?: VaultPolicySpecForProviderBackupVaultNameSelectorPolicy;

}

/**
 * Converts an object of type 'VaultPolicySpecForProviderBackupVaultNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecForProviderBackupVaultNameSelector(obj: VaultPolicySpecForProviderBackupVaultNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VaultPolicySpecForProviderBackupVaultNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultPolicySpecProviderConfigRefPolicy
 */
export interface VaultPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VaultPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VaultPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecProviderConfigRefPolicy(obj: VaultPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VaultPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface VaultPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VaultPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecPublishConnectionDetailsToConfigRef(obj: VaultPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VaultPolicySpecPublishConnectionDetailsToMetadata
 */
export interface VaultPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VaultPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VaultPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecPublishConnectionDetailsToMetadata(obj: VaultPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultPolicySpecForProviderBackupVaultNameRefPolicy
 */
export interface VaultPolicySpecForProviderBackupVaultNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultPolicySpecForProviderBackupVaultNameRefPolicy#resolution
   */
  readonly resolution?: VaultPolicySpecForProviderBackupVaultNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultPolicySpecForProviderBackupVaultNameRefPolicy#resolve
   */
  readonly resolve?: VaultPolicySpecForProviderBackupVaultNameRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultPolicySpecForProviderBackupVaultNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecForProviderBackupVaultNameRefPolicy(obj: VaultPolicySpecForProviderBackupVaultNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VaultPolicySpecForProviderBackupVaultNameSelectorPolicy
 */
export interface VaultPolicySpecForProviderBackupVaultNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultPolicySpecForProviderBackupVaultNameSelectorPolicy#resolution
   */
  readonly resolution?: VaultPolicySpecForProviderBackupVaultNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultPolicySpecForProviderBackupVaultNameSelectorPolicy#resolve
   */
  readonly resolve?: VaultPolicySpecForProviderBackupVaultNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VaultPolicySpecForProviderBackupVaultNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecForProviderBackupVaultNameSelectorPolicy(obj: VaultPolicySpecForProviderBackupVaultNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultPolicySpecProviderConfigRefPolicyResolution
 */
export enum VaultPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultPolicySpecProviderConfigRefPolicyResolve
 */
export enum VaultPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VaultPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VaultPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VaultPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VaultPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: VaultPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultPolicySpecForProviderBackupVaultNameRefPolicyResolution
 */
export enum VaultPolicySpecForProviderBackupVaultNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultPolicySpecForProviderBackupVaultNameRefPolicyResolve
 */
export enum VaultPolicySpecForProviderBackupVaultNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultPolicySpecForProviderBackupVaultNameSelectorPolicyResolution
 */
export enum VaultPolicySpecForProviderBackupVaultNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultPolicySpecForProviderBackupVaultNameSelectorPolicyResolve
 */
export enum VaultPolicySpecForProviderBackupVaultNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VaultPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VaultPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

