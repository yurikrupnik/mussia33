// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Vault is the Schema for the Vaults API. Provides a Glacier Vault.
 *
 * @schema Vault
 */
export class Vault extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Vault"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glacier.aws.upbound.io/v1beta1',
    kind: 'Vault',
  }

  /**
   * Renders a Kubernetes manifest for "Vault".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultProps): any {
    return {
      ...Vault.GVK,
      ...toJson_VaultProps(props),
    };
  }

  /**
   * Defines a "Vault" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultProps) {
    super(scope, id, {
      ...Vault.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Vault.GVK,
      ...toJson_VaultProps(resolved),
    };
  }
}

/**
 * Vault is the Schema for the Vaults API. Provides a Glacier Vault.
 *
 * @schema Vault
 */
export interface VaultProps {
  /**
   * @schema Vault#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultSpec defines the desired state of Vault
   *
   * @schema Vault#spec
   */
  readonly spec: VaultSpec;

}

/**
 * Converts an object of type 'VaultProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultProps(obj: VaultProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VaultSpec defines the desired state of Vault
 *
 * @schema VaultSpec
 */
export interface VaultSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VaultSpec#deletionPolicy
   */
  readonly deletionPolicy?: VaultSpecDeletionPolicy;

  /**
   * @schema VaultSpec#forProvider
   */
  readonly forProvider: VaultSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VaultSpec#initProvider
   */
  readonly initProvider?: VaultSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VaultSpec#managementPolicies
   */
  readonly managementPolicies?: VaultSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VaultSpec#providerConfigRef
   */
  readonly providerConfigRef?: VaultSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VaultSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VaultSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VaultSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VaultSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VaultSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpec(obj: VaultSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VaultSpecForProvider(obj.forProvider),
    'initProvider': toJson_VaultSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VaultSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VaultSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VaultSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VaultSpecDeletionPolicy
 */
export enum VaultSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VaultSpecForProvider
 */
export interface VaultSpecForProvider {
  /**
   * The policy document. This is a JSON formatted string. The heredoc syntax or file function is helpful here. Use the Glacier Developer Guide for more information on Glacier Vault Policy
   *
   * @schema VaultSpecForProvider#accessPolicy
   */
  readonly accessPolicy?: string;

  /**
   * The notifications for the Vault. Fields documented below.
   *
   * @schema VaultSpecForProvider#notification
   */
  readonly notification?: VaultSpecForProviderNotification[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VaultSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema VaultSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VaultSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProvider(obj: VaultSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPolicy': obj.accessPolicy,
    'notification': obj.notification?.map(y => toJson_VaultSpecForProviderNotification(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VaultSpecInitProvider
 */
export interface VaultSpecInitProvider {
  /**
   * The policy document. This is a JSON formatted string. The heredoc syntax or file function is helpful here. Use the Glacier Developer Guide for more information on Glacier Vault Policy
   *
   * @schema VaultSpecInitProvider#accessPolicy
   */
  readonly accessPolicy?: string;

  /**
   * The notifications for the Vault. Fields documented below.
   *
   * @schema VaultSpecInitProvider#notification
   */
  readonly notification?: VaultSpecInitProviderNotification[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VaultSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VaultSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecInitProvider(obj: VaultSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPolicy': obj.accessPolicy,
    'notification': obj.notification?.map(y => toJson_VaultSpecInitProviderNotification(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VaultSpecManagementPolicies
 */
export enum VaultSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VaultSpecProviderConfigRef
 */
export interface VaultSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultSpecProviderConfigRef#policy
   */
  readonly policy?: VaultSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecProviderConfigRef(obj: VaultSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VaultSpecPublishConnectionDetailsTo
 */
export interface VaultSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VaultSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VaultSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VaultSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VaultSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VaultSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VaultSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecPublishConnectionDetailsTo(obj: VaultSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VaultSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VaultSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VaultSpecWriteConnectionSecretToRef
 */
export interface VaultSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VaultSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VaultSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VaultSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecWriteConnectionSecretToRef(obj: VaultSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VaultSpecForProviderNotification
 */
export interface VaultSpecForProviderNotification {
  /**
   * You can configure a vault to publish a notification for ArchiveRetrievalCompleted and InventoryRetrievalCompleted events.
   *
   * @schema VaultSpecForProviderNotification#events
   */
  readonly events?: string[];

  /**
   * The SNS Topic ARN.
   *
   * @schema VaultSpecForProviderNotification#snsTopic
   */
  readonly snsTopic?: string;

  /**
   * Reference to a Topic in sns to populate snsTopic.
   *
   * @schema VaultSpecForProviderNotification#snsTopicRef
   */
  readonly snsTopicRef?: VaultSpecForProviderNotificationSnsTopicRef;

  /**
   * Selector for a Topic in sns to populate snsTopic.
   *
   * @schema VaultSpecForProviderNotification#snsTopicSelector
   */
  readonly snsTopicSelector?: VaultSpecForProviderNotificationSnsTopicSelector;

}

/**
 * Converts an object of type 'VaultSpecForProviderNotification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProviderNotification(obj: VaultSpecForProviderNotification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'snsTopic': obj.snsTopic,
    'snsTopicRef': toJson_VaultSpecForProviderNotificationSnsTopicRef(obj.snsTopicRef),
    'snsTopicSelector': toJson_VaultSpecForProviderNotificationSnsTopicSelector(obj.snsTopicSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VaultSpecInitProviderNotification
 */
export interface VaultSpecInitProviderNotification {
  /**
   * You can configure a vault to publish a notification for ArchiveRetrievalCompleted and InventoryRetrievalCompleted events.
   *
   * @schema VaultSpecInitProviderNotification#events
   */
  readonly events?: string[];

}

/**
 * Converts an object of type 'VaultSpecInitProviderNotification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecInitProviderNotification(obj: VaultSpecInitProviderNotification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultSpecProviderConfigRefPolicy
 */
export interface VaultSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VaultSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VaultSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecProviderConfigRefPolicy(obj: VaultSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VaultSpecPublishConnectionDetailsToConfigRef
 */
export interface VaultSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VaultSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecPublishConnectionDetailsToConfigRef(obj: VaultSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VaultSpecPublishConnectionDetailsToMetadata
 */
export interface VaultSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VaultSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VaultSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecPublishConnectionDetailsToMetadata(obj: VaultSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate snsTopic.
 *
 * @schema VaultSpecForProviderNotificationSnsTopicRef
 */
export interface VaultSpecForProviderNotificationSnsTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultSpecForProviderNotificationSnsTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultSpecForProviderNotificationSnsTopicRef#policy
   */
  readonly policy?: VaultSpecForProviderNotificationSnsTopicRefPolicy;

}

/**
 * Converts an object of type 'VaultSpecForProviderNotificationSnsTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProviderNotificationSnsTopicRef(obj: VaultSpecForProviderNotificationSnsTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultSpecForProviderNotificationSnsTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate snsTopic.
 *
 * @schema VaultSpecForProviderNotificationSnsTopicSelector
 */
export interface VaultSpecForProviderNotificationSnsTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VaultSpecForProviderNotificationSnsTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VaultSpecForProviderNotificationSnsTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VaultSpecForProviderNotificationSnsTopicSelector#policy
   */
  readonly policy?: VaultSpecForProviderNotificationSnsTopicSelectorPolicy;

}

/**
 * Converts an object of type 'VaultSpecForProviderNotificationSnsTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProviderNotificationSnsTopicSelector(obj: VaultSpecForProviderNotificationSnsTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VaultSpecForProviderNotificationSnsTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultSpecProviderConfigRefPolicyResolution
 */
export enum VaultSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultSpecProviderConfigRefPolicyResolve
 */
export enum VaultSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VaultSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VaultSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VaultSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VaultSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecPublishConnectionDetailsToConfigRefPolicy(obj: VaultSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultSpecForProviderNotificationSnsTopicRefPolicy
 */
export interface VaultSpecForProviderNotificationSnsTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultSpecForProviderNotificationSnsTopicRefPolicy#resolution
   */
  readonly resolution?: VaultSpecForProviderNotificationSnsTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultSpecForProviderNotificationSnsTopicRefPolicy#resolve
   */
  readonly resolve?: VaultSpecForProviderNotificationSnsTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultSpecForProviderNotificationSnsTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProviderNotificationSnsTopicRefPolicy(obj: VaultSpecForProviderNotificationSnsTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VaultSpecForProviderNotificationSnsTopicSelectorPolicy
 */
export interface VaultSpecForProviderNotificationSnsTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultSpecForProviderNotificationSnsTopicSelectorPolicy#resolution
   */
  readonly resolution?: VaultSpecForProviderNotificationSnsTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultSpecForProviderNotificationSnsTopicSelectorPolicy#resolve
   */
  readonly resolve?: VaultSpecForProviderNotificationSnsTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VaultSpecForProviderNotificationSnsTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultSpecForProviderNotificationSnsTopicSelectorPolicy(obj: VaultSpecForProviderNotificationSnsTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VaultSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VaultSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultSpecForProviderNotificationSnsTopicRefPolicyResolution
 */
export enum VaultSpecForProviderNotificationSnsTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultSpecForProviderNotificationSnsTopicRefPolicyResolve
 */
export enum VaultSpecForProviderNotificationSnsTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultSpecForProviderNotificationSnsTopicSelectorPolicyResolution
 */
export enum VaultSpecForProviderNotificationSnsTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultSpecForProviderNotificationSnsTopicSelectorPolicyResolve
 */
export enum VaultSpecForProviderNotificationSnsTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VaultLock is the Schema for the VaultLocks API. Manages a Glacier Vault Lock.
 *
 * @schema VaultLock
 */
export class VaultLock extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultLock"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glacier.aws.upbound.io/v1beta1',
    kind: 'VaultLock',
  }

  /**
   * Renders a Kubernetes manifest for "VaultLock".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultLockProps): any {
    return {
      ...VaultLock.GVK,
      ...toJson_VaultLockProps(props),
    };
  }

  /**
   * Defines a "VaultLock" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultLockProps) {
    super(scope, id, {
      ...VaultLock.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultLock.GVK,
      ...toJson_VaultLockProps(resolved),
    };
  }
}

/**
 * VaultLock is the Schema for the VaultLocks API. Manages a Glacier Vault Lock.
 *
 * @schema VaultLock
 */
export interface VaultLockProps {
  /**
   * @schema VaultLock#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultLockSpec defines the desired state of VaultLock
   *
   * @schema VaultLock#spec
   */
  readonly spec: VaultLockSpec;

}

/**
 * Converts an object of type 'VaultLockProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockProps(obj: VaultLockProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultLockSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VaultLockSpec defines the desired state of VaultLock
 *
 * @schema VaultLockSpec
 */
export interface VaultLockSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VaultLockSpec#deletionPolicy
   */
  readonly deletionPolicy?: VaultLockSpecDeletionPolicy;

  /**
   * @schema VaultLockSpec#forProvider
   */
  readonly forProvider: VaultLockSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VaultLockSpec#initProvider
   */
  readonly initProvider?: VaultLockSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VaultLockSpec#managementPolicies
   */
  readonly managementPolicies?: VaultLockSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VaultLockSpec#providerConfigRef
   */
  readonly providerConfigRef?: VaultLockSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VaultLockSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VaultLockSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VaultLockSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VaultLockSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VaultLockSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpec(obj: VaultLockSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VaultLockSpecForProvider(obj.forProvider),
    'initProvider': toJson_VaultLockSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VaultLockSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VaultLockSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VaultLockSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VaultLockSpecDeletionPolicy
 */
export enum VaultLockSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VaultLockSpecForProvider
 */
export interface VaultLockSpecForProvider {
  /**
   * Boolean whether to permanently apply this Glacier Lock Policy. Once completed, this cannot be undone. If set to false, the Glacier Lock Policy remains in a testing mode for 24 hours. Changing this from false to true will show as resource recreation, which is expected. Changing this from true to false is not possible unless the Glacier Vault is recreated at the same time.
   *
   * @schema VaultLockSpecForProvider#completeLock
   */
  readonly completeLock?: boolean;

  /**
   * This should only be used in conjunction with complete_lock being set to true.
   *
   * @schema VaultLockSpecForProvider#ignoreDeletionError
   */
  readonly ignoreDeletionError?: boolean;

  /**
   * JSON string containing the IAM policy to apply as the Glacier Vault Lock policy.
   *
   * @schema VaultLockSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VaultLockSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the Glacier Vault.
   *
   * @schema VaultLockSpecForProvider#vaultName
   */
  readonly vaultName?: string;

  /**
   * Reference to a Vault in glacier to populate vaultName.
   *
   * @schema VaultLockSpecForProvider#vaultNameRef
   */
  readonly vaultNameRef?: VaultLockSpecForProviderVaultNameRef;

  /**
   * Selector for a Vault in glacier to populate vaultName.
   *
   * @schema VaultLockSpecForProvider#vaultNameSelector
   */
  readonly vaultNameSelector?: VaultLockSpecForProviderVaultNameSelector;

}

/**
 * Converts an object of type 'VaultLockSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecForProvider(obj: VaultLockSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'completeLock': obj.completeLock,
    'ignoreDeletionError': obj.ignoreDeletionError,
    'policy': obj.policy,
    'region': obj.region,
    'vaultName': obj.vaultName,
    'vaultNameRef': toJson_VaultLockSpecForProviderVaultNameRef(obj.vaultNameRef),
    'vaultNameSelector': toJson_VaultLockSpecForProviderVaultNameSelector(obj.vaultNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VaultLockSpecInitProvider
 */
export interface VaultLockSpecInitProvider {
  /**
   * Boolean whether to permanently apply this Glacier Lock Policy. Once completed, this cannot be undone. If set to false, the Glacier Lock Policy remains in a testing mode for 24 hours. Changing this from false to true will show as resource recreation, which is expected. Changing this from true to false is not possible unless the Glacier Vault is recreated at the same time.
   *
   * @schema VaultLockSpecInitProvider#completeLock
   */
  readonly completeLock?: boolean;

  /**
   * This should only be used in conjunction with complete_lock being set to true.
   *
   * @schema VaultLockSpecInitProvider#ignoreDeletionError
   */
  readonly ignoreDeletionError?: boolean;

  /**
   * JSON string containing the IAM policy to apply as the Glacier Vault Lock policy.
   *
   * @schema VaultLockSpecInitProvider#policy
   */
  readonly policy?: string;

}

/**
 * Converts an object of type 'VaultLockSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecInitProvider(obj: VaultLockSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'completeLock': obj.completeLock,
    'ignoreDeletionError': obj.ignoreDeletionError,
    'policy': obj.policy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VaultLockSpecManagementPolicies
 */
export enum VaultLockSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VaultLockSpecProviderConfigRef
 */
export interface VaultLockSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultLockSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultLockSpecProviderConfigRef#policy
   */
  readonly policy?: VaultLockSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultLockSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecProviderConfigRef(obj: VaultLockSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultLockSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VaultLockSpecPublishConnectionDetailsTo
 */
export interface VaultLockSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VaultLockSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VaultLockSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VaultLockSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VaultLockSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VaultLockSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VaultLockSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecPublishConnectionDetailsTo(obj: VaultLockSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VaultLockSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VaultLockSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VaultLockSpecWriteConnectionSecretToRef
 */
export interface VaultLockSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VaultLockSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VaultLockSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VaultLockSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecWriteConnectionSecretToRef(obj: VaultLockSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Vault in glacier to populate vaultName.
 *
 * @schema VaultLockSpecForProviderVaultNameRef
 */
export interface VaultLockSpecForProviderVaultNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultLockSpecForProviderVaultNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultLockSpecForProviderVaultNameRef#policy
   */
  readonly policy?: VaultLockSpecForProviderVaultNameRefPolicy;

}

/**
 * Converts an object of type 'VaultLockSpecForProviderVaultNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecForProviderVaultNameRef(obj: VaultLockSpecForProviderVaultNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultLockSpecForProviderVaultNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Vault in glacier to populate vaultName.
 *
 * @schema VaultLockSpecForProviderVaultNameSelector
 */
export interface VaultLockSpecForProviderVaultNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VaultLockSpecForProviderVaultNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VaultLockSpecForProviderVaultNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VaultLockSpecForProviderVaultNameSelector#policy
   */
  readonly policy?: VaultLockSpecForProviderVaultNameSelectorPolicy;

}

/**
 * Converts an object of type 'VaultLockSpecForProviderVaultNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecForProviderVaultNameSelector(obj: VaultLockSpecForProviderVaultNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VaultLockSpecForProviderVaultNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultLockSpecProviderConfigRefPolicy
 */
export interface VaultLockSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultLockSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VaultLockSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultLockSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VaultLockSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultLockSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecProviderConfigRefPolicy(obj: VaultLockSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VaultLockSpecPublishConnectionDetailsToConfigRef
 */
export interface VaultLockSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VaultLockSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VaultLockSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VaultLockSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VaultLockSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecPublishConnectionDetailsToConfigRef(obj: VaultLockSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VaultLockSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VaultLockSpecPublishConnectionDetailsToMetadata
 */
export interface VaultLockSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultLockSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VaultLockSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VaultLockSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VaultLockSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecPublishConnectionDetailsToMetadata(obj: VaultLockSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VaultLockSpecForProviderVaultNameRefPolicy
 */
export interface VaultLockSpecForProviderVaultNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultLockSpecForProviderVaultNameRefPolicy#resolution
   */
  readonly resolution?: VaultLockSpecForProviderVaultNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultLockSpecForProviderVaultNameRefPolicy#resolve
   */
  readonly resolve?: VaultLockSpecForProviderVaultNameRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultLockSpecForProviderVaultNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecForProviderVaultNameRefPolicy(obj: VaultLockSpecForProviderVaultNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VaultLockSpecForProviderVaultNameSelectorPolicy
 */
export interface VaultLockSpecForProviderVaultNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultLockSpecForProviderVaultNameSelectorPolicy#resolution
   */
  readonly resolution?: VaultLockSpecForProviderVaultNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultLockSpecForProviderVaultNameSelectorPolicy#resolve
   */
  readonly resolve?: VaultLockSpecForProviderVaultNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VaultLockSpecForProviderVaultNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecForProviderVaultNameSelectorPolicy(obj: VaultLockSpecForProviderVaultNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultLockSpecProviderConfigRefPolicyResolution
 */
export enum VaultLockSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultLockSpecProviderConfigRefPolicyResolve
 */
export enum VaultLockSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VaultLockSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VaultLockSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VaultLockSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VaultLockSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VaultLockSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VaultLockSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VaultLockSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultLockSpecPublishConnectionDetailsToConfigRefPolicy(obj: VaultLockSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultLockSpecForProviderVaultNameRefPolicyResolution
 */
export enum VaultLockSpecForProviderVaultNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultLockSpecForProviderVaultNameRefPolicyResolve
 */
export enum VaultLockSpecForProviderVaultNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultLockSpecForProviderVaultNameSelectorPolicyResolution
 */
export enum VaultLockSpecForProviderVaultNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultLockSpecForProviderVaultNameSelectorPolicyResolve
 */
export enum VaultLockSpecForProviderVaultNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VaultLockSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VaultLockSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VaultLockSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VaultLockSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

