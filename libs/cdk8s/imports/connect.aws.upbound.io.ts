// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * BotAssociation is the Schema for the BotAssociations API. Associates an Amazon Connect instance to an Amazon Lex (V1) bot
 *
 * @schema BotAssociation
 */
export class BotAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BotAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'BotAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "BotAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BotAssociationProps): any {
    return {
      ...BotAssociation.GVK,
      ...toJson_BotAssociationProps(props),
    };
  }

  /**
   * Defines a "BotAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BotAssociationProps) {
    super(scope, id, {
      ...BotAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BotAssociation.GVK,
      ...toJson_BotAssociationProps(resolved),
    };
  }
}

/**
 * BotAssociation is the Schema for the BotAssociations API. Associates an Amazon Connect instance to an Amazon Lex (V1) bot
 *
 * @schema BotAssociation
 */
export interface BotAssociationProps {
  /**
   * @schema BotAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BotAssociationSpec defines the desired state of BotAssociation
   *
   * @schema BotAssociation#spec
   */
  readonly spec: BotAssociationSpec;

}

/**
 * Converts an object of type 'BotAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationProps(obj: BotAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BotAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BotAssociationSpec defines the desired state of BotAssociation
 *
 * @schema BotAssociationSpec
 */
export interface BotAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BotAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BotAssociationSpecDeletionPolicy;

  /**
   * @schema BotAssociationSpec#forProvider
   */
  readonly forProvider: BotAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BotAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: BotAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BotAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BotAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BotAssociationSpec#providerRef
   */
  readonly providerRef?: BotAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BotAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BotAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BotAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BotAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BotAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpec(obj: BotAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BotAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_BotAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BotAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BotAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BotAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BotAssociationSpecDeletionPolicy
 */
export enum BotAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BotAssociationSpecForProvider
 */
export interface BotAssociationSpecForProvider {
  /**
   * The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
   *
   * @schema BotAssociationSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema BotAssociationSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: BotAssociationSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema BotAssociationSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: BotAssociationSpecForProviderInstanceIdSelector;

  /**
   * Configuration information of an Amazon Lex (V1) bot. Detailed below.
   *
   * @schema BotAssociationSpecForProvider#lexBot
   */
  readonly lexBot?: BotAssociationSpecForProviderLexBot[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BotAssociationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BotAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecForProvider(obj: BotAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_BotAssociationSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_BotAssociationSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'lexBot': obj.lexBot?.map(y => toJson_BotAssociationSpecForProviderLexBot(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BotAssociationSpecManagementPolicy
 */
export enum BotAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BotAssociationSpecProviderConfigRef
 */
export interface BotAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: BotAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BotAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecProviderConfigRef(obj: BotAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BotAssociationSpecProviderRef
 */
export interface BotAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotAssociationSpecProviderRef#policy
   */
  readonly policy?: BotAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BotAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecProviderRef(obj: BotAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BotAssociationSpecPublishConnectionDetailsTo
 */
export interface BotAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BotAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BotAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BotAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BotAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BotAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BotAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecPublishConnectionDetailsTo(obj: BotAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BotAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BotAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BotAssociationSpecWriteConnectionSecretToRef
 */
export interface BotAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BotAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BotAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BotAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecWriteConnectionSecretToRef(obj: BotAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema BotAssociationSpecForProviderInstanceIdRef
 */
export interface BotAssociationSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotAssociationSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotAssociationSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: BotAssociationSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'BotAssociationSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecForProviderInstanceIdRef(obj: BotAssociationSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotAssociationSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema BotAssociationSpecForProviderInstanceIdSelector
 */
export interface BotAssociationSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BotAssociationSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BotAssociationSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BotAssociationSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: BotAssociationSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'BotAssociationSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecForProviderInstanceIdSelector(obj: BotAssociationSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BotAssociationSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BotAssociationSpecForProviderLexBot
 */
export interface BotAssociationSpecForProviderLexBot {
  /**
   * The Region that the Amazon Lex (V1) bot was created in. Defaults to current region.
   *
   * @default current region.
   * @schema BotAssociationSpecForProviderLexBot#lexRegion
   */
  readonly lexRegion?: string;

  /**
   * The name of the Amazon Lex (V1) bot.
   *
   * @schema BotAssociationSpecForProviderLexBot#name
   */
  readonly name?: string;

  /**
   * Reference to a Bot in lexmodels to populate name.
   *
   * @schema BotAssociationSpecForProviderLexBot#nameRef
   */
  readonly nameRef?: BotAssociationSpecForProviderLexBotNameRef;

  /**
   * Selector for a Bot in lexmodels to populate name.
   *
   * @schema BotAssociationSpecForProviderLexBot#nameSelector
   */
  readonly nameSelector?: BotAssociationSpecForProviderLexBotNameSelector;

}

/**
 * Converts an object of type 'BotAssociationSpecForProviderLexBot' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecForProviderLexBot(obj: BotAssociationSpecForProviderLexBot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lexRegion': obj.lexRegion,
    'name': obj.name,
    'nameRef': toJson_BotAssociationSpecForProviderLexBotNameRef(obj.nameRef),
    'nameSelector': toJson_BotAssociationSpecForProviderLexBotNameSelector(obj.nameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BotAssociationSpecProviderConfigRefPolicy
 */
export interface BotAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BotAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BotAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BotAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecProviderConfigRefPolicy(obj: BotAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BotAssociationSpecProviderRefPolicy
 */
export interface BotAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BotAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BotAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BotAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecProviderRefPolicy(obj: BotAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BotAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface BotAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BotAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BotAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecPublishConnectionDetailsToConfigRef(obj: BotAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BotAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface BotAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BotAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BotAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BotAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BotAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecPublishConnectionDetailsToMetadata(obj: BotAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BotAssociationSpecForProviderInstanceIdRefPolicy
 */
export interface BotAssociationSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotAssociationSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: BotAssociationSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotAssociationSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: BotAssociationSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BotAssociationSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecForProviderInstanceIdRefPolicy(obj: BotAssociationSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BotAssociationSpecForProviderInstanceIdSelectorPolicy
 */
export interface BotAssociationSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotAssociationSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: BotAssociationSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotAssociationSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: BotAssociationSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BotAssociationSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecForProviderInstanceIdSelectorPolicy(obj: BotAssociationSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bot in lexmodels to populate name.
 *
 * @schema BotAssociationSpecForProviderLexBotNameRef
 */
export interface BotAssociationSpecForProviderLexBotNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema BotAssociationSpecForProviderLexBotNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BotAssociationSpecForProviderLexBotNameRef#policy
   */
  readonly policy?: BotAssociationSpecForProviderLexBotNameRefPolicy;

}

/**
 * Converts an object of type 'BotAssociationSpecForProviderLexBotNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecForProviderLexBotNameRef(obj: BotAssociationSpecForProviderLexBotNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BotAssociationSpecForProviderLexBotNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bot in lexmodels to populate name.
 *
 * @schema BotAssociationSpecForProviderLexBotNameSelector
 */
export interface BotAssociationSpecForProviderLexBotNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BotAssociationSpecForProviderLexBotNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BotAssociationSpecForProviderLexBotNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BotAssociationSpecForProviderLexBotNameSelector#policy
   */
  readonly policy?: BotAssociationSpecForProviderLexBotNameSelectorPolicy;

}

/**
 * Converts an object of type 'BotAssociationSpecForProviderLexBotNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecForProviderLexBotNameSelector(obj: BotAssociationSpecForProviderLexBotNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BotAssociationSpecForProviderLexBotNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotAssociationSpecProviderConfigRefPolicyResolution
 */
export enum BotAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotAssociationSpecProviderConfigRefPolicyResolve
 */
export enum BotAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotAssociationSpecProviderRefPolicyResolution
 */
export enum BotAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotAssociationSpecProviderRefPolicyResolve
 */
export enum BotAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BotAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BotAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BotAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BotAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BotAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BotAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotAssociationSpecForProviderInstanceIdRefPolicyResolution
 */
export enum BotAssociationSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotAssociationSpecForProviderInstanceIdRefPolicyResolve
 */
export enum BotAssociationSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotAssociationSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum BotAssociationSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotAssociationSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum BotAssociationSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BotAssociationSpecForProviderLexBotNameRefPolicy
 */
export interface BotAssociationSpecForProviderLexBotNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotAssociationSpecForProviderLexBotNameRefPolicy#resolution
   */
  readonly resolution?: BotAssociationSpecForProviderLexBotNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotAssociationSpecForProviderLexBotNameRefPolicy#resolve
   */
  readonly resolve?: BotAssociationSpecForProviderLexBotNameRefPolicyResolve;

}

/**
 * Converts an object of type 'BotAssociationSpecForProviderLexBotNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecForProviderLexBotNameRefPolicy(obj: BotAssociationSpecForProviderLexBotNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BotAssociationSpecForProviderLexBotNameSelectorPolicy
 */
export interface BotAssociationSpecForProviderLexBotNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BotAssociationSpecForProviderLexBotNameSelectorPolicy#resolution
   */
  readonly resolution?: BotAssociationSpecForProviderLexBotNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BotAssociationSpecForProviderLexBotNameSelectorPolicy#resolve
   */
  readonly resolve?: BotAssociationSpecForProviderLexBotNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BotAssociationSpecForProviderLexBotNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BotAssociationSpecForProviderLexBotNameSelectorPolicy(obj: BotAssociationSpecForProviderLexBotNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BotAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BotAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotAssociationSpecForProviderLexBotNameRefPolicyResolution
 */
export enum BotAssociationSpecForProviderLexBotNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotAssociationSpecForProviderLexBotNameRefPolicyResolve
 */
export enum BotAssociationSpecForProviderLexBotNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BotAssociationSpecForProviderLexBotNameSelectorPolicyResolution
 */
export enum BotAssociationSpecForProviderLexBotNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BotAssociationSpecForProviderLexBotNameSelectorPolicyResolve
 */
export enum BotAssociationSpecForProviderLexBotNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ContactFlow is the Schema for the ContactFlows API. Provides details about a specific Amazon Connect Contact Flow.
 *
 * @schema ContactFlow
 */
export class ContactFlow extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ContactFlow"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'ContactFlow',
  }

  /**
   * Renders a Kubernetes manifest for "ContactFlow".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ContactFlowProps): any {
    return {
      ...ContactFlow.GVK,
      ...toJson_ContactFlowProps(props),
    };
  }

  /**
   * Defines a "ContactFlow" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ContactFlowProps) {
    super(scope, id, {
      ...ContactFlow.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ContactFlow.GVK,
      ...toJson_ContactFlowProps(resolved),
    };
  }
}

/**
 * ContactFlow is the Schema for the ContactFlows API. Provides details about a specific Amazon Connect Contact Flow.
 *
 * @schema ContactFlow
 */
export interface ContactFlowProps {
  /**
   * @schema ContactFlow#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ContactFlowSpec defines the desired state of ContactFlow
   *
   * @schema ContactFlow#spec
   */
  readonly spec: ContactFlowSpec;

}

/**
 * Converts an object of type 'ContactFlowProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowProps(obj: ContactFlowProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContactFlowSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContactFlowSpec defines the desired state of ContactFlow
 *
 * @schema ContactFlowSpec
 */
export interface ContactFlowSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ContactFlowSpec#deletionPolicy
   */
  readonly deletionPolicy?: ContactFlowSpecDeletionPolicy;

  /**
   * @schema ContactFlowSpec#forProvider
   */
  readonly forProvider: ContactFlowSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ContactFlowSpec#managementPolicy
   */
  readonly managementPolicy?: ContactFlowSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ContactFlowSpec#providerConfigRef
   */
  readonly providerConfigRef?: ContactFlowSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ContactFlowSpec#providerRef
   */
  readonly providerRef?: ContactFlowSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ContactFlowSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ContactFlowSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ContactFlowSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ContactFlowSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ContactFlowSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpec(obj: ContactFlowSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ContactFlowSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ContactFlowSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ContactFlowSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ContactFlowSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ContactFlowSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ContactFlowSpecDeletionPolicy
 */
export enum ContactFlowSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ContactFlowSpecForProvider
 */
export interface ContactFlowSpecForProvider {
  /**
   * Specifies the content of the Contact Flow, provided as a JSON string, written in Amazon Connect Contact Flow Language. If defined, the filename argument cannot be used.
   *
   * @schema ContactFlowSpecForProvider#content
   */
  readonly content?: string;

  /**
   * Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the Contact Flow source specified with filename. The usual way to set this is filebase64sha256("mycontact_flow.11.12 and later) or base64sha256(file("mycontact_flow.11.11 and earlier), where "mycontact_flow.json" is the local filename of the Contact Flow source.
   *
   * @schema ContactFlowSpecForProvider#contentHash
   */
  readonly contentHash?: string;

  /**
   * Specifies the description of the Contact Flow.
   *
   * @schema ContactFlowSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The path to the Contact Flow source within the local filesystem. Conflicts with content.
   *
   * @schema ContactFlowSpecForProvider#filename
   */
  readonly filename?: string;

  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema ContactFlowSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema ContactFlowSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: ContactFlowSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema ContactFlowSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: ContactFlowSpecForProviderInstanceIdSelector;

  /**
   * Specifies the name of the Contact Flow.
   *
   * @schema ContactFlowSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ContactFlowSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ContactFlowSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Specifies the type of the Contact Flow. Defaults to CONTACT_FLOW. Allowed Values are: CONTACT_FLOW, CUSTOMER_QUEUE, CUSTOMER_HOLD, CUSTOMER_WHISPER, AGENT_HOLD, AGENT_WHISPER, OUTBOUND_WHISPER, AGENT_TRANSFER, QUEUE_TRANSFER.
   *
   * @default CONTACT_FLOW. Allowed Values are: CONTACT_FLOW, CUSTOMER_QUEUE, CUSTOMER_HOLD, CUSTOMER_WHISPER, AGENT_HOLD, AGENT_WHISPER, OUTBOUND_WHISPER, AGENT_TRANSFER, QUEUE_TRANSFER.
   * @schema ContactFlowSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContactFlowSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecForProvider(obj: ContactFlowSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentHash': obj.contentHash,
    'description': obj.description,
    'filename': obj.filename,
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_ContactFlowSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_ContactFlowSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ContactFlowSpecManagementPolicy
 */
export enum ContactFlowSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ContactFlowSpecProviderConfigRef
 */
export interface ContactFlowSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContactFlowSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContactFlowSpecProviderConfigRef#policy
   */
  readonly policy?: ContactFlowSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ContactFlowSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecProviderConfigRef(obj: ContactFlowSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContactFlowSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ContactFlowSpecProviderRef
 */
export interface ContactFlowSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContactFlowSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContactFlowSpecProviderRef#policy
   */
  readonly policy?: ContactFlowSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ContactFlowSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecProviderRef(obj: ContactFlowSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContactFlowSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ContactFlowSpecPublishConnectionDetailsTo
 */
export interface ContactFlowSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ContactFlowSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ContactFlowSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ContactFlowSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ContactFlowSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ContactFlowSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ContactFlowSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecPublishConnectionDetailsTo(obj: ContactFlowSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ContactFlowSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ContactFlowSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ContactFlowSpecWriteConnectionSecretToRef
 */
export interface ContactFlowSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ContactFlowSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ContactFlowSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContactFlowSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecWriteConnectionSecretToRef(obj: ContactFlowSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema ContactFlowSpecForProviderInstanceIdRef
 */
export interface ContactFlowSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContactFlowSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContactFlowSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: ContactFlowSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'ContactFlowSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecForProviderInstanceIdRef(obj: ContactFlowSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContactFlowSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema ContactFlowSpecForProviderInstanceIdSelector
 */
export interface ContactFlowSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ContactFlowSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ContactFlowSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ContactFlowSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: ContactFlowSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ContactFlowSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecForProviderInstanceIdSelector(obj: ContactFlowSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ContactFlowSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContactFlowSpecProviderConfigRefPolicy
 */
export interface ContactFlowSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContactFlowSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ContactFlowSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContactFlowSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ContactFlowSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContactFlowSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecProviderConfigRefPolicy(obj: ContactFlowSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContactFlowSpecProviderRefPolicy
 */
export interface ContactFlowSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContactFlowSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ContactFlowSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContactFlowSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ContactFlowSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ContactFlowSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecProviderRefPolicy(obj: ContactFlowSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ContactFlowSpecPublishConnectionDetailsToConfigRef
 */
export interface ContactFlowSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContactFlowSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContactFlowSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ContactFlowSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ContactFlowSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecPublishConnectionDetailsToConfigRef(obj: ContactFlowSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContactFlowSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ContactFlowSpecPublishConnectionDetailsToMetadata
 */
export interface ContactFlowSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContactFlowSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContactFlowSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ContactFlowSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContactFlowSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecPublishConnectionDetailsToMetadata(obj: ContactFlowSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContactFlowSpecForProviderInstanceIdRefPolicy
 */
export interface ContactFlowSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContactFlowSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: ContactFlowSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContactFlowSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: ContactFlowSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ContactFlowSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecForProviderInstanceIdRefPolicy(obj: ContactFlowSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ContactFlowSpecForProviderInstanceIdSelectorPolicy
 */
export interface ContactFlowSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContactFlowSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: ContactFlowSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContactFlowSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: ContactFlowSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ContactFlowSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecForProviderInstanceIdSelectorPolicy(obj: ContactFlowSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContactFlowSpecProviderConfigRefPolicyResolution
 */
export enum ContactFlowSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContactFlowSpecProviderConfigRefPolicyResolve
 */
export enum ContactFlowSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContactFlowSpecProviderRefPolicyResolution
 */
export enum ContactFlowSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContactFlowSpecProviderRefPolicyResolve
 */
export enum ContactFlowSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ContactFlowSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ContactFlowSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContactFlowSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ContactFlowSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContactFlowSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ContactFlowSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContactFlowSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowSpecPublishConnectionDetailsToConfigRefPolicy(obj: ContactFlowSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContactFlowSpecForProviderInstanceIdRefPolicyResolution
 */
export enum ContactFlowSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContactFlowSpecForProviderInstanceIdRefPolicyResolve
 */
export enum ContactFlowSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContactFlowSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum ContactFlowSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContactFlowSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum ContactFlowSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContactFlowSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ContactFlowSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContactFlowSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ContactFlowSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ContactFlowModule is the Schema for the ContactFlowModules API. Provides details about a specific Amazon Connect Contact Flow Module.
 *
 * @schema ContactFlowModule
 */
export class ContactFlowModule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ContactFlowModule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'ContactFlowModule',
  }

  /**
   * Renders a Kubernetes manifest for "ContactFlowModule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ContactFlowModuleProps): any {
    return {
      ...ContactFlowModule.GVK,
      ...toJson_ContactFlowModuleProps(props),
    };
  }

  /**
   * Defines a "ContactFlowModule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ContactFlowModuleProps) {
    super(scope, id, {
      ...ContactFlowModule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ContactFlowModule.GVK,
      ...toJson_ContactFlowModuleProps(resolved),
    };
  }
}

/**
 * ContactFlowModule is the Schema for the ContactFlowModules API. Provides details about a specific Amazon Connect Contact Flow Module.
 *
 * @schema ContactFlowModule
 */
export interface ContactFlowModuleProps {
  /**
   * @schema ContactFlowModule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ContactFlowModuleSpec defines the desired state of ContactFlowModule
   *
   * @schema ContactFlowModule#spec
   */
  readonly spec: ContactFlowModuleSpec;

}

/**
 * Converts an object of type 'ContactFlowModuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleProps(obj: ContactFlowModuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContactFlowModuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContactFlowModuleSpec defines the desired state of ContactFlowModule
 *
 * @schema ContactFlowModuleSpec
 */
export interface ContactFlowModuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ContactFlowModuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: ContactFlowModuleSpecDeletionPolicy;

  /**
   * @schema ContactFlowModuleSpec#forProvider
   */
  readonly forProvider: ContactFlowModuleSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ContactFlowModuleSpec#managementPolicy
   */
  readonly managementPolicy?: ContactFlowModuleSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ContactFlowModuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: ContactFlowModuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ContactFlowModuleSpec#providerRef
   */
  readonly providerRef?: ContactFlowModuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ContactFlowModuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ContactFlowModuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ContactFlowModuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ContactFlowModuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ContactFlowModuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpec(obj: ContactFlowModuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ContactFlowModuleSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ContactFlowModuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ContactFlowModuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ContactFlowModuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ContactFlowModuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ContactFlowModuleSpecDeletionPolicy
 */
export enum ContactFlowModuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ContactFlowModuleSpecForProvider
 */
export interface ContactFlowModuleSpecForProvider {
  /**
   * Specifies the content of the Contact Flow Module, provided as a JSON string, written in Amazon Connect Contact Flow Language. If defined, the filename argument cannot be used.
   *
   * @schema ContactFlowModuleSpecForProvider#content
   */
  readonly content?: string;

  /**
   * Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the Contact Flow Module source specified with filename. The usual way to set this is filebase64sha256("contact_flow_module.11.12 and later) or base64sha256(file("contact_flow_module.11.11 and earlier), where "contact_flow_module.json" is the local filename of the Contact Flow Module source.
   *
   * @schema ContactFlowModuleSpecForProvider#contentHash
   */
  readonly contentHash?: string;

  /**
   * Specifies the description of the Contact Flow Module.
   *
   * @schema ContactFlowModuleSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The path to the Contact Flow Module source within the local filesystem. Conflicts with content.
   *
   * @schema ContactFlowModuleSpecForProvider#filename
   */
  readonly filename?: string;

  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema ContactFlowModuleSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema ContactFlowModuleSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: ContactFlowModuleSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema ContactFlowModuleSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: ContactFlowModuleSpecForProviderInstanceIdSelector;

  /**
   * Specifies the name of the Contact Flow Module.
   *
   * @schema ContactFlowModuleSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ContactFlowModuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ContactFlowModuleSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContactFlowModuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecForProvider(obj: ContactFlowModuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentHash': obj.contentHash,
    'description': obj.description,
    'filename': obj.filename,
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_ContactFlowModuleSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_ContactFlowModuleSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ContactFlowModuleSpecManagementPolicy
 */
export enum ContactFlowModuleSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ContactFlowModuleSpecProviderConfigRef
 */
export interface ContactFlowModuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContactFlowModuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContactFlowModuleSpecProviderConfigRef#policy
   */
  readonly policy?: ContactFlowModuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecProviderConfigRef(obj: ContactFlowModuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContactFlowModuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ContactFlowModuleSpecProviderRef
 */
export interface ContactFlowModuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContactFlowModuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContactFlowModuleSpecProviderRef#policy
   */
  readonly policy?: ContactFlowModuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecProviderRef(obj: ContactFlowModuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContactFlowModuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ContactFlowModuleSpecPublishConnectionDetailsTo
 */
export interface ContactFlowModuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ContactFlowModuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ContactFlowModuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ContactFlowModuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ContactFlowModuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ContactFlowModuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecPublishConnectionDetailsTo(obj: ContactFlowModuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ContactFlowModuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ContactFlowModuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ContactFlowModuleSpecWriteConnectionSecretToRef
 */
export interface ContactFlowModuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ContactFlowModuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ContactFlowModuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecWriteConnectionSecretToRef(obj: ContactFlowModuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema ContactFlowModuleSpecForProviderInstanceIdRef
 */
export interface ContactFlowModuleSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContactFlowModuleSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContactFlowModuleSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: ContactFlowModuleSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecForProviderInstanceIdRef(obj: ContactFlowModuleSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContactFlowModuleSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema ContactFlowModuleSpecForProviderInstanceIdSelector
 */
export interface ContactFlowModuleSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ContactFlowModuleSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ContactFlowModuleSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ContactFlowModuleSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: ContactFlowModuleSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecForProviderInstanceIdSelector(obj: ContactFlowModuleSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ContactFlowModuleSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContactFlowModuleSpecProviderConfigRefPolicy
 */
export interface ContactFlowModuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContactFlowModuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ContactFlowModuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContactFlowModuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ContactFlowModuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecProviderConfigRefPolicy(obj: ContactFlowModuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContactFlowModuleSpecProviderRefPolicy
 */
export interface ContactFlowModuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContactFlowModuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ContactFlowModuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContactFlowModuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ContactFlowModuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecProviderRefPolicy(obj: ContactFlowModuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ContactFlowModuleSpecPublishConnectionDetailsToConfigRef
 */
export interface ContactFlowModuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ContactFlowModuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ContactFlowModuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecPublishConnectionDetailsToConfigRef(obj: ContactFlowModuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ContactFlowModuleSpecPublishConnectionDetailsToMetadata
 */
export interface ContactFlowModuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContactFlowModuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ContactFlowModuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ContactFlowModuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecPublishConnectionDetailsToMetadata(obj: ContactFlowModuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ContactFlowModuleSpecForProviderInstanceIdRefPolicy
 */
export interface ContactFlowModuleSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContactFlowModuleSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: ContactFlowModuleSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContactFlowModuleSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: ContactFlowModuleSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecForProviderInstanceIdRefPolicy(obj: ContactFlowModuleSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ContactFlowModuleSpecForProviderInstanceIdSelectorPolicy
 */
export interface ContactFlowModuleSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContactFlowModuleSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: ContactFlowModuleSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContactFlowModuleSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: ContactFlowModuleSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecForProviderInstanceIdSelectorPolicy(obj: ContactFlowModuleSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContactFlowModuleSpecProviderConfigRefPolicyResolution
 */
export enum ContactFlowModuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContactFlowModuleSpecProviderConfigRefPolicyResolve
 */
export enum ContactFlowModuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContactFlowModuleSpecProviderRefPolicyResolution
 */
export enum ContactFlowModuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContactFlowModuleSpecProviderRefPolicyResolve
 */
export enum ContactFlowModuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContactFlowModuleSpecForProviderInstanceIdRefPolicyResolution
 */
export enum ContactFlowModuleSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContactFlowModuleSpecForProviderInstanceIdRefPolicyResolve
 */
export enum ContactFlowModuleSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContactFlowModuleSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum ContactFlowModuleSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContactFlowModuleSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum ContactFlowModuleSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ContactFlowModuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HoursOfOperation is the Schema for the HoursOfOperations API. Provides details about a specific Amazon Connect Hours of Operation.
 *
 * @schema HoursOfOperation
 */
export class HoursOfOperation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HoursOfOperation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'HoursOfOperation',
  }

  /**
   * Renders a Kubernetes manifest for "HoursOfOperation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HoursOfOperationProps): any {
    return {
      ...HoursOfOperation.GVK,
      ...toJson_HoursOfOperationProps(props),
    };
  }

  /**
   * Defines a "HoursOfOperation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HoursOfOperationProps) {
    super(scope, id, {
      ...HoursOfOperation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HoursOfOperation.GVK,
      ...toJson_HoursOfOperationProps(resolved),
    };
  }
}

/**
 * HoursOfOperation is the Schema for the HoursOfOperations API. Provides details about a specific Amazon Connect Hours of Operation.
 *
 * @schema HoursOfOperation
 */
export interface HoursOfOperationProps {
  /**
   * @schema HoursOfOperation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HoursOfOperationSpec defines the desired state of HoursOfOperation
   *
   * @schema HoursOfOperation#spec
   */
  readonly spec: HoursOfOperationSpec;

}

/**
 * Converts an object of type 'HoursOfOperationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationProps(obj: HoursOfOperationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HoursOfOperationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HoursOfOperationSpec defines the desired state of HoursOfOperation
 *
 * @schema HoursOfOperationSpec
 */
export interface HoursOfOperationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HoursOfOperationSpec#deletionPolicy
   */
  readonly deletionPolicy?: HoursOfOperationSpecDeletionPolicy;

  /**
   * @schema HoursOfOperationSpec#forProvider
   */
  readonly forProvider: HoursOfOperationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HoursOfOperationSpec#managementPolicy
   */
  readonly managementPolicy?: HoursOfOperationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HoursOfOperationSpec#providerConfigRef
   */
  readonly providerConfigRef?: HoursOfOperationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema HoursOfOperationSpec#providerRef
   */
  readonly providerRef?: HoursOfOperationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HoursOfOperationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HoursOfOperationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HoursOfOperationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HoursOfOperationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HoursOfOperationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpec(obj: HoursOfOperationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HoursOfOperationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_HoursOfOperationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_HoursOfOperationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_HoursOfOperationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HoursOfOperationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HoursOfOperationSpecDeletionPolicy
 */
export enum HoursOfOperationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HoursOfOperationSpecForProvider
 */
export interface HoursOfOperationSpecForProvider {
  /**
   * One or more config blocks which define the configuration information for the hours of operation: day, start time, and end time . Config blocks are documented below.
   *
   * @schema HoursOfOperationSpecForProvider#config
   */
  readonly config?: HoursOfOperationSpecForProviderConfig[];

  /**
   * Specifies the description of the Hours of Operation.
   *
   * @schema HoursOfOperationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema HoursOfOperationSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema HoursOfOperationSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: HoursOfOperationSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema HoursOfOperationSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: HoursOfOperationSpecForProviderInstanceIdSelector;

  /**
   * Specifies the name of the Hours of Operation.
   *
   * @schema HoursOfOperationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HoursOfOperationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HoursOfOperationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Specifies the time zone of the Hours of Operation.
   *
   * @schema HoursOfOperationSpecForProvider#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'HoursOfOperationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecForProvider(obj: HoursOfOperationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config?.map(y => toJson_HoursOfOperationSpecForProviderConfig(y)),
    'description': obj.description,
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_HoursOfOperationSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_HoursOfOperationSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HoursOfOperationSpecManagementPolicy
 */
export enum HoursOfOperationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HoursOfOperationSpecProviderConfigRef
 */
export interface HoursOfOperationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HoursOfOperationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HoursOfOperationSpecProviderConfigRef#policy
   */
  readonly policy?: HoursOfOperationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HoursOfOperationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecProviderConfigRef(obj: HoursOfOperationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HoursOfOperationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema HoursOfOperationSpecProviderRef
 */
export interface HoursOfOperationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema HoursOfOperationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HoursOfOperationSpecProviderRef#policy
   */
  readonly policy?: HoursOfOperationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'HoursOfOperationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecProviderRef(obj: HoursOfOperationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HoursOfOperationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HoursOfOperationSpecPublishConnectionDetailsTo
 */
export interface HoursOfOperationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HoursOfOperationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HoursOfOperationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HoursOfOperationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HoursOfOperationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HoursOfOperationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HoursOfOperationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecPublishConnectionDetailsTo(obj: HoursOfOperationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HoursOfOperationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HoursOfOperationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HoursOfOperationSpecWriteConnectionSecretToRef
 */
export interface HoursOfOperationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HoursOfOperationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HoursOfOperationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HoursOfOperationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecWriteConnectionSecretToRef(obj: HoursOfOperationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HoursOfOperationSpecForProviderConfig
 */
export interface HoursOfOperationSpecForProviderConfig {
  /**
   * Specifies the day that the hours of operation applies to.
   *
   * @schema HoursOfOperationSpecForProviderConfig#day
   */
  readonly day: string;

  /**
   * A end time block specifies the time that your contact center closes. The end_time is documented below.
   *
   * @schema HoursOfOperationSpecForProviderConfig#endTime
   */
  readonly endTime: HoursOfOperationSpecForProviderConfigEndTime[];

  /**
   * A start time block specifies the time that your contact center opens. The start_time is documented below.
   *
   * @schema HoursOfOperationSpecForProviderConfig#startTime
   */
  readonly startTime: HoursOfOperationSpecForProviderConfigStartTime[];

}

/**
 * Converts an object of type 'HoursOfOperationSpecForProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecForProviderConfig(obj: HoursOfOperationSpecForProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'endTime': obj.endTime?.map(y => toJson_HoursOfOperationSpecForProviderConfigEndTime(y)),
    'startTime': obj.startTime?.map(y => toJson_HoursOfOperationSpecForProviderConfigStartTime(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema HoursOfOperationSpecForProviderInstanceIdRef
 */
export interface HoursOfOperationSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HoursOfOperationSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HoursOfOperationSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: HoursOfOperationSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'HoursOfOperationSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecForProviderInstanceIdRef(obj: HoursOfOperationSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HoursOfOperationSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema HoursOfOperationSpecForProviderInstanceIdSelector
 */
export interface HoursOfOperationSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema HoursOfOperationSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HoursOfOperationSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HoursOfOperationSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: HoursOfOperationSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'HoursOfOperationSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecForProviderInstanceIdSelector(obj: HoursOfOperationSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HoursOfOperationSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HoursOfOperationSpecProviderConfigRefPolicy
 */
export interface HoursOfOperationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HoursOfOperationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HoursOfOperationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HoursOfOperationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HoursOfOperationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HoursOfOperationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecProviderConfigRefPolicy(obj: HoursOfOperationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HoursOfOperationSpecProviderRefPolicy
 */
export interface HoursOfOperationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HoursOfOperationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: HoursOfOperationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HoursOfOperationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: HoursOfOperationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'HoursOfOperationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecProviderRefPolicy(obj: HoursOfOperationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HoursOfOperationSpecPublishConnectionDetailsToConfigRef
 */
export interface HoursOfOperationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HoursOfOperationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HoursOfOperationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HoursOfOperationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecPublishConnectionDetailsToConfigRef(obj: HoursOfOperationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HoursOfOperationSpecPublishConnectionDetailsToMetadata
 */
export interface HoursOfOperationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HoursOfOperationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HoursOfOperationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HoursOfOperationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HoursOfOperationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecPublishConnectionDetailsToMetadata(obj: HoursOfOperationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HoursOfOperationSpecForProviderConfigEndTime
 */
export interface HoursOfOperationSpecForProviderConfigEndTime {
  /**
   * Specifies the hour of closing.
   *
   * @schema HoursOfOperationSpecForProviderConfigEndTime#hours
   */
  readonly hours: number;

  /**
   * Specifies the minute of closing.
   *
   * @schema HoursOfOperationSpecForProviderConfigEndTime#minutes
   */
  readonly minutes: number;

}

/**
 * Converts an object of type 'HoursOfOperationSpecForProviderConfigEndTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecForProviderConfigEndTime(obj: HoursOfOperationSpecForProviderConfigEndTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HoursOfOperationSpecForProviderConfigStartTime
 */
export interface HoursOfOperationSpecForProviderConfigStartTime {
  /**
   * Specifies the hour of opening.
   *
   * @schema HoursOfOperationSpecForProviderConfigStartTime#hours
   */
  readonly hours: number;

  /**
   * Specifies the minute of opening.
   *
   * @schema HoursOfOperationSpecForProviderConfigStartTime#minutes
   */
  readonly minutes: number;

}

/**
 * Converts an object of type 'HoursOfOperationSpecForProviderConfigStartTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecForProviderConfigStartTime(obj: HoursOfOperationSpecForProviderConfigStartTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HoursOfOperationSpecForProviderInstanceIdRefPolicy
 */
export interface HoursOfOperationSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HoursOfOperationSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: HoursOfOperationSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HoursOfOperationSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: HoursOfOperationSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HoursOfOperationSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecForProviderInstanceIdRefPolicy(obj: HoursOfOperationSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HoursOfOperationSpecForProviderInstanceIdSelectorPolicy
 */
export interface HoursOfOperationSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HoursOfOperationSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: HoursOfOperationSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HoursOfOperationSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: HoursOfOperationSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HoursOfOperationSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecForProviderInstanceIdSelectorPolicy(obj: HoursOfOperationSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HoursOfOperationSpecProviderConfigRefPolicyResolution
 */
export enum HoursOfOperationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HoursOfOperationSpecProviderConfigRefPolicyResolve
 */
export enum HoursOfOperationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HoursOfOperationSpecProviderRefPolicyResolution
 */
export enum HoursOfOperationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HoursOfOperationSpecProviderRefPolicyResolve
 */
export enum HoursOfOperationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicy(obj: HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HoursOfOperationSpecForProviderInstanceIdRefPolicyResolution
 */
export enum HoursOfOperationSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HoursOfOperationSpecForProviderInstanceIdRefPolicyResolve
 */
export enum HoursOfOperationSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HoursOfOperationSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum HoursOfOperationSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HoursOfOperationSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum HoursOfOperationSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HoursOfOperationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Instance is the Schema for the Instances API. Provides details about a specific Connect Instance.
 *
 * @schema Instance
 */
export class Instance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Instance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'Instance',
  }

  /**
   * Renders a Kubernetes manifest for "Instance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProps): any {
    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(props),
    };
  }

  /**
   * Defines a "Instance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProps) {
    super(scope, id, {
      ...Instance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(resolved),
    };
  }
}

/**
 * Instance is the Schema for the Instances API. Provides details about a specific Connect Instance.
 *
 * @schema Instance
 */
export interface InstanceProps {
  /**
   * @schema Instance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceSpec defines the desired state of Instance
   *
   * @schema Instance#spec
   */
  readonly spec: InstanceSpec;

}

/**
 * Converts an object of type 'InstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProps(obj: InstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSpec defines the desired state of Instance
 *
 * @schema InstanceSpec
 */
export interface InstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceSpecDeletionPolicy;

  /**
   * @schema InstanceSpec#forProvider
   */
  readonly forProvider: InstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#managementPolicy
   */
  readonly managementPolicy?: InstanceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InstanceSpec#providerRef
   */
  readonly providerRef?: InstanceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpec(obj: InstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_InstanceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InstanceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecDeletionPolicy
 */
export enum InstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceSpecForProvider
 */
export interface InstanceSpecForProvider {
  /**
   * Specifies whether auto resolve best voices is enabled. Defaults to true.
   *
   * @default true.
   * @schema InstanceSpecForProvider#autoResolveBestVoicesEnabled
   */
  readonly autoResolveBestVoicesEnabled?: boolean;

  /**
   * Specifies whether contact flow logs are enabled. Defaults to false.
   *
   * @default false.
   * @schema InstanceSpecForProvider#contactFlowLogsEnabled
   */
  readonly contactFlowLogsEnabled?: boolean;

  /**
   * Specifies whether contact lens is enabled. Defaults to true.
   *
   * @default true.
   * @schema InstanceSpecForProvider#contactLensEnabled
   */
  readonly contactLensEnabled?: boolean;

  /**
   * The identifier for the directory if identity_management_type is EXISTING_DIRECTORY.
   *
   * @schema InstanceSpecForProvider#directoryId
   */
  readonly directoryId?: string;

  /**
   * Reference to a Directory in ds to populate directoryId.
   *
   * @schema InstanceSpecForProvider#directoryIdRef
   */
  readonly directoryIdRef?: InstanceSpecForProviderDirectoryIdRef;

  /**
   * Selector for a Directory in ds to populate directoryId.
   *
   * @schema InstanceSpecForProvider#directoryIdSelector
   */
  readonly directoryIdSelector?: InstanceSpecForProviderDirectoryIdSelector;

  /**
   * Specifies whether early media for outbound calls is enabled . Defaults to true if outbound calls is enabled.
   *
   * @default true if outbound calls is enabled.
   * @schema InstanceSpecForProvider#earlyMediaEnabled
   */
  readonly earlyMediaEnabled?: boolean;

  /**
   * Specifies the identity management type attached to the instance. Allowed Values are: SAML, CONNECT_MANAGED, EXISTING_DIRECTORY.
   *
   * @schema InstanceSpecForProvider#identityManagementType
   */
  readonly identityManagementType?: string;

  /**
   * Specifies whether inbound calls are enabled.
   *
   * @schema InstanceSpecForProvider#inboundCallsEnabled
   */
  readonly inboundCallsEnabled?: boolean;

  /**
   * Specifies the name of the instance. Required if directory_id not specified.
   *
   * @schema InstanceSpecForProvider#instanceAlias
   */
  readonly instanceAlias?: string;

  /**
   * Specifies whether multi-party calls/conference is enabled. Defaults to false.
   *
   * @default false.
   * @schema InstanceSpecForProvider#multiPartyConferenceEnabled
   */
  readonly multiPartyConferenceEnabled?: boolean;

  /**
   * Specifies whether outbound calls are enabled.
   *
   * @schema InstanceSpecForProvider#outboundCallsEnabled
   */
  readonly outboundCallsEnabled?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InstanceSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'InstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProvider(obj: InstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoResolveBestVoicesEnabled': obj.autoResolveBestVoicesEnabled,
    'contactFlowLogsEnabled': obj.contactFlowLogsEnabled,
    'contactLensEnabled': obj.contactLensEnabled,
    'directoryId': obj.directoryId,
    'directoryIdRef': toJson_InstanceSpecForProviderDirectoryIdRef(obj.directoryIdRef),
    'directoryIdSelector': toJson_InstanceSpecForProviderDirectoryIdSelector(obj.directoryIdSelector),
    'earlyMediaEnabled': obj.earlyMediaEnabled,
    'identityManagementType': obj.identityManagementType,
    'inboundCallsEnabled': obj.inboundCallsEnabled,
    'instanceAlias': obj.instanceAlias,
    'multiPartyConferenceEnabled': obj.multiPartyConferenceEnabled,
    'outboundCallsEnabled': obj.outboundCallsEnabled,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecManagementPolicy
 */
export enum InstanceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceSpecProviderConfigRef
 */
export interface InstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRef(obj: InstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InstanceSpecProviderRef
 */
export interface InstanceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderRef#policy
   */
  readonly policy?: InstanceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderRef(obj: InstanceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceSpecPublishConnectionDetailsTo
 */
export interface InstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsTo(obj: InstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceSpecWriteConnectionSecretToRef
 */
export interface InstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecWriteConnectionSecretToRef(obj: InstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Directory in ds to populate directoryId.
 *
 * @schema InstanceSpecForProviderDirectoryIdRef
 */
export interface InstanceSpecForProviderDirectoryIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderDirectoryIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderDirectoryIdRef#policy
   */
  readonly policy?: InstanceSpecForProviderDirectoryIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDirectoryIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDirectoryIdRef(obj: InstanceSpecForProviderDirectoryIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderDirectoryIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Directory in ds to populate directoryId.
 *
 * @schema InstanceSpecForProviderDirectoryIdSelector
 */
export interface InstanceSpecForProviderDirectoryIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderDirectoryIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderDirectoryIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderDirectoryIdSelector#policy
   */
  readonly policy?: InstanceSpecForProviderDirectoryIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDirectoryIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDirectoryIdSelector(obj: InstanceSpecForProviderDirectoryIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderDirectoryIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderConfigRefPolicy
 */
export interface InstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRefPolicy(obj: InstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderRefPolicy
 */
export interface InstanceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderRefPolicy(obj: InstanceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj: InstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj: InstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderDirectoryIdRefPolicy
 */
export interface InstanceSpecForProviderDirectoryIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderDirectoryIdRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderDirectoryIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderDirectoryIdRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderDirectoryIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDirectoryIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDirectoryIdRefPolicy(obj: InstanceSpecForProviderDirectoryIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderDirectoryIdSelectorPolicy
 */
export interface InstanceSpecForProviderDirectoryIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderDirectoryIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderDirectoryIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderDirectoryIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderDirectoryIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDirectoryIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDirectoryIdSelectorPolicy(obj: InstanceSpecForProviderDirectoryIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolution
 */
export enum InstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolve
 */
export enum InstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderRefPolicyResolution
 */
export enum InstanceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderRefPolicyResolve
 */
export enum InstanceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderDirectoryIdRefPolicyResolution
 */
export enum InstanceSpecForProviderDirectoryIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderDirectoryIdRefPolicyResolve
 */
export enum InstanceSpecForProviderDirectoryIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderDirectoryIdSelectorPolicyResolution
 */
export enum InstanceSpecForProviderDirectoryIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderDirectoryIdSelectorPolicyResolve
 */
export enum InstanceSpecForProviderDirectoryIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InstanceStorageConfig is the Schema for the InstanceStorageConfigs API. Provides details about a specific Amazon Connect Instance Storage Config.
 *
 * @schema InstanceStorageConfig
 */
export class InstanceStorageConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InstanceStorageConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'InstanceStorageConfig',
  }

  /**
   * Renders a Kubernetes manifest for "InstanceStorageConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceStorageConfigProps): any {
    return {
      ...InstanceStorageConfig.GVK,
      ...toJson_InstanceStorageConfigProps(props),
    };
  }

  /**
   * Defines a "InstanceStorageConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceStorageConfigProps) {
    super(scope, id, {
      ...InstanceStorageConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InstanceStorageConfig.GVK,
      ...toJson_InstanceStorageConfigProps(resolved),
    };
  }
}

/**
 * InstanceStorageConfig is the Schema for the InstanceStorageConfigs API. Provides details about a specific Amazon Connect Instance Storage Config.
 *
 * @schema InstanceStorageConfig
 */
export interface InstanceStorageConfigProps {
  /**
   * @schema InstanceStorageConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceStorageConfigSpec defines the desired state of InstanceStorageConfig
   *
   * @schema InstanceStorageConfig#spec
   */
  readonly spec: InstanceStorageConfigSpec;

}

/**
 * Converts an object of type 'InstanceStorageConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigProps(obj: InstanceStorageConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceStorageConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceStorageConfigSpec defines the desired state of InstanceStorageConfig
 *
 * @schema InstanceStorageConfigSpec
 */
export interface InstanceStorageConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceStorageConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceStorageConfigSpecDeletionPolicy;

  /**
   * @schema InstanceStorageConfigSpec#forProvider
   */
  readonly forProvider: InstanceStorageConfigSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceStorageConfigSpec#managementPolicy
   */
  readonly managementPolicy?: InstanceStorageConfigSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceStorageConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceStorageConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InstanceStorageConfigSpec#providerRef
   */
  readonly providerRef?: InstanceStorageConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceStorageConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceStorageConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceStorageConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceStorageConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpec(obj: InstanceStorageConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceStorageConfigSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_InstanceStorageConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InstanceStorageConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InstanceStorageConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceStorageConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceStorageConfigSpecDeletionPolicy
 */
export enum InstanceStorageConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceStorageConfigSpecForProvider
 */
export interface InstanceStorageConfigSpecForProvider {
  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema InstanceStorageConfigSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema InstanceStorageConfigSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: InstanceStorageConfigSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema InstanceStorageConfigSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: InstanceStorageConfigSpecForProviderInstanceIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InstanceStorageConfigSpecForProvider#region
   */
  readonly region: string;

  /**
   * A valid resource type. Valid Values: CHAT_TRANSCRIPTS | CALL_RECORDINGS | SCHEDULED_REPORTS | MEDIA_STREAMS | CONTACT_TRACE_RECORDS | AGENT_EVENTS | REAL_TIME_CONTACT_ANALYSIS_SEGMENTS.
   *
   * @schema InstanceStorageConfigSpecForProvider#resourceType
   */
  readonly resourceType?: string;

  /**
   * Specifies the storage configuration options for the Connect Instance. Documented below.
   *
   * @schema InstanceStorageConfigSpecForProvider#storageConfig
   */
  readonly storageConfig?: InstanceStorageConfigSpecForProviderStorageConfig[];

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProvider(obj: InstanceStorageConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_InstanceStorageConfigSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_InstanceStorageConfigSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'region': obj.region,
    'resourceType': obj.resourceType,
    'storageConfig': obj.storageConfig?.map(y => toJson_InstanceStorageConfigSpecForProviderStorageConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceStorageConfigSpecManagementPolicy
 */
export enum InstanceStorageConfigSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceStorageConfigSpecProviderConfigRef
 */
export interface InstanceStorageConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceStorageConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceStorageConfigSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceStorageConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecProviderConfigRef(obj: InstanceStorageConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceStorageConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InstanceStorageConfigSpecProviderRef
 */
export interface InstanceStorageConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceStorageConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceStorageConfigSpecProviderRef#policy
   */
  readonly policy?: InstanceStorageConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecProviderRef(obj: InstanceStorageConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceStorageConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceStorageConfigSpecPublishConnectionDetailsTo
 */
export interface InstanceStorageConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceStorageConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceStorageConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceStorageConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceStorageConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceStorageConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecPublishConnectionDetailsTo(obj: InstanceStorageConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceStorageConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceStorageConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceStorageConfigSpecWriteConnectionSecretToRef
 */
export interface InstanceStorageConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceStorageConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceStorageConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecWriteConnectionSecretToRef(obj: InstanceStorageConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema InstanceStorageConfigSpecForProviderInstanceIdRef
 */
export interface InstanceStorageConfigSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceStorageConfigSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceStorageConfigSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderInstanceIdRef(obj: InstanceStorageConfigSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceStorageConfigSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema InstanceStorageConfigSpecForProviderInstanceIdSelector
 */
export interface InstanceStorageConfigSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceStorageConfigSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderInstanceIdSelector(obj: InstanceStorageConfigSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceStorageConfigSpecForProviderStorageConfig
 */
export interface InstanceStorageConfigSpecForProviderStorageConfig {
  /**
   * A block that specifies the configuration of the Kinesis Firehose delivery stream. Documented below.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfig#kinesisFirehoseConfig
   */
  readonly kinesisFirehoseConfig?: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfig[];

  /**
   * A block that specifies the configuration of the Kinesis data stream. Documented below.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfig#kinesisStreamConfig
   */
  readonly kinesisStreamConfig?: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfig[];

  /**
   * A block that specifies the configuration of the Kinesis video stream. Documented below.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfig#kinesisVideoStreamConfig
   */
  readonly kinesisVideoStreamConfig?: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfig[];

  /**
   * A block that specifies the configuration of S3 Bucket. Documented below.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfig#s3Config
   */
  readonly s3Config?: InstanceStorageConfigSpecForProviderStorageConfigS3Config[];

  /**
   * A valid storage type. Valid Values: S3 | KINESIS_VIDEO_STREAM | KINESIS_STREAM | KINESIS_FIREHOSE.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfig#storageType
   */
  readonly storageType: string;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfig(obj: InstanceStorageConfigSpecForProviderStorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinesisFirehoseConfig': obj.kinesisFirehoseConfig?.map(y => toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfig(y)),
    'kinesisStreamConfig': obj.kinesisStreamConfig?.map(y => toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfig(y)),
    'kinesisVideoStreamConfig': obj.kinesisVideoStreamConfig?.map(y => toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfig(y)),
    's3Config': obj.s3Config?.map(y => toJson_InstanceStorageConfigSpecForProviderStorageConfigS3Config(y)),
    'storageType': obj.storageType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceStorageConfigSpecProviderConfigRefPolicy
 */
export interface InstanceStorageConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecProviderConfigRefPolicy(obj: InstanceStorageConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceStorageConfigSpecProviderRefPolicy
 */
export interface InstanceStorageConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecProviderRefPolicy(obj: InstanceStorageConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceStorageConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceStorageConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceStorageConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceStorageConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecPublishConnectionDetailsToConfigRef(obj: InstanceStorageConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceStorageConfigSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceStorageConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceStorageConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceStorageConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceStorageConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecPublishConnectionDetailsToMetadata(obj: InstanceStorageConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceStorageConfigSpecForProviderInstanceIdRefPolicy
 */
export interface InstanceStorageConfigSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderInstanceIdRefPolicy(obj: InstanceStorageConfigSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicy
 */
export interface InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicy(obj: InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfig
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfig {
  /**
   * The Amazon Resource Name (ARN) of the delivery stream.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfig#firehoseArn
   */
  readonly firehoseArn?: string;

  /**
   * Reference to a DeliveryStream in firehose to populate firehoseArn.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfig#firehoseArnRef
   */
  readonly firehoseArnRef?: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRef;

  /**
   * Selector for a DeliveryStream in firehose to populate firehoseArn.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfig#firehoseArnSelector
   */
  readonly firehoseArnSelector?: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelector;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfig(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'firehoseArn': obj.firehoseArn,
    'firehoseArnRef': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRef(obj.firehoseArnRef),
    'firehoseArnSelector': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelector(obj.firehoseArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfig
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfig {
  /**
   * The Amazon Resource Name (ARN) of the data stream.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfig#streamArn
   */
  readonly streamArn?: string;

  /**
   * Reference to a Stream in kinesis to populate streamArn.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfig#streamArnRef
   */
  readonly streamArnRef?: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRef;

  /**
   * Selector for a Stream in kinesis to populate streamArn.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfig#streamArnSelector
   */
  readonly streamArnSelector?: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelector;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfig(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'streamArn': obj.streamArn,
    'streamArnRef': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRef(obj.streamArnRef),
    'streamArnSelector': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelector(obj.streamArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfig
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfig {
  /**
   * The encryption configuration. Documented below.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfig#encryptionConfig
   */
  readonly encryptionConfig: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig[];

  /**
   * The prefix of the video stream. Minimum length of 1. Maximum length of 128. When read from the state, the value returned is <prefix>-connect-<connect_instance_alias>-contact- since the API appends additional details to the prefix.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfig#prefix
   */
  readonly prefix: string;

  /**
   * The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. Minimum value of 0. Maximum value of 87600. A value of 0, indicates that the stream does not persist data.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfig#retentionPeriodHours
   */
  readonly retentionPeriodHours: number;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfig(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionConfig': obj.encryptionConfig?.map(y => toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig(y)),
    'prefix': obj.prefix,
    'retentionPeriodHours': obj.retentionPeriodHours,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3Config
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigS3Config {
  /**
   * The S3 bucket name.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3Config#bucketName
   */
  readonly bucketName?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketName.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3Config#bucketNameRef
   */
  readonly bucketNameRef?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRef;

  /**
   * Selector for a Bucket in s3 to populate bucketName.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3Config#bucketNameSelector
   */
  readonly bucketNameSelector?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelector;

  /**
   * The S3 bucket prefix.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3Config#bucketPrefix
   */
  readonly bucketPrefix: string;

  /**
   * The encryption configuration. Documented below.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3Config#encryptionConfig
   */
  readonly encryptionConfig?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig[];

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigS3Config' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigS3Config(obj: InstanceStorageConfigSpecForProviderStorageConfigS3Config | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketNameRef': toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRef(obj.bucketNameRef),
    'bucketNameSelector': toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelector(obj.bucketNameSelector),
    'bucketPrefix': obj.bucketPrefix,
    'encryptionConfig': obj.encryptionConfig?.map(y => toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecProviderConfigRefPolicyResolution
 */
export enum InstanceStorageConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecProviderConfigRefPolicyResolve
 */
export enum InstanceStorageConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecProviderRefPolicyResolution
 */
export enum InstanceStorageConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecProviderRefPolicyResolve
 */
export enum InstanceStorageConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderInstanceIdRefPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderInstanceIdRefPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a DeliveryStream in firehose to populate firehoseArn.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRef
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRef#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRef(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DeliveryStream in firehose to populate firehoseArn.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelector
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelector#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelector(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stream in kinesis to populate streamArn.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRef
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRef#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRef(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stream in kinesis to populate streamArn.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelector
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelector#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelector(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig {
  /**
   * The type of encryption. Valid Values: KMS.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig#encryptionType
   */
  readonly encryptionType: string;

  /**
   * The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig#keyId
   */
  readonly keyId?: string;

  /**
   * Reference to a Key in kms to populate keyId.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig#keyIdRef
   */
  readonly keyIdRef?: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRef;

  /**
   * Selector for a Key in kms to populate keyId.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig#keyIdSelector
   */
  readonly keyIdSelector?: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelector;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionType': obj.encryptionType,
    'keyId': obj.keyId,
    'keyIdRef': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRef(obj.keyIdRef),
    'keyIdSelector': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelector(obj.keyIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucketName.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRef
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRef#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRef(obj: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketName.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelector
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelector#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelector(obj: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig {
  /**
   * The type of encryption. Valid Values: KMS.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig#encryptionType
   */
  readonly encryptionType: string;

  /**
   * The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig#keyId
   */
  readonly keyId?: string;

  /**
   * Reference to a Key in kms to populate keyId.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig#keyIdRef
   */
  readonly keyIdRef?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRef;

  /**
   * Selector for a Key in kms to populate keyId.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig#keyIdSelector
   */
  readonly keyIdSelector?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelector;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig(obj: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionType': obj.encryptionType,
    'keyId': obj.keyId,
    'keyIdRef': toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRef(obj.keyIdRef),
    'keyIdSelector': toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelector(obj.keyIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceStorageConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicy
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicy(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicy
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicy(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicy
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicy(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicy
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicy(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate keyId.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRef
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRef#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRef(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate keyId.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelector
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelector#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelector(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicy
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicy(obj: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicy
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicy(obj: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate keyId.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRef
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRef#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRef(obj: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate keyId.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelector
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelector#policy
   */
  readonly policy?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelector(obj: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisFirehoseConfigFirehoseArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisStreamConfigStreamArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicy
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicy(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicy
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicy(obj: InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigS3ConfigBucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicy
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicy(obj: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicy
 */
export interface InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicy(obj: InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigKinesisVideoStreamConfigEncryptionConfigKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicyResolution
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicyResolve
 */
export enum InstanceStorageConfigSpecForProviderStorageConfigS3ConfigEncryptionConfigKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LambdaFunctionAssociation is the Schema for the LambdaFunctionAssociations API. Provides details about a specific Connect Lambda Function Association.
 *
 * @schema LambdaFunctionAssociation
 */
export class LambdaFunctionAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LambdaFunctionAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'LambdaFunctionAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "LambdaFunctionAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LambdaFunctionAssociationProps): any {
    return {
      ...LambdaFunctionAssociation.GVK,
      ...toJson_LambdaFunctionAssociationProps(props),
    };
  }

  /**
   * Defines a "LambdaFunctionAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LambdaFunctionAssociationProps) {
    super(scope, id, {
      ...LambdaFunctionAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LambdaFunctionAssociation.GVK,
      ...toJson_LambdaFunctionAssociationProps(resolved),
    };
  }
}

/**
 * LambdaFunctionAssociation is the Schema for the LambdaFunctionAssociations API. Provides details about a specific Connect Lambda Function Association.
 *
 * @schema LambdaFunctionAssociation
 */
export interface LambdaFunctionAssociationProps {
  /**
   * @schema LambdaFunctionAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LambdaFunctionAssociationSpec defines the desired state of LambdaFunctionAssociation
   *
   * @schema LambdaFunctionAssociation#spec
   */
  readonly spec: LambdaFunctionAssociationSpec;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationProps(obj: LambdaFunctionAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LambdaFunctionAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LambdaFunctionAssociationSpec defines the desired state of LambdaFunctionAssociation
 *
 * @schema LambdaFunctionAssociationSpec
 */
export interface LambdaFunctionAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LambdaFunctionAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: LambdaFunctionAssociationSpecDeletionPolicy;

  /**
   * @schema LambdaFunctionAssociationSpec#forProvider
   */
  readonly forProvider: LambdaFunctionAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LambdaFunctionAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: LambdaFunctionAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LambdaFunctionAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: LambdaFunctionAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LambdaFunctionAssociationSpec#providerRef
   */
  readonly providerRef?: LambdaFunctionAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LambdaFunctionAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LambdaFunctionAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LambdaFunctionAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LambdaFunctionAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpec(obj: LambdaFunctionAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LambdaFunctionAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LambdaFunctionAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LambdaFunctionAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LambdaFunctionAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LambdaFunctionAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LambdaFunctionAssociationSpecDeletionPolicy
 */
export enum LambdaFunctionAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LambdaFunctionAssociationSpecForProvider
 */
export interface LambdaFunctionAssociationSpecForProvider {
  /**
   * Amazon Resource Name (ARN) of the Lambda Function, omitting any version or alias qualifier.
   *
   * @schema LambdaFunctionAssociationSpecForProvider#functionArn
   */
  readonly functionArn?: string;

  /**
   * Reference to a Function in lambda to populate functionArn.
   *
   * @schema LambdaFunctionAssociationSpecForProvider#functionArnRef
   */
  readonly functionArnRef?: LambdaFunctionAssociationSpecForProviderFunctionArnRef;

  /**
   * Selector for a Function in lambda to populate functionArn.
   *
   * @schema LambdaFunctionAssociationSpecForProvider#functionArnSelector
   */
  readonly functionArnSelector?: LambdaFunctionAssociationSpecForProviderFunctionArnSelector;

  /**
   * The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
   *
   * @schema LambdaFunctionAssociationSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema LambdaFunctionAssociationSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: LambdaFunctionAssociationSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema LambdaFunctionAssociationSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: LambdaFunctionAssociationSpecForProviderInstanceIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LambdaFunctionAssociationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecForProvider(obj: LambdaFunctionAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionArn': obj.functionArn,
    'functionArnRef': toJson_LambdaFunctionAssociationSpecForProviderFunctionArnRef(obj.functionArnRef),
    'functionArnSelector': toJson_LambdaFunctionAssociationSpecForProviderFunctionArnSelector(obj.functionArnSelector),
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_LambdaFunctionAssociationSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_LambdaFunctionAssociationSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LambdaFunctionAssociationSpecManagementPolicy
 */
export enum LambdaFunctionAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LambdaFunctionAssociationSpecProviderConfigRef
 */
export interface LambdaFunctionAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LambdaFunctionAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LambdaFunctionAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: LambdaFunctionAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecProviderConfigRef(obj: LambdaFunctionAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LambdaFunctionAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LambdaFunctionAssociationSpecProviderRef
 */
export interface LambdaFunctionAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LambdaFunctionAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LambdaFunctionAssociationSpecProviderRef#policy
   */
  readonly policy?: LambdaFunctionAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecProviderRef(obj: LambdaFunctionAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LambdaFunctionAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsTo
 */
export interface LambdaFunctionAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LambdaFunctionAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecPublishConnectionDetailsTo(obj: LambdaFunctionAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LambdaFunctionAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LambdaFunctionAssociationSpecWriteConnectionSecretToRef
 */
export interface LambdaFunctionAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LambdaFunctionAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LambdaFunctionAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecWriteConnectionSecretToRef(obj: LambdaFunctionAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate functionArn.
 *
 * @schema LambdaFunctionAssociationSpecForProviderFunctionArnRef
 */
export interface LambdaFunctionAssociationSpecForProviderFunctionArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LambdaFunctionAssociationSpecForProviderFunctionArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LambdaFunctionAssociationSpecForProviderFunctionArnRef#policy
   */
  readonly policy?: LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicy;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecForProviderFunctionArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecForProviderFunctionArnRef(obj: LambdaFunctionAssociationSpecForProviderFunctionArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate functionArn.
 *
 * @schema LambdaFunctionAssociationSpecForProviderFunctionArnSelector
 */
export interface LambdaFunctionAssociationSpecForProviderFunctionArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LambdaFunctionAssociationSpecForProviderFunctionArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LambdaFunctionAssociationSpecForProviderFunctionArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LambdaFunctionAssociationSpecForProviderFunctionArnSelector#policy
   */
  readonly policy?: LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicy;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecForProviderFunctionArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecForProviderFunctionArnSelector(obj: LambdaFunctionAssociationSpecForProviderFunctionArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema LambdaFunctionAssociationSpecForProviderInstanceIdRef
 */
export interface LambdaFunctionAssociationSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LambdaFunctionAssociationSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LambdaFunctionAssociationSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecForProviderInstanceIdRef(obj: LambdaFunctionAssociationSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema LambdaFunctionAssociationSpecForProviderInstanceIdSelector
 */
export interface LambdaFunctionAssociationSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LambdaFunctionAssociationSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LambdaFunctionAssociationSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LambdaFunctionAssociationSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecForProviderInstanceIdSelector(obj: LambdaFunctionAssociationSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LambdaFunctionAssociationSpecProviderConfigRefPolicy
 */
export interface LambdaFunctionAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LambdaFunctionAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LambdaFunctionAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LambdaFunctionAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LambdaFunctionAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecProviderConfigRefPolicy(obj: LambdaFunctionAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LambdaFunctionAssociationSpecProviderRefPolicy
 */
export interface LambdaFunctionAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LambdaFunctionAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LambdaFunctionAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LambdaFunctionAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LambdaFunctionAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecProviderRefPolicy(obj: LambdaFunctionAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRef(obj: LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface LambdaFunctionAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecPublishConnectionDetailsToMetadata(obj: LambdaFunctionAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicy
 */
export interface LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicy#resolution
   */
  readonly resolution?: LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicy#resolve
   */
  readonly resolve?: LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicy(obj: LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicy
 */
export interface LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicy#resolution
   */
  readonly resolution?: LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicy#resolve
   */
  readonly resolve?: LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicy(obj: LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicy
 */
export interface LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicy(obj: LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicy
 */
export interface LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicy(obj: LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LambdaFunctionAssociationSpecProviderConfigRefPolicyResolution
 */
export enum LambdaFunctionAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LambdaFunctionAssociationSpecProviderConfigRefPolicyResolve
 */
export enum LambdaFunctionAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LambdaFunctionAssociationSpecProviderRefPolicyResolution
 */
export enum LambdaFunctionAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LambdaFunctionAssociationSpecProviderRefPolicyResolve
 */
export enum LambdaFunctionAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicyResolution
 */
export enum LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicyResolve
 */
export enum LambdaFunctionAssociationSpecForProviderFunctionArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicyResolution
 */
export enum LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicyResolve
 */
export enum LambdaFunctionAssociationSpecForProviderFunctionArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicyResolution
 */
export enum LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicyResolve
 */
export enum LambdaFunctionAssociationSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum LambdaFunctionAssociationSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LambdaFunctionAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PhoneNumber is the Schema for the PhoneNumbers API. Provides details about a specific Amazon Connect Phone Number.
 *
 * @schema PhoneNumber
 */
export class PhoneNumber extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PhoneNumber"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'PhoneNumber',
  }

  /**
   * Renders a Kubernetes manifest for "PhoneNumber".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PhoneNumberProps): any {
    return {
      ...PhoneNumber.GVK,
      ...toJson_PhoneNumberProps(props),
    };
  }

  /**
   * Defines a "PhoneNumber" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PhoneNumberProps) {
    super(scope, id, {
      ...PhoneNumber.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PhoneNumber.GVK,
      ...toJson_PhoneNumberProps(resolved),
    };
  }
}

/**
 * PhoneNumber is the Schema for the PhoneNumbers API. Provides details about a specific Amazon Connect Phone Number.
 *
 * @schema PhoneNumber
 */
export interface PhoneNumberProps {
  /**
   * @schema PhoneNumber#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PhoneNumberSpec defines the desired state of PhoneNumber
   *
   * @schema PhoneNumber#spec
   */
  readonly spec: PhoneNumberSpec;

}

/**
 * Converts an object of type 'PhoneNumberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberProps(obj: PhoneNumberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PhoneNumberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PhoneNumberSpec defines the desired state of PhoneNumber
 *
 * @schema PhoneNumberSpec
 */
export interface PhoneNumberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PhoneNumberSpec#deletionPolicy
   */
  readonly deletionPolicy?: PhoneNumberSpecDeletionPolicy;

  /**
   * @schema PhoneNumberSpec#forProvider
   */
  readonly forProvider: PhoneNumberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PhoneNumberSpec#managementPolicy
   */
  readonly managementPolicy?: PhoneNumberSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PhoneNumberSpec#providerConfigRef
   */
  readonly providerConfigRef?: PhoneNumberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PhoneNumberSpec#providerRef
   */
  readonly providerRef?: PhoneNumberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PhoneNumberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PhoneNumberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PhoneNumberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PhoneNumberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PhoneNumberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpec(obj: PhoneNumberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PhoneNumberSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PhoneNumberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PhoneNumberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PhoneNumberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PhoneNumberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PhoneNumberSpecDeletionPolicy
 */
export enum PhoneNumberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PhoneNumberSpecForProvider
 */
export interface PhoneNumberSpecForProvider {
  /**
   * The ISO country code. For a list of Valid values, refer to PhoneNumberCountryCode.
   *
   * @schema PhoneNumberSpecForProvider#countryCode
   */
  readonly countryCode?: string;

  /**
   * The description of the phone number.
   *
   * @schema PhoneNumberSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The prefix of the phone number that is used to filter available phone numbers. If provided, it must contain + as part of the country code. Do not specify this argument when importing the resource.
   *
   * @schema PhoneNumberSpecForProvider#prefix
   */
  readonly prefix?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PhoneNumberSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PhoneNumberSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The Amazon Resource Name (ARN) for Amazon Connect instances that phone numbers are claimed to.
   *
   * @schema PhoneNumberSpecForProvider#targetArn
   */
  readonly targetArn?: string;

  /**
   * Reference to a Instance in connect to populate targetArn.
   *
   * @schema PhoneNumberSpecForProvider#targetArnRef
   */
  readonly targetArnRef?: PhoneNumberSpecForProviderTargetArnRef;

  /**
   * Selector for a Instance in connect to populate targetArn.
   *
   * @schema PhoneNumberSpecForProvider#targetArnSelector
   */
  readonly targetArnSelector?: PhoneNumberSpecForProviderTargetArnSelector;

  /**
   * The type of phone number. Valid Values: TOLL_FREE | DID.
   *
   * @schema PhoneNumberSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PhoneNumberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecForProvider(obj: PhoneNumberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'countryCode': obj.countryCode,
    'description': obj.description,
    'prefix': obj.prefix,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetArn': obj.targetArn,
    'targetArnRef': toJson_PhoneNumberSpecForProviderTargetArnRef(obj.targetArnRef),
    'targetArnSelector': toJson_PhoneNumberSpecForProviderTargetArnSelector(obj.targetArnSelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PhoneNumberSpecManagementPolicy
 */
export enum PhoneNumberSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PhoneNumberSpecProviderConfigRef
 */
export interface PhoneNumberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PhoneNumberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PhoneNumberSpecProviderConfigRef#policy
   */
  readonly policy?: PhoneNumberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PhoneNumberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecProviderConfigRef(obj: PhoneNumberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PhoneNumberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PhoneNumberSpecProviderRef
 */
export interface PhoneNumberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PhoneNumberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PhoneNumberSpecProviderRef#policy
   */
  readonly policy?: PhoneNumberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PhoneNumberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecProviderRef(obj: PhoneNumberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PhoneNumberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PhoneNumberSpecPublishConnectionDetailsTo
 */
export interface PhoneNumberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PhoneNumberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PhoneNumberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PhoneNumberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PhoneNumberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PhoneNumberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PhoneNumberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecPublishConnectionDetailsTo(obj: PhoneNumberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PhoneNumberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PhoneNumberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PhoneNumberSpecWriteConnectionSecretToRef
 */
export interface PhoneNumberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PhoneNumberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PhoneNumberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PhoneNumberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecWriteConnectionSecretToRef(obj: PhoneNumberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate targetArn.
 *
 * @schema PhoneNumberSpecForProviderTargetArnRef
 */
export interface PhoneNumberSpecForProviderTargetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PhoneNumberSpecForProviderTargetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PhoneNumberSpecForProviderTargetArnRef#policy
   */
  readonly policy?: PhoneNumberSpecForProviderTargetArnRefPolicy;

}

/**
 * Converts an object of type 'PhoneNumberSpecForProviderTargetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecForProviderTargetArnRef(obj: PhoneNumberSpecForProviderTargetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PhoneNumberSpecForProviderTargetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate targetArn.
 *
 * @schema PhoneNumberSpecForProviderTargetArnSelector
 */
export interface PhoneNumberSpecForProviderTargetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PhoneNumberSpecForProviderTargetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PhoneNumberSpecForProviderTargetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PhoneNumberSpecForProviderTargetArnSelector#policy
   */
  readonly policy?: PhoneNumberSpecForProviderTargetArnSelectorPolicy;

}

/**
 * Converts an object of type 'PhoneNumberSpecForProviderTargetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecForProviderTargetArnSelector(obj: PhoneNumberSpecForProviderTargetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PhoneNumberSpecForProviderTargetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PhoneNumberSpecProviderConfigRefPolicy
 */
export interface PhoneNumberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhoneNumberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PhoneNumberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhoneNumberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PhoneNumberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PhoneNumberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecProviderConfigRefPolicy(obj: PhoneNumberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PhoneNumberSpecProviderRefPolicy
 */
export interface PhoneNumberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhoneNumberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PhoneNumberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhoneNumberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PhoneNumberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PhoneNumberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecProviderRefPolicy(obj: PhoneNumberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PhoneNumberSpecPublishConnectionDetailsToConfigRef
 */
export interface PhoneNumberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PhoneNumberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PhoneNumberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PhoneNumberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecPublishConnectionDetailsToConfigRef(obj: PhoneNumberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PhoneNumberSpecPublishConnectionDetailsToMetadata
 */
export interface PhoneNumberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PhoneNumberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PhoneNumberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PhoneNumberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PhoneNumberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecPublishConnectionDetailsToMetadata(obj: PhoneNumberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PhoneNumberSpecForProviderTargetArnRefPolicy
 */
export interface PhoneNumberSpecForProviderTargetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhoneNumberSpecForProviderTargetArnRefPolicy#resolution
   */
  readonly resolution?: PhoneNumberSpecForProviderTargetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhoneNumberSpecForProviderTargetArnRefPolicy#resolve
   */
  readonly resolve?: PhoneNumberSpecForProviderTargetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PhoneNumberSpecForProviderTargetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecForProviderTargetArnRefPolicy(obj: PhoneNumberSpecForProviderTargetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PhoneNumberSpecForProviderTargetArnSelectorPolicy
 */
export interface PhoneNumberSpecForProviderTargetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhoneNumberSpecForProviderTargetArnSelectorPolicy#resolution
   */
  readonly resolution?: PhoneNumberSpecForProviderTargetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhoneNumberSpecForProviderTargetArnSelectorPolicy#resolve
   */
  readonly resolve?: PhoneNumberSpecForProviderTargetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PhoneNumberSpecForProviderTargetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecForProviderTargetArnSelectorPolicy(obj: PhoneNumberSpecForProviderTargetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhoneNumberSpecProviderConfigRefPolicyResolution
 */
export enum PhoneNumberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhoneNumberSpecProviderConfigRefPolicyResolve
 */
export enum PhoneNumberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhoneNumberSpecProviderRefPolicyResolution
 */
export enum PhoneNumberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhoneNumberSpecProviderRefPolicyResolve
 */
export enum PhoneNumberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicy(obj: PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhoneNumberSpecForProviderTargetArnRefPolicyResolution
 */
export enum PhoneNumberSpecForProviderTargetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhoneNumberSpecForProviderTargetArnRefPolicyResolve
 */
export enum PhoneNumberSpecForProviderTargetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhoneNumberSpecForProviderTargetArnSelectorPolicyResolution
 */
export enum PhoneNumberSpecForProviderTargetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhoneNumberSpecForProviderTargetArnSelectorPolicyResolve
 */
export enum PhoneNumberSpecForProviderTargetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PhoneNumberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Queue is the Schema for the Queues API. Provides details about a specific Amazon Connect Queue
 *
 * @schema Queue
 */
export class Queue extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Queue"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'Queue',
  }

  /**
   * Renders a Kubernetes manifest for "Queue".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: QueueProps): any {
    return {
      ...Queue.GVK,
      ...toJson_QueueProps(props),
    };
  }

  /**
   * Defines a "Queue" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: QueueProps) {
    super(scope, id, {
      ...Queue.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Queue.GVK,
      ...toJson_QueueProps(resolved),
    };
  }
}

/**
 * Queue is the Schema for the Queues API. Provides details about a specific Amazon Connect Queue
 *
 * @schema Queue
 */
export interface QueueProps {
  /**
   * @schema Queue#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * QueueSpec defines the desired state of Queue
   *
   * @schema Queue#spec
   */
  readonly spec: QueueSpec;

}

/**
 * Converts an object of type 'QueueProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueProps(obj: QueueProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_QueueSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueSpec defines the desired state of Queue
 *
 * @schema QueueSpec
 */
export interface QueueSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema QueueSpec#deletionPolicy
   */
  readonly deletionPolicy?: QueueSpecDeletionPolicy;

  /**
   * @schema QueueSpec#forProvider
   */
  readonly forProvider: QueueSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema QueueSpec#managementPolicy
   */
  readonly managementPolicy?: QueueSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema QueueSpec#providerConfigRef
   */
  readonly providerConfigRef?: QueueSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema QueueSpec#providerRef
   */
  readonly providerRef?: QueueSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema QueueSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: QueueSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema QueueSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: QueueSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'QueueSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpec(obj: QueueSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_QueueSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_QueueSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_QueueSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_QueueSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_QueueSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema QueueSpecDeletionPolicy
 */
export enum QueueSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema QueueSpecForProvider
 */
export interface QueueSpecForProvider {
  /**
   * Specifies the description of the Queue.
   *
   * @schema QueueSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies the identifier of the Hours of Operation.
   *
   * @schema QueueSpecForProvider#hoursOfOperationId
   */
  readonly hoursOfOperationId?: string;

  /**
   * Reference to a HoursOfOperation in connect to populate hoursOfOperationId.
   *
   * @schema QueueSpecForProvider#hoursOfOperationIdRef
   */
  readonly hoursOfOperationIdRef?: QueueSpecForProviderHoursOfOperationIdRef;

  /**
   * Selector for a HoursOfOperation in connect to populate hoursOfOperationId.
   *
   * @schema QueueSpecForProvider#hoursOfOperationIdSelector
   */
  readonly hoursOfOperationIdSelector?: QueueSpecForProviderHoursOfOperationIdSelector;

  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema QueueSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema QueueSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: QueueSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema QueueSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: QueueSpecForProviderInstanceIdSelector;

  /**
   * Specifies the maximum number of contacts that can be in the queue before it is considered full. Minimum value of 0.
   *
   * @schema QueueSpecForProvider#maxContacts
   */
  readonly maxContacts?: number;

  /**
   * Specifies the name of the Queue.
   *
   * @schema QueueSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A block that defines the outbound caller ID name, number, and outbound whisper flow. The Outbound Caller Config block is documented below.
   *
   * @schema QueueSpecForProvider#outboundCallerConfig
   */
  readonly outboundCallerConfig?: QueueSpecForProviderOutboundCallerConfig[];

  /**
   * Specifies a list of quick connects ids that determine the quick connects available to agents who are working the queue.
   *
   * @schema QueueSpecForProvider#quickConnectIds
   */
  readonly quickConnectIds?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema QueueSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the description of the Queue. Valid values are ENABLED, DISABLED.
   *
   * @schema QueueSpecForProvider#status
   */
  readonly status?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema QueueSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'QueueSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProvider(obj: QueueSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'hoursOfOperationId': obj.hoursOfOperationId,
    'hoursOfOperationIdRef': toJson_QueueSpecForProviderHoursOfOperationIdRef(obj.hoursOfOperationIdRef),
    'hoursOfOperationIdSelector': toJson_QueueSpecForProviderHoursOfOperationIdSelector(obj.hoursOfOperationIdSelector),
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_QueueSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_QueueSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'maxContacts': obj.maxContacts,
    'name': obj.name,
    'outboundCallerConfig': obj.outboundCallerConfig?.map(y => toJson_QueueSpecForProviderOutboundCallerConfig(y)),
    'quickConnectIds': obj.quickConnectIds?.map(y => y),
    'region': obj.region,
    'status': obj.status,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema QueueSpecManagementPolicy
 */
export enum QueueSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema QueueSpecProviderConfigRef
 */
export interface QueueSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecProviderConfigRef#policy
   */
  readonly policy?: QueueSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecProviderConfigRef(obj: QueueSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema QueueSpecProviderRef
 */
export interface QueueSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecProviderRef#policy
   */
  readonly policy?: QueueSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecProviderRef(obj: QueueSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema QueueSpecPublishConnectionDetailsTo
 */
export interface QueueSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema QueueSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: QueueSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema QueueSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: QueueSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema QueueSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsTo(obj: QueueSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_QueueSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_QueueSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema QueueSpecWriteConnectionSecretToRef
 */
export interface QueueSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema QueueSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema QueueSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'QueueSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecWriteConnectionSecretToRef(obj: QueueSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HoursOfOperation in connect to populate hoursOfOperationId.
 *
 * @schema QueueSpecForProviderHoursOfOperationIdRef
 */
export interface QueueSpecForProviderHoursOfOperationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecForProviderHoursOfOperationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecForProviderHoursOfOperationIdRef#policy
   */
  readonly policy?: QueueSpecForProviderHoursOfOperationIdRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecForProviderHoursOfOperationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderHoursOfOperationIdRef(obj: QueueSpecForProviderHoursOfOperationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecForProviderHoursOfOperationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HoursOfOperation in connect to populate hoursOfOperationId.
 *
 * @schema QueueSpecForProviderHoursOfOperationIdSelector
 */
export interface QueueSpecForProviderHoursOfOperationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QueueSpecForProviderHoursOfOperationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QueueSpecForProviderHoursOfOperationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QueueSpecForProviderHoursOfOperationIdSelector#policy
   */
  readonly policy?: QueueSpecForProviderHoursOfOperationIdSelectorPolicy;

}

/**
 * Converts an object of type 'QueueSpecForProviderHoursOfOperationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderHoursOfOperationIdSelector(obj: QueueSpecForProviderHoursOfOperationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QueueSpecForProviderHoursOfOperationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema QueueSpecForProviderInstanceIdRef
 */
export interface QueueSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: QueueSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderInstanceIdRef(obj: QueueSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema QueueSpecForProviderInstanceIdSelector
 */
export interface QueueSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QueueSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QueueSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QueueSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: QueueSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'QueueSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderInstanceIdSelector(obj: QueueSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QueueSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema QueueSpecForProviderOutboundCallerConfig
 */
export interface QueueSpecForProviderOutboundCallerConfig {
  /**
   * Specifies the caller ID name.
   *
   * @schema QueueSpecForProviderOutboundCallerConfig#outboundCallerIdName
   */
  readonly outboundCallerIdName?: string;

  /**
   * Specifies the caller ID number.
   *
   * @schema QueueSpecForProviderOutboundCallerConfig#outboundCallerIdNumberId
   */
  readonly outboundCallerIdNumberId?: string;

  /**
   * Specifies outbound whisper flow to be used during an outbound call.
   *
   * @schema QueueSpecForProviderOutboundCallerConfig#outboundFlowId
   */
  readonly outboundFlowId?: string;

}

/**
 * Converts an object of type 'QueueSpecForProviderOutboundCallerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderOutboundCallerConfig(obj: QueueSpecForProviderOutboundCallerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outboundCallerIdName': obj.outboundCallerIdName,
    'outboundCallerIdNumberId': obj.outboundCallerIdNumberId,
    'outboundFlowId': obj.outboundFlowId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueSpecProviderConfigRefPolicy
 */
export interface QueueSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: QueueSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: QueueSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecProviderConfigRefPolicy(obj: QueueSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueSpecProviderRefPolicy
 */
export interface QueueSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecProviderRefPolicy#resolution
   */
  readonly resolution?: QueueSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecProviderRefPolicy#resolve
   */
  readonly resolve?: QueueSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecProviderRefPolicy(obj: QueueSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRef
 */
export interface QueueSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: QueueSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsToConfigRef(obj: QueueSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QueueSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema QueueSpecPublishConnectionDetailsToMetadata
 */
export interface QueueSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueueSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema QueueSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema QueueSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsToMetadata(obj: QueueSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueSpecForProviderHoursOfOperationIdRefPolicy
 */
export interface QueueSpecForProviderHoursOfOperationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecForProviderHoursOfOperationIdRefPolicy#resolution
   */
  readonly resolution?: QueueSpecForProviderHoursOfOperationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecForProviderHoursOfOperationIdRefPolicy#resolve
   */
  readonly resolve?: QueueSpecForProviderHoursOfOperationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecForProviderHoursOfOperationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderHoursOfOperationIdRefPolicy(obj: QueueSpecForProviderHoursOfOperationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QueueSpecForProviderHoursOfOperationIdSelectorPolicy
 */
export interface QueueSpecForProviderHoursOfOperationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecForProviderHoursOfOperationIdSelectorPolicy#resolution
   */
  readonly resolution?: QueueSpecForProviderHoursOfOperationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecForProviderHoursOfOperationIdSelectorPolicy#resolve
   */
  readonly resolve?: QueueSpecForProviderHoursOfOperationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecForProviderHoursOfOperationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderHoursOfOperationIdSelectorPolicy(obj: QueueSpecForProviderHoursOfOperationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QueueSpecForProviderInstanceIdRefPolicy
 */
export interface QueueSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: QueueSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: QueueSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderInstanceIdRefPolicy(obj: QueueSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QueueSpecForProviderInstanceIdSelectorPolicy
 */
export interface QueueSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: QueueSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: QueueSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecForProviderInstanceIdSelectorPolicy(obj: QueueSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecProviderConfigRefPolicyResolution
 */
export enum QueueSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecProviderConfigRefPolicyResolve
 */
export enum QueueSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecProviderRefPolicyResolution
 */
export enum QueueSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecProviderRefPolicyResolve
 */
export enum QueueSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface QueueSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: QueueSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: QueueSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QueueSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QueueSpecPublishConnectionDetailsToConfigRefPolicy(obj: QueueSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecForProviderHoursOfOperationIdRefPolicyResolution
 */
export enum QueueSpecForProviderHoursOfOperationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecForProviderHoursOfOperationIdRefPolicyResolve
 */
export enum QueueSpecForProviderHoursOfOperationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecForProviderHoursOfOperationIdSelectorPolicyResolution
 */
export enum QueueSpecForProviderHoursOfOperationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecForProviderHoursOfOperationIdSelectorPolicyResolve
 */
export enum QueueSpecForProviderHoursOfOperationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecForProviderInstanceIdRefPolicyResolution
 */
export enum QueueSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecForProviderInstanceIdRefPolicyResolve
 */
export enum QueueSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum QueueSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum QueueSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum QueueSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QueueSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum QueueSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * QuickConnect is the Schema for the QuickConnects API. Provides details about a specific Amazon Quick Connect
 *
 * @schema QuickConnect
 */
export class QuickConnect extends ApiObject {
  /**
   * Returns the apiVersion and kind for "QuickConnect"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'QuickConnect',
  }

  /**
   * Renders a Kubernetes manifest for "QuickConnect".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: QuickConnectProps): any {
    return {
      ...QuickConnect.GVK,
      ...toJson_QuickConnectProps(props),
    };
  }

  /**
   * Defines a "QuickConnect" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: QuickConnectProps) {
    super(scope, id, {
      ...QuickConnect.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...QuickConnect.GVK,
      ...toJson_QuickConnectProps(resolved),
    };
  }
}

/**
 * QuickConnect is the Schema for the QuickConnects API. Provides details about a specific Amazon Quick Connect
 *
 * @schema QuickConnect
 */
export interface QuickConnectProps {
  /**
   * @schema QuickConnect#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * QuickConnectSpec defines the desired state of QuickConnect
   *
   * @schema QuickConnect#spec
   */
  readonly spec: QuickConnectSpec;

}

/**
 * Converts an object of type 'QuickConnectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectProps(obj: QuickConnectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_QuickConnectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QuickConnectSpec defines the desired state of QuickConnect
 *
 * @schema QuickConnectSpec
 */
export interface QuickConnectSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema QuickConnectSpec#deletionPolicy
   */
  readonly deletionPolicy?: QuickConnectSpecDeletionPolicy;

  /**
   * @schema QuickConnectSpec#forProvider
   */
  readonly forProvider: QuickConnectSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema QuickConnectSpec#managementPolicy
   */
  readonly managementPolicy?: QuickConnectSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema QuickConnectSpec#providerConfigRef
   */
  readonly providerConfigRef?: QuickConnectSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema QuickConnectSpec#providerRef
   */
  readonly providerRef?: QuickConnectSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema QuickConnectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: QuickConnectSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema QuickConnectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: QuickConnectSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'QuickConnectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpec(obj: QuickConnectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_QuickConnectSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_QuickConnectSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_QuickConnectSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_QuickConnectSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_QuickConnectSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema QuickConnectSpecDeletionPolicy
 */
export enum QuickConnectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema QuickConnectSpecForProvider
 */
export interface QuickConnectSpecForProvider {
  /**
   * Specifies the description of the Quick Connect.
   *
   * @schema QuickConnectSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema QuickConnectSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema QuickConnectSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: QuickConnectSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema QuickConnectSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: QuickConnectSpecForProviderInstanceIdSelector;

  /**
   * Specifies the name of the Quick Connect.
   *
   * @schema QuickConnectSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A block that defines the configuration information for the Quick Connect: quick_connect_type and one of phone_config, queue_config, user_config . The Quick Connect Config block is documented below.
   *
   * @schema QuickConnectSpecForProvider#quickConnectConfig
   */
  readonly quickConnectConfig?: QuickConnectSpecForProviderQuickConnectConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema QuickConnectSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema QuickConnectSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'QuickConnectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecForProvider(obj: QuickConnectSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_QuickConnectSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_QuickConnectSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'name': obj.name,
    'quickConnectConfig': obj.quickConnectConfig?.map(y => toJson_QuickConnectSpecForProviderQuickConnectConfig(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema QuickConnectSpecManagementPolicy
 */
export enum QuickConnectSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema QuickConnectSpecProviderConfigRef
 */
export interface QuickConnectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QuickConnectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QuickConnectSpecProviderConfigRef#policy
   */
  readonly policy?: QuickConnectSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'QuickConnectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecProviderConfigRef(obj: QuickConnectSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QuickConnectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema QuickConnectSpecProviderRef
 */
export interface QuickConnectSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema QuickConnectSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QuickConnectSpecProviderRef#policy
   */
  readonly policy?: QuickConnectSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'QuickConnectSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecProviderRef(obj: QuickConnectSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QuickConnectSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema QuickConnectSpecPublishConnectionDetailsTo
 */
export interface QuickConnectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema QuickConnectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: QuickConnectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema QuickConnectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: QuickConnectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema QuickConnectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'QuickConnectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecPublishConnectionDetailsTo(obj: QuickConnectSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_QuickConnectSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_QuickConnectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema QuickConnectSpecWriteConnectionSecretToRef
 */
export interface QuickConnectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema QuickConnectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema QuickConnectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'QuickConnectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecWriteConnectionSecretToRef(obj: QuickConnectSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema QuickConnectSpecForProviderInstanceIdRef
 */
export interface QuickConnectSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema QuickConnectSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QuickConnectSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: QuickConnectSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'QuickConnectSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecForProviderInstanceIdRef(obj: QuickConnectSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QuickConnectSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema QuickConnectSpecForProviderInstanceIdSelector
 */
export interface QuickConnectSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QuickConnectSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QuickConnectSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QuickConnectSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: QuickConnectSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'QuickConnectSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecForProviderInstanceIdSelector(obj: QuickConnectSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QuickConnectSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema QuickConnectSpecForProviderQuickConnectConfig
 */
export interface QuickConnectSpecForProviderQuickConnectConfig {
  /**
   * Specifies the phone configuration of the Quick Connect. This is required only if quick_connect_type is PHONE_NUMBER. The phone_config block is documented below.
   *
   * @schema QuickConnectSpecForProviderQuickConnectConfig#phoneConfig
   */
  readonly phoneConfig?: QuickConnectSpecForProviderQuickConnectConfigPhoneConfig[];

  /**
   * Specifies the queue configuration of the Quick Connect. This is required only if quick_connect_type is QUEUE. The queue_config block is documented below.
   *
   * @schema QuickConnectSpecForProviderQuickConnectConfig#queueConfig
   */
  readonly queueConfig?: QuickConnectSpecForProviderQuickConnectConfigQueueConfig[];

  /**
   * Specifies the configuration type of the quick connect. valid values are PHONE_NUMBER, QUEUE, USER.
   *
   * @schema QuickConnectSpecForProviderQuickConnectConfig#quickConnectType
   */
  readonly quickConnectType: string;

  /**
   * Specifies the user configuration of the Quick Connect. This is required only if quick_connect_type is USER. The user_config block is documented below.
   *
   * @schema QuickConnectSpecForProviderQuickConnectConfig#userConfig
   */
  readonly userConfig?: QuickConnectSpecForProviderQuickConnectConfigUserConfig[];

}

/**
 * Converts an object of type 'QuickConnectSpecForProviderQuickConnectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecForProviderQuickConnectConfig(obj: QuickConnectSpecForProviderQuickConnectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'phoneConfig': obj.phoneConfig?.map(y => toJson_QuickConnectSpecForProviderQuickConnectConfigPhoneConfig(y)),
    'queueConfig': obj.queueConfig?.map(y => toJson_QuickConnectSpecForProviderQuickConnectConfigQueueConfig(y)),
    'quickConnectType': obj.quickConnectType,
    'userConfig': obj.userConfig?.map(y => toJson_QuickConnectSpecForProviderQuickConnectConfigUserConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QuickConnectSpecProviderConfigRefPolicy
 */
export interface QuickConnectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuickConnectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: QuickConnectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuickConnectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: QuickConnectSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QuickConnectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecProviderConfigRefPolicy(obj: QuickConnectSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QuickConnectSpecProviderRefPolicy
 */
export interface QuickConnectSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuickConnectSpecProviderRefPolicy#resolution
   */
  readonly resolution?: QuickConnectSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuickConnectSpecProviderRefPolicy#resolve
   */
  readonly resolve?: QuickConnectSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'QuickConnectSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecProviderRefPolicy(obj: QuickConnectSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema QuickConnectSpecPublishConnectionDetailsToConfigRef
 */
export interface QuickConnectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QuickConnectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QuickConnectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: QuickConnectSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'QuickConnectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecPublishConnectionDetailsToConfigRef(obj: QuickConnectSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QuickConnectSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema QuickConnectSpecPublishConnectionDetailsToMetadata
 */
export interface QuickConnectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema QuickConnectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema QuickConnectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema QuickConnectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'QuickConnectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecPublishConnectionDetailsToMetadata(obj: QuickConnectSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QuickConnectSpecForProviderInstanceIdRefPolicy
 */
export interface QuickConnectSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuickConnectSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: QuickConnectSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuickConnectSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: QuickConnectSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'QuickConnectSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecForProviderInstanceIdRefPolicy(obj: QuickConnectSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QuickConnectSpecForProviderInstanceIdSelectorPolicy
 */
export interface QuickConnectSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuickConnectSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: QuickConnectSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuickConnectSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: QuickConnectSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QuickConnectSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecForProviderInstanceIdSelectorPolicy(obj: QuickConnectSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema QuickConnectSpecForProviderQuickConnectConfigPhoneConfig
 */
export interface QuickConnectSpecForProviderQuickConnectConfigPhoneConfig {
  /**
   * Specifies the phone number in in E.164 format.
   *
   * @schema QuickConnectSpecForProviderQuickConnectConfigPhoneConfig#phoneNumber
   */
  readonly phoneNumber: string;

}

/**
 * Converts an object of type 'QuickConnectSpecForProviderQuickConnectConfigPhoneConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecForProviderQuickConnectConfigPhoneConfig(obj: QuickConnectSpecForProviderQuickConnectConfigPhoneConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'phoneNumber': obj.phoneNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema QuickConnectSpecForProviderQuickConnectConfigQueueConfig
 */
export interface QuickConnectSpecForProviderQuickConnectConfigQueueConfig {
  /**
   * Specifies the identifier of the contact flow.
   *
   * @schema QuickConnectSpecForProviderQuickConnectConfigQueueConfig#contactFlowId
   */
  readonly contactFlowId: string;

  /**
   * Specifies the identifier for the queue.
   *
   * @schema QuickConnectSpecForProviderQuickConnectConfigQueueConfig#queueId
   */
  readonly queueId: string;

}

/**
 * Converts an object of type 'QuickConnectSpecForProviderQuickConnectConfigQueueConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecForProviderQuickConnectConfigQueueConfig(obj: QuickConnectSpecForProviderQuickConnectConfigQueueConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contactFlowId': obj.contactFlowId,
    'queueId': obj.queueId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema QuickConnectSpecForProviderQuickConnectConfigUserConfig
 */
export interface QuickConnectSpecForProviderQuickConnectConfigUserConfig {
  /**
   * Specifies the identifier of the contact flow.
   *
   * @schema QuickConnectSpecForProviderQuickConnectConfigUserConfig#contactFlowId
   */
  readonly contactFlowId: string;

  /**
   * Specifies the identifier for the user.
   *
   * @schema QuickConnectSpecForProviderQuickConnectConfigUserConfig#userId
   */
  readonly userId: string;

}

/**
 * Converts an object of type 'QuickConnectSpecForProviderQuickConnectConfigUserConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecForProviderQuickConnectConfigUserConfig(obj: QuickConnectSpecForProviderQuickConnectConfigUserConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contactFlowId': obj.contactFlowId,
    'userId': obj.userId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuickConnectSpecProviderConfigRefPolicyResolution
 */
export enum QuickConnectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuickConnectSpecProviderConfigRefPolicyResolve
 */
export enum QuickConnectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuickConnectSpecProviderRefPolicyResolution
 */
export enum QuickConnectSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuickConnectSpecProviderRefPolicyResolve
 */
export enum QuickConnectSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema QuickConnectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface QuickConnectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuickConnectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: QuickConnectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuickConnectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: QuickConnectSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QuickConnectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuickConnectSpecPublishConnectionDetailsToConfigRefPolicy(obj: QuickConnectSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuickConnectSpecForProviderInstanceIdRefPolicyResolution
 */
export enum QuickConnectSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuickConnectSpecForProviderInstanceIdRefPolicyResolve
 */
export enum QuickConnectSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuickConnectSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum QuickConnectSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuickConnectSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum QuickConnectSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuickConnectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum QuickConnectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuickConnectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum QuickConnectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RoutingProfile is the Schema for the RoutingProfiles API. Provides details about a specific Amazon Connect Routing Profile.
 *
 * @schema RoutingProfile
 */
export class RoutingProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RoutingProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'RoutingProfile',
  }

  /**
   * Renders a Kubernetes manifest for "RoutingProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RoutingProfileProps): any {
    return {
      ...RoutingProfile.GVK,
      ...toJson_RoutingProfileProps(props),
    };
  }

  /**
   * Defines a "RoutingProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RoutingProfileProps) {
    super(scope, id, {
      ...RoutingProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RoutingProfile.GVK,
      ...toJson_RoutingProfileProps(resolved),
    };
  }
}

/**
 * RoutingProfile is the Schema for the RoutingProfiles API. Provides details about a specific Amazon Connect Routing Profile.
 *
 * @schema RoutingProfile
 */
export interface RoutingProfileProps {
  /**
   * @schema RoutingProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RoutingProfileSpec defines the desired state of RoutingProfile
   *
   * @schema RoutingProfile#spec
   */
  readonly spec: RoutingProfileSpec;

}

/**
 * Converts an object of type 'RoutingProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileProps(obj: RoutingProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RoutingProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoutingProfileSpec defines the desired state of RoutingProfile
 *
 * @schema RoutingProfileSpec
 */
export interface RoutingProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RoutingProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: RoutingProfileSpecDeletionPolicy;

  /**
   * @schema RoutingProfileSpec#forProvider
   */
  readonly forProvider: RoutingProfileSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RoutingProfileSpec#managementPolicy
   */
  readonly managementPolicy?: RoutingProfileSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RoutingProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: RoutingProfileSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RoutingProfileSpec#providerRef
   */
  readonly providerRef?: RoutingProfileSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RoutingProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RoutingProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RoutingProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RoutingProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RoutingProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpec(obj: RoutingProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RoutingProfileSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RoutingProfileSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RoutingProfileSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RoutingProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RoutingProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RoutingProfileSpecDeletionPolicy
 */
export enum RoutingProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RoutingProfileSpecForProvider
 */
export interface RoutingProfileSpecForProvider {
  /**
   * Specifies the default outbound queue for the Routing Profile.
   *
   * @schema RoutingProfileSpecForProvider#defaultOutboundQueueId
   */
  readonly defaultOutboundQueueId?: string;

  /**
   * Reference to a Queue in connect to populate defaultOutboundQueueId.
   *
   * @schema RoutingProfileSpecForProvider#defaultOutboundQueueIdRef
   */
  readonly defaultOutboundQueueIdRef?: RoutingProfileSpecForProviderDefaultOutboundQueueIdRef;

  /**
   * Selector for a Queue in connect to populate defaultOutboundQueueId.
   *
   * @schema RoutingProfileSpecForProvider#defaultOutboundQueueIdSelector
   */
  readonly defaultOutboundQueueIdSelector?: RoutingProfileSpecForProviderDefaultOutboundQueueIdSelector;

  /**
   * Specifies the description of the Routing Profile.
   *
   * @schema RoutingProfileSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema RoutingProfileSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema RoutingProfileSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: RoutingProfileSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema RoutingProfileSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: RoutingProfileSpecForProviderInstanceIdSelector;

  /**
   * One or more media_concurrencies blocks that specify the channels that agents can handle in the Contact Control Panel (CCP) for this Routing Profile. The media_concurrencies block is documented below.
   *
   * @schema RoutingProfileSpecForProvider#mediaConcurrencies
   */
  readonly mediaConcurrencies?: RoutingProfileSpecForProviderMediaConcurrencies[];

  /**
   * Specifies the name of the Routing Profile.
   *
   * @schema RoutingProfileSpecForProvider#name
   */
  readonly name?: string;

  /**
   * One or more queue_configs blocks that specify the inbound queues associated with the routing profile. If no queue is added, the agent only can make outbound calls. The queue_configs block is documented below.
   *
   * @schema RoutingProfileSpecForProvider#queueConfigs
   */
  readonly queueConfigs?: RoutingProfileSpecForProviderQueueConfigs[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RoutingProfileSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RoutingProfileSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RoutingProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProvider(obj: RoutingProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultOutboundQueueId': obj.defaultOutboundQueueId,
    'defaultOutboundQueueIdRef': toJson_RoutingProfileSpecForProviderDefaultOutboundQueueIdRef(obj.defaultOutboundQueueIdRef),
    'defaultOutboundQueueIdSelector': toJson_RoutingProfileSpecForProviderDefaultOutboundQueueIdSelector(obj.defaultOutboundQueueIdSelector),
    'description': obj.description,
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_RoutingProfileSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_RoutingProfileSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'mediaConcurrencies': obj.mediaConcurrencies?.map(y => toJson_RoutingProfileSpecForProviderMediaConcurrencies(y)),
    'name': obj.name,
    'queueConfigs': obj.queueConfigs?.map(y => toJson_RoutingProfileSpecForProviderQueueConfigs(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RoutingProfileSpecManagementPolicy
 */
export enum RoutingProfileSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RoutingProfileSpecProviderConfigRef
 */
export interface RoutingProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutingProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutingProfileSpecProviderConfigRef#policy
   */
  readonly policy?: RoutingProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RoutingProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecProviderConfigRef(obj: RoutingProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutingProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RoutingProfileSpecProviderRef
 */
export interface RoutingProfileSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutingProfileSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutingProfileSpecProviderRef#policy
   */
  readonly policy?: RoutingProfileSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RoutingProfileSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecProviderRef(obj: RoutingProfileSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutingProfileSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RoutingProfileSpecPublishConnectionDetailsTo
 */
export interface RoutingProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RoutingProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RoutingProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RoutingProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RoutingProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RoutingProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RoutingProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecPublishConnectionDetailsTo(obj: RoutingProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RoutingProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RoutingProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RoutingProfileSpecWriteConnectionSecretToRef
 */
export interface RoutingProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RoutingProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RoutingProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RoutingProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecWriteConnectionSecretToRef(obj: RoutingProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Queue in connect to populate defaultOutboundQueueId.
 *
 * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdRef
 */
export interface RoutingProfileSpecForProviderDefaultOutboundQueueIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdRef#policy
   */
  readonly policy?: RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicy;

}

/**
 * Converts an object of type 'RoutingProfileSpecForProviderDefaultOutboundQueueIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProviderDefaultOutboundQueueIdRef(obj: RoutingProfileSpecForProviderDefaultOutboundQueueIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Queue in connect to populate defaultOutboundQueueId.
 *
 * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdSelector
 */
export interface RoutingProfileSpecForProviderDefaultOutboundQueueIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdSelector#policy
   */
  readonly policy?: RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicy;

}

/**
 * Converts an object of type 'RoutingProfileSpecForProviderDefaultOutboundQueueIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProviderDefaultOutboundQueueIdSelector(obj: RoutingProfileSpecForProviderDefaultOutboundQueueIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema RoutingProfileSpecForProviderInstanceIdRef
 */
export interface RoutingProfileSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutingProfileSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutingProfileSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: RoutingProfileSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'RoutingProfileSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProviderInstanceIdRef(obj: RoutingProfileSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutingProfileSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema RoutingProfileSpecForProviderInstanceIdSelector
 */
export interface RoutingProfileSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RoutingProfileSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RoutingProfileSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RoutingProfileSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: RoutingProfileSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'RoutingProfileSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProviderInstanceIdSelector(obj: RoutingProfileSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RoutingProfileSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RoutingProfileSpecForProviderMediaConcurrencies
 */
export interface RoutingProfileSpecForProviderMediaConcurrencies {
  /**
   * Specifies the channels that agents can handle in the Contact Control Panel (CCP). Valid values are VOICE, CHAT, TASK.
   *
   * @schema RoutingProfileSpecForProviderMediaConcurrencies#channel
   */
  readonly channel: string;

  /**
   * Specifies the number of contacts an agent can have on a channel simultaneously. Valid Range for VOICE: Minimum value of 1. Maximum value of 1. Valid Range for CHAT: Minimum value of 1. Maximum value of 10. Valid Range for TASK: Minimum value of 1. Maximum value of 10.
   *
   * @schema RoutingProfileSpecForProviderMediaConcurrencies#concurrency
   */
  readonly concurrency: number;

}

/**
 * Converts an object of type 'RoutingProfileSpecForProviderMediaConcurrencies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProviderMediaConcurrencies(obj: RoutingProfileSpecForProviderMediaConcurrencies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
    'concurrency': obj.concurrency,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RoutingProfileSpecForProviderQueueConfigs
 */
export interface RoutingProfileSpecForProviderQueueConfigs {
  /**
   * Specifies the channels agents can handle in the Contact Control Panel (CCP) for this routing profile. Valid values are VOICE, CHAT, TASK.
   *
   * @schema RoutingProfileSpecForProviderQueueConfigs#channel
   */
  readonly channel: string;

  /**
   * Specifies the delay, in seconds, that a contact should be in the queue before they are routed to an available agent
   *
   * @schema RoutingProfileSpecForProviderQueueConfigs#delay
   */
  readonly delay: number;

  /**
   * Specifies the order in which contacts are to be handled for the queue.
   *
   * @schema RoutingProfileSpecForProviderQueueConfigs#priority
   */
  readonly priority: number;

  /**
   * Specifies the identifier for the queue.
   *
   * @schema RoutingProfileSpecForProviderQueueConfigs#queueId
   */
  readonly queueId: string;

}

/**
 * Converts an object of type 'RoutingProfileSpecForProviderQueueConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProviderQueueConfigs(obj: RoutingProfileSpecForProviderQueueConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
    'delay': obj.delay,
    'priority': obj.priority,
    'queueId': obj.queueId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutingProfileSpecProviderConfigRefPolicy
 */
export interface RoutingProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RoutingProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RoutingProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutingProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecProviderConfigRefPolicy(obj: RoutingProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutingProfileSpecProviderRefPolicy
 */
export interface RoutingProfileSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingProfileSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RoutingProfileSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingProfileSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RoutingProfileSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutingProfileSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecProviderRefPolicy(obj: RoutingProfileSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RoutingProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface RoutingProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RoutingProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RoutingProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RoutingProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecPublishConnectionDetailsToConfigRef(obj: RoutingProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RoutingProfileSpecPublishConnectionDetailsToMetadata
 */
export interface RoutingProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RoutingProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RoutingProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RoutingProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RoutingProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecPublishConnectionDetailsToMetadata(obj: RoutingProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicy
 */
export interface RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicy#resolution
   */
  readonly resolution?: RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicy#resolve
   */
  readonly resolve?: RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicy(obj: RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicy
 */
export interface RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicy#resolution
   */
  readonly resolution?: RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicy#resolve
   */
  readonly resolve?: RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicy(obj: RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RoutingProfileSpecForProviderInstanceIdRefPolicy
 */
export interface RoutingProfileSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingProfileSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: RoutingProfileSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingProfileSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: RoutingProfileSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutingProfileSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProviderInstanceIdRefPolicy(obj: RoutingProfileSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RoutingProfileSpecForProviderInstanceIdSelectorPolicy
 */
export interface RoutingProfileSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingProfileSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: RoutingProfileSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingProfileSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: RoutingProfileSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RoutingProfileSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecForProviderInstanceIdSelectorPolicy(obj: RoutingProfileSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingProfileSpecProviderConfigRefPolicyResolution
 */
export enum RoutingProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingProfileSpecProviderConfigRefPolicyResolve
 */
export enum RoutingProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingProfileSpecProviderRefPolicyResolution
 */
export enum RoutingProfileSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingProfileSpecProviderRefPolicyResolve
 */
export enum RoutingProfileSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicyResolution
 */
export enum RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicyResolve
 */
export enum RoutingProfileSpecForProviderDefaultOutboundQueueIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicyResolution
 */
export enum RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicyResolve
 */
export enum RoutingProfileSpecForProviderDefaultOutboundQueueIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingProfileSpecForProviderInstanceIdRefPolicyResolution
 */
export enum RoutingProfileSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingProfileSpecForProviderInstanceIdRefPolicyResolve
 */
export enum RoutingProfileSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingProfileSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum RoutingProfileSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingProfileSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum RoutingProfileSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RoutingProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SecurityProfile is the Schema for the SecurityProfiles API. Provides details about a specific Amazon Connect Security Profile.
 *
 * @schema SecurityProfile
 */
export class SecurityProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecurityProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'SecurityProfile',
  }

  /**
   * Renders a Kubernetes manifest for "SecurityProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecurityProfileProps): any {
    return {
      ...SecurityProfile.GVK,
      ...toJson_SecurityProfileProps(props),
    };
  }

  /**
   * Defines a "SecurityProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecurityProfileProps) {
    super(scope, id, {
      ...SecurityProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecurityProfile.GVK,
      ...toJson_SecurityProfileProps(resolved),
    };
  }
}

/**
 * SecurityProfile is the Schema for the SecurityProfiles API. Provides details about a specific Amazon Connect Security Profile.
 *
 * @schema SecurityProfile
 */
export interface SecurityProfileProps {
  /**
   * @schema SecurityProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecurityProfileSpec defines the desired state of SecurityProfile
   *
   * @schema SecurityProfile#spec
   */
  readonly spec: SecurityProfileSpec;

}

/**
 * Converts an object of type 'SecurityProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileProps(obj: SecurityProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecurityProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityProfileSpec defines the desired state of SecurityProfile
 *
 * @schema SecurityProfileSpec
 */
export interface SecurityProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecurityProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecurityProfileSpecDeletionPolicy;

  /**
   * @schema SecurityProfileSpec#forProvider
   */
  readonly forProvider: SecurityProfileSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecurityProfileSpec#managementPolicy
   */
  readonly managementPolicy?: SecurityProfileSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecurityProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecurityProfileSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SecurityProfileSpec#providerRef
   */
  readonly providerRef?: SecurityProfileSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecurityProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecurityProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecurityProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecurityProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecurityProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpec(obj: SecurityProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecurityProfileSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SecurityProfileSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SecurityProfileSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SecurityProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecurityProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecurityProfileSpecDeletionPolicy
 */
export enum SecurityProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SecurityProfileSpecForProvider
 */
export interface SecurityProfileSpecForProvider {
  /**
   * Specifies the description of the Security Profile.
   *
   * @schema SecurityProfileSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema SecurityProfileSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema SecurityProfileSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: SecurityProfileSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema SecurityProfileSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: SecurityProfileSpecForProviderInstanceIdSelector;

  /**
   * Specifies the name of the Security Profile.
   *
   * @schema SecurityProfileSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Specifies a list of permissions assigned to the security profile.
   *
   * @schema SecurityProfileSpecForProvider#permissions
   */
  readonly permissions?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SecurityProfileSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema SecurityProfileSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SecurityProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecForProvider(obj: SecurityProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_SecurityProfileSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_SecurityProfileSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'name': obj.name,
    'permissions': obj.permissions?.map(y => y),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecurityProfileSpecManagementPolicy
 */
export enum SecurityProfileSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecurityProfileSpecProviderConfigRef
 */
export interface SecurityProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityProfileSpecProviderConfigRef#policy
   */
  readonly policy?: SecurityProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecProviderConfigRef(obj: SecurityProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SecurityProfileSpecProviderRef
 */
export interface SecurityProfileSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityProfileSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityProfileSpecProviderRef#policy
   */
  readonly policy?: SecurityProfileSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SecurityProfileSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecProviderRef(obj: SecurityProfileSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityProfileSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecurityProfileSpecPublishConnectionDetailsTo
 */
export interface SecurityProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecurityProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecurityProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecurityProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecurityProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecurityProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecurityProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecPublishConnectionDetailsTo(obj: SecurityProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecurityProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecurityProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecurityProfileSpecWriteConnectionSecretToRef
 */
export interface SecurityProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecurityProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecurityProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecurityProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecWriteConnectionSecretToRef(obj: SecurityProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema SecurityProfileSpecForProviderInstanceIdRef
 */
export interface SecurityProfileSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityProfileSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityProfileSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: SecurityProfileSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'SecurityProfileSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecForProviderInstanceIdRef(obj: SecurityProfileSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityProfileSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema SecurityProfileSpecForProviderInstanceIdSelector
 */
export interface SecurityProfileSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityProfileSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityProfileSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityProfileSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: SecurityProfileSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityProfileSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecForProviderInstanceIdSelector(obj: SecurityProfileSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityProfileSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityProfileSpecProviderConfigRefPolicy
 */
export interface SecurityProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecProviderConfigRefPolicy(obj: SecurityProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityProfileSpecProviderRefPolicy
 */
export interface SecurityProfileSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityProfileSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SecurityProfileSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityProfileSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SecurityProfileSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityProfileSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecProviderRefPolicy(obj: SecurityProfileSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecurityProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface SecurityProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecPublishConnectionDetailsToConfigRef(obj: SecurityProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecurityProfileSpecPublishConnectionDetailsToMetadata
 */
export interface SecurityProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecurityProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecurityProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecPublishConnectionDetailsToMetadata(obj: SecurityProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityProfileSpecForProviderInstanceIdRefPolicy
 */
export interface SecurityProfileSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityProfileSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: SecurityProfileSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityProfileSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: SecurityProfileSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityProfileSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecForProviderInstanceIdRefPolicy(obj: SecurityProfileSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityProfileSpecForProviderInstanceIdSelectorPolicy
 */
export interface SecurityProfileSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityProfileSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: SecurityProfileSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityProfileSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: SecurityProfileSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityProfileSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecForProviderInstanceIdSelectorPolicy(obj: SecurityProfileSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityProfileSpecProviderConfigRefPolicyResolution
 */
export enum SecurityProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityProfileSpecProviderConfigRefPolicyResolve
 */
export enum SecurityProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityProfileSpecProviderRefPolicyResolution
 */
export enum SecurityProfileSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityProfileSpecProviderRefPolicyResolve
 */
export enum SecurityProfileSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityProfileSpecForProviderInstanceIdRefPolicyResolution
 */
export enum SecurityProfileSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityProfileSpecForProviderInstanceIdRefPolicyResolve
 */
export enum SecurityProfileSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityProfileSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum SecurityProfileSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityProfileSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum SecurityProfileSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecurityProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * User is the Schema for the Users API. Provides details about a specific Amazon Connect User
 *
 * @schema User
 */
export class User extends ApiObject {
  /**
   * Returns the apiVersion and kind for "User"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'User',
  }

  /**
   * Renders a Kubernetes manifest for "User".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserProps): any {
    return {
      ...User.GVK,
      ...toJson_UserProps(props),
    };
  }

  /**
   * Defines a "User" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserProps) {
    super(scope, id, {
      ...User.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...User.GVK,
      ...toJson_UserProps(resolved),
    };
  }
}

/**
 * User is the Schema for the Users API. Provides details about a specific Amazon Connect User
 *
 * @schema User
 */
export interface UserProps {
  /**
   * @schema User#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserSpec defines the desired state of User
   *
   * @schema User#spec
   */
  readonly spec: UserSpec;

}

/**
 * Converts an object of type 'UserProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProps(obj: UserProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserSpec defines the desired state of User
 *
 * @schema UserSpec
 */
export interface UserSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserSpecDeletionPolicy;

  /**
   * @schema UserSpec#forProvider
   */
  readonly forProvider: UserSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserSpec#managementPolicy
   */
  readonly managementPolicy?: UserSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserSpec#providerRef
   */
  readonly providerRef?: UserSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpec(obj: UserSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_UserSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserSpecDeletionPolicy
 */
export enum UserSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserSpecForProvider
 */
export interface UserSpecForProvider {
  /**
   * The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory. This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.
   *
   * @schema UserSpecForProvider#directoryUserId
   */
  readonly directoryUserId?: string;

  /**
   * The identifier of the hierarchy group for the user.
   *
   * @schema UserSpecForProvider#hierarchyGroupId
   */
  readonly hierarchyGroupId?: string;

  /**
   * A block that contains information about the identity of the user. Documented below.
   *
   * @schema UserSpecForProvider#identityInfo
   */
  readonly identityInfo?: UserSpecForProviderIdentityInfo[];

  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema UserSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema UserSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: UserSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema UserSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: UserSpecForProviderInstanceIdSelector;

  /**
   * The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+.
   *
   * @schema UserSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.
   *
   * @schema UserSpecForProvider#passwordSecretRef
   */
  readonly passwordSecretRef?: UserSpecForProviderPasswordSecretRef;

  /**
   * A block that contains information about the phone settings for the user. Documented below.
   *
   * @schema UserSpecForProvider#phoneConfig
   */
  readonly phoneConfig?: UserSpecForProviderPhoneConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserSpecForProvider#region
   */
  readonly region: string;

  /**
   * The identifier of the routing profile for the user.
   *
   * @schema UserSpecForProvider#routingProfileId
   */
  readonly routingProfileId?: string;

  /**
   * Reference to a RoutingProfile in connect to populate routingProfileId.
   *
   * @schema UserSpecForProvider#routingProfileIdRef
   */
  readonly routingProfileIdRef?: UserSpecForProviderRoutingProfileIdRef;

  /**
   * Selector for a RoutingProfile in connect to populate routingProfileId.
   *
   * @schema UserSpecForProvider#routingProfileIdSelector
   */
  readonly routingProfileIdSelector?: UserSpecForProviderRoutingProfileIdSelector;

  /**
   * A list of identifiers for the security profiles for the user. Specify a minimum of 1 and maximum of 10 security profile ids. For more information, see Best Practices for Security Profiles in the Amazon Connect Administrator Guide.
   *
   * @schema UserSpecForProvider#securityProfileIds
   */
  readonly securityProfileIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema UserSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'UserSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProvider(obj: UserSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directoryUserId': obj.directoryUserId,
    'hierarchyGroupId': obj.hierarchyGroupId,
    'identityInfo': obj.identityInfo?.map(y => toJson_UserSpecForProviderIdentityInfo(y)),
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_UserSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_UserSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'name': obj.name,
    'passwordSecretRef': toJson_UserSpecForProviderPasswordSecretRef(obj.passwordSecretRef),
    'phoneConfig': obj.phoneConfig?.map(y => toJson_UserSpecForProviderPhoneConfig(y)),
    'region': obj.region,
    'routingProfileId': obj.routingProfileId,
    'routingProfileIdRef': toJson_UserSpecForProviderRoutingProfileIdRef(obj.routingProfileIdRef),
    'routingProfileIdSelector': toJson_UserSpecForProviderRoutingProfileIdSelector(obj.routingProfileIdSelector),
    'securityProfileIds': obj.securityProfileIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserSpecManagementPolicy
 */
export enum UserSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserSpecProviderConfigRef
 */
export interface UserSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderConfigRef#policy
   */
  readonly policy?: UserSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRef(obj: UserSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserSpecProviderRef
 */
export interface UserSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderRef#policy
   */
  readonly policy?: UserSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderRef(obj: UserSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserSpecPublishConnectionDetailsTo
 */
export interface UserSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsTo(obj: UserSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserSpecWriteConnectionSecretToRef
 */
export interface UserSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecWriteConnectionSecretToRef(obj: UserSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderIdentityInfo
 */
export interface UserSpecForProviderIdentityInfo {
  /**
   * The email address. If you are using SAML for identity management and include this parameter, an error is returned. Note that updates to the email is supported. From the UpdateUserIdentityInfo API documentation it is strongly recommended to limit who has the ability to invoke UpdateUserIdentityInfo. Someone with that ability can change the login credentials of other users by changing their email address. This poses a security risk to your organization. They can change the email address of a user to the attacker's email address, and then reset the password through email. For more information, see Best Practices for Security Profiles in the Amazon Connect Administrator Guide.
   *
   * @schema UserSpecForProviderIdentityInfo#email
   */
  readonly email?: string;

  /**
   * The first name. This is required if you are using Amazon Connect or SAML for identity management. Minimum length of 1. Maximum length of 100.
   *
   * @schema UserSpecForProviderIdentityInfo#firstName
   */
  readonly firstName?: string;

  /**
   * The last name. This is required if you are using Amazon Connect or SAML for identity management. Minimum length of 1. Maximum length of 100.
   *
   * @schema UserSpecForProviderIdentityInfo#lastName
   */
  readonly lastName?: string;

}

/**
 * Converts an object of type 'UserSpecForProviderIdentityInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderIdentityInfo(obj: UserSpecForProviderIdentityInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'email': obj.email,
    'firstName': obj.firstName,
    'lastName': obj.lastName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema UserSpecForProviderInstanceIdRef
 */
export interface UserSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: UserSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderInstanceIdRef(obj: UserSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema UserSpecForProviderInstanceIdSelector
 */
export interface UserSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: UserSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderInstanceIdSelector(obj: UserSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.
 *
 * @schema UserSpecForProviderPasswordSecretRef
 */
export interface UserSpecForProviderPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema UserSpecForProviderPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema UserSpecForProviderPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecForProviderPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecForProviderPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderPasswordSecretRef(obj: UserSpecForProviderPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderPhoneConfig
 */
export interface UserSpecForProviderPhoneConfig {
  /**
   * The After Call Work (ACW) timeout setting, in seconds. Minimum value of 0.
   *
   * @schema UserSpecForProviderPhoneConfig#afterContactWorkTimeLimit
   */
  readonly afterContactWorkTimeLimit?: number;

  /**
   * When Auto-Accept Call is enabled for an available agent, the agent connects to contacts automatically.
   *
   * @schema UserSpecForProviderPhoneConfig#autoAccept
   */
  readonly autoAccept?: boolean;

  /**
   * The phone number for the user's desk phone. Required if phone_type is set as DESK_PHONE.
   *
   * @schema UserSpecForProviderPhoneConfig#deskPhoneNumber
   */
  readonly deskPhoneNumber?: string;

  /**
   * The phone type. Valid values are DESK_PHONE and SOFT_PHONE.
   *
   * @schema UserSpecForProviderPhoneConfig#phoneType
   */
  readonly phoneType: string;

}

/**
 * Converts an object of type 'UserSpecForProviderPhoneConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderPhoneConfig(obj: UserSpecForProviderPhoneConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'afterContactWorkTimeLimit': obj.afterContactWorkTimeLimit,
    'autoAccept': obj.autoAccept,
    'deskPhoneNumber': obj.deskPhoneNumber,
    'phoneType': obj.phoneType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RoutingProfile in connect to populate routingProfileId.
 *
 * @schema UserSpecForProviderRoutingProfileIdRef
 */
export interface UserSpecForProviderRoutingProfileIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecForProviderRoutingProfileIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecForProviderRoutingProfileIdRef#policy
   */
  readonly policy?: UserSpecForProviderRoutingProfileIdRefPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderRoutingProfileIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoutingProfileIdRef(obj: UserSpecForProviderRoutingProfileIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecForProviderRoutingProfileIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RoutingProfile in connect to populate routingProfileId.
 *
 * @schema UserSpecForProviderRoutingProfileIdSelector
 */
export interface UserSpecForProviderRoutingProfileIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserSpecForProviderRoutingProfileIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserSpecForProviderRoutingProfileIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserSpecForProviderRoutingProfileIdSelector#policy
   */
  readonly policy?: UserSpecForProviderRoutingProfileIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderRoutingProfileIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoutingProfileIdSelector(obj: UserSpecForProviderRoutingProfileIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserSpecForProviderRoutingProfileIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderConfigRefPolicy
 */
export interface UserSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRefPolicy(obj: UserSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderRefPolicy
 */
export interface UserSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderRefPolicy(obj: UserSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRef
 */
export interface UserSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRef(obj: UserSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserSpecPublishConnectionDetailsToMetadata
 */
export interface UserSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToMetadata(obj: UserSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecForProviderInstanceIdRefPolicy
 */
export interface UserSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderInstanceIdRefPolicy(obj: UserSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserSpecForProviderInstanceIdSelectorPolicy
 */
export interface UserSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderInstanceIdSelectorPolicy(obj: UserSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecForProviderRoutingProfileIdRefPolicy
 */
export interface UserSpecForProviderRoutingProfileIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderRoutingProfileIdRefPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderRoutingProfileIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderRoutingProfileIdRefPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderRoutingProfileIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderRoutingProfileIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoutingProfileIdRefPolicy(obj: UserSpecForProviderRoutingProfileIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserSpecForProviderRoutingProfileIdSelectorPolicy
 */
export interface UserSpecForProviderRoutingProfileIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderRoutingProfileIdSelectorPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderRoutingProfileIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderRoutingProfileIdSelectorPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderRoutingProfileIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderRoutingProfileIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoutingProfileIdSelectorPolicy(obj: UserSpecForProviderRoutingProfileIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderConfigRefPolicyResolution
 */
export enum UserSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecProviderConfigRefPolicyResolve
 */
export enum UserSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderRefPolicyResolution
 */
export enum UserSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecProviderRefPolicyResolve
 */
export enum UserSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderInstanceIdRefPolicyResolution
 */
export enum UserSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderInstanceIdRefPolicyResolve
 */
export enum UserSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum UserSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum UserSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderRoutingProfileIdRefPolicyResolution
 */
export enum UserSpecForProviderRoutingProfileIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderRoutingProfileIdRefPolicyResolve
 */
export enum UserSpecForProviderRoutingProfileIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderRoutingProfileIdSelectorPolicyResolution
 */
export enum UserSpecForProviderRoutingProfileIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderRoutingProfileIdSelectorPolicyResolve
 */
export enum UserSpecForProviderRoutingProfileIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserHierarchyStructure is the Schema for the UserHierarchyStructures API. Provides details about a specific Amazon Connect User Hierarchy Structure
 *
 * @schema UserHierarchyStructure
 */
export class UserHierarchyStructure extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserHierarchyStructure"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'UserHierarchyStructure',
  }

  /**
   * Renders a Kubernetes manifest for "UserHierarchyStructure".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserHierarchyStructureProps): any {
    return {
      ...UserHierarchyStructure.GVK,
      ...toJson_UserHierarchyStructureProps(props),
    };
  }

  /**
   * Defines a "UserHierarchyStructure" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserHierarchyStructureProps) {
    super(scope, id, {
      ...UserHierarchyStructure.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserHierarchyStructure.GVK,
      ...toJson_UserHierarchyStructureProps(resolved),
    };
  }
}

/**
 * UserHierarchyStructure is the Schema for the UserHierarchyStructures API. Provides details about a specific Amazon Connect User Hierarchy Structure
 *
 * @schema UserHierarchyStructure
 */
export interface UserHierarchyStructureProps {
  /**
   * @schema UserHierarchyStructure#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserHierarchyStructureSpec defines the desired state of UserHierarchyStructure
   *
   * @schema UserHierarchyStructure#spec
   */
  readonly spec: UserHierarchyStructureSpec;

}

/**
 * Converts an object of type 'UserHierarchyStructureProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureProps(obj: UserHierarchyStructureProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserHierarchyStructureSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserHierarchyStructureSpec defines the desired state of UserHierarchyStructure
 *
 * @schema UserHierarchyStructureSpec
 */
export interface UserHierarchyStructureSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserHierarchyStructureSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserHierarchyStructureSpecDeletionPolicy;

  /**
   * @schema UserHierarchyStructureSpec#forProvider
   */
  readonly forProvider: UserHierarchyStructureSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserHierarchyStructureSpec#managementPolicy
   */
  readonly managementPolicy?: UserHierarchyStructureSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserHierarchyStructureSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserHierarchyStructureSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserHierarchyStructureSpec#providerRef
   */
  readonly providerRef?: UserHierarchyStructureSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserHierarchyStructureSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserHierarchyStructureSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserHierarchyStructureSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserHierarchyStructureSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpec(obj: UserHierarchyStructureSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserHierarchyStructureSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_UserHierarchyStructureSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserHierarchyStructureSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserHierarchyStructureSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserHierarchyStructureSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserHierarchyStructureSpecDeletionPolicy
 */
export enum UserHierarchyStructureSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserHierarchyStructureSpecForProvider
 */
export interface UserHierarchyStructureSpecForProvider {
  /**
   * A block that defines the hierarchy structure's levels. The hierarchy_structure block is documented below.
   *
   * @schema UserHierarchyStructureSpecForProvider#hierarchyStructure
   */
  readonly hierarchyStructure?: UserHierarchyStructureSpecForProviderHierarchyStructure[];

  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema UserHierarchyStructureSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema UserHierarchyStructureSpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: UserHierarchyStructureSpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema UserHierarchyStructureSpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: UserHierarchyStructureSpecForProviderInstanceIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserHierarchyStructureSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProvider(obj: UserHierarchyStructureSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hierarchyStructure': obj.hierarchyStructure?.map(y => toJson_UserHierarchyStructureSpecForProviderHierarchyStructure(y)),
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_UserHierarchyStructureSpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_UserHierarchyStructureSpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserHierarchyStructureSpecManagementPolicy
 */
export enum UserHierarchyStructureSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserHierarchyStructureSpecProviderConfigRef
 */
export interface UserHierarchyStructureSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserHierarchyStructureSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserHierarchyStructureSpecProviderConfigRef#policy
   */
  readonly policy?: UserHierarchyStructureSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecProviderConfigRef(obj: UserHierarchyStructureSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserHierarchyStructureSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserHierarchyStructureSpecProviderRef
 */
export interface UserHierarchyStructureSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserHierarchyStructureSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserHierarchyStructureSpecProviderRef#policy
   */
  readonly policy?: UserHierarchyStructureSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecProviderRef(obj: UserHierarchyStructureSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserHierarchyStructureSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserHierarchyStructureSpecPublishConnectionDetailsTo
 */
export interface UserHierarchyStructureSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserHierarchyStructureSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserHierarchyStructureSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserHierarchyStructureSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserHierarchyStructureSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserHierarchyStructureSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecPublishConnectionDetailsTo(obj: UserHierarchyStructureSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserHierarchyStructureSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserHierarchyStructureSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserHierarchyStructureSpecWriteConnectionSecretToRef
 */
export interface UserHierarchyStructureSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserHierarchyStructureSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserHierarchyStructureSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecWriteConnectionSecretToRef(obj: UserHierarchyStructureSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserHierarchyStructureSpecForProviderHierarchyStructure
 */
export interface UserHierarchyStructureSpecForProviderHierarchyStructure {
  /**
   * A block that defines the details of level five. The level block is documented below.
   *
   * @schema UserHierarchyStructureSpecForProviderHierarchyStructure#levelFive
   */
  readonly levelFive?: UserHierarchyStructureSpecForProviderHierarchyStructureLevelFive[];

  /**
   * A block that defines the details of level four. The level block is documented below.
   *
   * @schema UserHierarchyStructureSpecForProviderHierarchyStructure#levelFour
   */
  readonly levelFour?: UserHierarchyStructureSpecForProviderHierarchyStructureLevelFour[];

  /**
   * A block that defines the details of level one. The level block is documented below.
   *
   * @schema UserHierarchyStructureSpecForProviderHierarchyStructure#levelOne
   */
  readonly levelOne?: UserHierarchyStructureSpecForProviderHierarchyStructureLevelOne[];

  /**
   * A block that defines the details of level three. The level block is documented below.
   *
   * @schema UserHierarchyStructureSpecForProviderHierarchyStructure#levelThree
   */
  readonly levelThree?: UserHierarchyStructureSpecForProviderHierarchyStructureLevelThree[];

  /**
   * A block that defines the details of level two. The level block is documented below.
   *
   * @schema UserHierarchyStructureSpecForProviderHierarchyStructure#levelTwo
   */
  readonly levelTwo?: UserHierarchyStructureSpecForProviderHierarchyStructureLevelTwo[];

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProviderHierarchyStructure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProviderHierarchyStructure(obj: UserHierarchyStructureSpecForProviderHierarchyStructure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'levelFive': obj.levelFive?.map(y => toJson_UserHierarchyStructureSpecForProviderHierarchyStructureLevelFive(y)),
    'levelFour': obj.levelFour?.map(y => toJson_UserHierarchyStructureSpecForProviderHierarchyStructureLevelFour(y)),
    'levelOne': obj.levelOne?.map(y => toJson_UserHierarchyStructureSpecForProviderHierarchyStructureLevelOne(y)),
    'levelThree': obj.levelThree?.map(y => toJson_UserHierarchyStructureSpecForProviderHierarchyStructureLevelThree(y)),
    'levelTwo': obj.levelTwo?.map(y => toJson_UserHierarchyStructureSpecForProviderHierarchyStructureLevelTwo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema UserHierarchyStructureSpecForProviderInstanceIdRef
 */
export interface UserHierarchyStructureSpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserHierarchyStructureSpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserHierarchyStructureSpecForProviderInstanceIdRef#policy
   */
  readonly policy?: UserHierarchyStructureSpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProviderInstanceIdRef(obj: UserHierarchyStructureSpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserHierarchyStructureSpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema UserHierarchyStructureSpecForProviderInstanceIdSelector
 */
export interface UserHierarchyStructureSpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserHierarchyStructureSpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserHierarchyStructureSpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserHierarchyStructureSpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProviderInstanceIdSelector(obj: UserHierarchyStructureSpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserHierarchyStructureSpecProviderConfigRefPolicy
 */
export interface UserHierarchyStructureSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserHierarchyStructureSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserHierarchyStructureSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserHierarchyStructureSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserHierarchyStructureSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecProviderConfigRefPolicy(obj: UserHierarchyStructureSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserHierarchyStructureSpecProviderRefPolicy
 */
export interface UserHierarchyStructureSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserHierarchyStructureSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserHierarchyStructureSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserHierarchyStructureSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserHierarchyStructureSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecProviderRefPolicy(obj: UserHierarchyStructureSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserHierarchyStructureSpecPublishConnectionDetailsToConfigRef
 */
export interface UserHierarchyStructureSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserHierarchyStructureSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserHierarchyStructureSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecPublishConnectionDetailsToConfigRef(obj: UserHierarchyStructureSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserHierarchyStructureSpecPublishConnectionDetailsToMetadata
 */
export interface UserHierarchyStructureSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserHierarchyStructureSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserHierarchyStructureSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserHierarchyStructureSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecPublishConnectionDetailsToMetadata(obj: UserHierarchyStructureSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserHierarchyStructureSpecForProviderHierarchyStructureLevelFive
 */
export interface UserHierarchyStructureSpecForProviderHierarchyStructureLevelFive {
  /**
   * The name of the user hierarchy level. Must not be more than 50 characters.
   *
   * @schema UserHierarchyStructureSpecForProviderHierarchyStructureLevelFive#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProviderHierarchyStructureLevelFive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProviderHierarchyStructureLevelFive(obj: UserHierarchyStructureSpecForProviderHierarchyStructureLevelFive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserHierarchyStructureSpecForProviderHierarchyStructureLevelFour
 */
export interface UserHierarchyStructureSpecForProviderHierarchyStructureLevelFour {
  /**
   * The name of the user hierarchy level. Must not be more than 50 characters.
   *
   * @schema UserHierarchyStructureSpecForProviderHierarchyStructureLevelFour#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProviderHierarchyStructureLevelFour' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProviderHierarchyStructureLevelFour(obj: UserHierarchyStructureSpecForProviderHierarchyStructureLevelFour | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserHierarchyStructureSpecForProviderHierarchyStructureLevelOne
 */
export interface UserHierarchyStructureSpecForProviderHierarchyStructureLevelOne {
  /**
   * The name of the user hierarchy level. Must not be more than 50 characters.
   *
   * @schema UserHierarchyStructureSpecForProviderHierarchyStructureLevelOne#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProviderHierarchyStructureLevelOne' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProviderHierarchyStructureLevelOne(obj: UserHierarchyStructureSpecForProviderHierarchyStructureLevelOne | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserHierarchyStructureSpecForProviderHierarchyStructureLevelThree
 */
export interface UserHierarchyStructureSpecForProviderHierarchyStructureLevelThree {
  /**
   * The name of the user hierarchy level. Must not be more than 50 characters.
   *
   * @schema UserHierarchyStructureSpecForProviderHierarchyStructureLevelThree#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProviderHierarchyStructureLevelThree' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProviderHierarchyStructureLevelThree(obj: UserHierarchyStructureSpecForProviderHierarchyStructureLevelThree | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserHierarchyStructureSpecForProviderHierarchyStructureLevelTwo
 */
export interface UserHierarchyStructureSpecForProviderHierarchyStructureLevelTwo {
  /**
   * The name of the user hierarchy level. Must not be more than 50 characters.
   *
   * @schema UserHierarchyStructureSpecForProviderHierarchyStructureLevelTwo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProviderHierarchyStructureLevelTwo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProviderHierarchyStructureLevelTwo(obj: UserHierarchyStructureSpecForProviderHierarchyStructureLevelTwo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserHierarchyStructureSpecForProviderInstanceIdRefPolicy
 */
export interface UserHierarchyStructureSpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserHierarchyStructureSpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: UserHierarchyStructureSpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserHierarchyStructureSpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: UserHierarchyStructureSpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProviderInstanceIdRefPolicy(obj: UserHierarchyStructureSpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicy
 */
export interface UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicy(obj: UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserHierarchyStructureSpecProviderConfigRefPolicyResolution
 */
export enum UserHierarchyStructureSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserHierarchyStructureSpecProviderConfigRefPolicyResolve
 */
export enum UserHierarchyStructureSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserHierarchyStructureSpecProviderRefPolicyResolution
 */
export enum UserHierarchyStructureSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserHierarchyStructureSpecProviderRefPolicyResolve
 */
export enum UserHierarchyStructureSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserHierarchyStructureSpecForProviderInstanceIdRefPolicyResolution
 */
export enum UserHierarchyStructureSpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserHierarchyStructureSpecForProviderInstanceIdRefPolicyResolve
 */
export enum UserHierarchyStructureSpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum UserHierarchyStructureSpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserHierarchyStructureSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Vocabulary is the Schema for the Vocabularys API. Provides details about a specific Amazon Connect Vocabulary
 *
 * @schema Vocabulary
 */
export class Vocabulary extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Vocabulary"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'connect.aws.upbound.io/v1beta1',
    kind: 'Vocabulary',
  }

  /**
   * Renders a Kubernetes manifest for "Vocabulary".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VocabularyProps): any {
    return {
      ...Vocabulary.GVK,
      ...toJson_VocabularyProps(props),
    };
  }

  /**
   * Defines a "Vocabulary" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VocabularyProps) {
    super(scope, id, {
      ...Vocabulary.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Vocabulary.GVK,
      ...toJson_VocabularyProps(resolved),
    };
  }
}

/**
 * Vocabulary is the Schema for the Vocabularys API. Provides details about a specific Amazon Connect Vocabulary
 *
 * @schema Vocabulary
 */
export interface VocabularyProps {
  /**
   * @schema Vocabulary#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VocabularySpec defines the desired state of Vocabulary
   *
   * @schema Vocabulary#spec
   */
  readonly spec: VocabularySpec;

}

/**
 * Converts an object of type 'VocabularyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularyProps(obj: VocabularyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VocabularySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VocabularySpec defines the desired state of Vocabulary
 *
 * @schema VocabularySpec
 */
export interface VocabularySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VocabularySpec#deletionPolicy
   */
  readonly deletionPolicy?: VocabularySpecDeletionPolicy;

  /**
   * @schema VocabularySpec#forProvider
   */
  readonly forProvider: VocabularySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VocabularySpec#managementPolicy
   */
  readonly managementPolicy?: VocabularySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VocabularySpec#providerConfigRef
   */
  readonly providerConfigRef?: VocabularySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema VocabularySpec#providerRef
   */
  readonly providerRef?: VocabularySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VocabularySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VocabularySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VocabularySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VocabularySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VocabularySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpec(obj: VocabularySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VocabularySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_VocabularySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_VocabularySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_VocabularySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VocabularySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VocabularySpecDeletionPolicy
 */
export enum VocabularySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VocabularySpecForProvider
 */
export interface VocabularySpecForProvider {
  /**
   * The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with Phrase, IPA, SoundsLike, and DisplayAs fields. Separate the fields with TAB characters. For more information, see Create a custom vocabulary using a table. Minimum length of 1. Maximum length of 60000.
   *
   * @schema VocabularySpecForProvider#content
   */
  readonly content?: string;

  /**
   * Specifies the identifier of the hosting Amazon Connect Instance.
   *
   * @schema VocabularySpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * Reference to a Instance in connect to populate instanceId.
   *
   * @schema VocabularySpecForProvider#instanceIdRef
   */
  readonly instanceIdRef?: VocabularySpecForProviderInstanceIdRef;

  /**
   * Selector for a Instance in connect to populate instanceId.
   *
   * @schema VocabularySpecForProvider#instanceIdSelector
   */
  readonly instanceIdSelector?: VocabularySpecForProviderInstanceIdSelector;

  /**
   * The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see What is Amazon Transcribe?. Valid Values are ar-AE, de-CH, de-DE, en-AB, en-AU, en-GB, en-IE, en-IN, en-US, en-WL, es-ES, es-US, fr-CA, fr-FR, hi-IN, it-IT, ja-JP, ko-KR, pt-BR, pt-PT, zh-CN.
   *
   * @schema VocabularySpecForProvider#languageCode
   */
  readonly languageCode?: string;

  /**
   * A unique name of the custom vocabulary. Must not be more than 140 characters.
   *
   * @schema VocabularySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VocabularySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema VocabularySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VocabularySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecForProvider(obj: VocabularySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'instanceId': obj.instanceId,
    'instanceIdRef': toJson_VocabularySpecForProviderInstanceIdRef(obj.instanceIdRef),
    'instanceIdSelector': toJson_VocabularySpecForProviderInstanceIdSelector(obj.instanceIdSelector),
    'languageCode': obj.languageCode,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VocabularySpecManagementPolicy
 */
export enum VocabularySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VocabularySpecProviderConfigRef
 */
export interface VocabularySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VocabularySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VocabularySpecProviderConfigRef#policy
   */
  readonly policy?: VocabularySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VocabularySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecProviderConfigRef(obj: VocabularySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VocabularySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema VocabularySpecProviderRef
 */
export interface VocabularySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema VocabularySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VocabularySpecProviderRef#policy
   */
  readonly policy?: VocabularySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'VocabularySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecProviderRef(obj: VocabularySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VocabularySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VocabularySpecPublishConnectionDetailsTo
 */
export interface VocabularySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VocabularySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VocabularySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VocabularySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VocabularySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VocabularySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VocabularySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecPublishConnectionDetailsTo(obj: VocabularySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VocabularySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VocabularySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VocabularySpecWriteConnectionSecretToRef
 */
export interface VocabularySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VocabularySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VocabularySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VocabularySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecWriteConnectionSecretToRef(obj: VocabularySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in connect to populate instanceId.
 *
 * @schema VocabularySpecForProviderInstanceIdRef
 */
export interface VocabularySpecForProviderInstanceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VocabularySpecForProviderInstanceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VocabularySpecForProviderInstanceIdRef#policy
   */
  readonly policy?: VocabularySpecForProviderInstanceIdRefPolicy;

}

/**
 * Converts an object of type 'VocabularySpecForProviderInstanceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecForProviderInstanceIdRef(obj: VocabularySpecForProviderInstanceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VocabularySpecForProviderInstanceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in connect to populate instanceId.
 *
 * @schema VocabularySpecForProviderInstanceIdSelector
 */
export interface VocabularySpecForProviderInstanceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VocabularySpecForProviderInstanceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VocabularySpecForProviderInstanceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VocabularySpecForProviderInstanceIdSelector#policy
   */
  readonly policy?: VocabularySpecForProviderInstanceIdSelectorPolicy;

}

/**
 * Converts an object of type 'VocabularySpecForProviderInstanceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecForProviderInstanceIdSelector(obj: VocabularySpecForProviderInstanceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VocabularySpecForProviderInstanceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VocabularySpecProviderConfigRefPolicy
 */
export interface VocabularySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VocabularySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VocabularySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VocabularySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecProviderConfigRefPolicy(obj: VocabularySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VocabularySpecProviderRefPolicy
 */
export interface VocabularySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularySpecProviderRefPolicy#resolution
   */
  readonly resolution?: VocabularySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularySpecProviderRefPolicy#resolve
   */
  readonly resolve?: VocabularySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'VocabularySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecProviderRefPolicy(obj: VocabularySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VocabularySpecPublishConnectionDetailsToConfigRef
 */
export interface VocabularySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VocabularySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VocabularySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VocabularySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VocabularySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecPublishConnectionDetailsToConfigRef(obj: VocabularySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VocabularySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VocabularySpecPublishConnectionDetailsToMetadata
 */
export interface VocabularySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VocabularySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VocabularySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VocabularySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VocabularySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecPublishConnectionDetailsToMetadata(obj: VocabularySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VocabularySpecForProviderInstanceIdRefPolicy
 */
export interface VocabularySpecForProviderInstanceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularySpecForProviderInstanceIdRefPolicy#resolution
   */
  readonly resolution?: VocabularySpecForProviderInstanceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularySpecForProviderInstanceIdRefPolicy#resolve
   */
  readonly resolve?: VocabularySpecForProviderInstanceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VocabularySpecForProviderInstanceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecForProviderInstanceIdRefPolicy(obj: VocabularySpecForProviderInstanceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VocabularySpecForProviderInstanceIdSelectorPolicy
 */
export interface VocabularySpecForProviderInstanceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularySpecForProviderInstanceIdSelectorPolicy#resolution
   */
  readonly resolution?: VocabularySpecForProviderInstanceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularySpecForProviderInstanceIdSelectorPolicy#resolve
   */
  readonly resolve?: VocabularySpecForProviderInstanceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VocabularySpecForProviderInstanceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecForProviderInstanceIdSelectorPolicy(obj: VocabularySpecForProviderInstanceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularySpecProviderConfigRefPolicyResolution
 */
export enum VocabularySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularySpecProviderConfigRefPolicyResolve
 */
export enum VocabularySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularySpecProviderRefPolicyResolution
 */
export enum VocabularySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularySpecProviderRefPolicyResolve
 */
export enum VocabularySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VocabularySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VocabularySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VocabularySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VocabularySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VocabularySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VocabularySpecPublishConnectionDetailsToConfigRefPolicy(obj: VocabularySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularySpecForProviderInstanceIdRefPolicyResolution
 */
export enum VocabularySpecForProviderInstanceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularySpecForProviderInstanceIdRefPolicyResolve
 */
export enum VocabularySpecForProviderInstanceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularySpecForProviderInstanceIdSelectorPolicyResolution
 */
export enum VocabularySpecForProviderInstanceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularySpecForProviderInstanceIdSelectorPolicyResolve
 */
export enum VocabularySpecForProviderInstanceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VocabularySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

