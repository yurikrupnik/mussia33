// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Instance is the Schema for the Instances API. A Google Cloud Redis instance.
 *
 * @schema Instance
 */
export class Instance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Instance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redis.gcp.upbound.io/v1beta1',
    kind: 'Instance',
  }

  /**
   * Renders a Kubernetes manifest for "Instance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProps): any {
    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(props),
    };
  }

  /**
   * Defines a "Instance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProps) {
    super(scope, id, {
      ...Instance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(resolved),
    };
  }
}

/**
 * Instance is the Schema for the Instances API. A Google Cloud Redis instance.
 *
 * @schema Instance
 */
export interface InstanceProps {
  /**
   * @schema Instance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceSpec defines the desired state of Instance
   *
   * @schema Instance#spec
   */
  readonly spec: InstanceSpec;

}

/**
 * Converts an object of type 'InstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProps(obj: InstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSpec defines the desired state of Instance
 *
 * @schema InstanceSpec
 */
export interface InstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceSpecDeletionPolicy;

  /**
   * @schema InstanceSpec#forProvider
   */
  readonly forProvider: InstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InstanceSpec#initProvider
   */
  readonly initProvider?: InstanceSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InstanceSpec#managementPolicies
   */
  readonly managementPolicies?: InstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpec(obj: InstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_InstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecDeletionPolicy
 */
export enum InstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceSpecForProvider
 */
export interface InstanceSpecForProvider {
  /**
   * Only applicable to STANDARD_HA tier which protects the instance against zonal failures by provisioning it across two zones. If provided, it must be a different zone from the one provided in [locationId].
   *
   * @schema InstanceSpecForProvider#alternativeLocationId
   */
  readonly alternativeLocationId?: string;

  /**
   * Optional. Indicates whether OSS Redis AUTH is enabled for the instance. If set to "true" AUTH is enabled on the instance. Default value is "false" meaning AUTH is disabled.
   *
   * @schema InstanceSpecForProvider#authEnabled
   */
  readonly authEnabled?: boolean;

  /**
   * The full name of the Google Compute Engine network to which the instance is connected. If left unspecified, the default network will be used.
   *
   * @schema InstanceSpecForProvider#authorizedNetwork
   */
  readonly authorizedNetwork?: string;

  /**
   * The connection mode of the Redis instance. Default value is DIRECT_PEERING. Possible values are: DIRECT_PEERING, PRIVATE_SERVICE_ACCESS.
   *
   * @schema InstanceSpecForProvider#connectMode
   */
  readonly connectMode?: string;

  /**
   * Optional. The KMS key reference that you want to use to encrypt the data at rest for this Redis instance. If this is provided, CMEK is enabled.
   *
   * @schema InstanceSpecForProvider#customerManagedKey
   */
  readonly customerManagedKey?: string;

  /**
   * Reference to a CryptoKey in kms to populate customerManagedKey.
   *
   * @schema InstanceSpecForProvider#customerManagedKeyRef
   */
  readonly customerManagedKeyRef?: InstanceSpecForProviderCustomerManagedKeyRef;

  /**
   * Selector for a CryptoKey in kms to populate customerManagedKey.
   *
   * @schema InstanceSpecForProvider#customerManagedKeySelector
   */
  readonly customerManagedKeySelector?: InstanceSpecForProviderCustomerManagedKeySelector;

  /**
   * An arbitrary and optional user-provided name for the instance.
   *
   * @schema InstanceSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Resource labels to represent user provided metadata.
   *
   * @schema InstanceSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The zone where the instance will be provisioned. If not provided, the service will choose a zone for the instance. For STANDARD_HA tier, instances will be created across two zones for protection against zonal failures. If [alternativeLocationId] is also provided, it must be different from [locationId].
   *
   * @schema InstanceSpecForProvider#locationId
   */
  readonly locationId?: string;

  /**
   * Maintenance policy for an instance. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#maintenancePolicy
   */
  readonly maintenancePolicy?: InstanceSpecForProviderMaintenancePolicy[];

  /**
   * Redis memory size in GiB.
   *
   * @schema InstanceSpecForProvider#memorySizeGb
   */
  readonly memorySizeGb?: number;

  /**
   * Persistence configuration for an instance. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#persistenceConfig
   */
  readonly persistenceConfig?: InstanceSpecForProviderPersistenceConfig[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema InstanceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Optional. Read replica mode. Can only be specified when trying to create the instance. If not set, Memorystore Redis backend will default to READ_REPLICAS_DISABLED.
   *
   * @schema InstanceSpecForProvider#readReplicasMode
   */
  readonly readReplicasMode?: string;

  /**
   * Redis configuration parameters, according to http://redis.io/topics/config. Please check Memorystore documentation for the list of supported parameters: https://cloud.google.com/memorystore/docs/redis/reference/rest/v1/projects.locations.instances#Instance.FIELDS.redis_configs
   *
   * @schema InstanceSpecForProvider#redisConfigs
   */
  readonly redisConfigs?: { [key: string]: string };

  /**
   * The version of Redis software. If not provided, latest supported version will be used. Please check the API documentation linked at the top for the latest valid values.
   *
   * @schema InstanceSpecForProvider#redisVersion
   */
  readonly redisVersion?: string;

  /**
   * The name of the Redis region of the instance.
   *
   * @schema InstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Optional. The number of replica nodes. The valid range for the Standard Tier with read replicas enabled is [1-5] and defaults to 2. If read replicas are not enabled for a Standard Tier instance, the only valid value is 1 and the default is 1. The valid value for basic tier is 0 and the default is also 0.
   *
   * @schema InstanceSpecForProvider#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * The CIDR range of internal addresses that are reserved for this instance. If not provided, the service will choose an unused /29 block, for example, 10.0.0.0/29 or 192.168.0.0/29. Ranges must be unique and non-overlapping with existing subnets in an authorized network.
   *
   * @schema InstanceSpecForProvider#reservedIpRange
   */
  readonly reservedIpRange?: string;

  /**
   * Optional. Additional IP range for node placement. Required when enabling read replicas on an existing instance. For DIRECT_PEERING mode value must be a CIDR range of size /28, or "auto". For PRIVATE_SERVICE_ACCESS mode value must be the name of an allocated address range associated with the private service access connection, or "auto".
   *
   * @schema InstanceSpecForProvider#secondaryIpRange
   */
  readonly secondaryIpRange?: string;

  /**
   * The service tier of the instance. Must be one of these values:
   *
   * @schema InstanceSpecForProvider#tier
   */
  readonly tier?: string;

  /**
   * The TLS mode of the Redis instance, If not provided, TLS is disabled for the instance.
   *
   * @schema InstanceSpecForProvider#transitEncryptionMode
   */
  readonly transitEncryptionMode?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProvider(obj: InstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alternativeLocationId': obj.alternativeLocationId,
    'authEnabled': obj.authEnabled,
    'authorizedNetwork': obj.authorizedNetwork,
    'connectMode': obj.connectMode,
    'customerManagedKey': obj.customerManagedKey,
    'customerManagedKeyRef': toJson_InstanceSpecForProviderCustomerManagedKeyRef(obj.customerManagedKeyRef),
    'customerManagedKeySelector': toJson_InstanceSpecForProviderCustomerManagedKeySelector(obj.customerManagedKeySelector),
    'displayName': obj.displayName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locationId': obj.locationId,
    'maintenancePolicy': obj.maintenancePolicy?.map(y => toJson_InstanceSpecForProviderMaintenancePolicy(y)),
    'memorySizeGb': obj.memorySizeGb,
    'persistenceConfig': obj.persistenceConfig?.map(y => toJson_InstanceSpecForProviderPersistenceConfig(y)),
    'project': obj.project,
    'readReplicasMode': obj.readReplicasMode,
    'redisConfigs': ((obj.redisConfigs) === undefined) ? undefined : (Object.entries(obj.redisConfigs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'redisVersion': obj.redisVersion,
    'region': obj.region,
    'replicaCount': obj.replicaCount,
    'reservedIpRange': obj.reservedIpRange,
    'secondaryIpRange': obj.secondaryIpRange,
    'tier': obj.tier,
    'transitEncryptionMode': obj.transitEncryptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema InstanceSpecInitProvider
 */
export interface InstanceSpecInitProvider {
  /**
   * Only applicable to STANDARD_HA tier which protects the instance against zonal failures by provisioning it across two zones. If provided, it must be a different zone from the one provided in [locationId].
   *
   * @schema InstanceSpecInitProvider#alternativeLocationId
   */
  readonly alternativeLocationId?: string;

  /**
   * Optional. Indicates whether OSS Redis AUTH is enabled for the instance. If set to "true" AUTH is enabled on the instance. Default value is "false" meaning AUTH is disabled.
   *
   * @schema InstanceSpecInitProvider#authEnabled
   */
  readonly authEnabled?: boolean;

  /**
   * The full name of the Google Compute Engine network to which the instance is connected. If left unspecified, the default network will be used.
   *
   * @schema InstanceSpecInitProvider#authorizedNetwork
   */
  readonly authorizedNetwork?: string;

  /**
   * The connection mode of the Redis instance. Default value is DIRECT_PEERING. Possible values are: DIRECT_PEERING, PRIVATE_SERVICE_ACCESS.
   *
   * @schema InstanceSpecInitProvider#connectMode
   */
  readonly connectMode?: string;

  /**
   * An arbitrary and optional user-provided name for the instance.
   *
   * @schema InstanceSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Resource labels to represent user provided metadata.
   *
   * @schema InstanceSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The zone where the instance will be provisioned. If not provided, the service will choose a zone for the instance. For STANDARD_HA tier, instances will be created across two zones for protection against zonal failures. If [alternativeLocationId] is also provided, it must be different from [locationId].
   *
   * @schema InstanceSpecInitProvider#locationId
   */
  readonly locationId?: string;

  /**
   * Maintenance policy for an instance. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#maintenancePolicy
   */
  readonly maintenancePolicy?: InstanceSpecInitProviderMaintenancePolicy[];

  /**
   * Redis memory size in GiB.
   *
   * @schema InstanceSpecInitProvider#memorySizeGb
   */
  readonly memorySizeGb?: number;

  /**
   * Persistence configuration for an instance. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#persistenceConfig
   */
  readonly persistenceConfig?: InstanceSpecInitProviderPersistenceConfig[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema InstanceSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Optional. Read replica mode. Can only be specified when trying to create the instance. If not set, Memorystore Redis backend will default to READ_REPLICAS_DISABLED.
   *
   * @schema InstanceSpecInitProvider#readReplicasMode
   */
  readonly readReplicasMode?: string;

  /**
   * Redis configuration parameters, according to http://redis.io/topics/config. Please check Memorystore documentation for the list of supported parameters: https://cloud.google.com/memorystore/docs/redis/reference/rest/v1/projects.locations.instances#Instance.FIELDS.redis_configs
   *
   * @schema InstanceSpecInitProvider#redisConfigs
   */
  readonly redisConfigs?: { [key: string]: string };

  /**
   * The version of Redis software. If not provided, latest supported version will be used. Please check the API documentation linked at the top for the latest valid values.
   *
   * @schema InstanceSpecInitProvider#redisVersion
   */
  readonly redisVersion?: string;

  /**
   * Optional. The number of replica nodes. The valid range for the Standard Tier with read replicas enabled is [1-5] and defaults to 2. If read replicas are not enabled for a Standard Tier instance, the only valid value is 1 and the default is 1. The valid value for basic tier is 0 and the default is also 0.
   *
   * @schema InstanceSpecInitProvider#replicaCount
   */
  readonly replicaCount?: number;

  /**
   * The CIDR range of internal addresses that are reserved for this instance. If not provided, the service will choose an unused /29 block, for example, 10.0.0.0/29 or 192.168.0.0/29. Ranges must be unique and non-overlapping with existing subnets in an authorized network.
   *
   * @schema InstanceSpecInitProvider#reservedIpRange
   */
  readonly reservedIpRange?: string;

  /**
   * Optional. Additional IP range for node placement. Required when enabling read replicas on an existing instance. For DIRECT_PEERING mode value must be a CIDR range of size /28, or "auto". For PRIVATE_SERVICE_ACCESS mode value must be the name of an allocated address range associated with the private service access connection, or "auto".
   *
   * @schema InstanceSpecInitProvider#secondaryIpRange
   */
  readonly secondaryIpRange?: string;

  /**
   * The service tier of the instance. Must be one of these values:
   *
   * @schema InstanceSpecInitProvider#tier
   */
  readonly tier?: string;

  /**
   * The TLS mode of the Redis instance, If not provided, TLS is disabled for the instance.
   *
   * @schema InstanceSpecInitProvider#transitEncryptionMode
   */
  readonly transitEncryptionMode?: string;

}

/**
 * Converts an object of type 'InstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProvider(obj: InstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alternativeLocationId': obj.alternativeLocationId,
    'authEnabled': obj.authEnabled,
    'authorizedNetwork': obj.authorizedNetwork,
    'connectMode': obj.connectMode,
    'displayName': obj.displayName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locationId': obj.locationId,
    'maintenancePolicy': obj.maintenancePolicy?.map(y => toJson_InstanceSpecInitProviderMaintenancePolicy(y)),
    'memorySizeGb': obj.memorySizeGb,
    'persistenceConfig': obj.persistenceConfig?.map(y => toJson_InstanceSpecInitProviderPersistenceConfig(y)),
    'project': obj.project,
    'readReplicasMode': obj.readReplicasMode,
    'redisConfigs': ((obj.redisConfigs) === undefined) ? undefined : (Object.entries(obj.redisConfigs).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'redisVersion': obj.redisVersion,
    'replicaCount': obj.replicaCount,
    'reservedIpRange': obj.reservedIpRange,
    'secondaryIpRange': obj.secondaryIpRange,
    'tier': obj.tier,
    'transitEncryptionMode': obj.transitEncryptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InstanceSpecManagementPolicies
 */
export enum InstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceSpecProviderConfigRef
 */
export interface InstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRef(obj: InstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceSpecPublishConnectionDetailsTo
 */
export interface InstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsTo(obj: InstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceSpecWriteConnectionSecretToRef
 */
export interface InstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecWriteConnectionSecretToRef(obj: InstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate customerManagedKey.
 *
 * @schema InstanceSpecForProviderCustomerManagedKeyRef
 */
export interface InstanceSpecForProviderCustomerManagedKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderCustomerManagedKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderCustomerManagedKeyRef#policy
   */
  readonly policy?: InstanceSpecForProviderCustomerManagedKeyRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCustomerManagedKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCustomerManagedKeyRef(obj: InstanceSpecForProviderCustomerManagedKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderCustomerManagedKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate customerManagedKey.
 *
 * @schema InstanceSpecForProviderCustomerManagedKeySelector
 */
export interface InstanceSpecForProviderCustomerManagedKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderCustomerManagedKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderCustomerManagedKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderCustomerManagedKeySelector#policy
   */
  readonly policy?: InstanceSpecForProviderCustomerManagedKeySelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCustomerManagedKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCustomerManagedKeySelector(obj: InstanceSpecForProviderCustomerManagedKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderCustomerManagedKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderMaintenancePolicy
 */
export interface InstanceSpecForProviderMaintenancePolicy {
  /**
   * Optional. Description of what this policy is for. Create/Update methods return INVALID_ARGUMENT if the length is greater than 512.
   *
   * @schema InstanceSpecForProviderMaintenancePolicy#description
   */
  readonly description?: string;

  /**
   * Optional. Maintenance window that is applied to resources covered by this policy. Minimum 1. For the current version, the maximum number of weekly_window is expected to be one. Structure is documented below.
   *
   * @schema InstanceSpecForProviderMaintenancePolicy#weeklyMaintenanceWindow
   */
  readonly weeklyMaintenanceWindow?: InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow[];

}

/**
 * Converts an object of type 'InstanceSpecForProviderMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMaintenancePolicy(obj: InstanceSpecForProviderMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'weeklyMaintenanceWindow': obj.weeklyMaintenanceWindow?.map(y => toJson_InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderPersistenceConfig
 */
export interface InstanceSpecForProviderPersistenceConfig {
  /**
   * Optional. Controls whether Persistence features are enabled. If not provided, the existing value will be used.
   *
   * @schema InstanceSpecForProviderPersistenceConfig#persistenceMode
   */
  readonly persistenceMode?: string;

  /**
   * Optional. Available snapshot periods for scheduling.
   *
   * @schema InstanceSpecForProviderPersistenceConfig#rdbSnapshotPeriod
   */
  readonly rdbSnapshotPeriod?: string;

  /**
   * Optional. Date and time that the first snapshot was/will be attempted, and to which future snapshots will be aligned. If not provided, the current time will be used. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema InstanceSpecForProviderPersistenceConfig#rdbSnapshotStartTime
   */
  readonly rdbSnapshotStartTime?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderPersistenceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderPersistenceConfig(obj: InstanceSpecForProviderPersistenceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'persistenceMode': obj.persistenceMode,
    'rdbSnapshotPeriod': obj.rdbSnapshotPeriod,
    'rdbSnapshotStartTime': obj.rdbSnapshotStartTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderMaintenancePolicy
 */
export interface InstanceSpecInitProviderMaintenancePolicy {
  /**
   * Optional. Description of what this policy is for. Create/Update methods return INVALID_ARGUMENT if the length is greater than 512.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicy#description
   */
  readonly description?: string;

  /**
   * Optional. Maintenance window that is applied to resources covered by this policy. Minimum 1. For the current version, the maximum number of weekly_window is expected to be one. Structure is documented below.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicy#weeklyMaintenanceWindow
   */
  readonly weeklyMaintenanceWindow?: InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow[];

}

/**
 * Converts an object of type 'InstanceSpecInitProviderMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderMaintenancePolicy(obj: InstanceSpecInitProviderMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'weeklyMaintenanceWindow': obj.weeklyMaintenanceWindow?.map(y => toJson_InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderPersistenceConfig
 */
export interface InstanceSpecInitProviderPersistenceConfig {
  /**
   * Optional. Controls whether Persistence features are enabled. If not provided, the existing value will be used.
   *
   * @schema InstanceSpecInitProviderPersistenceConfig#persistenceMode
   */
  readonly persistenceMode?: string;

  /**
   * Optional. Available snapshot periods for scheduling.
   *
   * @schema InstanceSpecInitProviderPersistenceConfig#rdbSnapshotPeriod
   */
  readonly rdbSnapshotPeriod?: string;

  /**
   * Optional. Date and time that the first snapshot was/will be attempted, and to which future snapshots will be aligned. If not provided, the current time will be used. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema InstanceSpecInitProviderPersistenceConfig#rdbSnapshotStartTime
   */
  readonly rdbSnapshotStartTime?: string;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderPersistenceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderPersistenceConfig(obj: InstanceSpecInitProviderPersistenceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'persistenceMode': obj.persistenceMode,
    'rdbSnapshotPeriod': obj.rdbSnapshotPeriod,
    'rdbSnapshotStartTime': obj.rdbSnapshotStartTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderConfigRefPolicy
 */
export interface InstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRefPolicy(obj: InstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj: InstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj: InstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderCustomerManagedKeyRefPolicy
 */
export interface InstanceSpecForProviderCustomerManagedKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderCustomerManagedKeyRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderCustomerManagedKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderCustomerManagedKeyRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderCustomerManagedKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCustomerManagedKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCustomerManagedKeyRefPolicy(obj: InstanceSpecForProviderCustomerManagedKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderCustomerManagedKeySelectorPolicy
 */
export interface InstanceSpecForProviderCustomerManagedKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderCustomerManagedKeySelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderCustomerManagedKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderCustomerManagedKeySelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderCustomerManagedKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCustomerManagedKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCustomerManagedKeySelectorPolicy(obj: InstanceSpecForProviderCustomerManagedKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow
 */
export interface InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow {
  /**
   * Required. The day of week that maintenance updates occur.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow#day
   */
  readonly day?: string;

  /**
   * Required. Start time of the window in UTC time. Structure is documented below.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow#startTime
   */
  readonly startTime?: InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime[];

}

/**
 * Converts an object of type 'InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow(obj: InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'startTime': obj.startTime?.map(y => toJson_InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow
 */
export interface InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow {
  /**
   * Required. The day of week that maintenance updates occur.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow#day
   */
  readonly day?: string;

  /**
   * Required. Start time of the window in UTC time. Structure is documented below.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow#startTime
   */
  readonly startTime?: InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime[];

}

/**
 * Converts an object of type 'InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow(obj: InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'startTime': obj.startTime?.map(y => toJson_InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolution
 */
export enum InstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolve
 */
export enum InstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderCustomerManagedKeyRefPolicyResolution
 */
export enum InstanceSpecForProviderCustomerManagedKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderCustomerManagedKeyRefPolicyResolve
 */
export enum InstanceSpecForProviderCustomerManagedKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderCustomerManagedKeySelectorPolicyResolution
 */
export enum InstanceSpecForProviderCustomerManagedKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderCustomerManagedKeySelectorPolicyResolve
 */
export enum InstanceSpecForProviderCustomerManagedKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime
 */
export interface InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime(obj: InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime
 */
export interface InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime(obj: InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

