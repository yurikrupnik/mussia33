// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Alias is the Schema for the Aliass API. Creates a Lambda function alias.
 *
 * @schema Alias
 */
export class Alias extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Alias"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'Alias',
  }

  /**
   * Renders a Kubernetes manifest for "Alias".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AliasProps): any {
    return {
      ...Alias.GVK,
      ...toJson_AliasProps(props),
    };
  }

  /**
   * Defines a "Alias" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AliasProps) {
    super(scope, id, {
      ...Alias.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Alias.GVK,
      ...toJson_AliasProps(resolved),
    };
  }
}

/**
 * Alias is the Schema for the Aliass API. Creates a Lambda function alias.
 *
 * @schema Alias
 */
export interface AliasProps {
  /**
   * @schema Alias#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AliasSpec defines the desired state of Alias
   *
   * @schema Alias#spec
   */
  readonly spec: AliasSpec;

}

/**
 * Converts an object of type 'AliasProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasProps(obj: AliasProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AliasSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AliasSpec defines the desired state of Alias
 *
 * @schema AliasSpec
 */
export interface AliasSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AliasSpec#deletionPolicy
   */
  readonly deletionPolicy?: AliasSpecDeletionPolicy;

  /**
   * @schema AliasSpec#forProvider
   */
  readonly forProvider: AliasSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AliasSpec#providerConfigRef
   */
  readonly providerConfigRef?: AliasSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AliasSpec#providerRef
   */
  readonly providerRef?: AliasSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AliasSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AliasSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AliasSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AliasSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AliasSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpec(obj: AliasSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AliasSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AliasSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AliasSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AliasSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AliasSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AliasSpecDeletionPolicy
 */
export enum AliasSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AliasSpecForProvider
 */
export interface AliasSpecForProvider {
  /**
   * Description of the alias.
   *
   * @schema AliasSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Lambda Function name or ARN.
   *
   * @schema AliasSpecForProvider#functionName
   */
  readonly functionName?: string;

  /**
   * Reference to a Function to populate functionName.
   *
   * @schema AliasSpecForProvider#functionNameRef
   */
  readonly functionNameRef?: AliasSpecForProviderFunctionNameRef;

  /**
   * Selector for a Function to populate functionName.
   *
   * @schema AliasSpecForProvider#functionNameSelector
   */
  readonly functionNameSelector?: AliasSpecForProviderFunctionNameSelector;

  /**
   * Lambda function version for which you are creating the alias. Pattern: (\$LATEST|[0-9]+).
   *
   * @schema AliasSpecForProvider#functionVersion
   */
  readonly functionVersion: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AliasSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Lambda alias' route configuration settings. Fields documented below
   *
   * @schema AliasSpecForProvider#routingConfig
   */
  readonly routingConfig?: AliasSpecForProviderRoutingConfig[];

}

/**
 * Converts an object of type 'AliasSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProvider(obj: AliasSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'functionName': obj.functionName,
    'functionNameRef': toJson_AliasSpecForProviderFunctionNameRef(obj.functionNameRef),
    'functionNameSelector': toJson_AliasSpecForProviderFunctionNameSelector(obj.functionNameSelector),
    'functionVersion': obj.functionVersion,
    'region': obj.region,
    'routingConfig': obj.routingConfig?.map(y => toJson_AliasSpecForProviderRoutingConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AliasSpecProviderConfigRef
 */
export interface AliasSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecProviderConfigRef#policy
   */
  readonly policy?: AliasSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderConfigRef(obj: AliasSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AliasSpecProviderRef
 */
export interface AliasSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecProviderRef#policy
   */
  readonly policy?: AliasSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderRef(obj: AliasSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AliasSpecPublishConnectionDetailsTo
 */
export interface AliasSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AliasSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AliasSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsTo(obj: AliasSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AliasSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AliasSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AliasSpecWriteConnectionSecretToRef
 */
export interface AliasSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AliasSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AliasSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AliasSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecWriteConnectionSecretToRef(obj: AliasSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function to populate functionName.
 *
 * @schema AliasSpecForProviderFunctionNameRef
 */
export interface AliasSpecForProviderFunctionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecForProviderFunctionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecForProviderFunctionNameRef#policy
   */
  readonly policy?: AliasSpecForProviderFunctionNameRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecForProviderFunctionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderFunctionNameRef(obj: AliasSpecForProviderFunctionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecForProviderFunctionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function to populate functionName.
 *
 * @schema AliasSpecForProviderFunctionNameSelector
 */
export interface AliasSpecForProviderFunctionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AliasSpecForProviderFunctionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AliasSpecForProviderFunctionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AliasSpecForProviderFunctionNameSelector#policy
   */
  readonly policy?: AliasSpecForProviderFunctionNameSelectorPolicy;

}

/**
 * Converts an object of type 'AliasSpecForProviderFunctionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderFunctionNameSelector(obj: AliasSpecForProviderFunctionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AliasSpecForProviderFunctionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AliasSpecForProviderRoutingConfig
 */
export interface AliasSpecForProviderRoutingConfig {
  /**
   * A map that defines the proportion of events that should be sent to different versions of a lambda function.
   *
   * @schema AliasSpecForProviderRoutingConfig#additionalVersionWeights
   */
  readonly additionalVersionWeights?: { [key: string]: number };

}

/**
 * Converts an object of type 'AliasSpecForProviderRoutingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderRoutingConfig(obj: AliasSpecForProviderRoutingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalVersionWeights': ((obj.additionalVersionWeights) === undefined) ? undefined : (Object.entries(obj.additionalVersionWeights).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AliasSpecProviderConfigRefPolicy
 */
export interface AliasSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AliasSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AliasSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderConfigRefPolicy(obj: AliasSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AliasSpecProviderRefPolicy
 */
export interface AliasSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AliasSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AliasSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderRefPolicy(obj: AliasSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRef
 */
export interface AliasSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AliasSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToConfigRef(obj: AliasSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AliasSpecPublishConnectionDetailsToMetadata
 */
export interface AliasSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToMetadata(obj: AliasSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AliasSpecForProviderFunctionNameRefPolicy
 */
export interface AliasSpecForProviderFunctionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecForProviderFunctionNameRefPolicy#resolution
   */
  readonly resolution?: AliasSpecForProviderFunctionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecForProviderFunctionNameRefPolicy#resolve
   */
  readonly resolve?: AliasSpecForProviderFunctionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecForProviderFunctionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderFunctionNameRefPolicy(obj: AliasSpecForProviderFunctionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AliasSpecForProviderFunctionNameSelectorPolicy
 */
export interface AliasSpecForProviderFunctionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecForProviderFunctionNameSelectorPolicy#resolution
   */
  readonly resolution?: AliasSpecForProviderFunctionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecForProviderFunctionNameSelectorPolicy#resolve
   */
  readonly resolve?: AliasSpecForProviderFunctionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecForProviderFunctionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderFunctionNameSelectorPolicy(obj: AliasSpecForProviderFunctionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecProviderConfigRefPolicyResolution
 */
export enum AliasSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecProviderConfigRefPolicyResolve
 */
export enum AliasSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecProviderRefPolicyResolution
 */
export enum AliasSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecProviderRefPolicyResolve
 */
export enum AliasSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AliasSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToConfigRefPolicy(obj: AliasSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecForProviderFunctionNameRefPolicyResolution
 */
export enum AliasSpecForProviderFunctionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecForProviderFunctionNameRefPolicyResolve
 */
export enum AliasSpecForProviderFunctionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecForProviderFunctionNameSelectorPolicyResolution
 */
export enum AliasSpecForProviderFunctionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecForProviderFunctionNameSelectorPolicyResolve
 */
export enum AliasSpecForProviderFunctionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CodeSigningConfig is the Schema for the CodeSigningConfigs API. Provides a Lambda Code Signing Config resource.
 *
 * @schema CodeSigningConfig
 */
export class CodeSigningConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CodeSigningConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'CodeSigningConfig',
  }

  /**
   * Renders a Kubernetes manifest for "CodeSigningConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CodeSigningConfigProps): any {
    return {
      ...CodeSigningConfig.GVK,
      ...toJson_CodeSigningConfigProps(props),
    };
  }

  /**
   * Defines a "CodeSigningConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CodeSigningConfigProps) {
    super(scope, id, {
      ...CodeSigningConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CodeSigningConfig.GVK,
      ...toJson_CodeSigningConfigProps(resolved),
    };
  }
}

/**
 * CodeSigningConfig is the Schema for the CodeSigningConfigs API. Provides a Lambda Code Signing Config resource.
 *
 * @schema CodeSigningConfig
 */
export interface CodeSigningConfigProps {
  /**
   * @schema CodeSigningConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CodeSigningConfigSpec defines the desired state of CodeSigningConfig
   *
   * @schema CodeSigningConfig#spec
   */
  readonly spec: CodeSigningConfigSpec;

}

/**
 * Converts an object of type 'CodeSigningConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigProps(obj: CodeSigningConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CodeSigningConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CodeSigningConfigSpec defines the desired state of CodeSigningConfig
 *
 * @schema CodeSigningConfigSpec
 */
export interface CodeSigningConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema CodeSigningConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: CodeSigningConfigSpecDeletionPolicy;

  /**
   * @schema CodeSigningConfigSpec#forProvider
   */
  readonly forProvider: CodeSigningConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CodeSigningConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: CodeSigningConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CodeSigningConfigSpec#providerRef
   */
  readonly providerRef?: CodeSigningConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CodeSigningConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CodeSigningConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CodeSigningConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CodeSigningConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CodeSigningConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpec(obj: CodeSigningConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CodeSigningConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_CodeSigningConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CodeSigningConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CodeSigningConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CodeSigningConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema CodeSigningConfigSpecDeletionPolicy
 */
export enum CodeSigningConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CodeSigningConfigSpecForProvider
 */
export interface CodeSigningConfigSpecForProvider {
  /**
   * A configuration block of allowed publishers as signing profiles for this code signing configuration. Detailed below.
   *
   * @schema CodeSigningConfigSpecForProvider#allowedPublishers
   */
  readonly allowedPublishers: CodeSigningConfigSpecForProviderAllowedPublishers[];

  /**
   * Descriptive name for this code signing configuration.
   *
   * @schema CodeSigningConfigSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A configuration block of code signing policies that define the actions to take if the validation checks fail. Detailed below.
   *
   * @schema CodeSigningConfigSpecForProvider#policies
   */
  readonly policies?: CodeSigningConfigSpecForProviderPolicies[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CodeSigningConfigSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecForProvider(obj: CodeSigningConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedPublishers': obj.allowedPublishers?.map(y => toJson_CodeSigningConfigSpecForProviderAllowedPublishers(y)),
    'description': obj.description,
    'policies': obj.policies?.map(y => toJson_CodeSigningConfigSpecForProviderPolicies(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CodeSigningConfigSpecProviderConfigRef
 */
export interface CodeSigningConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodeSigningConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodeSigningConfigSpecProviderConfigRef#policy
   */
  readonly policy?: CodeSigningConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecProviderConfigRef(obj: CodeSigningConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodeSigningConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CodeSigningConfigSpecProviderRef
 */
export interface CodeSigningConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodeSigningConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodeSigningConfigSpecProviderRef#policy
   */
  readonly policy?: CodeSigningConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecProviderRef(obj: CodeSigningConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodeSigningConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CodeSigningConfigSpecPublishConnectionDetailsTo
 */
export interface CodeSigningConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CodeSigningConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CodeSigningConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CodeSigningConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CodeSigningConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CodeSigningConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecPublishConnectionDetailsTo(obj: CodeSigningConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CodeSigningConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CodeSigningConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CodeSigningConfigSpecWriteConnectionSecretToRef
 */
export interface CodeSigningConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CodeSigningConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CodeSigningConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecWriteConnectionSecretToRef(obj: CodeSigningConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodeSigningConfigSpecForProviderAllowedPublishers
 */
export interface CodeSigningConfigSpecForProviderAllowedPublishers {
  /**
   * The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishers#signingProfileVersionArns
   */
  readonly signingProfileVersionArns?: string[];

  /**
   * References to SigningProfile in signer to populate signingProfileVersionArns.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishers#signingProfileVersionArnsRefs
   */
  readonly signingProfileVersionArnsRefs?: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefs[];

  /**
   * Selector for a list of SigningProfile in signer to populate signingProfileVersionArns.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishers#signingProfileVersionArnsSelector
   */
  readonly signingProfileVersionArnsSelector?: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelector;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecForProviderAllowedPublishers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecForProviderAllowedPublishers(obj: CodeSigningConfigSpecForProviderAllowedPublishers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'signingProfileVersionArns': obj.signingProfileVersionArns?.map(y => y),
    'signingProfileVersionArnsRefs': obj.signingProfileVersionArnsRefs?.map(y => toJson_CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefs(y)),
    'signingProfileVersionArnsSelector': toJson_CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelector(obj.signingProfileVersionArnsSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodeSigningConfigSpecForProviderPolicies
 */
export interface CodeSigningConfigSpecForProviderPolicies {
  /**
   * Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Valid values: Warn, Enforce. Default value: Warn.
   *
   * @schema CodeSigningConfigSpecForProviderPolicies#untrustedArtifactOnDeployment
   */
  readonly untrustedArtifactOnDeployment: string;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecForProviderPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecForProviderPolicies(obj: CodeSigningConfigSpecForProviderPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'untrustedArtifactOnDeployment': obj.untrustedArtifactOnDeployment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodeSigningConfigSpecProviderConfigRefPolicy
 */
export interface CodeSigningConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodeSigningConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CodeSigningConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodeSigningConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CodeSigningConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecProviderConfigRefPolicy(obj: CodeSigningConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodeSigningConfigSpecProviderRefPolicy
 */
export interface CodeSigningConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodeSigningConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CodeSigningConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodeSigningConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CodeSigningConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecProviderRefPolicy(obj: CodeSigningConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CodeSigningConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface CodeSigningConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodeSigningConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodeSigningConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecPublishConnectionDetailsToConfigRef(obj: CodeSigningConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CodeSigningConfigSpecPublishConnectionDetailsToMetadata
 */
export interface CodeSigningConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CodeSigningConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CodeSigningConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CodeSigningConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecPublishConnectionDetailsToMetadata(obj: CodeSigningConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefs
 */
export interface CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefs#policy
   */
  readonly policy?: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicy;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefs(obj: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SigningProfile in signer to populate signingProfileVersionArns.
 *
 * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelector
 */
export interface CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelector#policy
   */
  readonly policy?: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicy;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelector(obj: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodeSigningConfigSpecProviderConfigRefPolicyResolution
 */
export enum CodeSigningConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodeSigningConfigSpecProviderConfigRefPolicyResolve
 */
export enum CodeSigningConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodeSigningConfigSpecProviderRefPolicyResolution
 */
export enum CodeSigningConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodeSigningConfigSpecProviderRefPolicyResolve
 */
export enum CodeSigningConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicy
 */
export interface CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicy#resolution
   */
  readonly resolution?: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicy#resolve
   */
  readonly resolve?: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicyResolve;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicy(obj: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicy
 */
export interface CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicy#resolution
   */
  readonly resolution?: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicy#resolve
   */
  readonly resolve?: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicy(obj: CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CodeSigningConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicyResolution
 */
export enum CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicyResolve
 */
export enum CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicyResolution
 */
export enum CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicyResolve
 */
export enum CodeSigningConfigSpecForProviderAllowedPublishersSigningProfileVersionArnsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EventSourceMapping is the Schema for the EventSourceMappings API. Provides a Lambda event source mapping. This allows Lambda functions to get events from Kinesis, DynamoDB, SQS, Amazon MQ and Managed Streaming for Apache Kafka (MSK).
 *
 * @schema EventSourceMapping
 */
export class EventSourceMapping extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EventSourceMapping"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'EventSourceMapping',
  }

  /**
   * Renders a Kubernetes manifest for "EventSourceMapping".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EventSourceMappingProps): any {
    return {
      ...EventSourceMapping.GVK,
      ...toJson_EventSourceMappingProps(props),
    };
  }

  /**
   * Defines a "EventSourceMapping" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EventSourceMappingProps) {
    super(scope, id, {
      ...EventSourceMapping.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EventSourceMapping.GVK,
      ...toJson_EventSourceMappingProps(resolved),
    };
  }
}

/**
 * EventSourceMapping is the Schema for the EventSourceMappings API. Provides a Lambda event source mapping. This allows Lambda functions to get events from Kinesis, DynamoDB, SQS, Amazon MQ and Managed Streaming for Apache Kafka (MSK).
 *
 * @schema EventSourceMapping
 */
export interface EventSourceMappingProps {
  /**
   * @schema EventSourceMapping#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EventSourceMappingSpec defines the desired state of EventSourceMapping
   *
   * @schema EventSourceMapping#spec
   */
  readonly spec: EventSourceMappingSpec;

}

/**
 * Converts an object of type 'EventSourceMappingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingProps(obj: EventSourceMappingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EventSourceMappingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventSourceMappingSpec defines the desired state of EventSourceMapping
 *
 * @schema EventSourceMappingSpec
 */
export interface EventSourceMappingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema EventSourceMappingSpec#deletionPolicy
   */
  readonly deletionPolicy?: EventSourceMappingSpecDeletionPolicy;

  /**
   * @schema EventSourceMappingSpec#forProvider
   */
  readonly forProvider: EventSourceMappingSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EventSourceMappingSpec#providerConfigRef
   */
  readonly providerConfigRef?: EventSourceMappingSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EventSourceMappingSpec#providerRef
   */
  readonly providerRef?: EventSourceMappingSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EventSourceMappingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EventSourceMappingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EventSourceMappingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EventSourceMappingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EventSourceMappingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpec(obj: EventSourceMappingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EventSourceMappingSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_EventSourceMappingSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EventSourceMappingSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EventSourceMappingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EventSourceMappingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema EventSourceMappingSpecDeletionPolicy
 */
export enum EventSourceMappingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EventSourceMappingSpecForProvider
 */
export interface EventSourceMappingSpecForProvider {
  /**
   * Additional configuration block for Amazon Managed Kafka sources. Incompatible with "self_managed_event_source" and "self_managed_kafka_event_source_config". Detailed below.
   *
   * @schema EventSourceMappingSpecForProvider#amazonManagedKafkaEventSourceConfig
   */
  readonly amazonManagedKafkaEventSourceConfig?: EventSourceMappingSpecForProviderAmazonManagedKafkaEventSourceConfig[];

  /**
   * The largest number of records that Lambda will retrieve from your event source at the time of invocation. Defaults to 100 for DynamoDB, Kinesis, MQ and MSK, 10 for SQS.
   *
   * @default 100 for DynamoDB, Kinesis, MQ and MSK, 10 for SQS.
   * @schema EventSourceMappingSpecForProvider#batchSize
   */
  readonly batchSize?: number;

  /**
   * If the function returns an error, split the batch in two and retry. Only available for stream sources (DynamoDB and Kinesis). Defaults to false.
   *
   * @default false.
   * @schema EventSourceMappingSpecForProvider#bisectBatchOnFunctionError
   */
  readonly bisectBatchOnFunctionError?: boolean;

  /**
   * An Amazon SQS queue or Amazon SNS topic destination for failed records. Only available for stream sources (DynamoDB and Kinesis). Detailed below.
   *
   * @schema EventSourceMappingSpecForProvider#destinationConfig
   */
  readonly destinationConfig?: EventSourceMappingSpecForProviderDestinationConfig[];

  /**
   * Determines if the mapping will be enabled on creation. Defaults to true.
   *
   * @default true.
   * @schema EventSourceMappingSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * The event source ARN - this is required for Kinesis stream, DynamoDB stream, SQS queue, MQ broker or MSK cluster.  It is incompatible with a Self Managed Kafka source.
   *
   * @schema EventSourceMappingSpecForProvider#eventSourceArn
   */
  readonly eventSourceArn?: string;

  /**
   * The criteria to use for event filtering Kinesis stream, DynamoDB stream, SQS queue event sources. Detailed below.
   *
   * @schema EventSourceMappingSpecForProvider#filterCriteria
   */
  readonly filterCriteria?: EventSourceMappingSpecForProviderFilterCriteria[];

  /**
   * The name or the ARN of the Lambda function that will be subscribing to events.
   *
   * @schema EventSourceMappingSpecForProvider#functionName
   */
  readonly functionName?: string;

  /**
   * Reference to a Function to populate functionName.
   *
   * @schema EventSourceMappingSpecForProvider#functionNameRef
   */
  readonly functionNameRef?: EventSourceMappingSpecForProviderFunctionNameRef;

  /**
   * Selector for a Function to populate functionName.
   *
   * @schema EventSourceMappingSpecForProvider#functionNameSelector
   */
  readonly functionNameSelector?: EventSourceMappingSpecForProviderFunctionNameSelector;

  /**
   * A list of current response type enums applied to the event source mapping for AWS Lambda checkpointing. Only available for SQS and stream sources (DynamoDB and Kinesis). Valid values: ReportBatchItemFailures.
   *
   * @schema EventSourceMappingSpecForProvider#functionResponseTypes
   */
  readonly functionResponseTypes?: string[];

  /**
   * The maximum amount of time to gather records before invoking the function, in seconds (between 0 and 300). Records will continue to buffer (or accumulate in the case of an SQS queue event source) until either maximum_batching_window_in_seconds expires or batch_size has been met. For streaming event sources, defaults to as soon as records are available in the stream. If the batch it reads from the stream/queue only has one record in it, Lambda only sends one record to the function. Only available for stream sources (DynamoDB and Kinesis) and SQS standard queues.
   *
   * @schema EventSourceMappingSpecForProvider#maximumBatchingWindowInSeconds
   */
  readonly maximumBatchingWindowInSeconds?: number;

  /**
   * The maximum age of a record that Lambda sends to a function for processing. Only available for stream sources (DynamoDB and Kinesis). Must be either -1 (forever, and the default value) or between 60 and 604800 (inclusive).
   *
   * @schema EventSourceMappingSpecForProvider#maximumRecordAgeInSeconds
   */
  readonly maximumRecordAgeInSeconds?: number;

  /**
   * The maximum number of times to retry when the function returns an error. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of -1 (forever), maximum of 10000.
   *
   * @schema EventSourceMappingSpecForProvider#maximumRetryAttempts
   */
  readonly maximumRetryAttempts?: number;

  /**
   * The number of batches to process from each shard concurrently. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of 1, maximum of 10.
   *
   * @schema EventSourceMappingSpecForProvider#parallelizationFactor
   */
  readonly parallelizationFactor?: number;

  /**
   * The name of the Amazon MQ broker destination queue to consume. Only available for MQ sources. A single queue name must be specified.
   *
   * @schema EventSourceMappingSpecForProvider#queues
   */
  readonly queues?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EventSourceMappingSpecForProvider#region
   */
  readonly region: string;

  /**
   * Scaling configuration of the event source. Only available for SQS queues. Detailed below.
   *
   * @schema EventSourceMappingSpecForProvider#scalingConfig
   */
  readonly scalingConfig?: EventSourceMappingSpecForProviderScalingConfig[];

  /**
   * For Self Managed Kafka sources, the location of the self managed cluster. If set, configuration must also include source_access_configuration. Detailed below.
   *
   * @schema EventSourceMappingSpecForProvider#selfManagedEventSource
   */
  readonly selfManagedEventSource?: EventSourceMappingSpecForProviderSelfManagedEventSource[];

  /**
   * Additional configuration block for Self Managed Kafka sources. Incompatible with "event_source_arn" and "amazon_managed_kafka_event_source_config". Detailed below.
   *
   * @schema EventSourceMappingSpecForProvider#selfManagedKafkaEventSourceConfig
   */
  readonly selfManagedKafkaEventSourceConfig?: EventSourceMappingSpecForProviderSelfManagedKafkaEventSourceConfig[];

  /**
   * :  For Self Managed Kafka sources, the access configuration for the source. If set, configuration must also include self_managed_event_source. Detailed below.
   *
   * @schema EventSourceMappingSpecForProvider#sourceAccessConfiguration
   */
  readonly sourceAccessConfiguration?: EventSourceMappingSpecForProviderSourceAccessConfiguration[];

  /**
   * The position in the stream where AWS Lambda should start reading. Must be one of AT_TIMESTAMP (Kinesis only), LATEST or TRIM_HORIZON if getting events from Kinesis, DynamoDB, MSK or Self Managed Apache Kafka. Must not be provided if getting events from SQS. More information about these positions can be found in the AWS DynamoDB Streams API Reference and AWS Kinesis API Reference.
   *
   * @schema EventSourceMappingSpecForProvider#startingPosition
   */
  readonly startingPosition?: string;

  /**
   * A timestamp in RFC3339 format of the data record which to start reading when using starting_position set to AT_TIMESTAMP. If a record with this exact timestamp does not exist, the next later record is chosen. If the timestamp is older than the current trim horizon, the oldest available record is chosen.
   *
   * @schema EventSourceMappingSpecForProvider#startingPositionTimestamp
   */
  readonly startingPositionTimestamp?: string;

  /**
   * The name of the Kafka topics. Only available for MSK sources. A single topic name must be specified.
   *
   * @schema EventSourceMappingSpecForProvider#topics
   */
  readonly topics?: string[];

  /**
   * The duration in seconds of a processing window for AWS Lambda streaming analytics. The range is between 1 second up to 900 seconds. Only available for stream sources (DynamoDB and Kinesis).
   *
   * @schema EventSourceMappingSpecForProvider#tumblingWindowInSeconds
   */
  readonly tumblingWindowInSeconds?: number;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProvider(obj: EventSourceMappingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amazonManagedKafkaEventSourceConfig': obj.amazonManagedKafkaEventSourceConfig?.map(y => toJson_EventSourceMappingSpecForProviderAmazonManagedKafkaEventSourceConfig(y)),
    'batchSize': obj.batchSize,
    'bisectBatchOnFunctionError': obj.bisectBatchOnFunctionError,
    'destinationConfig': obj.destinationConfig?.map(y => toJson_EventSourceMappingSpecForProviderDestinationConfig(y)),
    'enabled': obj.enabled,
    'eventSourceArn': obj.eventSourceArn,
    'filterCriteria': obj.filterCriteria?.map(y => toJson_EventSourceMappingSpecForProviderFilterCriteria(y)),
    'functionName': obj.functionName,
    'functionNameRef': toJson_EventSourceMappingSpecForProviderFunctionNameRef(obj.functionNameRef),
    'functionNameSelector': toJson_EventSourceMappingSpecForProviderFunctionNameSelector(obj.functionNameSelector),
    'functionResponseTypes': obj.functionResponseTypes?.map(y => y),
    'maximumBatchingWindowInSeconds': obj.maximumBatchingWindowInSeconds,
    'maximumRecordAgeInSeconds': obj.maximumRecordAgeInSeconds,
    'maximumRetryAttempts': obj.maximumRetryAttempts,
    'parallelizationFactor': obj.parallelizationFactor,
    'queues': obj.queues?.map(y => y),
    'region': obj.region,
    'scalingConfig': obj.scalingConfig?.map(y => toJson_EventSourceMappingSpecForProviderScalingConfig(y)),
    'selfManagedEventSource': obj.selfManagedEventSource?.map(y => toJson_EventSourceMappingSpecForProviderSelfManagedEventSource(y)),
    'selfManagedKafkaEventSourceConfig': obj.selfManagedKafkaEventSourceConfig?.map(y => toJson_EventSourceMappingSpecForProviderSelfManagedKafkaEventSourceConfig(y)),
    'sourceAccessConfiguration': obj.sourceAccessConfiguration?.map(y => toJson_EventSourceMappingSpecForProviderSourceAccessConfiguration(y)),
    'startingPosition': obj.startingPosition,
    'startingPositionTimestamp': obj.startingPositionTimestamp,
    'topics': obj.topics?.map(y => y),
    'tumblingWindowInSeconds': obj.tumblingWindowInSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EventSourceMappingSpecProviderConfigRef
 */
export interface EventSourceMappingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSourceMappingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSourceMappingSpecProviderConfigRef#policy
   */
  readonly policy?: EventSourceMappingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSourceMappingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecProviderConfigRef(obj: EventSourceMappingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSourceMappingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EventSourceMappingSpecProviderRef
 */
export interface EventSourceMappingSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSourceMappingSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSourceMappingSpecProviderRef#policy
   */
  readonly policy?: EventSourceMappingSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EventSourceMappingSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecProviderRef(obj: EventSourceMappingSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSourceMappingSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EventSourceMappingSpecPublishConnectionDetailsTo
 */
export interface EventSourceMappingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EventSourceMappingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EventSourceMappingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EventSourceMappingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EventSourceMappingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EventSourceMappingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecPublishConnectionDetailsTo(obj: EventSourceMappingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EventSourceMappingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EventSourceMappingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EventSourceMappingSpecWriteConnectionSecretToRef
 */
export interface EventSourceMappingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EventSourceMappingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EventSourceMappingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecWriteConnectionSecretToRef(obj: EventSourceMappingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventSourceMappingSpecForProviderAmazonManagedKafkaEventSourceConfig
 */
export interface EventSourceMappingSpecForProviderAmazonManagedKafkaEventSourceConfig {
  /**
   * A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See AmazonManagedKafkaEventSourceConfig Syntax.
   *
   * @schema EventSourceMappingSpecForProviderAmazonManagedKafkaEventSourceConfig#consumerGroupId
   */
  readonly consumerGroupId?: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderAmazonManagedKafkaEventSourceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderAmazonManagedKafkaEventSourceConfig(obj: EventSourceMappingSpecForProviderAmazonManagedKafkaEventSourceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumerGroupId': obj.consumerGroupId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventSourceMappingSpecForProviderDestinationConfig
 */
export interface EventSourceMappingSpecForProviderDestinationConfig {
  /**
   * The destination configuration for failed invocations. Detailed below.
   *
   * @schema EventSourceMappingSpecForProviderDestinationConfig#onFailure
   */
  readonly onFailure?: EventSourceMappingSpecForProviderDestinationConfigOnFailure[];

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderDestinationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderDestinationConfig(obj: EventSourceMappingSpecForProviderDestinationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onFailure': obj.onFailure?.map(y => toJson_EventSourceMappingSpecForProviderDestinationConfigOnFailure(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventSourceMappingSpecForProviderFilterCriteria
 */
export interface EventSourceMappingSpecForProviderFilterCriteria {
  /**
   * A set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. Detailed below.
   *
   * @schema EventSourceMappingSpecForProviderFilterCriteria#filter
   */
  readonly filter?: EventSourceMappingSpecForProviderFilterCriteriaFilter[];

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderFilterCriteria' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderFilterCriteria(obj: EventSourceMappingSpecForProviderFilterCriteria | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter?.map(y => toJson_EventSourceMappingSpecForProviderFilterCriteriaFilter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function to populate functionName.
 *
 * @schema EventSourceMappingSpecForProviderFunctionNameRef
 */
export interface EventSourceMappingSpecForProviderFunctionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSourceMappingSpecForProviderFunctionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSourceMappingSpecForProviderFunctionNameRef#policy
   */
  readonly policy?: EventSourceMappingSpecForProviderFunctionNameRefPolicy;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderFunctionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderFunctionNameRef(obj: EventSourceMappingSpecForProviderFunctionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSourceMappingSpecForProviderFunctionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function to populate functionName.
 *
 * @schema EventSourceMappingSpecForProviderFunctionNameSelector
 */
export interface EventSourceMappingSpecForProviderFunctionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventSourceMappingSpecForProviderFunctionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventSourceMappingSpecForProviderFunctionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventSourceMappingSpecForProviderFunctionNameSelector#policy
   */
  readonly policy?: EventSourceMappingSpecForProviderFunctionNameSelectorPolicy;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderFunctionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderFunctionNameSelector(obj: EventSourceMappingSpecForProviderFunctionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventSourceMappingSpecForProviderFunctionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventSourceMappingSpecForProviderScalingConfig
 */
export interface EventSourceMappingSpecForProviderScalingConfig {
  /**
   * Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be between 2 and 1000. See Configuring maximum concurrency for Amazon SQS event sources.
   *
   * @schema EventSourceMappingSpecForProviderScalingConfig#maximumConcurrency
   */
  readonly maximumConcurrency?: number;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderScalingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderScalingConfig(obj: EventSourceMappingSpecForProviderScalingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumConcurrency': obj.maximumConcurrency,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventSourceMappingSpecForProviderSelfManagedEventSource
 */
export interface EventSourceMappingSpecForProviderSelfManagedEventSource {
  /**
   * A map of endpoints for the self managed source.  For Kafka self-managed sources, the key should be KAFKA_BOOTSTRAP_SERVERS and the value should be a string with a comma separated list of broker endpoints.
   *
   * @schema EventSourceMappingSpecForProviderSelfManagedEventSource#endpoints
   */
  readonly endpoints: { [key: string]: string };

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderSelfManagedEventSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderSelfManagedEventSource(obj: EventSourceMappingSpecForProviderSelfManagedEventSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': ((obj.endpoints) === undefined) ? undefined : (Object.entries(obj.endpoints).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventSourceMappingSpecForProviderSelfManagedKafkaEventSourceConfig
 */
export interface EventSourceMappingSpecForProviderSelfManagedKafkaEventSourceConfig {
  /**
   * A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See SelfManagedKafkaEventSourceConfig Syntax.
   *
   * @schema EventSourceMappingSpecForProviderSelfManagedKafkaEventSourceConfig#consumerGroupId
   */
  readonly consumerGroupId?: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderSelfManagedKafkaEventSourceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderSelfManagedKafkaEventSourceConfig(obj: EventSourceMappingSpecForProviderSelfManagedKafkaEventSourceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumerGroupId': obj.consumerGroupId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventSourceMappingSpecForProviderSourceAccessConfiguration
 */
export interface EventSourceMappingSpecForProviderSourceAccessConfiguration {
  /**
   * The type of this configuration.  For Self Managed Kafka you will need to supply blocks for type VPC_SUBNET and VPC_SECURITY_GROUP.
   *
   * @schema EventSourceMappingSpecForProviderSourceAccessConfiguration#type
   */
  readonly type: string;

  /**
   * The URI for this configuration.  For type VPC_SUBNET the value should be subnet:subnet_id where subnet_id is the value you would find in an aws_subnet resource's id attribute.  For type VPC_SECURITY_GROUP the value should be security_group:security_group_id where security_group_id is the value you would find in an aws_security_group resource's id attribute.
   *
   * @schema EventSourceMappingSpecForProviderSourceAccessConfiguration#uri
   */
  readonly uri: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderSourceAccessConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderSourceAccessConfiguration(obj: EventSourceMappingSpecForProviderSourceAccessConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSourceMappingSpecProviderConfigRefPolicy
 */
export interface EventSourceMappingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSourceMappingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EventSourceMappingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSourceMappingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EventSourceMappingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSourceMappingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecProviderConfigRefPolicy(obj: EventSourceMappingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSourceMappingSpecProviderRefPolicy
 */
export interface EventSourceMappingSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSourceMappingSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EventSourceMappingSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSourceMappingSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EventSourceMappingSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSourceMappingSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecProviderRefPolicy(obj: EventSourceMappingSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EventSourceMappingSpecPublishConnectionDetailsToConfigRef
 */
export interface EventSourceMappingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSourceMappingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSourceMappingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSourceMappingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecPublishConnectionDetailsToConfigRef(obj: EventSourceMappingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EventSourceMappingSpecPublishConnectionDetailsToMetadata
 */
export interface EventSourceMappingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSourceMappingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSourceMappingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EventSourceMappingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecPublishConnectionDetailsToMetadata(obj: EventSourceMappingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventSourceMappingSpecForProviderDestinationConfigOnFailure
 */
export interface EventSourceMappingSpecForProviderDestinationConfigOnFailure {
  /**
   * The Amazon Resource Name (ARN) of the destination resource.
   *
   * @schema EventSourceMappingSpecForProviderDestinationConfigOnFailure#destinationArn
   */
  readonly destinationArn: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderDestinationConfigOnFailure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderDestinationConfigOnFailure(obj: EventSourceMappingSpecForProviderDestinationConfigOnFailure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationArn': obj.destinationArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventSourceMappingSpecForProviderFilterCriteriaFilter
 */
export interface EventSourceMappingSpecForProviderFilterCriteriaFilter {
  /**
   * A filter pattern up to 4096 characters. See Filter Rule Syntax.
   *
   * @schema EventSourceMappingSpecForProviderFilterCriteriaFilter#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderFilterCriteriaFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderFilterCriteriaFilter(obj: EventSourceMappingSpecForProviderFilterCriteriaFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSourceMappingSpecForProviderFunctionNameRefPolicy
 */
export interface EventSourceMappingSpecForProviderFunctionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSourceMappingSpecForProviderFunctionNameRefPolicy#resolution
   */
  readonly resolution?: EventSourceMappingSpecForProviderFunctionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSourceMappingSpecForProviderFunctionNameRefPolicy#resolve
   */
  readonly resolve?: EventSourceMappingSpecForProviderFunctionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderFunctionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderFunctionNameRefPolicy(obj: EventSourceMappingSpecForProviderFunctionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventSourceMappingSpecForProviderFunctionNameSelectorPolicy
 */
export interface EventSourceMappingSpecForProviderFunctionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSourceMappingSpecForProviderFunctionNameSelectorPolicy#resolution
   */
  readonly resolution?: EventSourceMappingSpecForProviderFunctionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSourceMappingSpecForProviderFunctionNameSelectorPolicy#resolve
   */
  readonly resolve?: EventSourceMappingSpecForProviderFunctionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventSourceMappingSpecForProviderFunctionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecForProviderFunctionNameSelectorPolicy(obj: EventSourceMappingSpecForProviderFunctionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSourceMappingSpecProviderConfigRefPolicyResolution
 */
export enum EventSourceMappingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSourceMappingSpecProviderConfigRefPolicyResolve
 */
export enum EventSourceMappingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSourceMappingSpecProviderRefPolicyResolution
 */
export enum EventSourceMappingSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSourceMappingSpecProviderRefPolicyResolve
 */
export enum EventSourceMappingSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj: EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSourceMappingSpecForProviderFunctionNameRefPolicyResolution
 */
export enum EventSourceMappingSpecForProviderFunctionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSourceMappingSpecForProviderFunctionNameRefPolicyResolve
 */
export enum EventSourceMappingSpecForProviderFunctionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSourceMappingSpecForProviderFunctionNameSelectorPolicyResolution
 */
export enum EventSourceMappingSpecForProviderFunctionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSourceMappingSpecForProviderFunctionNameSelectorPolicyResolve
 */
export enum EventSourceMappingSpecForProviderFunctionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EventSourceMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Function is the Schema for the Functions API. Provides a Lambda Function resource. Lambda allows you to trigger execution of code in response to events in AWS, enabling serverless backend solutions. The Lambda Function itself includes source code and runtime configuration.
 *
 * @schema Function
 */
export class Function extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Function"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'Function',
  }

  /**
   * Renders a Kubernetes manifest for "Function".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionProps): any {
    return {
      ...Function.GVK,
      ...toJson_FunctionProps(props),
    };
  }

  /**
   * Defines a "Function" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionProps) {
    super(scope, id, {
      ...Function.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Function.GVK,
      ...toJson_FunctionProps(resolved),
    };
  }
}

/**
 * Function is the Schema for the Functions API. Provides a Lambda Function resource. Lambda allows you to trigger execution of code in response to events in AWS, enabling serverless backend solutions. The Lambda Function itself includes source code and runtime configuration.
 *
 * @schema Function
 */
export interface FunctionProps {
  /**
   * @schema Function#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionSpec defines the desired state of Function
   *
   * @schema Function#spec
   */
  readonly spec: FunctionSpec;

}

/**
 * Converts an object of type 'FunctionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionProps(obj: FunctionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionSpec defines the desired state of Function
 *
 * @schema FunctionSpec
 */
export interface FunctionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema FunctionSpec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionSpecDeletionPolicy;

  /**
   * @schema FunctionSpec#forProvider
   */
  readonly forProvider: FunctionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionSpec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FunctionSpec#providerRef
   */
  readonly providerRef?: FunctionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpec(obj: FunctionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_FunctionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FunctionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FunctionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema FunctionSpecDeletionPolicy
 */
export enum FunctionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FunctionSpecForProvider
 */
export interface FunctionSpecForProvider {
  /**
   * Instruction set architecture for your Lambda function. Valid values are ["x86_64"] and ["arm64"]. Default is ["x86_64"]. Removing this attribute, function's architecture stay the same.
   *
   * @default x86_64"]. Removing this attribute, function's architecture stay the same.
   * @schema FunctionSpecForProvider#architectures
   */
  readonly architectures?: string[];

  /**
   * To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
   *
   * @schema FunctionSpecForProvider#codeSigningConfigArn
   */
  readonly codeSigningConfigArn?: string;

  /**
   * Configuration block. Detailed below.
   *
   * @schema FunctionSpecForProvider#deadLetterConfig
   */
  readonly deadLetterConfig?: FunctionSpecForProviderDeadLetterConfig[];

  /**
   * Description of what your Lambda Function does.
   *
   * @schema FunctionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Configuration block. Detailed below.
   *
   * @schema FunctionSpecForProvider#environment
   */
  readonly environment?: FunctionSpecForProviderEnvironment[];

  /**
   * The amount of Ephemeral storage(/tmp) to allocate for the Lambda Function in MB. This parameter is used to expand the total amount of Ephemeral storage available, beyond the default amount of 512MB. Detailed below.
   *
   * @schema FunctionSpecForProvider#ephemeralStorage
   */
  readonly ephemeralStorage?: FunctionSpecForProviderEphemeralStorage[];

  /**
   * Configuration block. Detailed below.
   *
   * @schema FunctionSpecForProvider#fileSystemConfig
   */
  readonly fileSystemConfig?: FunctionSpecForProviderFileSystemConfig[];

  /**
   * Function entrypoint in your code.
   *
   * @schema FunctionSpecForProvider#handler
   */
  readonly handler?: string;

  /**
   * Configuration block. Detailed below.
   *
   * @schema FunctionSpecForProvider#imageConfig
   */
  readonly imageConfig?: FunctionSpecForProviderImageConfig[];

  /**
   * ECR image URI containing the function's deployment package. Exactly one of filename, image_uri,  or s3_bucket must be specified.
   *
   * @schema FunctionSpecForProvider#imageUri
   */
  readonly imageUri?: string;

  /**
   * Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key that is used to encrypt environment variables. If this configuration is not provided when environment variables are in use, AWS Lambda uses a default service key. To fix the perpetual difference, remove this configuration.
   *
   * @schema FunctionSpecForProvider#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema FunctionSpecForProvider#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: FunctionSpecForProviderKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema FunctionSpecForProvider#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: FunctionSpecForProviderKmsKeyArnSelector;

  /**
   * List of Lambda Layer Version ARNs (maximum of 5) to attach to your Lambda Function. See Lambda Layers
   *
   * @schema FunctionSpecForProvider#layers
   */
  readonly layers?: string[];

  /**
   * Amount of memory in MB your Lambda Function can use at runtime. Defaults to 128. See Limits
   *
   * @default 128. See Limits
   * @schema FunctionSpecForProvider#memorySize
   */
  readonly memorySize?: number;

  /**
   * Lambda deployment package type. Valid values are Zip and Image. Defaults to Zip.
   *
   * @default Zip.
   * @schema FunctionSpecForProvider#packageType
   */
  readonly packageType?: string;

  /**
   * Whether to publish creation/change as new Lambda Function Version. Defaults to false.
   *
   * @default false.
   * @schema FunctionSpecForProvider#publish
   */
  readonly publish?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FunctionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Whether to replace the security groups on associated lambda network interfaces upon destruction. Removing these security groups from orphaned network interfaces can speed up security group deletion times by avoiding a dependency on AWS's internal cleanup operations. By default, the ENI security groups will be replaced with the default security group in the function's VPC. Set the replacement_security_group_ids attribute to use a custom list of security groups for replacement.
   *
   * @schema FunctionSpecForProvider#replaceSecurityGroupsOnDestroy
   */
  readonly replaceSecurityGroupsOnDestroy?: boolean;

  /**
   * References to SecurityGroup in ec2 to populate replacementSecurityGroupIds.
   *
   * @schema FunctionSpecForProvider#replacementSecurityGroupIdRefs
   */
  readonly replacementSecurityGroupIdRefs?: FunctionSpecForProviderReplacementSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate replacementSecurityGroupIds.
   *
   * @schema FunctionSpecForProvider#replacementSecurityGroupIdSelector
   */
  readonly replacementSecurityGroupIdSelector?: FunctionSpecForProviderReplacementSecurityGroupIdSelector;

  /**
   * List of security group IDs to assign to orphaned Lambda function network interfaces upon destruction. replace_security_groups_on_destroy must be set to true to use this attribute.
   *
   * @schema FunctionSpecForProvider#replacementSecurityGroupIds
   */
  readonly replacementSecurityGroupIds?: string[];

  /**
   * Amount of reserved concurrent executions for this lambda function. A value of 0 disables lambda from being triggered and -1 removes any concurrency limitations. Defaults to Unreserved Concurrency Limits -1. See Managing Concurrency
   *
   * @default Unreserved Concurrency Limits -1. See Managing Concurrency
   * @schema FunctionSpecForProvider#reservedConcurrentExecutions
   */
  readonly reservedConcurrentExecutions?: number;

  /**
   * Amazon Resource Name (ARN) of the function's execution role. The role provides the function's identity and access to AWS services and resources.
   *
   * @schema FunctionSpecForProvider#role
   */
  readonly role?: string;

  /**
   * Reference to a Role in iam to populate role.
   *
   * @schema FunctionSpecForProvider#roleRef
   */
  readonly roleRef?: FunctionSpecForProviderRoleRef;

  /**
   * Selector for a Role in iam to populate role.
   *
   * @schema FunctionSpecForProvider#roleSelector
   */
  readonly roleSelector?: FunctionSpecForProviderRoleSelector;

  /**
   * Identifier of the function's runtime. See Runtimes for valid values.
   *
   * @schema FunctionSpecForProvider#runtime
   */
  readonly runtime?: string;

  /**
   * S3 bucket location containing the function's deployment package. This bucket must reside in the same AWS region where you are creating the Lambda function. Exactly one of filename, image_uri, or s3_bucket must be specified. When s3_bucket is set, s3_key is required.
   *
   * @schema FunctionSpecForProvider#s3Bucket
   */
  readonly s3Bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate s3Bucket.
   *
   * @schema FunctionSpecForProvider#s3BucketRef
   */
  readonly s3BucketRef?: FunctionSpecForProviderS3BucketRef;

  /**
   * Selector for a Bucket in s3 to populate s3Bucket.
   *
   * @schema FunctionSpecForProvider#s3BucketSelector
   */
  readonly s3BucketSelector?: FunctionSpecForProviderS3BucketSelector;

  /**
   * S3 key of an object containing the function's deployment package. When s3_bucket is set, s3_key is required.
   *
   * @schema FunctionSpecForProvider#s3Key
   */
  readonly s3Key?: string;

  /**
   * Object version containing the function's deployment package. Conflicts with filename and image_uri.
   *
   * @schema FunctionSpecForProvider#s3ObjectVersion
   */
  readonly s3ObjectVersion?: string;

  /**
   * Snap start settings block. Detailed below.
   *
   * @schema FunctionSpecForProvider#snapStart
   */
  readonly snapStart?: FunctionSpecForProviderSnapStart[];

  /**
   * Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the package file specified with either filename or s3_key. The usual way to set this is filebase64sha256("file.11.12 and later) or base64sha256(file("file.11.11 and earlier), where "file.zip" is the local filename of the lambda function source archive.
   *
   * @schema FunctionSpecForProvider#sourceCodeHash
   */
  readonly sourceCodeHash?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FunctionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Amount of time your Lambda Function has to run in seconds. Defaults to 3. See Limits.
   *
   * @default 3. See Limits.
   * @schema FunctionSpecForProvider#timeout
   */
  readonly timeout?: number;

  /**
   * Configuration block. Detailed below.
   *
   * @schema FunctionSpecForProvider#tracingConfig
   */
  readonly tracingConfig?: FunctionSpecForProviderTracingConfig[];

  /**
   * Configuration block. Detailed below.
   *
   * @schema FunctionSpecForProvider#vpcConfig
   */
  readonly vpcConfig?: FunctionSpecForProviderVpcConfig[];

}

/**
 * Converts an object of type 'FunctionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProvider(obj: FunctionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'architectures': obj.architectures?.map(y => y),
    'codeSigningConfigArn': obj.codeSigningConfigArn,
    'deadLetterConfig': obj.deadLetterConfig?.map(y => toJson_FunctionSpecForProviderDeadLetterConfig(y)),
    'description': obj.description,
    'environment': obj.environment?.map(y => toJson_FunctionSpecForProviderEnvironment(y)),
    'ephemeralStorage': obj.ephemeralStorage?.map(y => toJson_FunctionSpecForProviderEphemeralStorage(y)),
    'fileSystemConfig': obj.fileSystemConfig?.map(y => toJson_FunctionSpecForProviderFileSystemConfig(y)),
    'handler': obj.handler,
    'imageConfig': obj.imageConfig?.map(y => toJson_FunctionSpecForProviderImageConfig(y)),
    'imageUri': obj.imageUri,
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_FunctionSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_FunctionSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'layers': obj.layers?.map(y => y),
    'memorySize': obj.memorySize,
    'packageType': obj.packageType,
    'publish': obj.publish,
    'region': obj.region,
    'replaceSecurityGroupsOnDestroy': obj.replaceSecurityGroupsOnDestroy,
    'replacementSecurityGroupIdRefs': obj.replacementSecurityGroupIdRefs?.map(y => toJson_FunctionSpecForProviderReplacementSecurityGroupIdRefs(y)),
    'replacementSecurityGroupIdSelector': toJson_FunctionSpecForProviderReplacementSecurityGroupIdSelector(obj.replacementSecurityGroupIdSelector),
    'replacementSecurityGroupIds': obj.replacementSecurityGroupIds?.map(y => y),
    'reservedConcurrentExecutions': obj.reservedConcurrentExecutions,
    'role': obj.role,
    'roleRef': toJson_FunctionSpecForProviderRoleRef(obj.roleRef),
    'roleSelector': toJson_FunctionSpecForProviderRoleSelector(obj.roleSelector),
    'runtime': obj.runtime,
    's3Bucket': obj.s3Bucket,
    's3BucketRef': toJson_FunctionSpecForProviderS3BucketRef(obj.s3BucketRef),
    's3BucketSelector': toJson_FunctionSpecForProviderS3BucketSelector(obj.s3BucketSelector),
    's3Key': obj.s3Key,
    's3ObjectVersion': obj.s3ObjectVersion,
    'snapStart': obj.snapStart?.map(y => toJson_FunctionSpecForProviderSnapStart(y)),
    'sourceCodeHash': obj.sourceCodeHash,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timeout': obj.timeout,
    'tracingConfig': obj.tracingConfig?.map(y => toJson_FunctionSpecForProviderTracingConfig(y)),
    'vpcConfig': obj.vpcConfig?.map(y => toJson_FunctionSpecForProviderVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionSpecProviderConfigRef
 */
export interface FunctionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecProviderConfigRef#policy
   */
  readonly policy?: FunctionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRef(obj: FunctionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FunctionSpecProviderRef
 */
export interface FunctionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecProviderRef#policy
   */
  readonly policy?: FunctionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderRef(obj: FunctionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionSpecPublishConnectionDetailsTo
 */
export interface FunctionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsTo(obj: FunctionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionSpecWriteConnectionSecretToRef
 */
export interface FunctionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecWriteConnectionSecretToRef(obj: FunctionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderDeadLetterConfig
 */
export interface FunctionSpecForProviderDeadLetterConfig {
  /**
   * ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the sns:Publish or sqs:SendMessage action on this ARN, depending on which service is targeted.
   *
   * @schema FunctionSpecForProviderDeadLetterConfig#targetArn
   */
  readonly targetArn: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderDeadLetterConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderDeadLetterConfig(obj: FunctionSpecForProviderDeadLetterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetArn': obj.targetArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderEnvironment
 */
export interface FunctionSpecForProviderEnvironment {
  /**
   * Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
   *
   * @schema FunctionSpecForProviderEnvironment#variables
   */
  readonly variables?: { [key: string]: string };

}

/**
 * Converts an object of type 'FunctionSpecForProviderEnvironment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEnvironment(obj: FunctionSpecForProviderEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'variables': ((obj.variables) === undefined) ? undefined : (Object.entries(obj.variables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderEphemeralStorage
 */
export interface FunctionSpecForProviderEphemeralStorage {
  /**
   * The size of the Lambda function Ephemeral storage(/tmp) represented in MB. The minimum supported ephemeral_storage value defaults to 512MB and the maximum supported value is 10240MB.
   *
   * @schema FunctionSpecForProviderEphemeralStorage#size
   */
  readonly size?: number;

}

/**
 * Converts an object of type 'FunctionSpecForProviderEphemeralStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderEphemeralStorage(obj: FunctionSpecForProviderEphemeralStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderFileSystemConfig
 */
export interface FunctionSpecForProviderFileSystemConfig {
  /**
   * Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
   *
   * @schema FunctionSpecForProviderFileSystemConfig#arn
   */
  readonly arn?: string;

  /**
   * Reference to a AccessPoint in efs to populate arn.
   *
   * @schema FunctionSpecForProviderFileSystemConfig#arnRef
   */
  readonly arnRef?: FunctionSpecForProviderFileSystemConfigArnRef;

  /**
   * Selector for a AccessPoint in efs to populate arn.
   *
   * @schema FunctionSpecForProviderFileSystemConfig#arnSelector
   */
  readonly arnSelector?: FunctionSpecForProviderFileSystemConfigArnSelector;

  /**
   * Path where the function can access the file system, starting with /mnt/.
   *
   * @schema FunctionSpecForProviderFileSystemConfig#localMountPath
   */
  readonly localMountPath: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderFileSystemConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderFileSystemConfig(obj: FunctionSpecForProviderFileSystemConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'arnRef': toJson_FunctionSpecForProviderFileSystemConfigArnRef(obj.arnRef),
    'arnSelector': toJson_FunctionSpecForProviderFileSystemConfigArnSelector(obj.arnSelector),
    'localMountPath': obj.localMountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderImageConfig
 */
export interface FunctionSpecForProviderImageConfig {
  /**
   * Parameters that you want to pass in with entry_point.
   *
   * @schema FunctionSpecForProviderImageConfig#command
   */
  readonly command?: string[];

  /**
   * Entry point to your application, which is typically the location of the runtime executable.
   *
   * @schema FunctionSpecForProviderImageConfig#entryPoint
   */
  readonly entryPoint?: string[];

  /**
   * Working directory.
   *
   * @schema FunctionSpecForProviderImageConfig#workingDirectory
   */
  readonly workingDirectory?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderImageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderImageConfig(obj: FunctionSpecForProviderImageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
    'entryPoint': obj.entryPoint?.map(y => y),
    'workingDirectory': obj.workingDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema FunctionSpecForProviderKmsKeyArnRef
 */
export interface FunctionSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: FunctionSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderKmsKeyArnRef(obj: FunctionSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema FunctionSpecForProviderKmsKeyArnSelector
 */
export interface FunctionSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: FunctionSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderKmsKeyArnSelector(obj: FunctionSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FunctionSpecForProviderReplacementSecurityGroupIdRefs
 */
export interface FunctionSpecForProviderReplacementSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderReplacementSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderReplacementSecurityGroupIdRefs#policy
   */
  readonly policy?: FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderReplacementSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderReplacementSecurityGroupIdRefs(obj: FunctionSpecForProviderReplacementSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate replacementSecurityGroupIds.
 *
 * @schema FunctionSpecForProviderReplacementSecurityGroupIdSelector
 */
export interface FunctionSpecForProviderReplacementSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderReplacementSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderReplacementSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderReplacementSecurityGroupIdSelector#policy
   */
  readonly policy?: FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderReplacementSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderReplacementSecurityGroupIdSelector(obj: FunctionSpecForProviderReplacementSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate role.
 *
 * @schema FunctionSpecForProviderRoleRef
 */
export interface FunctionSpecForProviderRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderRoleRef#policy
   */
  readonly policy?: FunctionSpecForProviderRoleRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderRoleRef(obj: FunctionSpecForProviderRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate role.
 *
 * @schema FunctionSpecForProviderRoleSelector
 */
export interface FunctionSpecForProviderRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderRoleSelector#policy
   */
  readonly policy?: FunctionSpecForProviderRoleSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderRoleSelector(obj: FunctionSpecForProviderRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate s3Bucket.
 *
 * @schema FunctionSpecForProviderS3BucketRef
 */
export interface FunctionSpecForProviderS3BucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderS3BucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderS3BucketRef#policy
   */
  readonly policy?: FunctionSpecForProviderS3BucketRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderS3BucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderS3BucketRef(obj: FunctionSpecForProviderS3BucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderS3BucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate s3Bucket.
 *
 * @schema FunctionSpecForProviderS3BucketSelector
 */
export interface FunctionSpecForProviderS3BucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderS3BucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderS3BucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderS3BucketSelector#policy
   */
  readonly policy?: FunctionSpecForProviderS3BucketSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderS3BucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderS3BucketSelector(obj: FunctionSpecForProviderS3BucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderS3BucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderSnapStart
 */
export interface FunctionSpecForProviderSnapStart {
  /**
   * Conditions where snap start is enabled. Valid values are PublishedVersions.
   *
   * @schema FunctionSpecForProviderSnapStart#applyOn
   */
  readonly applyOn: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSnapStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSnapStart(obj: FunctionSpecForProviderSnapStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyOn': obj.applyOn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderTracingConfig
 */
export interface FunctionSpecForProviderTracingConfig {
  /**
   * Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are PassThrough and Active. If PassThrough, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If Active, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
   *
   * @schema FunctionSpecForProviderTracingConfig#mode
   */
  readonly mode: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderTracingConfig(obj: FunctionSpecForProviderTracingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderVpcConfig
 */
export interface FunctionSpecForProviderVpcConfig {
  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema FunctionSpecForProviderVpcConfig#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: FunctionSpecForProviderVpcConfigSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema FunctionSpecForProviderVpcConfig#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: FunctionSpecForProviderVpcConfigSecurityGroupIdSelector;

  /**
   * List of security group IDs associated with the Lambda function.
   *
   * @schema FunctionSpecForProviderVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema FunctionSpecForProviderVpcConfig#subnetIdRefs
   */
  readonly subnetIdRefs?: FunctionSpecForProviderVpcConfigSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema FunctionSpecForProviderVpcConfig#subnetIdSelector
   */
  readonly subnetIdSelector?: FunctionSpecForProviderVpcConfigSubnetIdSelector;

  /**
   * List of subnet IDs associated with the Lambda function.
   *
   * @schema FunctionSpecForProviderVpcConfig#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfig(obj: FunctionSpecForProviderVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_FunctionSpecForProviderVpcConfigSubnetIdRefs(y)),
    'subnetIdSelector': toJson_FunctionSpecForProviderVpcConfigSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecProviderConfigRefPolicy
 */
export interface FunctionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRefPolicy(obj: FunctionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecProviderRefPolicy
 */
export interface FunctionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderRefPolicy(obj: FunctionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj: FunctionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToMetadata
 */
export interface FunctionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj: FunctionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AccessPoint in efs to populate arn.
 *
 * @schema FunctionSpecForProviderFileSystemConfigArnRef
 */
export interface FunctionSpecForProviderFileSystemConfigArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderFileSystemConfigArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderFileSystemConfigArnRef#policy
   */
  readonly policy?: FunctionSpecForProviderFileSystemConfigArnRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderFileSystemConfigArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderFileSystemConfigArnRef(obj: FunctionSpecForProviderFileSystemConfigArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderFileSystemConfigArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AccessPoint in efs to populate arn.
 *
 * @schema FunctionSpecForProviderFileSystemConfigArnSelector
 */
export interface FunctionSpecForProviderFileSystemConfigArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderFileSystemConfigArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderFileSystemConfigArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderFileSystemConfigArnSelector#policy
   */
  readonly policy?: FunctionSpecForProviderFileSystemConfigArnSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderFileSystemConfigArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderFileSystemConfigArnSelector(obj: FunctionSpecForProviderFileSystemConfigArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderFileSystemConfigArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderKmsKeyArnRefPolicy
 */
export interface FunctionSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderKmsKeyArnRefPolicy(obj: FunctionSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface FunctionSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderKmsKeyArnSelectorPolicy(obj: FunctionSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicy
 */
export interface FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicy(obj: FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicy
 */
export interface FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicy(obj: FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderRoleRefPolicy
 */
export interface FunctionSpecForProviderRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderRoleRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderRoleRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderRoleRefPolicy(obj: FunctionSpecForProviderRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderRoleSelectorPolicy
 */
export interface FunctionSpecForProviderRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderRoleSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderRoleSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderRoleSelectorPolicy(obj: FunctionSpecForProviderRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderS3BucketRefPolicy
 */
export interface FunctionSpecForProviderS3BucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderS3BucketRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderS3BucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderS3BucketRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderS3BucketRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderS3BucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderS3BucketRefPolicy(obj: FunctionSpecForProviderS3BucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderS3BucketSelectorPolicy
 */
export interface FunctionSpecForProviderS3BucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderS3BucketSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderS3BucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderS3BucketSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderS3BucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderS3BucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderS3BucketSelectorPolicy(obj: FunctionSpecForProviderS3BucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefs
 */
export interface FunctionSpecForProviderVpcConfigSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefs#policy
   */
  readonly policy?: FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdRefs(obj: FunctionSpecForProviderVpcConfigSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelector
 */
export interface FunctionSpecForProviderVpcConfigSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelector#policy
   */
  readonly policy?: FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdSelector(obj: FunctionSpecForProviderVpcConfigSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdRefs
 */
export interface FunctionSpecForProviderVpcConfigSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdRefs#policy
   */
  readonly policy?: FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSubnetIdRefs(obj: FunctionSpecForProviderVpcConfigSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdSelector
 */
export interface FunctionSpecForProviderVpcConfigSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdSelector#policy
   */
  readonly policy?: FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSubnetIdSelector(obj: FunctionSpecForProviderVpcConfigSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolution
 */
export enum FunctionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolve
 */
export enum FunctionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecProviderRefPolicyResolution
 */
export enum FunctionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecProviderRefPolicyResolve
 */
export enum FunctionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderFileSystemConfigArnRefPolicy
 */
export interface FunctionSpecForProviderFileSystemConfigArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderFileSystemConfigArnRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderFileSystemConfigArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderFileSystemConfigArnRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderFileSystemConfigArnRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderFileSystemConfigArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderFileSystemConfigArnRefPolicy(obj: FunctionSpecForProviderFileSystemConfigArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderFileSystemConfigArnSelectorPolicy
 */
export interface FunctionSpecForProviderFileSystemConfigArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderFileSystemConfigArnSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderFileSystemConfigArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderFileSystemConfigArnSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderFileSystemConfigArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderFileSystemConfigArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderFileSystemConfigArnSelectorPolicy(obj: FunctionSpecForProviderFileSystemConfigArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum FunctionSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum FunctionSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum FunctionSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum FunctionSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicyResolution
 */
export enum FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicyResolve
 */
export enum FunctionSpecForProviderReplacementSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicyResolution
 */
export enum FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicyResolve
 */
export enum FunctionSpecForProviderReplacementSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderRoleRefPolicyResolution
 */
export enum FunctionSpecForProviderRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderRoleRefPolicyResolve
 */
export enum FunctionSpecForProviderRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderRoleSelectorPolicyResolution
 */
export enum FunctionSpecForProviderRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderRoleSelectorPolicyResolve
 */
export enum FunctionSpecForProviderRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderS3BucketRefPolicyResolution
 */
export enum FunctionSpecForProviderS3BucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderS3BucketRefPolicyResolve
 */
export enum FunctionSpecForProviderS3BucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderS3BucketSelectorPolicyResolution
 */
export enum FunctionSpecForProviderS3BucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderS3BucketSelectorPolicyResolve
 */
export enum FunctionSpecForProviderS3BucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy
 */
export interface FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy(obj: FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy
 */
export interface FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy(obj: FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy
 */
export interface FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy(obj: FunctionSpecForProviderVpcConfigSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy
 */
export interface FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj: FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderFileSystemConfigArnRefPolicyResolution
 */
export enum FunctionSpecForProviderFileSystemConfigArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderFileSystemConfigArnRefPolicyResolve
 */
export enum FunctionSpecForProviderFileSystemConfigArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderFileSystemConfigArnSelectorPolicyResolution
 */
export enum FunctionSpecForProviderFileSystemConfigArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderFileSystemConfigArnSelectorPolicyResolve
 */
export enum FunctionSpecForProviderFileSystemConfigArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution
 */
export enum FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve
 */
export enum FunctionSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution
 */
export enum FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve
 */
export enum FunctionSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolution
 */
export enum FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolve
 */
export enum FunctionSpecForProviderVpcConfigSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution
 */
export enum FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve
 */
export enum FunctionSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FunctionEventInvokeConfig is the Schema for the FunctionEventInvokeConfigs API. Manages an asynchronous invocation configuration for a Lambda Function or Alias.
 *
 * @schema FunctionEventInvokeConfig
 */
export class FunctionEventInvokeConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FunctionEventInvokeConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'FunctionEventInvokeConfig',
  }

  /**
   * Renders a Kubernetes manifest for "FunctionEventInvokeConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionEventInvokeConfigProps): any {
    return {
      ...FunctionEventInvokeConfig.GVK,
      ...toJson_FunctionEventInvokeConfigProps(props),
    };
  }

  /**
   * Defines a "FunctionEventInvokeConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionEventInvokeConfigProps) {
    super(scope, id, {
      ...FunctionEventInvokeConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FunctionEventInvokeConfig.GVK,
      ...toJson_FunctionEventInvokeConfigProps(resolved),
    };
  }
}

/**
 * FunctionEventInvokeConfig is the Schema for the FunctionEventInvokeConfigs API. Manages an asynchronous invocation configuration for a Lambda Function or Alias.
 *
 * @schema FunctionEventInvokeConfig
 */
export interface FunctionEventInvokeConfigProps {
  /**
   * @schema FunctionEventInvokeConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionEventInvokeConfigSpec defines the desired state of FunctionEventInvokeConfig
   *
   * @schema FunctionEventInvokeConfig#spec
   */
  readonly spec: FunctionEventInvokeConfigSpec;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigProps(obj: FunctionEventInvokeConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionEventInvokeConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionEventInvokeConfigSpec defines the desired state of FunctionEventInvokeConfig
 *
 * @schema FunctionEventInvokeConfigSpec
 */
export interface FunctionEventInvokeConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema FunctionEventInvokeConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionEventInvokeConfigSpecDeletionPolicy;

  /**
   * @schema FunctionEventInvokeConfigSpec#forProvider
   */
  readonly forProvider: FunctionEventInvokeConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionEventInvokeConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionEventInvokeConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FunctionEventInvokeConfigSpec#providerRef
   */
  readonly providerRef?: FunctionEventInvokeConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionEventInvokeConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionEventInvokeConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionEventInvokeConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionEventInvokeConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpec(obj: FunctionEventInvokeConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionEventInvokeConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_FunctionEventInvokeConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FunctionEventInvokeConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FunctionEventInvokeConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionEventInvokeConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema FunctionEventInvokeConfigSpecDeletionPolicy
 */
export enum FunctionEventInvokeConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FunctionEventInvokeConfigSpecForProvider
 */
export interface FunctionEventInvokeConfigSpecForProvider {
  /**
   * Configuration block with destination configuration. See below for details.
   *
   * @schema FunctionEventInvokeConfigSpecForProvider#destinationConfig
   */
  readonly destinationConfig?: FunctionEventInvokeConfigSpecForProviderDestinationConfig[];

  /**
   * Name or Amazon Resource Name (ARN) of the Lambda Function, omitting any version or alias qualifier.
   *
   * @schema FunctionEventInvokeConfigSpecForProvider#functionName
   */
  readonly functionName: string;

  /**
   * Maximum age of a request that Lambda sends to a function for processing in seconds. Valid values between 60 and 21600.
   *
   * @schema FunctionEventInvokeConfigSpecForProvider#maximumEventAgeInSeconds
   */
  readonly maximumEventAgeInSeconds?: number;

  /**
   * Maximum number of times to retry when the function returns an error. Valid values between 0 and 2. Defaults to 2.
   *
   * @default 2.
   * @schema FunctionEventInvokeConfigSpecForProvider#maximumRetryAttempts
   */
  readonly maximumRetryAttempts?: number;

  /**
   * Lambda Function published version, $LATEST, or Lambda Alias name.
   *
   * @schema FunctionEventInvokeConfigSpecForProvider#qualifier
   */
  readonly qualifier?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FunctionEventInvokeConfigSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProvider(obj: FunctionEventInvokeConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationConfig': obj.destinationConfig?.map(y => toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfig(y)),
    'functionName': obj.functionName,
    'maximumEventAgeInSeconds': obj.maximumEventAgeInSeconds,
    'maximumRetryAttempts': obj.maximumRetryAttempts,
    'qualifier': obj.qualifier,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionEventInvokeConfigSpecProviderConfigRef
 */
export interface FunctionEventInvokeConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionEventInvokeConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionEventInvokeConfigSpecProviderConfigRef#policy
   */
  readonly policy?: FunctionEventInvokeConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecProviderConfigRef(obj: FunctionEventInvokeConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionEventInvokeConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FunctionEventInvokeConfigSpecProviderRef
 */
export interface FunctionEventInvokeConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionEventInvokeConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionEventInvokeConfigSpecProviderRef#policy
   */
  readonly policy?: FunctionEventInvokeConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecProviderRef(obj: FunctionEventInvokeConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionEventInvokeConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsTo
 */
export interface FunctionEventInvokeConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionEventInvokeConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecPublishConnectionDetailsTo(obj: FunctionEventInvokeConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionEventInvokeConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionEventInvokeConfigSpecWriteConnectionSecretToRef
 */
export interface FunctionEventInvokeConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionEventInvokeConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionEventInvokeConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecWriteConnectionSecretToRef(obj: FunctionEventInvokeConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfig
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfig {
  /**
   * Configuration block with destination configuration for failed asynchronous invocations. See below for details.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfig#onFailure
   */
  readonly onFailure?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailure[];

  /**
   * Configuration block with destination configuration for successful asynchronous invocations. See below for details.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfig#onSuccess
   */
  readonly onSuccess?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccess[];

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfig(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onFailure': obj.onFailure?.map(y => toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailure(y)),
    'onSuccess': obj.onSuccess?.map(y => toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccess(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionEventInvokeConfigSpecProviderConfigRefPolicy
 */
export interface FunctionEventInvokeConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionEventInvokeConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionEventInvokeConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionEventInvokeConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionEventInvokeConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecProviderConfigRefPolicy(obj: FunctionEventInvokeConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionEventInvokeConfigSpecProviderRefPolicy
 */
export interface FunctionEventInvokeConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionEventInvokeConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FunctionEventInvokeConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionEventInvokeConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FunctionEventInvokeConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecProviderRefPolicy(obj: FunctionEventInvokeConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRef(obj: FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToMetadata
 */
export interface FunctionEventInvokeConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecPublishConnectionDetailsToMetadata(obj: FunctionEventInvokeConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailure
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailure {
  /**
   * Amazon Resource Name (ARN) of the destination resource. See the Lambda Developer Guide for acceptable resource types and associated IAM permissions.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailure#destination
   */
  readonly destination?: string;

  /**
   * Reference to a Queue in sqs to populate destination.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailure#destinationRef
   */
  readonly destinationRef?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRef;

  /**
   * Selector for a Queue in sqs to populate destination.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailure#destinationSelector
   */
  readonly destinationSelector?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelector;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailure(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination,
    'destinationRef': toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRef(obj.destinationRef),
    'destinationSelector': toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelector(obj.destinationSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccess
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccess {
  /**
   * Amazon Resource Name (ARN) of the destination resource. See the Lambda Developer Guide for acceptable resource types and associated IAM permissions.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccess#destination
   */
  readonly destination?: string;

  /**
   * Reference to a Topic in sns to populate destination.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccess#destinationRef
   */
  readonly destinationRef?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRef;

  /**
   * Selector for a Topic in sns to populate destination.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccess#destinationSelector
   */
  readonly destinationSelector?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelector;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccess(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination,
    'destinationRef': toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRef(obj.destinationRef),
    'destinationSelector': toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelector(obj.destinationSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionEventInvokeConfigSpecProviderConfigRefPolicyResolution
 */
export enum FunctionEventInvokeConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionEventInvokeConfigSpecProviderConfigRefPolicyResolve
 */
export enum FunctionEventInvokeConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionEventInvokeConfigSpecProviderRefPolicyResolution
 */
export enum FunctionEventInvokeConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionEventInvokeConfigSpecProviderRefPolicyResolve
 */
export enum FunctionEventInvokeConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Queue in sqs to populate destination.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRef
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRef#policy
   */
  readonly policy?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicy;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRef(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Queue in sqs to populate destination.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelector
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelector#policy
   */
  readonly policy?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelector(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate destination.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRef
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRef#policy
   */
  readonly policy?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicy;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRef(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate destination.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelector
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelector#policy
   */
  readonly policy?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelector(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionEventInvokeConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicy
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicy#resolution
   */
  readonly resolution?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicy#resolve
   */
  readonly resolve?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicy(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicy
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicy#resolution
   */
  readonly resolution?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicy#resolve
   */
  readonly resolve?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicy(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicy
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicy#resolution
   */
  readonly resolution?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicy#resolve
   */
  readonly resolve?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicy(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicy
 */
export interface FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicy#resolution
   */
  readonly resolution?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicy#resolve
   */
  readonly resolve?: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicy(obj: FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicyResolution
 */
export enum FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicyResolve
 */
export enum FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicyResolution
 */
export enum FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicyResolve
 */
export enum FunctionEventInvokeConfigSpecForProviderDestinationConfigOnFailureDestinationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicyResolution
 */
export enum FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicyResolve
 */
export enum FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicyResolution
 */
export enum FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicyResolve
 */
export enum FunctionEventInvokeConfigSpecForProviderDestinationConfigOnSuccessDestinationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FunctionURL is the Schema for the FunctionURLs API. Provides a Lambda function URL resource.
 *
 * @schema FunctionURL
 */
export class FunctionUrl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FunctionURL"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'FunctionURL',
  }

  /**
   * Renders a Kubernetes manifest for "FunctionURL".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionUrlProps): any {
    return {
      ...FunctionUrl.GVK,
      ...toJson_FunctionUrlProps(props),
    };
  }

  /**
   * Defines a "FunctionURL" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionUrlProps) {
    super(scope, id, {
      ...FunctionUrl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FunctionUrl.GVK,
      ...toJson_FunctionUrlProps(resolved),
    };
  }
}

/**
 * FunctionURL is the Schema for the FunctionURLs API. Provides a Lambda function URL resource.
 *
 * @schema FunctionURL
 */
export interface FunctionUrlProps {
  /**
   * @schema FunctionURL#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionURLSpec defines the desired state of FunctionURL
   *
   * @schema FunctionURL#spec
   */
  readonly spec: FunctionUrlSpec;

}

/**
 * Converts an object of type 'FunctionUrlProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlProps(obj: FunctionUrlProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionUrlSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionURLSpec defines the desired state of FunctionURL
 *
 * @schema FunctionUrlSpec
 */
export interface FunctionUrlSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema FunctionUrlSpec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionUrlSpecDeletionPolicy;

  /**
   * @schema FunctionUrlSpec#forProvider
   */
  readonly forProvider: FunctionUrlSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionUrlSpec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionUrlSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FunctionUrlSpec#providerRef
   */
  readonly providerRef?: FunctionUrlSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionUrlSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionUrlSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionUrlSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionUrlSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionUrlSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpec(obj: FunctionUrlSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionUrlSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_FunctionUrlSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FunctionUrlSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FunctionUrlSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionUrlSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema FunctionUrlSpecDeletionPolicy
 */
export enum FunctionUrlSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FunctionUrlSpecForProvider
 */
export interface FunctionUrlSpecForProvider {
  /**
   * The type of authentication that the function URL uses. Set to "AWS_IAM" to restrict access to authenticated IAM users only. Set to "NONE" to bypass IAM authentication and create a public endpoint. See the AWS documentation for more details.
   *
   * @schema FunctionUrlSpecForProvider#authorizationType
   */
  readonly authorizationType: string;

  /**
   * The cross-origin resource sharing (CORS) settings for the function URL. Documented below.
   *
   * @schema FunctionUrlSpecForProvider#cors
   */
  readonly cors?: FunctionUrlSpecForProviderCors[];

  /**
   * The name (or ARN) of the Lambda function.
   *
   * @schema FunctionUrlSpecForProvider#functionName
   */
  readonly functionName?: string;

  /**
   * Reference to a Function to populate functionName.
   *
   * @schema FunctionUrlSpecForProvider#functionNameRef
   */
  readonly functionNameRef?: FunctionUrlSpecForProviderFunctionNameRef;

  /**
   * Selector for a Function to populate functionName.
   *
   * @schema FunctionUrlSpecForProvider#functionNameSelector
   */
  readonly functionNameSelector?: FunctionUrlSpecForProviderFunctionNameSelector;

  /**
   * The alias name or "$LATEST".
   *
   * @schema FunctionUrlSpecForProvider#qualifier
   */
  readonly qualifier?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FunctionUrlSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'FunctionUrlSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecForProvider(obj: FunctionUrlSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationType': obj.authorizationType,
    'cors': obj.cors?.map(y => toJson_FunctionUrlSpecForProviderCors(y)),
    'functionName': obj.functionName,
    'functionNameRef': toJson_FunctionUrlSpecForProviderFunctionNameRef(obj.functionNameRef),
    'functionNameSelector': toJson_FunctionUrlSpecForProviderFunctionNameSelector(obj.functionNameSelector),
    'qualifier': obj.qualifier,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionUrlSpecProviderConfigRef
 */
export interface FunctionUrlSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionUrlSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionUrlSpecProviderConfigRef#policy
   */
  readonly policy?: FunctionUrlSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionUrlSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecProviderConfigRef(obj: FunctionUrlSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionUrlSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FunctionUrlSpecProviderRef
 */
export interface FunctionUrlSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionUrlSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionUrlSpecProviderRef#policy
   */
  readonly policy?: FunctionUrlSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FunctionUrlSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecProviderRef(obj: FunctionUrlSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionUrlSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionUrlSpecPublishConnectionDetailsTo
 */
export interface FunctionUrlSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionUrlSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionUrlSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionUrlSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionUrlSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionUrlSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionUrlSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecPublishConnectionDetailsTo(obj: FunctionUrlSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionUrlSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionUrlSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionUrlSpecWriteConnectionSecretToRef
 */
export interface FunctionUrlSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionUrlSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionUrlSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionUrlSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecWriteConnectionSecretToRef(obj: FunctionUrlSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionUrlSpecForProviderCors
 */
export interface FunctionUrlSpecForProviderCors {
  /**
   * Whether to allow cookies or other credentials in requests to the function URL. The default is false.
   *
   * @schema FunctionUrlSpecForProviderCors#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * The HTTP headers that origins can include in requests to the function URL. For example: ["date", "keep-alive", "x-custom-header"].
   *
   * @schema FunctionUrlSpecForProviderCors#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * The HTTP methods that are allowed when calling the function URL. For example: ["GET", "POST", "DELETE"], or the wildcard character (["*"]).
   *
   * @schema FunctionUrlSpecForProviderCors#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * The origins that can access the function URL. You can list any number of specific origins (or the wildcard character ("*")), separated by a comma. For example: ["https://www.example.com", "http://localhost:60905"].
   *
   * @schema FunctionUrlSpecForProviderCors#allowOrigins
   */
  readonly allowOrigins?: string[];

  /**
   * The HTTP headers in your function response that you want to expose to origins that call the function URL.
   *
   * @schema FunctionUrlSpecForProviderCors#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to 0, which means that the browser doesn't cache results. The maximum value is 86400.
   *
   * @schema FunctionUrlSpecForProviderCors#maxAge
   */
  readonly maxAge?: number;

}

/**
 * Converts an object of type 'FunctionUrlSpecForProviderCors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecForProviderCors(obj: FunctionUrlSpecForProviderCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => y),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function to populate functionName.
 *
 * @schema FunctionUrlSpecForProviderFunctionNameRef
 */
export interface FunctionUrlSpecForProviderFunctionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionUrlSpecForProviderFunctionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionUrlSpecForProviderFunctionNameRef#policy
   */
  readonly policy?: FunctionUrlSpecForProviderFunctionNameRefPolicy;

}

/**
 * Converts an object of type 'FunctionUrlSpecForProviderFunctionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecForProviderFunctionNameRef(obj: FunctionUrlSpecForProviderFunctionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionUrlSpecForProviderFunctionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function to populate functionName.
 *
 * @schema FunctionUrlSpecForProviderFunctionNameSelector
 */
export interface FunctionUrlSpecForProviderFunctionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionUrlSpecForProviderFunctionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionUrlSpecForProviderFunctionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionUrlSpecForProviderFunctionNameSelector#policy
   */
  readonly policy?: FunctionUrlSpecForProviderFunctionNameSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionUrlSpecForProviderFunctionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecForProviderFunctionNameSelector(obj: FunctionUrlSpecForProviderFunctionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionUrlSpecForProviderFunctionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionUrlSpecProviderConfigRefPolicy
 */
export interface FunctionUrlSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionUrlSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionUrlSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionUrlSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionUrlSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionUrlSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecProviderConfigRefPolicy(obj: FunctionUrlSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionUrlSpecProviderRefPolicy
 */
export interface FunctionUrlSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionUrlSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FunctionUrlSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionUrlSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FunctionUrlSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionUrlSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecProviderRefPolicy(obj: FunctionUrlSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionUrlSpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionUrlSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionUrlSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionUrlSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionUrlSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecPublishConnectionDetailsToConfigRef(obj: FunctionUrlSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionUrlSpecPublishConnectionDetailsToMetadata
 */
export interface FunctionUrlSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionUrlSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionUrlSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionUrlSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionUrlSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecPublishConnectionDetailsToMetadata(obj: FunctionUrlSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionUrlSpecForProviderFunctionNameRefPolicy
 */
export interface FunctionUrlSpecForProviderFunctionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionUrlSpecForProviderFunctionNameRefPolicy#resolution
   */
  readonly resolution?: FunctionUrlSpecForProviderFunctionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionUrlSpecForProviderFunctionNameRefPolicy#resolve
   */
  readonly resolve?: FunctionUrlSpecForProviderFunctionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionUrlSpecForProviderFunctionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecForProviderFunctionNameRefPolicy(obj: FunctionUrlSpecForProviderFunctionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionUrlSpecForProviderFunctionNameSelectorPolicy
 */
export interface FunctionUrlSpecForProviderFunctionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionUrlSpecForProviderFunctionNameSelectorPolicy#resolution
   */
  readonly resolution?: FunctionUrlSpecForProviderFunctionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionUrlSpecForProviderFunctionNameSelectorPolicy#resolve
   */
  readonly resolve?: FunctionUrlSpecForProviderFunctionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionUrlSpecForProviderFunctionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecForProviderFunctionNameSelectorPolicy(obj: FunctionUrlSpecForProviderFunctionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionUrlSpecProviderConfigRefPolicyResolution
 */
export enum FunctionUrlSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionUrlSpecProviderConfigRefPolicyResolve
 */
export enum FunctionUrlSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionUrlSpecProviderRefPolicyResolution
 */
export enum FunctionUrlSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionUrlSpecProviderRefPolicyResolve
 */
export enum FunctionUrlSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionUrlSpecForProviderFunctionNameRefPolicyResolution
 */
export enum FunctionUrlSpecForProviderFunctionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionUrlSpecForProviderFunctionNameRefPolicyResolve
 */
export enum FunctionUrlSpecForProviderFunctionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionUrlSpecForProviderFunctionNameSelectorPolicyResolution
 */
export enum FunctionUrlSpecForProviderFunctionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionUrlSpecForProviderFunctionNameSelectorPolicyResolve
 */
export enum FunctionUrlSpecForProviderFunctionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionUrlSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Invocation is the Schema for the Invocations API. Invoke AWS Lambda Function
 *
 * @schema Invocation
 */
export class Invocation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Invocation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'Invocation',
  }

  /**
   * Renders a Kubernetes manifest for "Invocation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InvocationProps): any {
    return {
      ...Invocation.GVK,
      ...toJson_InvocationProps(props),
    };
  }

  /**
   * Defines a "Invocation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InvocationProps) {
    super(scope, id, {
      ...Invocation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Invocation.GVK,
      ...toJson_InvocationProps(resolved),
    };
  }
}

/**
 * Invocation is the Schema for the Invocations API. Invoke AWS Lambda Function
 *
 * @schema Invocation
 */
export interface InvocationProps {
  /**
   * @schema Invocation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InvocationSpec defines the desired state of Invocation
   *
   * @schema Invocation#spec
   */
  readonly spec: InvocationSpec;

}

/**
 * Converts an object of type 'InvocationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationProps(obj: InvocationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InvocationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InvocationSpec defines the desired state of Invocation
 *
 * @schema InvocationSpec
 */
export interface InvocationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema InvocationSpec#deletionPolicy
   */
  readonly deletionPolicy?: InvocationSpecDeletionPolicy;

  /**
   * @schema InvocationSpec#forProvider
   */
  readonly forProvider: InvocationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InvocationSpec#providerConfigRef
   */
  readonly providerConfigRef?: InvocationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InvocationSpec#providerRef
   */
  readonly providerRef?: InvocationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InvocationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InvocationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InvocationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InvocationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InvocationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpec(obj: InvocationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InvocationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_InvocationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InvocationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InvocationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InvocationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema InvocationSpecDeletionPolicy
 */
export enum InvocationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InvocationSpecForProvider
 */
export interface InvocationSpecForProvider {
  /**
   * Name of the lambda function.
   *
   * @schema InvocationSpecForProvider#functionName
   */
  readonly functionName?: string;

  /**
   * Reference to a Function to populate functionName.
   *
   * @schema InvocationSpecForProvider#functionNameRef
   */
  readonly functionNameRef?: InvocationSpecForProviderFunctionNameRef;

  /**
   * Selector for a Function to populate functionName.
   *
   * @schema InvocationSpecForProvider#functionNameSelector
   */
  readonly functionNameSelector?: InvocationSpecForProviderFunctionNameSelector;

  /**
   * JSON payload to the lambda function.
   *
   * @schema InvocationSpecForProvider#input
   */
  readonly input: string;

  /**
   * Qualifier (i.e., version) of the lambda function. Defaults to $LATEST.
   *
   * @default LATEST.
   * @schema InvocationSpecForProvider#qualifier
   */
  readonly qualifier?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InvocationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Map of arbitrary keys and values that, when changed, will trigger a re-invocation.
   *
   * @schema InvocationSpecForProvider#triggers
   */
  readonly triggers?: { [key: string]: string };

}

/**
 * Converts an object of type 'InvocationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecForProvider(obj: InvocationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionName': obj.functionName,
    'functionNameRef': toJson_InvocationSpecForProviderFunctionNameRef(obj.functionNameRef),
    'functionNameSelector': toJson_InvocationSpecForProviderFunctionNameSelector(obj.functionNameSelector),
    'input': obj.input,
    'qualifier': obj.qualifier,
    'region': obj.region,
    'triggers': ((obj.triggers) === undefined) ? undefined : (Object.entries(obj.triggers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InvocationSpecProviderConfigRef
 */
export interface InvocationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvocationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvocationSpecProviderConfigRef#policy
   */
  readonly policy?: InvocationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InvocationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecProviderConfigRef(obj: InvocationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvocationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InvocationSpecProviderRef
 */
export interface InvocationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvocationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvocationSpecProviderRef#policy
   */
  readonly policy?: InvocationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InvocationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecProviderRef(obj: InvocationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvocationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InvocationSpecPublishConnectionDetailsTo
 */
export interface InvocationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InvocationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InvocationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InvocationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InvocationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InvocationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InvocationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecPublishConnectionDetailsTo(obj: InvocationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InvocationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InvocationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InvocationSpecWriteConnectionSecretToRef
 */
export interface InvocationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InvocationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InvocationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InvocationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecWriteConnectionSecretToRef(obj: InvocationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function to populate functionName.
 *
 * @schema InvocationSpecForProviderFunctionNameRef
 */
export interface InvocationSpecForProviderFunctionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvocationSpecForProviderFunctionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvocationSpecForProviderFunctionNameRef#policy
   */
  readonly policy?: InvocationSpecForProviderFunctionNameRefPolicy;

}

/**
 * Converts an object of type 'InvocationSpecForProviderFunctionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecForProviderFunctionNameRef(obj: InvocationSpecForProviderFunctionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvocationSpecForProviderFunctionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function to populate functionName.
 *
 * @schema InvocationSpecForProviderFunctionNameSelector
 */
export interface InvocationSpecForProviderFunctionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InvocationSpecForProviderFunctionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InvocationSpecForProviderFunctionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InvocationSpecForProviderFunctionNameSelector#policy
   */
  readonly policy?: InvocationSpecForProviderFunctionNameSelectorPolicy;

}

/**
 * Converts an object of type 'InvocationSpecForProviderFunctionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecForProviderFunctionNameSelector(obj: InvocationSpecForProviderFunctionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InvocationSpecForProviderFunctionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InvocationSpecProviderConfigRefPolicy
 */
export interface InvocationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvocationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InvocationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvocationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InvocationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InvocationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecProviderConfigRefPolicy(obj: InvocationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InvocationSpecProviderRefPolicy
 */
export interface InvocationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvocationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InvocationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvocationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InvocationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InvocationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecProviderRefPolicy(obj: InvocationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InvocationSpecPublishConnectionDetailsToConfigRef
 */
export interface InvocationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InvocationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InvocationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InvocationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InvocationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecPublishConnectionDetailsToConfigRef(obj: InvocationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InvocationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InvocationSpecPublishConnectionDetailsToMetadata
 */
export interface InvocationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InvocationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InvocationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InvocationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InvocationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecPublishConnectionDetailsToMetadata(obj: InvocationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InvocationSpecForProviderFunctionNameRefPolicy
 */
export interface InvocationSpecForProviderFunctionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvocationSpecForProviderFunctionNameRefPolicy#resolution
   */
  readonly resolution?: InvocationSpecForProviderFunctionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvocationSpecForProviderFunctionNameRefPolicy#resolve
   */
  readonly resolve?: InvocationSpecForProviderFunctionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'InvocationSpecForProviderFunctionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecForProviderFunctionNameRefPolicy(obj: InvocationSpecForProviderFunctionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InvocationSpecForProviderFunctionNameSelectorPolicy
 */
export interface InvocationSpecForProviderFunctionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvocationSpecForProviderFunctionNameSelectorPolicy#resolution
   */
  readonly resolution?: InvocationSpecForProviderFunctionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvocationSpecForProviderFunctionNameSelectorPolicy#resolve
   */
  readonly resolve?: InvocationSpecForProviderFunctionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InvocationSpecForProviderFunctionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecForProviderFunctionNameSelectorPolicy(obj: InvocationSpecForProviderFunctionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvocationSpecProviderConfigRefPolicyResolution
 */
export enum InvocationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvocationSpecProviderConfigRefPolicyResolve
 */
export enum InvocationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvocationSpecProviderRefPolicyResolution
 */
export enum InvocationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvocationSpecProviderRefPolicyResolve
 */
export enum InvocationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InvocationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InvocationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InvocationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InvocationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InvocationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InvocationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InvocationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InvocationSpecPublishConnectionDetailsToConfigRefPolicy(obj: InvocationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvocationSpecForProviderFunctionNameRefPolicyResolution
 */
export enum InvocationSpecForProviderFunctionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvocationSpecForProviderFunctionNameRefPolicyResolve
 */
export enum InvocationSpecForProviderFunctionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvocationSpecForProviderFunctionNameSelectorPolicyResolution
 */
export enum InvocationSpecForProviderFunctionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvocationSpecForProviderFunctionNameSelectorPolicyResolve
 */
export enum InvocationSpecForProviderFunctionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InvocationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InvocationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InvocationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InvocationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LayerVersion is the Schema for the LayerVersions API. Provides a Lambda Layer Version resource. Lambda Layers allow you to reuse shared bits of code across multiple lambda functions.
 *
 * @schema LayerVersion
 */
export class LayerVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LayerVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'LayerVersion',
  }

  /**
   * Renders a Kubernetes manifest for "LayerVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LayerVersionProps): any {
    return {
      ...LayerVersion.GVK,
      ...toJson_LayerVersionProps(props),
    };
  }

  /**
   * Defines a "LayerVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LayerVersionProps) {
    super(scope, id, {
      ...LayerVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LayerVersion.GVK,
      ...toJson_LayerVersionProps(resolved),
    };
  }
}

/**
 * LayerVersion is the Schema for the LayerVersions API. Provides a Lambda Layer Version resource. Lambda Layers allow you to reuse shared bits of code across multiple lambda functions.
 *
 * @schema LayerVersion
 */
export interface LayerVersionProps {
  /**
   * @schema LayerVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LayerVersionSpec defines the desired state of LayerVersion
   *
   * @schema LayerVersion#spec
   */
  readonly spec: LayerVersionSpec;

}

/**
 * Converts an object of type 'LayerVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionProps(obj: LayerVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LayerVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LayerVersionSpec defines the desired state of LayerVersion
 *
 * @schema LayerVersionSpec
 */
export interface LayerVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema LayerVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: LayerVersionSpecDeletionPolicy;

  /**
   * @schema LayerVersionSpec#forProvider
   */
  readonly forProvider: LayerVersionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LayerVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: LayerVersionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LayerVersionSpec#providerRef
   */
  readonly providerRef?: LayerVersionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LayerVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LayerVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LayerVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LayerVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LayerVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpec(obj: LayerVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LayerVersionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_LayerVersionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LayerVersionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LayerVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LayerVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema LayerVersionSpecDeletionPolicy
 */
export enum LayerVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LayerVersionSpecForProvider
 */
export interface LayerVersionSpecForProvider {
  /**
   * List of Architectures this layer is compatible with. Currently x86_64 and arm64 can be specified.
   *
   * @schema LayerVersionSpecForProvider#compatibleArchitectures
   */
  readonly compatibleArchitectures?: string[];

  /**
   * List of Runtimes this layer is compatible with. Up to 5 runtimes can be specified.
   *
   * @schema LayerVersionSpecForProvider#compatibleRuntimes
   */
  readonly compatibleRuntimes?: string[];

  /**
   * Description of what your Lambda Layer does.
   *
   * @schema LayerVersionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * prefixed options cannot be used.
   *
   * @schema LayerVersionSpecForProvider#filename
   */
  readonly filename?: string;

  /**
   * Unique name for your Lambda Layer
   *
   * @schema LayerVersionSpecForProvider#layerName
   */
  readonly layerName: string;

  /**
   * License info for your Lambda Layer. See License Info.
   *
   * @schema LayerVersionSpecForProvider#licenseInfo
   */
  readonly licenseInfo?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LayerVersionSpecForProvider#region
   */
  readonly region: string;

  /**
   * S3 bucket location containing the function's deployment package. Conflicts with filename. This bucket must reside in the same AWS region where you are creating the Lambda function.
   *
   * @schema LayerVersionSpecForProvider#s3Bucket
   */
  readonly s3Bucket?: string;

  /**
   * S3 key of an object containing the function's deployment package. Conflicts with filename.
   *
   * @schema LayerVersionSpecForProvider#s3Key
   */
  readonly s3Key?: string;

  /**
   * Object version containing the function's deployment package. Conflicts with filename.
   *
   * @schema LayerVersionSpecForProvider#s3ObjectVersion
   */
  readonly s3ObjectVersion?: string;

  /**
   * Whether to retain the old version of a previously deployed Lambda Layer. Default is false. When this is not set to true, changing any of compatible_architectures, compatible_runtimes, description, filename, layer_name, license_info, s3_bucket, s3_key, s3_object_version, or source_code_hash forces deletion of the existing layer version and creation of a new layer version.
   *
   * @default false. When this is not set to true, changing any of compatible_architectures, compatible_runtimes, description, filename, layer_name, license_info, s3_bucket, s3_key, s3_object_version, or source_code_hash forces deletion of the existing layer version and creation of a new layer version.
   * @schema LayerVersionSpecForProvider#skipDestroy
   */
  readonly skipDestroy?: boolean;

  /**
   * Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the package file specified with either filename or s3_key. The usual way to set this is ${filebase64sha256("file.11.12 or later) or ${base64sha256(file("file.11.11 and earlier), where "file.zip" is the local filename of the lambda layer source archive.
   *
   * @schema LayerVersionSpecForProvider#sourceCodeHash
   */
  readonly sourceCodeHash?: string;

}

/**
 * Converts an object of type 'LayerVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpecForProvider(obj: LayerVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compatibleArchitectures': obj.compatibleArchitectures?.map(y => y),
    'compatibleRuntimes': obj.compatibleRuntimes?.map(y => y),
    'description': obj.description,
    'filename': obj.filename,
    'layerName': obj.layerName,
    'licenseInfo': obj.licenseInfo,
    'region': obj.region,
    's3Bucket': obj.s3Bucket,
    's3Key': obj.s3Key,
    's3ObjectVersion': obj.s3ObjectVersion,
    'skipDestroy': obj.skipDestroy,
    'sourceCodeHash': obj.sourceCodeHash,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LayerVersionSpecProviderConfigRef
 */
export interface LayerVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LayerVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LayerVersionSpecProviderConfigRef#policy
   */
  readonly policy?: LayerVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LayerVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpecProviderConfigRef(obj: LayerVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LayerVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LayerVersionSpecProviderRef
 */
export interface LayerVersionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LayerVersionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LayerVersionSpecProviderRef#policy
   */
  readonly policy?: LayerVersionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LayerVersionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpecProviderRef(obj: LayerVersionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LayerVersionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LayerVersionSpecPublishConnectionDetailsTo
 */
export interface LayerVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LayerVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LayerVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LayerVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LayerVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LayerVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LayerVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpecPublishConnectionDetailsTo(obj: LayerVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LayerVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LayerVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LayerVersionSpecWriteConnectionSecretToRef
 */
export interface LayerVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LayerVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LayerVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LayerVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpecWriteConnectionSecretToRef(obj: LayerVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LayerVersionSpecProviderConfigRefPolicy
 */
export interface LayerVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LayerVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LayerVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LayerVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LayerVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LayerVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpecProviderConfigRefPolicy(obj: LayerVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LayerVersionSpecProviderRefPolicy
 */
export interface LayerVersionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LayerVersionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LayerVersionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LayerVersionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LayerVersionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LayerVersionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpecProviderRefPolicy(obj: LayerVersionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LayerVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface LayerVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LayerVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LayerVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LayerVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LayerVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpecPublishConnectionDetailsToConfigRef(obj: LayerVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LayerVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LayerVersionSpecPublishConnectionDetailsToMetadata
 */
export interface LayerVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LayerVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LayerVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LayerVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LayerVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpecPublishConnectionDetailsToMetadata(obj: LayerVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LayerVersionSpecProviderConfigRefPolicyResolution
 */
export enum LayerVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LayerVersionSpecProviderConfigRefPolicyResolve
 */
export enum LayerVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LayerVersionSpecProviderRefPolicyResolution
 */
export enum LayerVersionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LayerVersionSpecProviderRefPolicyResolve
 */
export enum LayerVersionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LayerVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LayerVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LayerVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LayerVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LayerVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LayerVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LayerVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: LayerVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LayerVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LayerVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LayerVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LayerVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LayerVersionPermission is the Schema for the LayerVersionPermissions API. Provides a Lambda Layer Version Permission resource.
 *
 * @schema LayerVersionPermission
 */
export class LayerVersionPermission extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LayerVersionPermission"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'LayerVersionPermission',
  }

  /**
   * Renders a Kubernetes manifest for "LayerVersionPermission".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LayerVersionPermissionProps): any {
    return {
      ...LayerVersionPermission.GVK,
      ...toJson_LayerVersionPermissionProps(props),
    };
  }

  /**
   * Defines a "LayerVersionPermission" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LayerVersionPermissionProps) {
    super(scope, id, {
      ...LayerVersionPermission.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LayerVersionPermission.GVK,
      ...toJson_LayerVersionPermissionProps(resolved),
    };
  }
}

/**
 * LayerVersionPermission is the Schema for the LayerVersionPermissions API. Provides a Lambda Layer Version Permission resource.
 *
 * @schema LayerVersionPermission
 */
export interface LayerVersionPermissionProps {
  /**
   * @schema LayerVersionPermission#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LayerVersionPermissionSpec defines the desired state of LayerVersionPermission
   *
   * @schema LayerVersionPermission#spec
   */
  readonly spec: LayerVersionPermissionSpec;

}

/**
 * Converts an object of type 'LayerVersionPermissionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionProps(obj: LayerVersionPermissionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LayerVersionPermissionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LayerVersionPermissionSpec defines the desired state of LayerVersionPermission
 *
 * @schema LayerVersionPermissionSpec
 */
export interface LayerVersionPermissionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema LayerVersionPermissionSpec#deletionPolicy
   */
  readonly deletionPolicy?: LayerVersionPermissionSpecDeletionPolicy;

  /**
   * @schema LayerVersionPermissionSpec#forProvider
   */
  readonly forProvider: LayerVersionPermissionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LayerVersionPermissionSpec#providerConfigRef
   */
  readonly providerConfigRef?: LayerVersionPermissionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LayerVersionPermissionSpec#providerRef
   */
  readonly providerRef?: LayerVersionPermissionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LayerVersionPermissionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LayerVersionPermissionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LayerVersionPermissionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LayerVersionPermissionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpec(obj: LayerVersionPermissionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LayerVersionPermissionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_LayerVersionPermissionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LayerVersionPermissionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LayerVersionPermissionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LayerVersionPermissionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema LayerVersionPermissionSpecDeletionPolicy
 */
export enum LayerVersionPermissionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LayerVersionPermissionSpecForProvider
 */
export interface LayerVersionPermissionSpecForProvider {
  /**
   * Action, which will be allowed. lambda:GetLayerVersion value is suggested by AWS documantation.
   *
   * @schema LayerVersionPermissionSpecForProvider#action
   */
  readonly action: string;

  /**
   * The name or ARN of the Lambda Layer, which you want to grant access to.
   *
   * @schema LayerVersionPermissionSpecForProvider#layerName
   */
  readonly layerName: string;

  /**
   * An identifier of AWS Organization, which should be able to use your Lambda Layer. principal should be equal to * if organization_id provided.
   *
   * @schema LayerVersionPermissionSpecForProvider#organizationId
   */
  readonly organizationId?: string;

  /**
   * AWS account ID which should be able to use your Lambda Layer. * can be used here, if you want to share your Lambda Layer widely.
   *
   * @schema LayerVersionPermissionSpecForProvider#principal
   */
  readonly principal: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LayerVersionPermissionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of Lambda Layer Permission, for example dev-account - human readable note about what is this permission for.
   *
   * @schema LayerVersionPermissionSpecForProvider#statementId
   */
  readonly statementId: string;

  /**
   * Version of Lambda Layer, which you want to grant access to. Note: permissions only apply to a single version of a layer.
   *
   * @schema LayerVersionPermissionSpecForProvider#versionNumber
   */
  readonly versionNumber: number;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpecForProvider(obj: LayerVersionPermissionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'layerName': obj.layerName,
    'organizationId': obj.organizationId,
    'principal': obj.principal,
    'region': obj.region,
    'statementId': obj.statementId,
    'versionNumber': obj.versionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LayerVersionPermissionSpecProviderConfigRef
 */
export interface LayerVersionPermissionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LayerVersionPermissionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LayerVersionPermissionSpecProviderConfigRef#policy
   */
  readonly policy?: LayerVersionPermissionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpecProviderConfigRef(obj: LayerVersionPermissionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LayerVersionPermissionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LayerVersionPermissionSpecProviderRef
 */
export interface LayerVersionPermissionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LayerVersionPermissionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LayerVersionPermissionSpecProviderRef#policy
   */
  readonly policy?: LayerVersionPermissionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpecProviderRef(obj: LayerVersionPermissionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LayerVersionPermissionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LayerVersionPermissionSpecPublishConnectionDetailsTo
 */
export interface LayerVersionPermissionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LayerVersionPermissionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LayerVersionPermissionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LayerVersionPermissionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LayerVersionPermissionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LayerVersionPermissionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpecPublishConnectionDetailsTo(obj: LayerVersionPermissionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LayerVersionPermissionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LayerVersionPermissionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LayerVersionPermissionSpecWriteConnectionSecretToRef
 */
export interface LayerVersionPermissionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LayerVersionPermissionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LayerVersionPermissionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpecWriteConnectionSecretToRef(obj: LayerVersionPermissionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LayerVersionPermissionSpecProviderConfigRefPolicy
 */
export interface LayerVersionPermissionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LayerVersionPermissionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LayerVersionPermissionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LayerVersionPermissionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LayerVersionPermissionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpecProviderConfigRefPolicy(obj: LayerVersionPermissionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LayerVersionPermissionSpecProviderRefPolicy
 */
export interface LayerVersionPermissionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LayerVersionPermissionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LayerVersionPermissionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LayerVersionPermissionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LayerVersionPermissionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpecProviderRefPolicy(obj: LayerVersionPermissionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LayerVersionPermissionSpecPublishConnectionDetailsToConfigRef
 */
export interface LayerVersionPermissionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LayerVersionPermissionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LayerVersionPermissionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpecPublishConnectionDetailsToConfigRef(obj: LayerVersionPermissionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LayerVersionPermissionSpecPublishConnectionDetailsToMetadata
 */
export interface LayerVersionPermissionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LayerVersionPermissionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LayerVersionPermissionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LayerVersionPermissionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpecPublishConnectionDetailsToMetadata(obj: LayerVersionPermissionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LayerVersionPermissionSpecProviderConfigRefPolicyResolution
 */
export enum LayerVersionPermissionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LayerVersionPermissionSpecProviderConfigRefPolicyResolve
 */
export enum LayerVersionPermissionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LayerVersionPermissionSpecProviderRefPolicyResolution
 */
export enum LayerVersionPermissionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LayerVersionPermissionSpecProviderRefPolicyResolve
 */
export enum LayerVersionPermissionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj: LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LayerVersionPermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Permission is the Schema for the Permissions API. Creates a Lambda function permission.
 *
 * @schema Permission
 */
export class Permission extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Permission"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'Permission',
  }

  /**
   * Renders a Kubernetes manifest for "Permission".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionProps): any {
    return {
      ...Permission.GVK,
      ...toJson_PermissionProps(props),
    };
  }

  /**
   * Defines a "Permission" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionProps) {
    super(scope, id, {
      ...Permission.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Permission.GVK,
      ...toJson_PermissionProps(resolved),
    };
  }
}

/**
 * Permission is the Schema for the Permissions API. Creates a Lambda function permission.
 *
 * @schema Permission
 */
export interface PermissionProps {
  /**
   * @schema Permission#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionSpec defines the desired state of Permission
   *
   * @schema Permission#spec
   */
  readonly spec: PermissionSpec;

}

/**
 * Converts an object of type 'PermissionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionProps(obj: PermissionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionSpec defines the desired state of Permission
 *
 * @schema PermissionSpec
 */
export interface PermissionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema PermissionSpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionSpecDeletionPolicy;

  /**
   * @schema PermissionSpec#forProvider
   */
  readonly forProvider: PermissionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PermissionSpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PermissionSpec#providerRef
   */
  readonly providerRef?: PermissionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PermissionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PermissionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpec(obj: PermissionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_PermissionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PermissionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PermissionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema PermissionSpecDeletionPolicy
 */
export enum PermissionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionSpecForProvider
 */
export interface PermissionSpecForProvider {
  /**
   * The AWS Lambda action you want to allow in this statement. (e.g., lambda:InvokeFunction)
   *
   * @schema PermissionSpecForProvider#action
   */
  readonly action: string;

  /**
   * The Event Source Token to validate.  Used with Alexa Skills.
   *
   * @schema PermissionSpecForProvider#eventSourceToken
   */
  readonly eventSourceToken?: string;

  /**
   * Name of the Lambda function whose resource policy you are updating
   *
   * @schema PermissionSpecForProvider#functionName
   */
  readonly functionName?: string;

  /**
   * Reference to a Function to populate functionName.
   *
   * @schema PermissionSpecForProvider#functionNameRef
   */
  readonly functionNameRef?: PermissionSpecForProviderFunctionNameRef;

  /**
   * Selector for a Function to populate functionName.
   *
   * @schema PermissionSpecForProvider#functionNameSelector
   */
  readonly functionNameSelector?: PermissionSpecForProviderFunctionNameSelector;

  /**
   * Lambda Function URLs authentication type. Valid values are: AWS_IAM or NONE. Only supported for lambda:InvokeFunctionUrl action.
   *
   * @schema PermissionSpecForProvider#functionUrlAuthType
   */
  readonly functionUrlAuthType?: string;

  /**
   * The principal who is getting this permission e.g., s3.amazonaws.com, an AWS account ID, or AWS IAM principal, or AWS service principal such as events.amazonaws.com or sns.amazonaws.com.
   *
   * @schema PermissionSpecForProvider#principal
   */
  readonly principal: string;

  /**
   * The identifier for your organization in AWS Organizations. Use this to grant permissions to all the AWS accounts under this organization.
   *
   * @schema PermissionSpecForProvider#principalOrgId
   */
  readonly principalOrgId?: string;

  /**
   * Query parameter to specify function version or alias name. The permission will then apply to the specific qualified ARN e.g., arn:aws:lambda:aws-region:acct-id:function:function-name:2
   *
   * @schema PermissionSpecForProvider#qualifier
   */
  readonly qualifier?: string;

  /**
   * Reference to a Alias to populate qualifier.
   *
   * @schema PermissionSpecForProvider#qualifierRef
   */
  readonly qualifierRef?: PermissionSpecForProviderQualifierRef;

  /**
   * Selector for a Alias to populate qualifier.
   *
   * @schema PermissionSpecForProvider#qualifierSelector
   */
  readonly qualifierSelector?: PermissionSpecForProviderQualifierSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PermissionSpecForProvider#region
   */
  readonly region: string;

  /**
   * This parameter is used when allowing cross-account access, or for S3 and SES. The AWS account ID (without a hyphen) of the source owner.
   *
   * @schema PermissionSpecForProvider#sourceAccount
   */
  readonly sourceAccount?: string;

  /**
   * When the principal is an AWS service, the ARN of the specific resource within that service to grant permission to. Without this, any resource from principal will be granted permission  even if that resource is from another account. For S3, this should be the ARN of the S3 Bucket. For EventBridge events, this should be the ARN of the EventBridge Rule. For API Gateway, this should be the ARN of the API, as described here.
   *
   * @schema PermissionSpecForProvider#sourceArn
   */
  readonly sourceArn?: string;

  /**
   * A unique statement identifier.
   *
   * @schema PermissionSpecForProvider#statementId
   */
  readonly statementId?: string;

  /**
   * A statement identifier prefix. Conflicts with statement_id.
   *
   * @schema PermissionSpecForProvider#statementIdPrefix
   */
  readonly statementIdPrefix?: string;

}

/**
 * Converts an object of type 'PermissionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProvider(obj: PermissionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'eventSourceToken': obj.eventSourceToken,
    'functionName': obj.functionName,
    'functionNameRef': toJson_PermissionSpecForProviderFunctionNameRef(obj.functionNameRef),
    'functionNameSelector': toJson_PermissionSpecForProviderFunctionNameSelector(obj.functionNameSelector),
    'functionUrlAuthType': obj.functionUrlAuthType,
    'principal': obj.principal,
    'principalOrgId': obj.principalOrgId,
    'qualifier': obj.qualifier,
    'qualifierRef': toJson_PermissionSpecForProviderQualifierRef(obj.qualifierRef),
    'qualifierSelector': toJson_PermissionSpecForProviderQualifierSelector(obj.qualifierSelector),
    'region': obj.region,
    'sourceAccount': obj.sourceAccount,
    'sourceArn': obj.sourceArn,
    'statementId': obj.statementId,
    'statementIdPrefix': obj.statementIdPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PermissionSpecProviderConfigRef
 */
export interface PermissionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecProviderConfigRef#policy
   */
  readonly policy?: PermissionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderConfigRef(obj: PermissionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PermissionSpecProviderRef
 */
export interface PermissionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecProviderRef#policy
   */
  readonly policy?: PermissionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderRef(obj: PermissionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PermissionSpecPublishConnectionDetailsTo
 */
export interface PermissionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsTo(obj: PermissionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PermissionSpecWriteConnectionSecretToRef
 */
export interface PermissionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecWriteConnectionSecretToRef(obj: PermissionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function to populate functionName.
 *
 * @schema PermissionSpecForProviderFunctionNameRef
 */
export interface PermissionSpecForProviderFunctionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecForProviderFunctionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecForProviderFunctionNameRef#policy
   */
  readonly policy?: PermissionSpecForProviderFunctionNameRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderFunctionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderFunctionNameRef(obj: PermissionSpecForProviderFunctionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecForProviderFunctionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function to populate functionName.
 *
 * @schema PermissionSpecForProviderFunctionNameSelector
 */
export interface PermissionSpecForProviderFunctionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionSpecForProviderFunctionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionSpecForProviderFunctionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionSpecForProviderFunctionNameSelector#policy
   */
  readonly policy?: PermissionSpecForProviderFunctionNameSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderFunctionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderFunctionNameSelector(obj: PermissionSpecForProviderFunctionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionSpecForProviderFunctionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Alias to populate qualifier.
 *
 * @schema PermissionSpecForProviderQualifierRef
 */
export interface PermissionSpecForProviderQualifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecForProviderQualifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecForProviderQualifierRef#policy
   */
  readonly policy?: PermissionSpecForProviderQualifierRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderQualifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderQualifierRef(obj: PermissionSpecForProviderQualifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecForProviderQualifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Alias to populate qualifier.
 *
 * @schema PermissionSpecForProviderQualifierSelector
 */
export interface PermissionSpecForProviderQualifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionSpecForProviderQualifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionSpecForProviderQualifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionSpecForProviderQualifierSelector#policy
   */
  readonly policy?: PermissionSpecForProviderQualifierSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderQualifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderQualifierSelector(obj: PermissionSpecForProviderQualifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionSpecForProviderQualifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecProviderConfigRefPolicy
 */
export interface PermissionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderConfigRefPolicy(obj: PermissionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecProviderRefPolicy
 */
export interface PermissionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderRefPolicy(obj: PermissionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToConfigRef(obj: PermissionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionSpecPublishConnectionDetailsToMetadata
 */
export interface PermissionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToMetadata(obj: PermissionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecForProviderFunctionNameRefPolicy
 */
export interface PermissionSpecForProviderFunctionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderFunctionNameRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderFunctionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderFunctionNameRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderFunctionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderFunctionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderFunctionNameRefPolicy(obj: PermissionSpecForProviderFunctionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionSpecForProviderFunctionNameSelectorPolicy
 */
export interface PermissionSpecForProviderFunctionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderFunctionNameSelectorPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderFunctionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderFunctionNameSelectorPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderFunctionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderFunctionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderFunctionNameSelectorPolicy(obj: PermissionSpecForProviderFunctionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecForProviderQualifierRefPolicy
 */
export interface PermissionSpecForProviderQualifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderQualifierRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderQualifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderQualifierRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderQualifierRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderQualifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderQualifierRefPolicy(obj: PermissionSpecForProviderQualifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionSpecForProviderQualifierSelectorPolicy
 */
export interface PermissionSpecForProviderQualifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderQualifierSelectorPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderQualifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderQualifierSelectorPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderQualifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderQualifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderQualifierSelectorPolicy(obj: PermissionSpecForProviderQualifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecProviderConfigRefPolicyResolution
 */
export enum PermissionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecProviderConfigRefPolicyResolve
 */
export enum PermissionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecProviderRefPolicyResolution
 */
export enum PermissionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecProviderRefPolicyResolve
 */
export enum PermissionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderFunctionNameRefPolicyResolution
 */
export enum PermissionSpecForProviderFunctionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderFunctionNameRefPolicyResolve
 */
export enum PermissionSpecForProviderFunctionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderFunctionNameSelectorPolicyResolution
 */
export enum PermissionSpecForProviderFunctionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderFunctionNameSelectorPolicyResolve
 */
export enum PermissionSpecForProviderFunctionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderQualifierRefPolicyResolution
 */
export enum PermissionSpecForProviderQualifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderQualifierRefPolicyResolve
 */
export enum PermissionSpecForProviderQualifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderQualifierSelectorPolicyResolution
 */
export enum PermissionSpecForProviderQualifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderQualifierSelectorPolicyResolve
 */
export enum PermissionSpecForProviderQualifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProvisionedConcurrencyConfig is the Schema for the ProvisionedConcurrencyConfigs API. Manages a Lambda Provisioned Concurrency Configuration
 *
 * @schema ProvisionedConcurrencyConfig
 */
export class ProvisionedConcurrencyConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProvisionedConcurrencyConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.aws.upbound.io/v1beta1',
    kind: 'ProvisionedConcurrencyConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ProvisionedConcurrencyConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProvisionedConcurrencyConfigProps): any {
    return {
      ...ProvisionedConcurrencyConfig.GVK,
      ...toJson_ProvisionedConcurrencyConfigProps(props),
    };
  }

  /**
   * Defines a "ProvisionedConcurrencyConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProvisionedConcurrencyConfigProps) {
    super(scope, id, {
      ...ProvisionedConcurrencyConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProvisionedConcurrencyConfig.GVK,
      ...toJson_ProvisionedConcurrencyConfigProps(resolved),
    };
  }
}

/**
 * ProvisionedConcurrencyConfig is the Schema for the ProvisionedConcurrencyConfigs API. Manages a Lambda Provisioned Concurrency Configuration
 *
 * @schema ProvisionedConcurrencyConfig
 */
export interface ProvisionedConcurrencyConfigProps {
  /**
   * @schema ProvisionedConcurrencyConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProvisionedConcurrencyConfigSpec defines the desired state of ProvisionedConcurrencyConfig
   *
   * @schema ProvisionedConcurrencyConfig#spec
   */
  readonly spec: ProvisionedConcurrencyConfigSpec;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigProps(obj: ProvisionedConcurrencyConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProvisionedConcurrencyConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProvisionedConcurrencyConfigSpec defines the desired state of ProvisionedConcurrencyConfig
 *
 * @schema ProvisionedConcurrencyConfigSpec
 */
export interface ProvisionedConcurrencyConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ProvisionedConcurrencyConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProvisionedConcurrencyConfigSpecDeletionPolicy;

  /**
   * @schema ProvisionedConcurrencyConfigSpec#forProvider
   */
  readonly forProvider: ProvisionedConcurrencyConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProvisionedConcurrencyConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProvisionedConcurrencyConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ProvisionedConcurrencyConfigSpec#providerRef
   */
  readonly providerRef?: ProvisionedConcurrencyConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProvisionedConcurrencyConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProvisionedConcurrencyConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProvisionedConcurrencyConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProvisionedConcurrencyConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpec(obj: ProvisionedConcurrencyConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProvisionedConcurrencyConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ProvisionedConcurrencyConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ProvisionedConcurrencyConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ProvisionedConcurrencyConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProvisionedConcurrencyConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ProvisionedConcurrencyConfigSpecDeletionPolicy
 */
export enum ProvisionedConcurrencyConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProvisionedConcurrencyConfigSpecForProvider
 */
export interface ProvisionedConcurrencyConfigSpecForProvider {
  /**
   * Name or Amazon Resource Name (ARN) of the Lambda Function.
   *
   * @schema ProvisionedConcurrencyConfigSpecForProvider#functionName
   */
  readonly functionName: string;

  /**
   * Amount of capacity to allocate. Must be greater than or equal to 1.
   *
   * @schema ProvisionedConcurrencyConfigSpecForProvider#provisionedConcurrentExecutions
   */
  readonly provisionedConcurrentExecutions: number;

  /**
   * Lambda Function version or Lambda Alias name.
   *
   * @schema ProvisionedConcurrencyConfigSpecForProvider#qualifier
   */
  readonly qualifier: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProvisionedConcurrencyConfigSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpecForProvider(obj: ProvisionedConcurrencyConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionName': obj.functionName,
    'provisionedConcurrentExecutions': obj.provisionedConcurrentExecutions,
    'qualifier': obj.qualifier,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProvisionedConcurrencyConfigSpecProviderConfigRef
 */
export interface ProvisionedConcurrencyConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProvisionedConcurrencyConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProvisionedConcurrencyConfigSpecProviderConfigRef#policy
   */
  readonly policy?: ProvisionedConcurrencyConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpecProviderConfigRef(obj: ProvisionedConcurrencyConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProvisionedConcurrencyConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ProvisionedConcurrencyConfigSpecProviderRef
 */
export interface ProvisionedConcurrencyConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProvisionedConcurrencyConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProvisionedConcurrencyConfigSpecProviderRef#policy
   */
  readonly policy?: ProvisionedConcurrencyConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpecProviderRef(obj: ProvisionedConcurrencyConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProvisionedConcurrencyConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsTo
 */
export interface ProvisionedConcurrencyConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpecPublishConnectionDetailsTo(obj: ProvisionedConcurrencyConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProvisionedConcurrencyConfigSpecWriteConnectionSecretToRef
 */
export interface ProvisionedConcurrencyConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProvisionedConcurrencyConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProvisionedConcurrencyConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpecWriteConnectionSecretToRef(obj: ProvisionedConcurrencyConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProvisionedConcurrencyConfigSpecProviderConfigRefPolicy
 */
export interface ProvisionedConcurrencyConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisionedConcurrencyConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProvisionedConcurrencyConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisionedConcurrencyConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProvisionedConcurrencyConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpecProviderConfigRefPolicy(obj: ProvisionedConcurrencyConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProvisionedConcurrencyConfigSpecProviderRefPolicy
 */
export interface ProvisionedConcurrencyConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisionedConcurrencyConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ProvisionedConcurrencyConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisionedConcurrencyConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ProvisionedConcurrencyConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpecProviderRefPolicy(obj: ProvisionedConcurrencyConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRef(obj: ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToMetadata
 */
export interface ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToMetadata(obj: ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisionedConcurrencyConfigSpecProviderConfigRefPolicyResolution
 */
export enum ProvisionedConcurrencyConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisionedConcurrencyConfigSpecProviderConfigRefPolicyResolve
 */
export enum ProvisionedConcurrencyConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisionedConcurrencyConfigSpecProviderRefPolicyResolution
 */
export enum ProvisionedConcurrencyConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisionedConcurrencyConfigSpecProviderRefPolicyResolve
 */
export enum ProvisionedConcurrencyConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProvisionedConcurrencyConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

