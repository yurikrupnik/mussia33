// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CryptoKey is the Schema for the CryptoKeys API. A
 *
 * @schema CryptoKey
 */
export class CryptoKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CryptoKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.gcp.upbound.io/v1beta1',
    kind: 'CryptoKey',
  }

  /**
   * Renders a Kubernetes manifest for "CryptoKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CryptoKeyProps): any {
    return {
      ...CryptoKey.GVK,
      ...toJson_CryptoKeyProps(props),
    };
  }

  /**
   * Defines a "CryptoKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CryptoKeyProps) {
    super(scope, id, {
      ...CryptoKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CryptoKey.GVK,
      ...toJson_CryptoKeyProps(resolved),
    };
  }
}

/**
 * CryptoKey is the Schema for the CryptoKeys API. A
 *
 * @schema CryptoKey
 */
export interface CryptoKeyProps {
  /**
   * @schema CryptoKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CryptoKeySpec defines the desired state of CryptoKey
   *
   * @schema CryptoKey#spec
   */
  readonly spec: CryptoKeySpec;

}

/**
 * Converts an object of type 'CryptoKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyProps(obj: CryptoKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CryptoKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CryptoKeySpec defines the desired state of CryptoKey
 *
 * @schema CryptoKeySpec
 */
export interface CryptoKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CryptoKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: CryptoKeySpecDeletionPolicy;

  /**
   * @schema CryptoKeySpec#forProvider
   */
  readonly forProvider: CryptoKeySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CryptoKeySpec#managementPolicy
   */
  readonly managementPolicy?: CryptoKeySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CryptoKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: CryptoKeySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CryptoKeySpec#providerRef
   */
  readonly providerRef?: CryptoKeySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CryptoKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CryptoKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CryptoKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CryptoKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CryptoKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpec(obj: CryptoKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CryptoKeySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CryptoKeySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CryptoKeySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CryptoKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CryptoKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CryptoKeySpecDeletionPolicy
 */
export enum CryptoKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CryptoKeySpecForProvider
 */
export interface CryptoKeySpecForProvider {
  /**
   * The period of time that versions of this key spend in the DESTROY_SCHEDULED state before transitioning to DESTROYED. If not specified at creation time, the default duration is 24 hours.
   *
   * @schema CryptoKeySpecForProvider#destroyScheduledDuration
   */
  readonly destroyScheduledDuration?: string;

  /**
   * Whether this key may contain imported versions only.
   *
   * @schema CryptoKeySpecForProvider#importOnly
   */
  readonly importOnly?: boolean;

  /**
   * The KeyRing that this key belongs to. Format: 'projects/{{project}}/locations/{{location}}/keyRings/{{keyRing}}'.
   *
   * @schema CryptoKeySpecForProvider#keyRing
   */
  readonly keyRing?: string;

  /**
   * Reference to a KeyRing in kms to populate keyRing.
   *
   * @schema CryptoKeySpecForProvider#keyRingRef
   */
  readonly keyRingRef?: CryptoKeySpecForProviderKeyRingRef;

  /**
   * Selector for a KeyRing in kms to populate keyRing.
   *
   * @schema CryptoKeySpecForProvider#keyRingSelector
   */
  readonly keyRingSelector?: CryptoKeySpecForProviderKeyRingSelector;

  /**
   * Labels with user-defined metadata to apply to this resource.
   *
   * @schema CryptoKeySpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The immutable purpose of this CryptoKey. See the purpose reference for possible inputs. Default value is ENCRYPT_DECRYPT. Possible values are: ENCRYPT_DECRYPT, ASYMMETRIC_SIGN, ASYMMETRIC_DECRYPT, MAC.
   *
   * @schema CryptoKeySpecForProvider#purpose
   */
  readonly purpose?: string;

  /**
   * Every time this period passes, generate a new CryptoKeyVersion and set it as the primary. The first rotation will take place after the specified period. The rotation period has the format of a decimal number with up to 9 fractional digits, followed by the letter s (seconds). It must be greater than a day (ie, 86400).
   *
   * @schema CryptoKeySpecForProvider#rotationPeriod
   */
  readonly rotationPeriod?: string;

  /**
   * If set to true, the request will create a CryptoKey without any CryptoKeyVersions. You must use the google_kms_key_ring_import_job resource to import the CryptoKeyVersion.
   *
   * @schema CryptoKeySpecForProvider#skipInitialVersionCreation
   */
  readonly skipInitialVersionCreation?: boolean;

  /**
   * A template describing settings for new crypto key versions. Structure is documented below.
   *
   * @schema CryptoKeySpecForProvider#versionTemplate
   */
  readonly versionTemplate?: CryptoKeySpecForProviderVersionTemplate[];

}

/**
 * Converts an object of type 'CryptoKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecForProvider(obj: CryptoKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destroyScheduledDuration': obj.destroyScheduledDuration,
    'importOnly': obj.importOnly,
    'keyRing': obj.keyRing,
    'keyRingRef': toJson_CryptoKeySpecForProviderKeyRingRef(obj.keyRingRef),
    'keyRingSelector': toJson_CryptoKeySpecForProviderKeyRingSelector(obj.keyRingSelector),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'purpose': obj.purpose,
    'rotationPeriod': obj.rotationPeriod,
    'skipInitialVersionCreation': obj.skipInitialVersionCreation,
    'versionTemplate': obj.versionTemplate?.map(y => toJson_CryptoKeySpecForProviderVersionTemplate(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CryptoKeySpecManagementPolicy
 */
export enum CryptoKeySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CryptoKeySpecProviderConfigRef
 */
export interface CryptoKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeySpecProviderConfigRef#policy
   */
  readonly policy?: CryptoKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecProviderConfigRef(obj: CryptoKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CryptoKeySpecProviderRef
 */
export interface CryptoKeySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeySpecProviderRef#policy
   */
  readonly policy?: CryptoKeySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecProviderRef(obj: CryptoKeySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CryptoKeySpecPublishConnectionDetailsTo
 */
export interface CryptoKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CryptoKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CryptoKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CryptoKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CryptoKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CryptoKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CryptoKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecPublishConnectionDetailsTo(obj: CryptoKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CryptoKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CryptoKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CryptoKeySpecWriteConnectionSecretToRef
 */
export interface CryptoKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CryptoKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CryptoKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CryptoKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecWriteConnectionSecretToRef(obj: CryptoKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a KeyRing in kms to populate keyRing.
 *
 * @schema CryptoKeySpecForProviderKeyRingRef
 */
export interface CryptoKeySpecForProviderKeyRingRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeySpecForProviderKeyRingRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeySpecForProviderKeyRingRef#policy
   */
  readonly policy?: CryptoKeySpecForProviderKeyRingRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeySpecForProviderKeyRingRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecForProviderKeyRingRef(obj: CryptoKeySpecForProviderKeyRingRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeySpecForProviderKeyRingRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a KeyRing in kms to populate keyRing.
 *
 * @schema CryptoKeySpecForProviderKeyRingSelector
 */
export interface CryptoKeySpecForProviderKeyRingSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CryptoKeySpecForProviderKeyRingSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CryptoKeySpecForProviderKeyRingSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CryptoKeySpecForProviderKeyRingSelector#policy
   */
  readonly policy?: CryptoKeySpecForProviderKeyRingSelectorPolicy;

}

/**
 * Converts an object of type 'CryptoKeySpecForProviderKeyRingSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecForProviderKeyRingSelector(obj: CryptoKeySpecForProviderKeyRingSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CryptoKeySpecForProviderKeyRingSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CryptoKeySpecForProviderVersionTemplate
 */
export interface CryptoKeySpecForProviderVersionTemplate {
  /**
   * The algorithm to use when creating a version based on this template. See the algorithm reference for possible inputs.
   *
   * @schema CryptoKeySpecForProviderVersionTemplate#algorithm
   */
  readonly algorithm: string;

  /**
   * The protection level to use when creating a version based on this template. Possible values include "SOFTWARE", "HSM", "EXTERNAL", "EXTERNAL_VPC". Defaults to "SOFTWARE".
   *
   * @default SOFTWARE".
   * @schema CryptoKeySpecForProviderVersionTemplate#protectionLevel
   */
  readonly protectionLevel?: string;

}

/**
 * Converts an object of type 'CryptoKeySpecForProviderVersionTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecForProviderVersionTemplate(obj: CryptoKeySpecForProviderVersionTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'protectionLevel': obj.protectionLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CryptoKeySpecProviderConfigRefPolicy
 */
export interface CryptoKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CryptoKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CryptoKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecProviderConfigRefPolicy(obj: CryptoKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CryptoKeySpecProviderRefPolicy
 */
export interface CryptoKeySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeySpecProviderRefPolicy#resolution
   */
  readonly resolution?: CryptoKeySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeySpecProviderRefPolicy#resolve
   */
  readonly resolve?: CryptoKeySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecProviderRefPolicy(obj: CryptoKeySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CryptoKeySpecPublishConnectionDetailsToConfigRef
 */
export interface CryptoKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CryptoKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecPublishConnectionDetailsToConfigRef(obj: CryptoKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CryptoKeySpecPublishConnectionDetailsToMetadata
 */
export interface CryptoKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CryptoKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CryptoKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CryptoKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CryptoKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecPublishConnectionDetailsToMetadata(obj: CryptoKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CryptoKeySpecForProviderKeyRingRefPolicy
 */
export interface CryptoKeySpecForProviderKeyRingRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeySpecForProviderKeyRingRefPolicy#resolution
   */
  readonly resolution?: CryptoKeySpecForProviderKeyRingRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeySpecForProviderKeyRingRefPolicy#resolve
   */
  readonly resolve?: CryptoKeySpecForProviderKeyRingRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeySpecForProviderKeyRingRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecForProviderKeyRingRefPolicy(obj: CryptoKeySpecForProviderKeyRingRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CryptoKeySpecForProviderKeyRingSelectorPolicy
 */
export interface CryptoKeySpecForProviderKeyRingSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeySpecForProviderKeyRingSelectorPolicy#resolution
   */
  readonly resolution?: CryptoKeySpecForProviderKeyRingSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeySpecForProviderKeyRingSelectorPolicy#resolve
   */
  readonly resolve?: CryptoKeySpecForProviderKeyRingSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeySpecForProviderKeyRingSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecForProviderKeyRingSelectorPolicy(obj: CryptoKeySpecForProviderKeyRingSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeySpecProviderConfigRefPolicyResolution
 */
export enum CryptoKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeySpecProviderConfigRefPolicyResolve
 */
export enum CryptoKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeySpecProviderRefPolicyResolution
 */
export enum CryptoKeySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeySpecProviderRefPolicyResolve
 */
export enum CryptoKeySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CryptoKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CryptoKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CryptoKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CryptoKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: CryptoKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeySpecForProviderKeyRingRefPolicyResolution
 */
export enum CryptoKeySpecForProviderKeyRingRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeySpecForProviderKeyRingRefPolicyResolve
 */
export enum CryptoKeySpecForProviderKeyRingRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeySpecForProviderKeyRingSelectorPolicyResolution
 */
export enum CryptoKeySpecForProviderKeyRingSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeySpecForProviderKeyRingSelectorPolicyResolve
 */
export enum CryptoKeySpecForProviderKeyRingSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CryptoKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CryptoKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CryptoKeyIAMMember is the Schema for the CryptoKeyIAMMembers API. <no value>
 *
 * @schema CryptoKeyIAMMember
 */
export class CryptoKeyIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CryptoKeyIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.gcp.upbound.io/v1beta1',
    kind: 'CryptoKeyIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "CryptoKeyIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CryptoKeyIamMemberProps): any {
    return {
      ...CryptoKeyIamMember.GVK,
      ...toJson_CryptoKeyIamMemberProps(props),
    };
  }

  /**
   * Defines a "CryptoKeyIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CryptoKeyIamMemberProps) {
    super(scope, id, {
      ...CryptoKeyIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CryptoKeyIamMember.GVK,
      ...toJson_CryptoKeyIamMemberProps(resolved),
    };
  }
}

/**
 * CryptoKeyIAMMember is the Schema for the CryptoKeyIAMMembers API. <no value>
 *
 * @schema CryptoKeyIAMMember
 */
export interface CryptoKeyIamMemberProps {
  /**
   * @schema CryptoKeyIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CryptoKeyIAMMemberSpec defines the desired state of CryptoKeyIAMMember
   *
   * @schema CryptoKeyIAMMember#spec
   */
  readonly spec: CryptoKeyIamMemberSpec;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberProps(obj: CryptoKeyIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CryptoKeyIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CryptoKeyIAMMemberSpec defines the desired state of CryptoKeyIAMMember
 *
 * @schema CryptoKeyIamMemberSpec
 */
export interface CryptoKeyIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CryptoKeyIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: CryptoKeyIamMemberSpecDeletionPolicy;

  /**
   * @schema CryptoKeyIamMemberSpec#forProvider
   */
  readonly forProvider: CryptoKeyIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CryptoKeyIamMemberSpec#managementPolicy
   */
  readonly managementPolicy?: CryptoKeyIamMemberSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CryptoKeyIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: CryptoKeyIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CryptoKeyIamMemberSpec#providerRef
   */
  readonly providerRef?: CryptoKeyIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CryptoKeyIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CryptoKeyIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CryptoKeyIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CryptoKeyIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpec(obj: CryptoKeyIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CryptoKeyIamMemberSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CryptoKeyIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CryptoKeyIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CryptoKeyIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CryptoKeyIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CryptoKeyIamMemberSpecDeletionPolicy
 */
export enum CryptoKeyIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CryptoKeyIamMemberSpecForProvider
 */
export interface CryptoKeyIamMemberSpecForProvider {
  /**
   * @schema CryptoKeyIamMemberSpecForProvider#condition
   */
  readonly condition?: CryptoKeyIamMemberSpecForProviderCondition[];

  /**
   * @schema CryptoKeyIamMemberSpecForProvider#cryptoKeyId
   */
  readonly cryptoKeyId?: string;

  /**
   * Reference to a CryptoKey to populate cryptoKeyId.
   *
   * @schema CryptoKeyIamMemberSpecForProvider#cryptoKeyIdRef
   */
  readonly cryptoKeyIdRef?: CryptoKeyIamMemberSpecForProviderCryptoKeyIdRef;

  /**
   * Selector for a CryptoKey to populate cryptoKeyId.
   *
   * @schema CryptoKeyIamMemberSpecForProvider#cryptoKeyIdSelector
   */
  readonly cryptoKeyIdSelector?: CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelector;

  /**
   * @schema CryptoKeyIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema CryptoKeyIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecForProvider(obj: CryptoKeyIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_CryptoKeyIamMemberSpecForProviderCondition(y)),
    'cryptoKeyId': obj.cryptoKeyId,
    'cryptoKeyIdRef': toJson_CryptoKeyIamMemberSpecForProviderCryptoKeyIdRef(obj.cryptoKeyIdRef),
    'cryptoKeyIdSelector': toJson_CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelector(obj.cryptoKeyIdSelector),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CryptoKeyIamMemberSpecManagementPolicy
 */
export enum CryptoKeyIamMemberSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CryptoKeyIamMemberSpecProviderConfigRef
 */
export interface CryptoKeyIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeyIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeyIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: CryptoKeyIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecProviderConfigRef(obj: CryptoKeyIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeyIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CryptoKeyIamMemberSpecProviderRef
 */
export interface CryptoKeyIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeyIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeyIamMemberSpecProviderRef#policy
   */
  readonly policy?: CryptoKeyIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecProviderRef(obj: CryptoKeyIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeyIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsTo
 */
export interface CryptoKeyIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CryptoKeyIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecPublishConnectionDetailsTo(obj: CryptoKeyIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CryptoKeyIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CryptoKeyIamMemberSpecWriteConnectionSecretToRef
 */
export interface CryptoKeyIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CryptoKeyIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CryptoKeyIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecWriteConnectionSecretToRef(obj: CryptoKeyIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CryptoKeyIamMemberSpecForProviderCondition
 */
export interface CryptoKeyIamMemberSpecForProviderCondition {
  /**
   * @schema CryptoKeyIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema CryptoKeyIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema CryptoKeyIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecForProviderCondition(obj: CryptoKeyIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey to populate cryptoKeyId.
 *
 * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdRef
 */
export interface CryptoKeyIamMemberSpecForProviderCryptoKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdRef#policy
   */
  readonly policy?: CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecForProviderCryptoKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecForProviderCryptoKeyIdRef(obj: CryptoKeyIamMemberSpecForProviderCryptoKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey to populate cryptoKeyId.
 *
 * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelector
 */
export interface CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelector#policy
   */
  readonly policy?: CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelector(obj: CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CryptoKeyIamMemberSpecProviderConfigRefPolicy
 */
export interface CryptoKeyIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeyIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CryptoKeyIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeyIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CryptoKeyIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecProviderConfigRefPolicy(obj: CryptoKeyIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CryptoKeyIamMemberSpecProviderRefPolicy
 */
export interface CryptoKeyIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeyIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CryptoKeyIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeyIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CryptoKeyIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecProviderRefPolicy(obj: CryptoKeyIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRef(obj: CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface CryptoKeyIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecPublishConnectionDetailsToMetadata(obj: CryptoKeyIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicy
 */
export interface CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicy#resolution
   */
  readonly resolution?: CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicy#resolve
   */
  readonly resolve?: CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicy(obj: CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicy
 */
export interface CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicy(obj: CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeyIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum CryptoKeyIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeyIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum CryptoKeyIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeyIamMemberSpecProviderRefPolicyResolution
 */
export enum CryptoKeyIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeyIamMemberSpecProviderRefPolicyResolve
 */
export enum CryptoKeyIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicyResolution
 */
export enum CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicyResolve
 */
export enum CryptoKeyIamMemberSpecForProviderCryptoKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicyResolution
 */
export enum CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicyResolve
 */
export enum CryptoKeyIamMemberSpecForProviderCryptoKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CryptoKeyIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CryptoKeyVersion is the Schema for the CryptoKeyVersions API. A
 *
 * @schema CryptoKeyVersion
 */
export class CryptoKeyVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CryptoKeyVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.gcp.upbound.io/v1beta1',
    kind: 'CryptoKeyVersion',
  }

  /**
   * Renders a Kubernetes manifest for "CryptoKeyVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CryptoKeyVersionProps): any {
    return {
      ...CryptoKeyVersion.GVK,
      ...toJson_CryptoKeyVersionProps(props),
    };
  }

  /**
   * Defines a "CryptoKeyVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CryptoKeyVersionProps) {
    super(scope, id, {
      ...CryptoKeyVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CryptoKeyVersion.GVK,
      ...toJson_CryptoKeyVersionProps(resolved),
    };
  }
}

/**
 * CryptoKeyVersion is the Schema for the CryptoKeyVersions API. A
 *
 * @schema CryptoKeyVersion
 */
export interface CryptoKeyVersionProps {
  /**
   * @schema CryptoKeyVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CryptoKeyVersionSpec defines the desired state of CryptoKeyVersion
   *
   * @schema CryptoKeyVersion#spec
   */
  readonly spec: CryptoKeyVersionSpec;

}

/**
 * Converts an object of type 'CryptoKeyVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionProps(obj: CryptoKeyVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CryptoKeyVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CryptoKeyVersionSpec defines the desired state of CryptoKeyVersion
 *
 * @schema CryptoKeyVersionSpec
 */
export interface CryptoKeyVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CryptoKeyVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: CryptoKeyVersionSpecDeletionPolicy;

  /**
   * @schema CryptoKeyVersionSpec#forProvider
   */
  readonly forProvider: CryptoKeyVersionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CryptoKeyVersionSpec#managementPolicy
   */
  readonly managementPolicy?: CryptoKeyVersionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CryptoKeyVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: CryptoKeyVersionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CryptoKeyVersionSpec#providerRef
   */
  readonly providerRef?: CryptoKeyVersionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CryptoKeyVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CryptoKeyVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CryptoKeyVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CryptoKeyVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpec(obj: CryptoKeyVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CryptoKeyVersionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CryptoKeyVersionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CryptoKeyVersionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CryptoKeyVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CryptoKeyVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CryptoKeyVersionSpecDeletionPolicy
 */
export enum CryptoKeyVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CryptoKeyVersionSpecForProvider
 */
export interface CryptoKeyVersionSpecForProvider {
  /**
   * The name of the cryptoKey associated with the CryptoKeyVersions. Format: 'projects/{{project}}/locations/{{location}}/keyRings/{{keyring}}/cryptoKeys/{{cryptoKey}}'
   *
   * @schema CryptoKeyVersionSpecForProvider#cryptoKey
   */
  readonly cryptoKey?: string;

  /**
   * Reference to a CryptoKey in kms to populate cryptoKey.
   *
   * @schema CryptoKeyVersionSpecForProvider#cryptoKeyRef
   */
  readonly cryptoKeyRef?: CryptoKeyVersionSpecForProviderCryptoKeyRef;

  /**
   * Selector for a CryptoKey in kms to populate cryptoKey.
   *
   * @schema CryptoKeyVersionSpecForProvider#cryptoKeySelector
   */
  readonly cryptoKeySelector?: CryptoKeyVersionSpecForProviderCryptoKeySelector;

  /**
   * The current state of the CryptoKeyVersion. Possible values are: PENDING_GENERATION, ENABLED, DISABLED, DESTROYED, DESTROY_SCHEDULED, PENDING_IMPORT, IMPORT_FAILED.
   *
   * @schema CryptoKeyVersionSpecForProvider#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecForProvider(obj: CryptoKeyVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': obj.cryptoKey,
    'cryptoKeyRef': toJson_CryptoKeyVersionSpecForProviderCryptoKeyRef(obj.cryptoKeyRef),
    'cryptoKeySelector': toJson_CryptoKeyVersionSpecForProviderCryptoKeySelector(obj.cryptoKeySelector),
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CryptoKeyVersionSpecManagementPolicy
 */
export enum CryptoKeyVersionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CryptoKeyVersionSpecProviderConfigRef
 */
export interface CryptoKeyVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeyVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeyVersionSpecProviderConfigRef#policy
   */
  readonly policy?: CryptoKeyVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecProviderConfigRef(obj: CryptoKeyVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeyVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CryptoKeyVersionSpecProviderRef
 */
export interface CryptoKeyVersionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeyVersionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeyVersionSpecProviderRef#policy
   */
  readonly policy?: CryptoKeyVersionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecProviderRef(obj: CryptoKeyVersionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeyVersionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CryptoKeyVersionSpecPublishConnectionDetailsTo
 */
export interface CryptoKeyVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CryptoKeyVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CryptoKeyVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CryptoKeyVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CryptoKeyVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CryptoKeyVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecPublishConnectionDetailsTo(obj: CryptoKeyVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CryptoKeyVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CryptoKeyVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CryptoKeyVersionSpecWriteConnectionSecretToRef
 */
export interface CryptoKeyVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CryptoKeyVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CryptoKeyVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecWriteConnectionSecretToRef(obj: CryptoKeyVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate cryptoKey.
 *
 * @schema CryptoKeyVersionSpecForProviderCryptoKeyRef
 */
export interface CryptoKeyVersionSpecForProviderCryptoKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeyVersionSpecForProviderCryptoKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeyVersionSpecForProviderCryptoKeyRef#policy
   */
  readonly policy?: CryptoKeyVersionSpecForProviderCryptoKeyRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecForProviderCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecForProviderCryptoKeyRef(obj: CryptoKeyVersionSpecForProviderCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeyVersionSpecForProviderCryptoKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate cryptoKey.
 *
 * @schema CryptoKeyVersionSpecForProviderCryptoKeySelector
 */
export interface CryptoKeyVersionSpecForProviderCryptoKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CryptoKeyVersionSpecForProviderCryptoKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CryptoKeyVersionSpecForProviderCryptoKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CryptoKeyVersionSpecForProviderCryptoKeySelector#policy
   */
  readonly policy?: CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicy;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecForProviderCryptoKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecForProviderCryptoKeySelector(obj: CryptoKeyVersionSpecForProviderCryptoKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CryptoKeyVersionSpecProviderConfigRefPolicy
 */
export interface CryptoKeyVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeyVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CryptoKeyVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeyVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CryptoKeyVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecProviderConfigRefPolicy(obj: CryptoKeyVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CryptoKeyVersionSpecProviderRefPolicy
 */
export interface CryptoKeyVersionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeyVersionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CryptoKeyVersionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeyVersionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CryptoKeyVersionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecProviderRefPolicy(obj: CryptoKeyVersionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CryptoKeyVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface CryptoKeyVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CryptoKeyVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CryptoKeyVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecPublishConnectionDetailsToConfigRef(obj: CryptoKeyVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CryptoKeyVersionSpecPublishConnectionDetailsToMetadata
 */
export interface CryptoKeyVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CryptoKeyVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CryptoKeyVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CryptoKeyVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecPublishConnectionDetailsToMetadata(obj: CryptoKeyVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CryptoKeyVersionSpecForProviderCryptoKeyRefPolicy
 */
export interface CryptoKeyVersionSpecForProviderCryptoKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeyVersionSpecForProviderCryptoKeyRefPolicy#resolution
   */
  readonly resolution?: CryptoKeyVersionSpecForProviderCryptoKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeyVersionSpecForProviderCryptoKeyRefPolicy#resolve
   */
  readonly resolve?: CryptoKeyVersionSpecForProviderCryptoKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecForProviderCryptoKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecForProviderCryptoKeyRefPolicy(obj: CryptoKeyVersionSpecForProviderCryptoKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicy
 */
export interface CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicy#resolution
   */
  readonly resolution?: CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicy#resolve
   */
  readonly resolve?: CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicy(obj: CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeyVersionSpecProviderConfigRefPolicyResolution
 */
export enum CryptoKeyVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeyVersionSpecProviderConfigRefPolicyResolve
 */
export enum CryptoKeyVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeyVersionSpecProviderRefPolicyResolution
 */
export enum CryptoKeyVersionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeyVersionSpecProviderRefPolicyResolve
 */
export enum CryptoKeyVersionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeyVersionSpecForProviderCryptoKeyRefPolicyResolution
 */
export enum CryptoKeyVersionSpecForProviderCryptoKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeyVersionSpecForProviderCryptoKeyRefPolicyResolve
 */
export enum CryptoKeyVersionSpecForProviderCryptoKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicyResolution
 */
export enum CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicyResolve
 */
export enum CryptoKeyVersionSpecForProviderCryptoKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CryptoKeyVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * KeyRing is the Schema for the KeyRings API. A
 *
 * @schema KeyRing
 */
export class KeyRing extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KeyRing"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.gcp.upbound.io/v1beta1',
    kind: 'KeyRing',
  }

  /**
   * Renders a Kubernetes manifest for "KeyRing".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KeyRingProps): any {
    return {
      ...KeyRing.GVK,
      ...toJson_KeyRingProps(props),
    };
  }

  /**
   * Defines a "KeyRing" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KeyRingProps) {
    super(scope, id, {
      ...KeyRing.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KeyRing.GVK,
      ...toJson_KeyRingProps(resolved),
    };
  }
}

/**
 * KeyRing is the Schema for the KeyRings API. A
 *
 * @schema KeyRing
 */
export interface KeyRingProps {
  /**
   * @schema KeyRing#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * KeyRingSpec defines the desired state of KeyRing
   *
   * @schema KeyRing#spec
   */
  readonly spec: KeyRingSpec;

}

/**
 * Converts an object of type 'KeyRingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingProps(obj: KeyRingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KeyRingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyRingSpec defines the desired state of KeyRing
 *
 * @schema KeyRingSpec
 */
export interface KeyRingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KeyRingSpec#deletionPolicy
   */
  readonly deletionPolicy?: KeyRingSpecDeletionPolicy;

  /**
   * @schema KeyRingSpec#forProvider
   */
  readonly forProvider: KeyRingSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KeyRingSpec#managementPolicy
   */
  readonly managementPolicy?: KeyRingSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema KeyRingSpec#providerConfigRef
   */
  readonly providerConfigRef?: KeyRingSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema KeyRingSpec#providerRef
   */
  readonly providerRef?: KeyRingSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema KeyRingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: KeyRingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema KeyRingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: KeyRingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'KeyRingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpec(obj: KeyRingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_KeyRingSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_KeyRingSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_KeyRingSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_KeyRingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_KeyRingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KeyRingSpecDeletionPolicy
 */
export enum KeyRingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema KeyRingSpecForProvider
 */
export interface KeyRingSpecForProvider {
  /**
   * The location for the KeyRing. A full list of valid locations can be found by running gcloud kms locations list.
   *
   * @schema KeyRingSpecForProvider#location
   */
  readonly location: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema KeyRingSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'KeyRingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpecForProvider(obj: KeyRingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'location': obj.location,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KeyRingSpecManagementPolicy
 */
export enum KeyRingSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema KeyRingSpecProviderConfigRef
 */
export interface KeyRingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingSpecProviderConfigRef#policy
   */
  readonly policy?: KeyRingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'KeyRingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpecProviderConfigRef(obj: KeyRingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema KeyRingSpecProviderRef
 */
export interface KeyRingSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingSpecProviderRef#policy
   */
  readonly policy?: KeyRingSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'KeyRingSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpecProviderRef(obj: KeyRingSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema KeyRingSpecPublishConnectionDetailsTo
 */
export interface KeyRingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema KeyRingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: KeyRingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema KeyRingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: KeyRingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema KeyRingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'KeyRingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpecPublishConnectionDetailsTo(obj: KeyRingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_KeyRingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_KeyRingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema KeyRingSpecWriteConnectionSecretToRef
 */
export interface KeyRingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema KeyRingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema KeyRingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'KeyRingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpecWriteConnectionSecretToRef(obj: KeyRingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeyRingSpecProviderConfigRefPolicy
 */
export interface KeyRingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: KeyRingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: KeyRingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpecProviderConfigRefPolicy(obj: KeyRingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeyRingSpecProviderRefPolicy
 */
export interface KeyRingSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingSpecProviderRefPolicy#resolution
   */
  readonly resolution?: KeyRingSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingSpecProviderRefPolicy#resolve
   */
  readonly resolve?: KeyRingSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpecProviderRefPolicy(obj: KeyRingSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema KeyRingSpecPublishConnectionDetailsToConfigRef
 */
export interface KeyRingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: KeyRingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'KeyRingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpecPublishConnectionDetailsToConfigRef(obj: KeyRingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema KeyRingSpecPublishConnectionDetailsToMetadata
 */
export interface KeyRingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeyRingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeyRingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema KeyRingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KeyRingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpecPublishConnectionDetailsToMetadata(obj: KeyRingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingSpecProviderConfigRefPolicyResolution
 */
export enum KeyRingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingSpecProviderConfigRefPolicyResolve
 */
export enum KeyRingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingSpecProviderRefPolicyResolution
 */
export enum KeyRingSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingSpecProviderRefPolicyResolve
 */
export enum KeyRingSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema KeyRingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface KeyRingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: KeyRingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: KeyRingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingSpecPublishConnectionDetailsToConfigRefPolicy(obj: KeyRingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum KeyRingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum KeyRingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * KeyRingIAMMember is the Schema for the KeyRingIAMMembers API. <no value>
 *
 * @schema KeyRingIAMMember
 */
export class KeyRingIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KeyRingIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.gcp.upbound.io/v1beta1',
    kind: 'KeyRingIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "KeyRingIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KeyRingIamMemberProps): any {
    return {
      ...KeyRingIamMember.GVK,
      ...toJson_KeyRingIamMemberProps(props),
    };
  }

  /**
   * Defines a "KeyRingIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KeyRingIamMemberProps) {
    super(scope, id, {
      ...KeyRingIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KeyRingIamMember.GVK,
      ...toJson_KeyRingIamMemberProps(resolved),
    };
  }
}

/**
 * KeyRingIAMMember is the Schema for the KeyRingIAMMembers API. <no value>
 *
 * @schema KeyRingIAMMember
 */
export interface KeyRingIamMemberProps {
  /**
   * @schema KeyRingIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * KeyRingIAMMemberSpec defines the desired state of KeyRingIAMMember
   *
   * @schema KeyRingIAMMember#spec
   */
  readonly spec: KeyRingIamMemberSpec;

}

/**
 * Converts an object of type 'KeyRingIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberProps(obj: KeyRingIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KeyRingIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyRingIAMMemberSpec defines the desired state of KeyRingIAMMember
 *
 * @schema KeyRingIamMemberSpec
 */
export interface KeyRingIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KeyRingIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: KeyRingIamMemberSpecDeletionPolicy;

  /**
   * @schema KeyRingIamMemberSpec#forProvider
   */
  readonly forProvider: KeyRingIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KeyRingIamMemberSpec#managementPolicy
   */
  readonly managementPolicy?: KeyRingIamMemberSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema KeyRingIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: KeyRingIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema KeyRingIamMemberSpec#providerRef
   */
  readonly providerRef?: KeyRingIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema KeyRingIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: KeyRingIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema KeyRingIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: KeyRingIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpec(obj: KeyRingIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_KeyRingIamMemberSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_KeyRingIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_KeyRingIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_KeyRingIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_KeyRingIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KeyRingIamMemberSpecDeletionPolicy
 */
export enum KeyRingIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema KeyRingIamMemberSpecForProvider
 */
export interface KeyRingIamMemberSpecForProvider {
  /**
   * @schema KeyRingIamMemberSpecForProvider#condition
   */
  readonly condition?: KeyRingIamMemberSpecForProviderCondition[];

  /**
   * @schema KeyRingIamMemberSpecForProvider#keyRingId
   */
  readonly keyRingId?: string;

  /**
   * Reference to a KeyRing to populate keyRingId.
   *
   * @schema KeyRingIamMemberSpecForProvider#keyRingIdRef
   */
  readonly keyRingIdRef?: KeyRingIamMemberSpecForProviderKeyRingIdRef;

  /**
   * Selector for a KeyRing to populate keyRingId.
   *
   * @schema KeyRingIamMemberSpecForProvider#keyRingIdSelector
   */
  readonly keyRingIdSelector?: KeyRingIamMemberSpecForProviderKeyRingIdSelector;

  /**
   * @schema KeyRingIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema KeyRingIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecForProvider(obj: KeyRingIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_KeyRingIamMemberSpecForProviderCondition(y)),
    'keyRingId': obj.keyRingId,
    'keyRingIdRef': toJson_KeyRingIamMemberSpecForProviderKeyRingIdRef(obj.keyRingIdRef),
    'keyRingIdSelector': toJson_KeyRingIamMemberSpecForProviderKeyRingIdSelector(obj.keyRingIdSelector),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KeyRingIamMemberSpecManagementPolicy
 */
export enum KeyRingIamMemberSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema KeyRingIamMemberSpecProviderConfigRef
 */
export interface KeyRingIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: KeyRingIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecProviderConfigRef(obj: KeyRingIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema KeyRingIamMemberSpecProviderRef
 */
export interface KeyRingIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingIamMemberSpecProviderRef#policy
   */
  readonly policy?: KeyRingIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecProviderRef(obj: KeyRingIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema KeyRingIamMemberSpecPublishConnectionDetailsTo
 */
export interface KeyRingIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema KeyRingIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: KeyRingIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema KeyRingIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: KeyRingIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema KeyRingIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecPublishConnectionDetailsTo(obj: KeyRingIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_KeyRingIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_KeyRingIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema KeyRingIamMemberSpecWriteConnectionSecretToRef
 */
export interface KeyRingIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema KeyRingIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema KeyRingIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecWriteConnectionSecretToRef(obj: KeyRingIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KeyRingIamMemberSpecForProviderCondition
 */
export interface KeyRingIamMemberSpecForProviderCondition {
  /**
   * @schema KeyRingIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema KeyRingIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema KeyRingIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecForProviderCondition(obj: KeyRingIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a KeyRing to populate keyRingId.
 *
 * @schema KeyRingIamMemberSpecForProviderKeyRingIdRef
 */
export interface KeyRingIamMemberSpecForProviderKeyRingIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingIamMemberSpecForProviderKeyRingIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingIamMemberSpecForProviderKeyRingIdRef#policy
   */
  readonly policy?: KeyRingIamMemberSpecForProviderKeyRingIdRefPolicy;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecForProviderKeyRingIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecForProviderKeyRingIdRef(obj: KeyRingIamMemberSpecForProviderKeyRingIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingIamMemberSpecForProviderKeyRingIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a KeyRing to populate keyRingId.
 *
 * @schema KeyRingIamMemberSpecForProviderKeyRingIdSelector
 */
export interface KeyRingIamMemberSpecForProviderKeyRingIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema KeyRingIamMemberSpecForProviderKeyRingIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema KeyRingIamMemberSpecForProviderKeyRingIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema KeyRingIamMemberSpecForProviderKeyRingIdSelector#policy
   */
  readonly policy?: KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicy;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecForProviderKeyRingIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecForProviderKeyRingIdSelector(obj: KeyRingIamMemberSpecForProviderKeyRingIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeyRingIamMemberSpecProviderConfigRefPolicy
 */
export interface KeyRingIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: KeyRingIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: KeyRingIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecProviderConfigRefPolicy(obj: KeyRingIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeyRingIamMemberSpecProviderRefPolicy
 */
export interface KeyRingIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: KeyRingIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: KeyRingIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecProviderRefPolicy(obj: KeyRingIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema KeyRingIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface KeyRingIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecPublishConnectionDetailsToConfigRef(obj: KeyRingIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema KeyRingIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface KeyRingIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeyRingIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeyRingIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema KeyRingIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecPublishConnectionDetailsToMetadata(obj: KeyRingIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeyRingIamMemberSpecForProviderKeyRingIdRefPolicy
 */
export interface KeyRingIamMemberSpecForProviderKeyRingIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingIamMemberSpecForProviderKeyRingIdRefPolicy#resolution
   */
  readonly resolution?: KeyRingIamMemberSpecForProviderKeyRingIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingIamMemberSpecForProviderKeyRingIdRefPolicy#resolve
   */
  readonly resolve?: KeyRingIamMemberSpecForProviderKeyRingIdRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecForProviderKeyRingIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecForProviderKeyRingIdRefPolicy(obj: KeyRingIamMemberSpecForProviderKeyRingIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicy
 */
export interface KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicy#resolution
   */
  readonly resolution?: KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicy#resolve
   */
  readonly resolve?: KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicy(obj: KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum KeyRingIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum KeyRingIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingIamMemberSpecProviderRefPolicyResolution
 */
export enum KeyRingIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingIamMemberSpecProviderRefPolicyResolve
 */
export enum KeyRingIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingIamMemberSpecForProviderKeyRingIdRefPolicyResolution
 */
export enum KeyRingIamMemberSpecForProviderKeyRingIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingIamMemberSpecForProviderKeyRingIdRefPolicyResolve
 */
export enum KeyRingIamMemberSpecForProviderKeyRingIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicyResolution
 */
export enum KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicyResolve
 */
export enum KeyRingIamMemberSpecForProviderKeyRingIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum KeyRingIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * KeyRingImportJob is the Schema for the KeyRingImportJobs API. A
 *
 * @schema KeyRingImportJob
 */
export class KeyRingImportJob extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KeyRingImportJob"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.gcp.upbound.io/v1beta1',
    kind: 'KeyRingImportJob',
  }

  /**
   * Renders a Kubernetes manifest for "KeyRingImportJob".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KeyRingImportJobProps): any {
    return {
      ...KeyRingImportJob.GVK,
      ...toJson_KeyRingImportJobProps(props),
    };
  }

  /**
   * Defines a "KeyRingImportJob" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KeyRingImportJobProps) {
    super(scope, id, {
      ...KeyRingImportJob.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KeyRingImportJob.GVK,
      ...toJson_KeyRingImportJobProps(resolved),
    };
  }
}

/**
 * KeyRingImportJob is the Schema for the KeyRingImportJobs API. A
 *
 * @schema KeyRingImportJob
 */
export interface KeyRingImportJobProps {
  /**
   * @schema KeyRingImportJob#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * KeyRingImportJobSpec defines the desired state of KeyRingImportJob
   *
   * @schema KeyRingImportJob#spec
   */
  readonly spec: KeyRingImportJobSpec;

}

/**
 * Converts an object of type 'KeyRingImportJobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobProps(obj: KeyRingImportJobProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KeyRingImportJobSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyRingImportJobSpec defines the desired state of KeyRingImportJob
 *
 * @schema KeyRingImportJobSpec
 */
export interface KeyRingImportJobSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KeyRingImportJobSpec#deletionPolicy
   */
  readonly deletionPolicy?: KeyRingImportJobSpecDeletionPolicy;

  /**
   * @schema KeyRingImportJobSpec#forProvider
   */
  readonly forProvider: KeyRingImportJobSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KeyRingImportJobSpec#managementPolicy
   */
  readonly managementPolicy?: KeyRingImportJobSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema KeyRingImportJobSpec#providerConfigRef
   */
  readonly providerConfigRef?: KeyRingImportJobSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema KeyRingImportJobSpec#providerRef
   */
  readonly providerRef?: KeyRingImportJobSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema KeyRingImportJobSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: KeyRingImportJobSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema KeyRingImportJobSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: KeyRingImportJobSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'KeyRingImportJobSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpec(obj: KeyRingImportJobSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_KeyRingImportJobSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_KeyRingImportJobSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_KeyRingImportJobSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_KeyRingImportJobSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_KeyRingImportJobSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KeyRingImportJobSpecDeletionPolicy
 */
export enum KeyRingImportJobSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema KeyRingImportJobSpecForProvider
 */
export interface KeyRingImportJobSpecForProvider {
  /**
   * The wrapping method to be used for incoming key material. Possible values are: RSA_OAEP_3072_SHA1_AES_256, RSA_OAEP_4096_SHA1_AES_256.
   *
   * @schema KeyRingImportJobSpecForProvider#importMethod
   */
  readonly importMethod?: string;

  /**
   * The KeyRing that this import job belongs to. Format: 'projects/{{project}}/locations/{{location}}/keyRings/{{keyRing}}'.
   *
   * @schema KeyRingImportJobSpecForProvider#keyRing
   */
  readonly keyRing?: string;

  /**
   * Reference to a KeyRing to populate keyRing.
   *
   * @schema KeyRingImportJobSpecForProvider#keyRingRef
   */
  readonly keyRingRef?: KeyRingImportJobSpecForProviderKeyRingRef;

  /**
   * Selector for a KeyRing to populate keyRing.
   *
   * @schema KeyRingImportJobSpecForProvider#keyRingSelector
   */
  readonly keyRingSelector?: KeyRingImportJobSpecForProviderKeyRingSelector;

  /**
   * The protection level of the ImportJob. This must match the protectionLevel of the versionTemplate on the CryptoKey you attempt to import into. Possible values are: SOFTWARE, HSM, EXTERNAL.
   *
   * @schema KeyRingImportJobSpecForProvider#protectionLevel
   */
  readonly protectionLevel?: string;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecForProvider(obj: KeyRingImportJobSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'importMethod': obj.importMethod,
    'keyRing': obj.keyRing,
    'keyRingRef': toJson_KeyRingImportJobSpecForProviderKeyRingRef(obj.keyRingRef),
    'keyRingSelector': toJson_KeyRingImportJobSpecForProviderKeyRingSelector(obj.keyRingSelector),
    'protectionLevel': obj.protectionLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KeyRingImportJobSpecManagementPolicy
 */
export enum KeyRingImportJobSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema KeyRingImportJobSpecProviderConfigRef
 */
export interface KeyRingImportJobSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingImportJobSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingImportJobSpecProviderConfigRef#policy
   */
  readonly policy?: KeyRingImportJobSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecProviderConfigRef(obj: KeyRingImportJobSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingImportJobSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema KeyRingImportJobSpecProviderRef
 */
export interface KeyRingImportJobSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingImportJobSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingImportJobSpecProviderRef#policy
   */
  readonly policy?: KeyRingImportJobSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecProviderRef(obj: KeyRingImportJobSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingImportJobSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema KeyRingImportJobSpecPublishConnectionDetailsTo
 */
export interface KeyRingImportJobSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema KeyRingImportJobSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: KeyRingImportJobSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema KeyRingImportJobSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: KeyRingImportJobSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema KeyRingImportJobSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecPublishConnectionDetailsTo(obj: KeyRingImportJobSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_KeyRingImportJobSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_KeyRingImportJobSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema KeyRingImportJobSpecWriteConnectionSecretToRef
 */
export interface KeyRingImportJobSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema KeyRingImportJobSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema KeyRingImportJobSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecWriteConnectionSecretToRef(obj: KeyRingImportJobSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a KeyRing to populate keyRing.
 *
 * @schema KeyRingImportJobSpecForProviderKeyRingRef
 */
export interface KeyRingImportJobSpecForProviderKeyRingRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingImportJobSpecForProviderKeyRingRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingImportJobSpecForProviderKeyRingRef#policy
   */
  readonly policy?: KeyRingImportJobSpecForProviderKeyRingRefPolicy;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecForProviderKeyRingRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecForProviderKeyRingRef(obj: KeyRingImportJobSpecForProviderKeyRingRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingImportJobSpecForProviderKeyRingRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a KeyRing to populate keyRing.
 *
 * @schema KeyRingImportJobSpecForProviderKeyRingSelector
 */
export interface KeyRingImportJobSpecForProviderKeyRingSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema KeyRingImportJobSpecForProviderKeyRingSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema KeyRingImportJobSpecForProviderKeyRingSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema KeyRingImportJobSpecForProviderKeyRingSelector#policy
   */
  readonly policy?: KeyRingImportJobSpecForProviderKeyRingSelectorPolicy;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecForProviderKeyRingSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecForProviderKeyRingSelector(obj: KeyRingImportJobSpecForProviderKeyRingSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_KeyRingImportJobSpecForProviderKeyRingSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeyRingImportJobSpecProviderConfigRefPolicy
 */
export interface KeyRingImportJobSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingImportJobSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: KeyRingImportJobSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingImportJobSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: KeyRingImportJobSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecProviderConfigRefPolicy(obj: KeyRingImportJobSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeyRingImportJobSpecProviderRefPolicy
 */
export interface KeyRingImportJobSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingImportJobSpecProviderRefPolicy#resolution
   */
  readonly resolution?: KeyRingImportJobSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingImportJobSpecProviderRefPolicy#resolve
   */
  readonly resolve?: KeyRingImportJobSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecProviderRefPolicy(obj: KeyRingImportJobSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema KeyRingImportJobSpecPublishConnectionDetailsToConfigRef
 */
export interface KeyRingImportJobSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeyRingImportJobSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeyRingImportJobSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecPublishConnectionDetailsToConfigRef(obj: KeyRingImportJobSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema KeyRingImportJobSpecPublishConnectionDetailsToMetadata
 */
export interface KeyRingImportJobSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeyRingImportJobSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeyRingImportJobSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema KeyRingImportJobSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecPublishConnectionDetailsToMetadata(obj: KeyRingImportJobSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeyRingImportJobSpecForProviderKeyRingRefPolicy
 */
export interface KeyRingImportJobSpecForProviderKeyRingRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingImportJobSpecForProviderKeyRingRefPolicy#resolution
   */
  readonly resolution?: KeyRingImportJobSpecForProviderKeyRingRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingImportJobSpecForProviderKeyRingRefPolicy#resolve
   */
  readonly resolve?: KeyRingImportJobSpecForProviderKeyRingRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecForProviderKeyRingRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecForProviderKeyRingRefPolicy(obj: KeyRingImportJobSpecForProviderKeyRingRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema KeyRingImportJobSpecForProviderKeyRingSelectorPolicy
 */
export interface KeyRingImportJobSpecForProviderKeyRingSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingImportJobSpecForProviderKeyRingSelectorPolicy#resolution
   */
  readonly resolution?: KeyRingImportJobSpecForProviderKeyRingSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingImportJobSpecForProviderKeyRingSelectorPolicy#resolve
   */
  readonly resolve?: KeyRingImportJobSpecForProviderKeyRingSelectorPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecForProviderKeyRingSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecForProviderKeyRingSelectorPolicy(obj: KeyRingImportJobSpecForProviderKeyRingSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingImportJobSpecProviderConfigRefPolicyResolution
 */
export enum KeyRingImportJobSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingImportJobSpecProviderConfigRefPolicyResolve
 */
export enum KeyRingImportJobSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingImportJobSpecProviderRefPolicyResolution
 */
export enum KeyRingImportJobSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingImportJobSpecProviderRefPolicyResolve
 */
export enum KeyRingImportJobSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicy(obj: KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingImportJobSpecForProviderKeyRingRefPolicyResolution
 */
export enum KeyRingImportJobSpecForProviderKeyRingRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingImportJobSpecForProviderKeyRingRefPolicyResolve
 */
export enum KeyRingImportJobSpecForProviderKeyRingRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingImportJobSpecForProviderKeyRingSelectorPolicyResolution
 */
export enum KeyRingImportJobSpecForProviderKeyRingSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingImportJobSpecForProviderKeyRingSelectorPolicyResolve
 */
export enum KeyRingImportJobSpecForProviderKeyRingSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum KeyRingImportJobSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SecretCiphertext is the Schema for the SecretCiphertexts API. Encrypts secret data with Google Cloud KMS and provides access to the ciphertext.
 *
 * @schema SecretCiphertext
 */
export class SecretCiphertext extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretCiphertext"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.gcp.upbound.io/v1beta1',
    kind: 'SecretCiphertext',
  }

  /**
   * Renders a Kubernetes manifest for "SecretCiphertext".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretCiphertextProps): any {
    return {
      ...SecretCiphertext.GVK,
      ...toJson_SecretCiphertextProps(props),
    };
  }

  /**
   * Defines a "SecretCiphertext" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretCiphertextProps) {
    super(scope, id, {
      ...SecretCiphertext.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretCiphertext.GVK,
      ...toJson_SecretCiphertextProps(resolved),
    };
  }
}

/**
 * SecretCiphertext is the Schema for the SecretCiphertexts API. Encrypts secret data with Google Cloud KMS and provides access to the ciphertext.
 *
 * @schema SecretCiphertext
 */
export interface SecretCiphertextProps {
  /**
   * @schema SecretCiphertext#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretCiphertextSpec defines the desired state of SecretCiphertext
   *
   * @schema SecretCiphertext#spec
   */
  readonly spec: SecretCiphertextSpec;

}

/**
 * Converts an object of type 'SecretCiphertextProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextProps(obj: SecretCiphertextProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretCiphertextSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretCiphertextSpec defines the desired state of SecretCiphertext
 *
 * @schema SecretCiphertextSpec
 */
export interface SecretCiphertextSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretCiphertextSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecretCiphertextSpecDeletionPolicy;

  /**
   * @schema SecretCiphertextSpec#forProvider
   */
  readonly forProvider: SecretCiphertextSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretCiphertextSpec#managementPolicy
   */
  readonly managementPolicy?: SecretCiphertextSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecretCiphertextSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecretCiphertextSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SecretCiphertextSpec#providerRef
   */
  readonly providerRef?: SecretCiphertextSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecretCiphertextSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecretCiphertextSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecretCiphertextSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecretCiphertextSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecretCiphertextSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpec(obj: SecretCiphertextSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecretCiphertextSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SecretCiphertextSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SecretCiphertextSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SecretCiphertextSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecretCiphertextSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretCiphertextSpecDeletionPolicy
 */
export enum SecretCiphertextSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SecretCiphertextSpecForProvider
 */
export interface SecretCiphertextSpecForProvider {
  /**
   * The additional authenticated data used for integrity checks during encryption and decryption. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema SecretCiphertextSpecForProvider#additionalAuthenticatedDataSecretRef
   */
  readonly additionalAuthenticatedDataSecretRef?: SecretCiphertextSpecForProviderAdditionalAuthenticatedDataSecretRef;

  /**
   * The full name of the CryptoKey that will be used to encrypt the provided plaintext. Format: 'projects/{{project}}/locations/{{location}}/keyRings/{{keyRing}}/cryptoKeys/{{cryptoKey}}'
   *
   * @schema SecretCiphertextSpecForProvider#cryptoKey
   */
  readonly cryptoKey?: string;

  /**
   * Reference to a CryptoKey in kms to populate cryptoKey.
   *
   * @schema SecretCiphertextSpecForProvider#cryptoKeyRef
   */
  readonly cryptoKeyRef?: SecretCiphertextSpecForProviderCryptoKeyRef;

  /**
   * Selector for a CryptoKey in kms to populate cryptoKey.
   *
   * @schema SecretCiphertextSpecForProvider#cryptoKeySelector
   */
  readonly cryptoKeySelector?: SecretCiphertextSpecForProviderCryptoKeySelector;

  /**
   * The plaintext to be encrypted. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema SecretCiphertextSpecForProvider#plaintext
   */
  readonly plaintext?: string;

}

/**
 * Converts an object of type 'SecretCiphertextSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecForProvider(obj: SecretCiphertextSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalAuthenticatedDataSecretRef': toJson_SecretCiphertextSpecForProviderAdditionalAuthenticatedDataSecretRef(obj.additionalAuthenticatedDataSecretRef),
    'cryptoKey': obj.cryptoKey,
    'cryptoKeyRef': toJson_SecretCiphertextSpecForProviderCryptoKeyRef(obj.cryptoKeyRef),
    'cryptoKeySelector': toJson_SecretCiphertextSpecForProviderCryptoKeySelector(obj.cryptoKeySelector),
    'plaintext': obj.plaintext,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretCiphertextSpecManagementPolicy
 */
export enum SecretCiphertextSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecretCiphertextSpecProviderConfigRef
 */
export interface SecretCiphertextSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretCiphertextSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretCiphertextSpecProviderConfigRef#policy
   */
  readonly policy?: SecretCiphertextSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretCiphertextSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecProviderConfigRef(obj: SecretCiphertextSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretCiphertextSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SecretCiphertextSpecProviderRef
 */
export interface SecretCiphertextSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretCiphertextSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretCiphertextSpecProviderRef#policy
   */
  readonly policy?: SecretCiphertextSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SecretCiphertextSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecProviderRef(obj: SecretCiphertextSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretCiphertextSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecretCiphertextSpecPublishConnectionDetailsTo
 */
export interface SecretCiphertextSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecretCiphertextSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecretCiphertextSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecretCiphertextSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecretCiphertextSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecretCiphertextSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretCiphertextSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecPublishConnectionDetailsTo(obj: SecretCiphertextSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecretCiphertextSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecretCiphertextSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecretCiphertextSpecWriteConnectionSecretToRef
 */
export interface SecretCiphertextSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecretCiphertextSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretCiphertextSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretCiphertextSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecWriteConnectionSecretToRef(obj: SecretCiphertextSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The additional authenticated data used for integrity checks during encryption and decryption. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema SecretCiphertextSpecForProviderAdditionalAuthenticatedDataSecretRef
 */
export interface SecretCiphertextSpecForProviderAdditionalAuthenticatedDataSecretRef {
  /**
   * The key to select.
   *
   * @schema SecretCiphertextSpecForProviderAdditionalAuthenticatedDataSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema SecretCiphertextSpecForProviderAdditionalAuthenticatedDataSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretCiphertextSpecForProviderAdditionalAuthenticatedDataSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretCiphertextSpecForProviderAdditionalAuthenticatedDataSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecForProviderAdditionalAuthenticatedDataSecretRef(obj: SecretCiphertextSpecForProviderAdditionalAuthenticatedDataSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate cryptoKey.
 *
 * @schema SecretCiphertextSpecForProviderCryptoKeyRef
 */
export interface SecretCiphertextSpecForProviderCryptoKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretCiphertextSpecForProviderCryptoKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretCiphertextSpecForProviderCryptoKeyRef#policy
   */
  readonly policy?: SecretCiphertextSpecForProviderCryptoKeyRefPolicy;

}

/**
 * Converts an object of type 'SecretCiphertextSpecForProviderCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecForProviderCryptoKeyRef(obj: SecretCiphertextSpecForProviderCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretCiphertextSpecForProviderCryptoKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate cryptoKey.
 *
 * @schema SecretCiphertextSpecForProviderCryptoKeySelector
 */
export interface SecretCiphertextSpecForProviderCryptoKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecretCiphertextSpecForProviderCryptoKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecretCiphertextSpecForProviderCryptoKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecretCiphertextSpecForProviderCryptoKeySelector#policy
   */
  readonly policy?: SecretCiphertextSpecForProviderCryptoKeySelectorPolicy;

}

/**
 * Converts an object of type 'SecretCiphertextSpecForProviderCryptoKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecForProviderCryptoKeySelector(obj: SecretCiphertextSpecForProviderCryptoKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecretCiphertextSpecForProviderCryptoKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretCiphertextSpecProviderConfigRefPolicy
 */
export interface SecretCiphertextSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretCiphertextSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecretCiphertextSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretCiphertextSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecretCiphertextSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretCiphertextSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecProviderConfigRefPolicy(obj: SecretCiphertextSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretCiphertextSpecProviderRefPolicy
 */
export interface SecretCiphertextSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretCiphertextSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SecretCiphertextSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretCiphertextSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SecretCiphertextSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretCiphertextSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecProviderRefPolicy(obj: SecretCiphertextSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecretCiphertextSpecPublishConnectionDetailsToConfigRef
 */
export interface SecretCiphertextSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretCiphertextSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretCiphertextSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretCiphertextSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecPublishConnectionDetailsToConfigRef(obj: SecretCiphertextSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecretCiphertextSpecPublishConnectionDetailsToMetadata
 */
export interface SecretCiphertextSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretCiphertextSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretCiphertextSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecretCiphertextSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretCiphertextSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecPublishConnectionDetailsToMetadata(obj: SecretCiphertextSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretCiphertextSpecForProviderCryptoKeyRefPolicy
 */
export interface SecretCiphertextSpecForProviderCryptoKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretCiphertextSpecForProviderCryptoKeyRefPolicy#resolution
   */
  readonly resolution?: SecretCiphertextSpecForProviderCryptoKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretCiphertextSpecForProviderCryptoKeyRefPolicy#resolve
   */
  readonly resolve?: SecretCiphertextSpecForProviderCryptoKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretCiphertextSpecForProviderCryptoKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecForProviderCryptoKeyRefPolicy(obj: SecretCiphertextSpecForProviderCryptoKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecretCiphertextSpecForProviderCryptoKeySelectorPolicy
 */
export interface SecretCiphertextSpecForProviderCryptoKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretCiphertextSpecForProviderCryptoKeySelectorPolicy#resolution
   */
  readonly resolution?: SecretCiphertextSpecForProviderCryptoKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretCiphertextSpecForProviderCryptoKeySelectorPolicy#resolve
   */
  readonly resolve?: SecretCiphertextSpecForProviderCryptoKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecretCiphertextSpecForProviderCryptoKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecForProviderCryptoKeySelectorPolicy(obj: SecretCiphertextSpecForProviderCryptoKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretCiphertextSpecProviderConfigRefPolicyResolution
 */
export enum SecretCiphertextSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretCiphertextSpecProviderConfigRefPolicyResolve
 */
export enum SecretCiphertextSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretCiphertextSpecProviderRefPolicyResolution
 */
export enum SecretCiphertextSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretCiphertextSpecProviderRefPolicyResolve
 */
export enum SecretCiphertextSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretCiphertextSpecForProviderCryptoKeyRefPolicyResolution
 */
export enum SecretCiphertextSpecForProviderCryptoKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretCiphertextSpecForProviderCryptoKeyRefPolicyResolve
 */
export enum SecretCiphertextSpecForProviderCryptoKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretCiphertextSpecForProviderCryptoKeySelectorPolicyResolution
 */
export enum SecretCiphertextSpecForProviderCryptoKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretCiphertextSpecForProviderCryptoKeySelectorPolicyResolve
 */
export enum SecretCiphertextSpecForProviderCryptoKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecretCiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

