// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Accelerator is the Schema for the Accelerators API. Provides a Global Accelerator accelerator.
 *
 * @schema Accelerator
 */
export class Accelerator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Accelerator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'globalaccelerator.aws.upbound.io/v1beta1',
    kind: 'Accelerator',
  }

  /**
   * Renders a Kubernetes manifest for "Accelerator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AcceleratorProps): any {
    return {
      ...Accelerator.GVK,
      ...toJson_AcceleratorProps(props),
    };
  }

  /**
   * Defines a "Accelerator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AcceleratorProps) {
    super(scope, id, {
      ...Accelerator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Accelerator.GVK,
      ...toJson_AcceleratorProps(resolved),
    };
  }
}

/**
 * Accelerator is the Schema for the Accelerators API. Provides a Global Accelerator accelerator.
 *
 * @schema Accelerator
 */
export interface AcceleratorProps {
  /**
   * @schema Accelerator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AcceleratorSpec defines the desired state of Accelerator
   *
   * @schema Accelerator#spec
   */
  readonly spec: AcceleratorSpec;

}

/**
 * Converts an object of type 'AcceleratorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorProps(obj: AcceleratorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AcceleratorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AcceleratorSpec defines the desired state of Accelerator
 *
 * @schema AcceleratorSpec
 */
export interface AcceleratorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AcceleratorSpec#deletionPolicy
   */
  readonly deletionPolicy?: AcceleratorSpecDeletionPolicy;

  /**
   * @schema AcceleratorSpec#forProvider
   */
  readonly forProvider: AcceleratorSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AcceleratorSpec#managementPolicy
   */
  readonly managementPolicy?: AcceleratorSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AcceleratorSpec#providerConfigRef
   */
  readonly providerConfigRef?: AcceleratorSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AcceleratorSpec#providerRef
   */
  readonly providerRef?: AcceleratorSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AcceleratorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AcceleratorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AcceleratorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AcceleratorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AcceleratorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpec(obj: AcceleratorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AcceleratorSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AcceleratorSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AcceleratorSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AcceleratorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AcceleratorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AcceleratorSpecDeletionPolicy
 */
export enum AcceleratorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AcceleratorSpecForProvider
 */
export interface AcceleratorSpecForProvider {
  /**
   * The attributes of the accelerator. Fields documented below.
   *
   * @schema AcceleratorSpecForProvider#attributes
   */
  readonly attributes?: AcceleratorSpecForProviderAttributes[];

  /**
   * Indicates whether the accelerator is enabled. Defaults to true. Valid values: true, false.
   *
   * @default true. Valid values: true, false.
   * @schema AcceleratorSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * The value for the address type. Defaults to IPV4. Valid values: IPV4, DUAL_STACK.
   *
   * @default IPV4. Valid values: IPV4, DUAL_STACK.
   * @schema AcceleratorSpecForProvider#ipAddressType
   */
  readonly ipAddressType?: string;

  /**
   * The IP addresses to use for BYOIP accelerators. If not specified, the service assigns IP addresses. Valid values: 1 or 2 IPv4 addresses.
   *
   * @schema AcceleratorSpecForProvider#ipAddresses
   */
  readonly ipAddresses?: string[];

  /**
   * The name of the accelerator.
   *
   * @schema AcceleratorSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AcceleratorSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AcceleratorSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AcceleratorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecForProvider(obj: AcceleratorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': obj.attributes?.map(y => toJson_AcceleratorSpecForProviderAttributes(y)),
    'enabled': obj.enabled,
    'ipAddressType': obj.ipAddressType,
    'ipAddresses': obj.ipAddresses?.map(y => y),
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AcceleratorSpecManagementPolicy
 */
export enum AcceleratorSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AcceleratorSpecProviderConfigRef
 */
export interface AcceleratorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AcceleratorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AcceleratorSpecProviderConfigRef#policy
   */
  readonly policy?: AcceleratorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AcceleratorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecProviderConfigRef(obj: AcceleratorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AcceleratorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AcceleratorSpecProviderRef
 */
export interface AcceleratorSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AcceleratorSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AcceleratorSpecProviderRef#policy
   */
  readonly policy?: AcceleratorSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AcceleratorSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecProviderRef(obj: AcceleratorSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AcceleratorSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsTo
 */
export interface AcceleratorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AcceleratorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AcceleratorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AcceleratorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecPublishConnectionDetailsTo(obj: AcceleratorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AcceleratorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AcceleratorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AcceleratorSpecWriteConnectionSecretToRef
 */
export interface AcceleratorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AcceleratorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AcceleratorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AcceleratorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecWriteConnectionSecretToRef(obj: AcceleratorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AcceleratorSpecForProviderAttributes
 */
export interface AcceleratorSpecForProviderAttributes {
  /**
   * Indicates whether flow logs are enabled. Defaults to false. Valid values: true, false.
   *
   * @default false. Valid values: true, false.
   * @schema AcceleratorSpecForProviderAttributes#flowLogsEnabled
   */
  readonly flowLogsEnabled?: boolean;

  /**
   * The name of the Amazon S3 bucket for the flow logs. Required if flow_logs_enabled is true.
   *
   * @schema AcceleratorSpecForProviderAttributes#flowLogsS3Bucket
   */
  readonly flowLogsS3Bucket?: string;

  /**
   * The prefix for the location in the Amazon S3 bucket for the flow logs. Required if flow_logs_enabled is true.
   *
   * @schema AcceleratorSpecForProviderAttributes#flowLogsS3Prefix
   */
  readonly flowLogsS3Prefix?: string;

}

/**
 * Converts an object of type 'AcceleratorSpecForProviderAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecForProviderAttributes(obj: AcceleratorSpecForProviderAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flowLogsEnabled': obj.flowLogsEnabled,
    'flowLogsS3Bucket': obj.flowLogsS3Bucket,
    'flowLogsS3Prefix': obj.flowLogsS3Prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AcceleratorSpecProviderConfigRefPolicy
 */
export interface AcceleratorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AcceleratorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AcceleratorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AcceleratorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AcceleratorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AcceleratorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecProviderConfigRefPolicy(obj: AcceleratorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AcceleratorSpecProviderRefPolicy
 */
export interface AcceleratorSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AcceleratorSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AcceleratorSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AcceleratorSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AcceleratorSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AcceleratorSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecProviderRefPolicy(obj: AcceleratorSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsToConfigRef
 */
export interface AcceleratorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AcceleratorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecPublishConnectionDetailsToConfigRef(obj: AcceleratorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsToMetadata
 */
export interface AcceleratorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AcceleratorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecPublishConnectionDetailsToMetadata(obj: AcceleratorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AcceleratorSpecProviderConfigRefPolicyResolution
 */
export enum AcceleratorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AcceleratorSpecProviderConfigRefPolicyResolve
 */
export enum AcceleratorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AcceleratorSpecProviderRefPolicyResolution
 */
export enum AcceleratorSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AcceleratorSpecProviderRefPolicyResolve
 */
export enum AcceleratorSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy(obj: AcceleratorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AcceleratorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EndpointGroup is the Schema for the EndpointGroups API. Provides a Global Accelerator endpoint group.
 *
 * @schema EndpointGroup
 */
export class EndpointGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EndpointGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'globalaccelerator.aws.upbound.io/v1beta1',
    kind: 'EndpointGroup',
  }

  /**
   * Renders a Kubernetes manifest for "EndpointGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EndpointGroupProps): any {
    return {
      ...EndpointGroup.GVK,
      ...toJson_EndpointGroupProps(props),
    };
  }

  /**
   * Defines a "EndpointGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EndpointGroupProps) {
    super(scope, id, {
      ...EndpointGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EndpointGroup.GVK,
      ...toJson_EndpointGroupProps(resolved),
    };
  }
}

/**
 * EndpointGroup is the Schema for the EndpointGroups API. Provides a Global Accelerator endpoint group.
 *
 * @schema EndpointGroup
 */
export interface EndpointGroupProps {
  /**
   * @schema EndpointGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EndpointGroupSpec defines the desired state of EndpointGroup
   *
   * @schema EndpointGroup#spec
   */
  readonly spec: EndpointGroupSpec;

}

/**
 * Converts an object of type 'EndpointGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupProps(obj: EndpointGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EndpointGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointGroupSpec defines the desired state of EndpointGroup
 *
 * @schema EndpointGroupSpec
 */
export interface EndpointGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EndpointGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: EndpointGroupSpecDeletionPolicy;

  /**
   * @schema EndpointGroupSpec#forProvider
   */
  readonly forProvider: EndpointGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EndpointGroupSpec#managementPolicy
   */
  readonly managementPolicy?: EndpointGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EndpointGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: EndpointGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EndpointGroupSpec#providerRef
   */
  readonly providerRef?: EndpointGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EndpointGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EndpointGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EndpointGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EndpointGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EndpointGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpec(obj: EndpointGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EndpointGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EndpointGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EndpointGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EndpointGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EndpointGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EndpointGroupSpecDeletionPolicy
 */
export enum EndpointGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EndpointGroupSpecForProvider
 */
export interface EndpointGroupSpecForProvider {
  /**
   * The list of endpoint objects. Fields documented below.
   *
   * @schema EndpointGroupSpecForProvider#endpointConfiguration
   */
  readonly endpointConfiguration?: EndpointGroupSpecForProviderEndpointConfiguration[];

  /**
   * The name of the AWS Region where the endpoint group is located.
   *
   * @schema EndpointGroupSpecForProvider#endpointGroupRegion
   */
  readonly endpointGroupRegion?: string;

  /**
   * The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.
   *
   * @schema EndpointGroupSpecForProvider#healthCheckIntervalSeconds
   */
  readonly healthCheckIntervalSeconds?: number;

  /**
   * If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).
   *
   * @schema EndpointGroupSpecForProvider#healthCheckPath
   */
  readonly healthCheckPath?: string;

  /**
   * The port that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the first port in the list.
   *
   * @schema EndpointGroupSpecForProvider#healthCheckPort
   */
  readonly healthCheckPort?: number;

  /**
   * The protocol that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.
   *
   * @schema EndpointGroupSpecForProvider#healthCheckProtocol
   */
  readonly healthCheckProtocol?: string;

  /**
   * The Amazon Resource Name (ARN) of the listener.
   *
   * @schema EndpointGroupSpecForProvider#listenerArn
   */
  readonly listenerArn?: string;

  /**
   * Reference to a Listener to populate listenerArn.
   *
   * @schema EndpointGroupSpecForProvider#listenerArnRef
   */
  readonly listenerArnRef?: EndpointGroupSpecForProviderListenerArnRef;

  /**
   * Selector for a Listener to populate listenerArn.
   *
   * @schema EndpointGroupSpecForProvider#listenerArnSelector
   */
  readonly listenerArnSelector?: EndpointGroupSpecForProviderListenerArnSelector;

  /**
   * Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. Fields documented below.
   *
   * @schema EndpointGroupSpecForProvider#portOverride
   */
  readonly portOverride?: EndpointGroupSpecForProviderPortOverride[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EndpointGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
   *
   * @schema EndpointGroupSpecForProvider#thresholdCount
   */
  readonly thresholdCount?: number;

  /**
   * The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for this listener. The default value is 100.
   *
   * @schema EndpointGroupSpecForProvider#trafficDialPercentage
   */
  readonly trafficDialPercentage?: number;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProvider(obj: EndpointGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointConfiguration': obj.endpointConfiguration?.map(y => toJson_EndpointGroupSpecForProviderEndpointConfiguration(y)),
    'endpointGroupRegion': obj.endpointGroupRegion,
    'healthCheckIntervalSeconds': obj.healthCheckIntervalSeconds,
    'healthCheckPath': obj.healthCheckPath,
    'healthCheckPort': obj.healthCheckPort,
    'healthCheckProtocol': obj.healthCheckProtocol,
    'listenerArn': obj.listenerArn,
    'listenerArnRef': toJson_EndpointGroupSpecForProviderListenerArnRef(obj.listenerArnRef),
    'listenerArnSelector': toJson_EndpointGroupSpecForProviderListenerArnSelector(obj.listenerArnSelector),
    'portOverride': obj.portOverride?.map(y => toJson_EndpointGroupSpecForProviderPortOverride(y)),
    'region': obj.region,
    'thresholdCount': obj.thresholdCount,
    'trafficDialPercentage': obj.trafficDialPercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EndpointGroupSpecManagementPolicy
 */
export enum EndpointGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EndpointGroupSpecProviderConfigRef
 */
export interface EndpointGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointGroupSpecProviderConfigRef#policy
   */
  readonly policy?: EndpointGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecProviderConfigRef(obj: EndpointGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EndpointGroupSpecProviderRef
 */
export interface EndpointGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointGroupSpecProviderRef#policy
   */
  readonly policy?: EndpointGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EndpointGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecProviderRef(obj: EndpointGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsTo
 */
export interface EndpointGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EndpointGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EndpointGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EndpointGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecPublishConnectionDetailsTo(obj: EndpointGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EndpointGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EndpointGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EndpointGroupSpecWriteConnectionSecretToRef
 */
export interface EndpointGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EndpointGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EndpointGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EndpointGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecWriteConnectionSecretToRef(obj: EndpointGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointGroupSpecForProviderEndpointConfiguration
 */
export interface EndpointGroupSpecForProviderEndpointConfiguration {
  /**
   * Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint. See the AWS documentation for more details. The default value is false.
   *
   * @schema EndpointGroupSpecForProviderEndpointConfiguration#clientIpPreservationEnabled
   */
  readonly clientIpPreservationEnabled?: boolean;

  /**
   * An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID.
   *
   * @schema EndpointGroupSpecForProviderEndpointConfiguration#endpointId
   */
  readonly endpointId?: string;

  /**
   * The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic based on proportions that you specify.
   *
   * @schema EndpointGroupSpecForProviderEndpointConfiguration#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderEndpointConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderEndpointConfiguration(obj: EndpointGroupSpecForProviderEndpointConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIpPreservationEnabled': obj.clientIpPreservationEnabled,
    'endpointId': obj.endpointId,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Listener to populate listenerArn.
 *
 * @schema EndpointGroupSpecForProviderListenerArnRef
 */
export interface EndpointGroupSpecForProviderListenerArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointGroupSpecForProviderListenerArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointGroupSpecForProviderListenerArnRef#policy
   */
  readonly policy?: EndpointGroupSpecForProviderListenerArnRefPolicy;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderListenerArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderListenerArnRef(obj: EndpointGroupSpecForProviderListenerArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointGroupSpecForProviderListenerArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Listener to populate listenerArn.
 *
 * @schema EndpointGroupSpecForProviderListenerArnSelector
 */
export interface EndpointGroupSpecForProviderListenerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EndpointGroupSpecForProviderListenerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EndpointGroupSpecForProviderListenerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EndpointGroupSpecForProviderListenerArnSelector#policy
   */
  readonly policy?: EndpointGroupSpecForProviderListenerArnSelectorPolicy;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderListenerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderListenerArnSelector(obj: EndpointGroupSpecForProviderListenerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EndpointGroupSpecForProviderListenerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointGroupSpecForProviderPortOverride
 */
export interface EndpointGroupSpecForProviderPortOverride {
  /**
   * The endpoint port that you want a listener port to be mapped to. This is the port on the endpoint, such as the Application Load Balancer or Amazon EC2 instance.
   *
   * @schema EndpointGroupSpecForProviderPortOverride#endpointPort
   */
  readonly endpointPort: number;

  /**
   * The listener port that you want to map to a specific endpoint port. This is the port that user traffic arrives to the Global Accelerator on.
   *
   * @schema EndpointGroupSpecForProviderPortOverride#listenerPort
   */
  readonly listenerPort: number;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderPortOverride' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderPortOverride(obj: EndpointGroupSpecForProviderPortOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointPort': obj.endpointPort,
    'listenerPort': obj.listenerPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointGroupSpecProviderConfigRefPolicy
 */
export interface EndpointGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecProviderConfigRefPolicy(obj: EndpointGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointGroupSpecProviderRefPolicy
 */
export interface EndpointGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EndpointGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EndpointGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecProviderRefPolicy(obj: EndpointGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface EndpointGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecPublishConnectionDetailsToConfigRef(obj: EndpointGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsToMetadata
 */
export interface EndpointGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EndpointGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecPublishConnectionDetailsToMetadata(obj: EndpointGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointGroupSpecForProviderListenerArnRefPolicy
 */
export interface EndpointGroupSpecForProviderListenerArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointGroupSpecForProviderListenerArnRefPolicy#resolution
   */
  readonly resolution?: EndpointGroupSpecForProviderListenerArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointGroupSpecForProviderListenerArnRefPolicy#resolve
   */
  readonly resolve?: EndpointGroupSpecForProviderListenerArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderListenerArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderListenerArnRefPolicy(obj: EndpointGroupSpecForProviderListenerArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EndpointGroupSpecForProviderListenerArnSelectorPolicy
 */
export interface EndpointGroupSpecForProviderListenerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointGroupSpecForProviderListenerArnSelectorPolicy#resolution
   */
  readonly resolution?: EndpointGroupSpecForProviderListenerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointGroupSpecForProviderListenerArnSelectorPolicy#resolve
   */
  readonly resolve?: EndpointGroupSpecForProviderListenerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EndpointGroupSpecForProviderListenerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecForProviderListenerArnSelectorPolicy(obj: EndpointGroupSpecForProviderListenerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointGroupSpecProviderConfigRefPolicyResolution
 */
export enum EndpointGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointGroupSpecProviderConfigRefPolicyResolve
 */
export enum EndpointGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointGroupSpecProviderRefPolicyResolution
 */
export enum EndpointGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointGroupSpecProviderRefPolicyResolve
 */
export enum EndpointGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointGroupSpecForProviderListenerArnRefPolicyResolution
 */
export enum EndpointGroupSpecForProviderListenerArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointGroupSpecForProviderListenerArnRefPolicyResolve
 */
export enum EndpointGroupSpecForProviderListenerArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointGroupSpecForProviderListenerArnSelectorPolicyResolution
 */
export enum EndpointGroupSpecForProviderListenerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointGroupSpecForProviderListenerArnSelectorPolicyResolve
 */
export enum EndpointGroupSpecForProviderListenerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EndpointGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Listener is the Schema for the Listeners API. Provides a Global Accelerator listener.
 *
 * @schema Listener
 */
export class Listener extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Listener"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'globalaccelerator.aws.upbound.io/v1beta1',
    kind: 'Listener',
  }

  /**
   * Renders a Kubernetes manifest for "Listener".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ListenerProps): any {
    return {
      ...Listener.GVK,
      ...toJson_ListenerProps(props),
    };
  }

  /**
   * Defines a "Listener" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ListenerProps) {
    super(scope, id, {
      ...Listener.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Listener.GVK,
      ...toJson_ListenerProps(resolved),
    };
  }
}

/**
 * Listener is the Schema for the Listeners API. Provides a Global Accelerator listener.
 *
 * @schema Listener
 */
export interface ListenerProps {
  /**
   * @schema Listener#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ListenerSpec defines the desired state of Listener
   *
   * @schema Listener#spec
   */
  readonly spec: ListenerSpec;

}

/**
 * Converts an object of type 'ListenerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerProps(obj: ListenerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ListenerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ListenerSpec defines the desired state of Listener
 *
 * @schema ListenerSpec
 */
export interface ListenerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ListenerSpec#deletionPolicy
   */
  readonly deletionPolicy?: ListenerSpecDeletionPolicy;

  /**
   * @schema ListenerSpec#forProvider
   */
  readonly forProvider: ListenerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ListenerSpec#managementPolicy
   */
  readonly managementPolicy?: ListenerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ListenerSpec#providerConfigRef
   */
  readonly providerConfigRef?: ListenerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ListenerSpec#providerRef
   */
  readonly providerRef?: ListenerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ListenerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ListenerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ListenerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ListenerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ListenerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpec(obj: ListenerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ListenerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ListenerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ListenerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ListenerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ListenerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ListenerSpecDeletionPolicy
 */
export enum ListenerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ListenerSpecForProvider
 */
export interface ListenerSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of your accelerator.
   *
   * @schema ListenerSpecForProvider#acceleratorArn
   */
  readonly acceleratorArn?: string;

  /**
   * Reference to a Accelerator to populate acceleratorArn.
   *
   * @schema ListenerSpecForProvider#acceleratorArnRef
   */
  readonly acceleratorArnRef?: ListenerSpecForProviderAcceleratorArnRef;

  /**
   * Selector for a Accelerator to populate acceleratorArn.
   *
   * @schema ListenerSpecForProvider#acceleratorArnSelector
   */
  readonly acceleratorArnSelector?: ListenerSpecForProviderAcceleratorArnSelector;

  /**
   * Direct all requests from a user to the same endpoint. Valid values are NONE, SOURCE_IP. Default: NONE. If NONE, Global Accelerator uses the "five-tuple" properties of source IP address, source port, destination IP address, destination port, and protocol to select the hash value. If SOURCE_IP, Global Accelerator uses the "two-tuple" properties of source (client) IP address and destination IP address to select the hash value.
   *
   * @schema ListenerSpecForProvider#clientAffinity
   */
  readonly clientAffinity?: string;

  /**
   * The list of port ranges for the connections from clients to the accelerator. Fields documented below.
   *
   * @schema ListenerSpecForProvider#portRange
   */
  readonly portRange?: ListenerSpecForProviderPortRange[];

  /**
   * The protocol for the connections from clients to the accelerator. Valid values are TCP, UDP.
   *
   * @schema ListenerSpecForProvider#protocol
   */
  readonly protocol?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ListenerSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ListenerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProvider(obj: ListenerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorArn': obj.acceleratorArn,
    'acceleratorArnRef': toJson_ListenerSpecForProviderAcceleratorArnRef(obj.acceleratorArnRef),
    'acceleratorArnSelector': toJson_ListenerSpecForProviderAcceleratorArnSelector(obj.acceleratorArnSelector),
    'clientAffinity': obj.clientAffinity,
    'portRange': obj.portRange?.map(y => toJson_ListenerSpecForProviderPortRange(y)),
    'protocol': obj.protocol,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ListenerSpecManagementPolicy
 */
export enum ListenerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ListenerSpecProviderConfigRef
 */
export interface ListenerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecProviderConfigRef#policy
   */
  readonly policy?: ListenerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecProviderConfigRef(obj: ListenerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ListenerSpecProviderRef
 */
export interface ListenerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecProviderRef#policy
   */
  readonly policy?: ListenerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecProviderRef(obj: ListenerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ListenerSpecPublishConnectionDetailsTo
 */
export interface ListenerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ListenerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ListenerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ListenerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ListenerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ListenerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsTo(obj: ListenerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ListenerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ListenerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ListenerSpecWriteConnectionSecretToRef
 */
export interface ListenerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ListenerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ListenerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ListenerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecWriteConnectionSecretToRef(obj: ListenerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Accelerator to populate acceleratorArn.
 *
 * @schema ListenerSpecForProviderAcceleratorArnRef
 */
export interface ListenerSpecForProviderAcceleratorArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecForProviderAcceleratorArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecForProviderAcceleratorArnRef#policy
   */
  readonly policy?: ListenerSpecForProviderAcceleratorArnRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderAcceleratorArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderAcceleratorArnRef(obj: ListenerSpecForProviderAcceleratorArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecForProviderAcceleratorArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Accelerator to populate acceleratorArn.
 *
 * @schema ListenerSpecForProviderAcceleratorArnSelector
 */
export interface ListenerSpecForProviderAcceleratorArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ListenerSpecForProviderAcceleratorArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ListenerSpecForProviderAcceleratorArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ListenerSpecForProviderAcceleratorArnSelector#policy
   */
  readonly policy?: ListenerSpecForProviderAcceleratorArnSelectorPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderAcceleratorArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderAcceleratorArnSelector(obj: ListenerSpecForProviderAcceleratorArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ListenerSpecForProviderAcceleratorArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ListenerSpecForProviderPortRange
 */
export interface ListenerSpecForProviderPortRange {
  /**
   * The first port in the range of ports, inclusive.
   *
   * @schema ListenerSpecForProviderPortRange#fromPort
   */
  readonly fromPort?: number;

  /**
   * The last port in the range of ports, inclusive.
   *
   * @schema ListenerSpecForProviderPortRange#toPort
   */
  readonly toPort?: number;

}

/**
 * Converts an object of type 'ListenerSpecForProviderPortRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderPortRange(obj: ListenerSpecForProviderPortRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPort': obj.fromPort,
    'toPort': obj.toPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecProviderConfigRefPolicy
 */
export interface ListenerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecProviderConfigRefPolicy(obj: ListenerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecProviderRefPolicy
 */
export interface ListenerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecProviderRefPolicy(obj: ListenerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRef
 */
export interface ListenerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ListenerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsToConfigRef(obj: ListenerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ListenerSpecPublishConnectionDetailsToMetadata
 */
export interface ListenerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ListenerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ListenerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ListenerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsToMetadata(obj: ListenerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecForProviderAcceleratorArnRefPolicy
 */
export interface ListenerSpecForProviderAcceleratorArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderAcceleratorArnRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderAcceleratorArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderAcceleratorArnRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderAcceleratorArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderAcceleratorArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderAcceleratorArnRefPolicy(obj: ListenerSpecForProviderAcceleratorArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ListenerSpecForProviderAcceleratorArnSelectorPolicy
 */
export interface ListenerSpecForProviderAcceleratorArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderAcceleratorArnSelectorPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderAcceleratorArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderAcceleratorArnSelectorPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderAcceleratorArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderAcceleratorArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderAcceleratorArnSelectorPolicy(obj: ListenerSpecForProviderAcceleratorArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecProviderConfigRefPolicyResolution
 */
export enum ListenerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecProviderConfigRefPolicyResolve
 */
export enum ListenerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecProviderRefPolicyResolution
 */
export enum ListenerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecProviderRefPolicyResolve
 */
export enum ListenerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ListenerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsToConfigRefPolicy(obj: ListenerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderAcceleratorArnRefPolicyResolution
 */
export enum ListenerSpecForProviderAcceleratorArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderAcceleratorArnRefPolicyResolve
 */
export enum ListenerSpecForProviderAcceleratorArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderAcceleratorArnSelectorPolicyResolution
 */
export enum ListenerSpecForProviderAcceleratorArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderAcceleratorArnSelectorPolicyResolve
 */
export enum ListenerSpecForProviderAcceleratorArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

