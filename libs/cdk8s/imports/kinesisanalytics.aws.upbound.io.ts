// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Application is the Schema for the Applications API. Provides a AWS Kinesis Analytics Application
 *
 * @schema Application
 */
export class Application extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Application"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kinesisanalytics.aws.upbound.io/v1beta1',
    kind: 'Application',
  }

  /**
   * Renders a Kubernetes manifest for "Application".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationProps): any {
    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(props),
    };
  }

  /**
   * Defines a "Application" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationProps) {
    super(scope, id, {
      ...Application.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(resolved),
    };
  }
}

/**
 * Application is the Schema for the Applications API. Provides a AWS Kinesis Analytics Application
 *
 * @schema Application
 */
export interface ApplicationProps {
  /**
   * @schema Application#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApplicationSpec defines the desired state of Application
   *
   * @schema Application#spec
   */
  readonly spec: ApplicationSpec;

}

/**
 * Converts an object of type 'ApplicationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationProps(obj: ApplicationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSpec defines the desired state of Application
 *
 * @schema ApplicationSpec
 */
export interface ApplicationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApplicationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationSpecDeletionPolicy;

  /**
   * @schema ApplicationSpec#forProvider
   */
  readonly forProvider: ApplicationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ApplicationSpec#initProvider
   */
  readonly initProvider?: ApplicationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApplicationSpec#managementPolicies
   */
  readonly managementPolicies?: ApplicationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpec(obj: ApplicationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationSpecForProvider(obj.forProvider),
    'initProvider': toJson_ApplicationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApplicationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApplicationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApplicationSpecDeletionPolicy
 */
export enum ApplicationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApplicationSpecForProvider
 */
export interface ApplicationSpecForProvider {
  /**
   * The CloudWatch log stream options to monitor application errors. See CloudWatch Logging Options below for more details.
   *
   * @schema ApplicationSpecForProvider#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: ApplicationSpecForProviderCloudwatchLoggingOptions[];

  /**
   * SQL Code to transform input data, and generate output.
   *
   * @schema ApplicationSpecForProvider#code
   */
  readonly code?: string;

  /**
   * Description of the application.
   *
   * @schema ApplicationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Input configuration of the application. See Inputs below for more details.
   *
   * @schema ApplicationSpecForProvider#inputs
   */
  readonly inputs?: ApplicationSpecForProviderInputs[];

  /**
   * Output destination configuration of the application. See Outputs below for more details.
   *
   * @schema ApplicationSpecForProvider#outputs
   */
  readonly outputs?: ApplicationSpecForProviderOutputs[];

  /**
   * An S3 Reference Data Source for the application. See Reference Data Sources below for more details.
   *
   * @schema ApplicationSpecForProvider#referenceDataSources
   */
  readonly referenceDataSources?: ApplicationSpecForProviderReferenceDataSources[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApplicationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Whether to start or stop the Kinesis Analytics Application. To start an application, an input with a defined starting_position must be configured. To modify an application's starting position, first stop the application by setting start_application = false, then update starting_position and set start_application = true.
   *
   * @schema ApplicationSpecForProvider#startApplication
   */
  readonly startApplication?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProvider(obj: ApplicationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_ApplicationSpecForProviderCloudwatchLoggingOptions(y)),
    'code': obj.code,
    'description': obj.description,
    'inputs': obj.inputs?.map(y => toJson_ApplicationSpecForProviderInputs(y)),
    'outputs': obj.outputs?.map(y => toJson_ApplicationSpecForProviderOutputs(y)),
    'referenceDataSources': obj.referenceDataSources?.map(y => toJson_ApplicationSpecForProviderReferenceDataSources(y)),
    'region': obj.region,
    'startApplication': obj.startApplication,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ApplicationSpecInitProvider
 */
export interface ApplicationSpecInitProvider {
  /**
   * The CloudWatch log stream options to monitor application errors. See CloudWatch Logging Options below for more details.
   *
   * @schema ApplicationSpecInitProvider#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: any[];

  /**
   * SQL Code to transform input data, and generate output.
   *
   * @schema ApplicationSpecInitProvider#code
   */
  readonly code?: string;

  /**
   * Description of the application.
   *
   * @schema ApplicationSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Input configuration of the application. See Inputs below for more details.
   *
   * @schema ApplicationSpecInitProvider#inputs
   */
  readonly inputs?: ApplicationSpecInitProviderInputs[];

  /**
   * Output destination configuration of the application. See Outputs below for more details.
   *
   * @schema ApplicationSpecInitProvider#outputs
   */
  readonly outputs?: ApplicationSpecInitProviderOutputs[];

  /**
   * An S3 Reference Data Source for the application. See Reference Data Sources below for more details.
   *
   * @schema ApplicationSpecInitProvider#referenceDataSources
   */
  readonly referenceDataSources?: ApplicationSpecInitProviderReferenceDataSources[];

  /**
   * Whether to start or stop the Kinesis Analytics Application. To start an application, an input with a defined starting_position must be configured. To modify an application's starting position, first stop the application by setting start_application = false, then update starting_position and set start_application = true.
   *
   * @schema ApplicationSpecInitProvider#startApplication
   */
  readonly startApplication?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProvider(obj: ApplicationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => y),
    'code': obj.code,
    'description': obj.description,
    'inputs': obj.inputs?.map(y => toJson_ApplicationSpecInitProviderInputs(y)),
    'outputs': obj.outputs?.map(y => toJson_ApplicationSpecInitProviderOutputs(y)),
    'referenceDataSources': obj.referenceDataSources?.map(y => toJson_ApplicationSpecInitProviderReferenceDataSources(y)),
    'startApplication': obj.startApplication,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApplicationSpecManagementPolicies
 */
export enum ApplicationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationSpecProviderConfigRef
 */
export interface ApplicationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRef(obj: ApplicationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationSpecPublishConnectionDetailsTo
 */
export interface ApplicationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsTo(obj: ApplicationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationSpecWriteConnectionSecretToRef
 */
export interface ApplicationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecWriteConnectionSecretToRef(obj: ApplicationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptions
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptions {
  /**
   * The ARN of the CloudWatch Log Stream.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptions#logStreamArn
   */
  readonly logStreamArn?: string;

  /**
   * Reference to a Stream in cloudwatchlogs to populate logStreamArn.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptions#logStreamArnRef
   */
  readonly logStreamArnRef?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef;

  /**
   * Selector for a Stream in cloudwatchlogs to populate logStreamArn.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptions#logStreamArnSelector
   */
  readonly logStreamArnSelector?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector;

  /**
   * The ARN of the IAM Role used to send application messages.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptions#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptions#roleArnRef
   */
  readonly roleArnRef?: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptions#roleArnSelector
   */
  readonly roleArnSelector?: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelector;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptions(obj: ApplicationSpecForProviderCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logStreamArn': obj.logStreamArn,
    'logStreamArnRef': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef(obj.logStreamArnRef),
    'logStreamArnSelector': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector(obj.logStreamArnSelector),
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputs
 */
export interface ApplicationSpecForProviderInputs {
  /**
   * The Kinesis Firehose configuration for the streaming source. Conflicts with kinesis_stream. See Kinesis Firehose below for more details.
   *
   * @schema ApplicationSpecForProviderInputs#kinesisFirehose
   */
  readonly kinesisFirehose?: ApplicationSpecForProviderInputsKinesisFirehose[];

  /**
   * The Kinesis Stream configuration for the streaming source. Conflicts with kinesis_firehose. See Kinesis Stream below for more details.
   *
   * @schema ApplicationSpecForProviderInputs#kinesisStream
   */
  readonly kinesisStream?: ApplicationSpecForProviderInputsKinesisStream[];

  /**
   * The Name Prefix to use when creating an in-application stream.
   *
   * @schema ApplicationSpecForProviderInputs#namePrefix
   */
  readonly namePrefix?: string;

  /**
   * The number of Parallel in-application streams to create. See Parallelism below for more details.
   *
   * @schema ApplicationSpecForProviderInputs#parallelism
   */
  readonly parallelism?: ApplicationSpecForProviderInputsParallelism[];

  /**
   * The Processing Configuration to transform records as they are received from the stream. See Processing Configuration below for more details.
   *
   * @schema ApplicationSpecForProviderInputs#processingConfiguration
   */
  readonly processingConfiguration?: ApplicationSpecForProviderInputsProcessingConfiguration[];

  /**
   * The Schema format of the data in the streaming source. See Source Schema below for more details.
   *
   * @schema ApplicationSpecForProviderInputs#schema
   */
  readonly schema?: ApplicationSpecForProviderInputsSchema[];

  /**
   * The point at which the application starts processing records from the streaming source. See Starting Position Configuration below for more details.
   *
   * @schema ApplicationSpecForProviderInputs#startingPositionConfiguration
   */
  readonly startingPositionConfiguration?: ApplicationSpecForProviderInputsStartingPositionConfiguration[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputs(obj: ApplicationSpecForProviderInputs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinesisFirehose': obj.kinesisFirehose?.map(y => toJson_ApplicationSpecForProviderInputsKinesisFirehose(y)),
    'kinesisStream': obj.kinesisStream?.map(y => toJson_ApplicationSpecForProviderInputsKinesisStream(y)),
    'namePrefix': obj.namePrefix,
    'parallelism': obj.parallelism?.map(y => toJson_ApplicationSpecForProviderInputsParallelism(y)),
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_ApplicationSpecForProviderInputsProcessingConfiguration(y)),
    'schema': obj.schema?.map(y => toJson_ApplicationSpecForProviderInputsSchema(y)),
    'startingPositionConfiguration': obj.startingPositionConfiguration?.map(y => toJson_ApplicationSpecForProviderInputsStartingPositionConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderOutputs
 */
export interface ApplicationSpecForProviderOutputs {
  /**
   * The Kinesis Firehose configuration for the destination stream. Conflicts with kinesis_stream. See Kinesis Firehose below for more details.
   *
   * @schema ApplicationSpecForProviderOutputs#kinesisFirehose
   */
  readonly kinesisFirehose?: ApplicationSpecForProviderOutputsKinesisFirehose[];

  /**
   * The Kinesis Stream configuration for the destination stream. Conflicts with kinesis_firehose. See Kinesis Stream below for more details.
   *
   * @schema ApplicationSpecForProviderOutputs#kinesisStream
   */
  readonly kinesisStream?: ApplicationSpecForProviderOutputsKinesisStream[];

  /**
   * The Lambda function destination. See Lambda below for more details.
   *
   * @schema ApplicationSpecForProviderOutputs#lambda
   */
  readonly lambda?: ApplicationSpecForProviderOutputsLambda[];

  /**
   * The Name of the in-application stream.
   *
   * @schema ApplicationSpecForProviderOutputs#name
   */
  readonly name?: string;

  /**
   * The Schema format of the data written to the destination. See Destination Schema below for more details.
   *
   * @schema ApplicationSpecForProviderOutputs#schema
   */
  readonly schema?: ApplicationSpecForProviderOutputsSchema[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputs(obj: ApplicationSpecForProviderOutputs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinesisFirehose': obj.kinesisFirehose?.map(y => toJson_ApplicationSpecForProviderOutputsKinesisFirehose(y)),
    'kinesisStream': obj.kinesisStream?.map(y => toJson_ApplicationSpecForProviderOutputsKinesisStream(y)),
    'lambda': obj.lambda?.map(y => toJson_ApplicationSpecForProviderOutputsLambda(y)),
    'name': obj.name,
    'schema': obj.schema?.map(y => toJson_ApplicationSpecForProviderOutputsSchema(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderReferenceDataSources
 */
export interface ApplicationSpecForProviderReferenceDataSources {
  /**
   * The S3 configuration for the reference data source. See S3 Reference below for more details.
   *
   * @schema ApplicationSpecForProviderReferenceDataSources#s3
   */
  readonly s3?: ApplicationSpecForProviderReferenceDataSourcesS3[];

  /**
   * The Schema format of the data in the streaming source. See Source Schema below for more details.
   *
   * @schema ApplicationSpecForProviderReferenceDataSources#schema
   */
  readonly schema?: ApplicationSpecForProviderReferenceDataSourcesSchema[];

  /**
   * The in-application Table Name.
   *
   * @schema ApplicationSpecForProviderReferenceDataSources#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderReferenceDataSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderReferenceDataSources(obj: ApplicationSpecForProviderReferenceDataSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3': obj.s3?.map(y => toJson_ApplicationSpecForProviderReferenceDataSourcesS3(y)),
    'schema': obj.schema?.map(y => toJson_ApplicationSpecForProviderReferenceDataSourcesSchema(y)),
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputs
 */
export interface ApplicationSpecInitProviderInputs {
  /**
   * The Kinesis Firehose configuration for the streaming source. Conflicts with kinesis_stream. See Kinesis Firehose below for more details.
   *
   * @schema ApplicationSpecInitProviderInputs#kinesisFirehose
   */
  readonly kinesisFirehose?: ApplicationSpecInitProviderInputsKinesisFirehose[];

  /**
   * The Kinesis Stream configuration for the streaming source. Conflicts with kinesis_firehose. See Kinesis Stream below for more details.
   *
   * @schema ApplicationSpecInitProviderInputs#kinesisStream
   */
  readonly kinesisStream?: any[];

  /**
   * The Name Prefix to use when creating an in-application stream.
   *
   * @schema ApplicationSpecInitProviderInputs#namePrefix
   */
  readonly namePrefix?: string;

  /**
   * The number of Parallel in-application streams to create. See Parallelism below for more details.
   *
   * @schema ApplicationSpecInitProviderInputs#parallelism
   */
  readonly parallelism?: ApplicationSpecInitProviderInputsParallelism[];

  /**
   * The Processing Configuration to transform records as they are received from the stream. See Processing Configuration below for more details.
   *
   * @schema ApplicationSpecInitProviderInputs#processingConfiguration
   */
  readonly processingConfiguration?: ApplicationSpecInitProviderInputsProcessingConfiguration[];

  /**
   * The Schema format of the data in the streaming source. See Source Schema below for more details.
   *
   * @schema ApplicationSpecInitProviderInputs#schema
   */
  readonly schema?: ApplicationSpecInitProviderInputsSchema[];

  /**
   * The point at which the application starts processing records from the streaming source. See Starting Position Configuration below for more details.
   *
   * @schema ApplicationSpecInitProviderInputs#startingPositionConfiguration
   */
  readonly startingPositionConfiguration?: ApplicationSpecInitProviderInputsStartingPositionConfiguration[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputs(obj: ApplicationSpecInitProviderInputs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinesisFirehose': obj.kinesisFirehose?.map(y => toJson_ApplicationSpecInitProviderInputsKinesisFirehose(y)),
    'kinesisStream': obj.kinesisStream?.map(y => y),
    'namePrefix': obj.namePrefix,
    'parallelism': obj.parallelism?.map(y => toJson_ApplicationSpecInitProviderInputsParallelism(y)),
    'processingConfiguration': obj.processingConfiguration?.map(y => toJson_ApplicationSpecInitProviderInputsProcessingConfiguration(y)),
    'schema': obj.schema?.map(y => toJson_ApplicationSpecInitProviderInputsSchema(y)),
    'startingPositionConfiguration': obj.startingPositionConfiguration?.map(y => toJson_ApplicationSpecInitProviderInputsStartingPositionConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderOutputs
 */
export interface ApplicationSpecInitProviderOutputs {
  /**
   * The Kinesis Firehose configuration for the destination stream. Conflicts with kinesis_stream. See Kinesis Firehose below for more details.
   *
   * @schema ApplicationSpecInitProviderOutputs#kinesisFirehose
   */
  readonly kinesisFirehose?: any[];

  /**
   * The Kinesis Stream configuration for the destination stream. Conflicts with kinesis_firehose. See Kinesis Stream below for more details.
   *
   * @schema ApplicationSpecInitProviderOutputs#kinesisStream
   */
  readonly kinesisStream?: ApplicationSpecInitProviderOutputsKinesisStream[];

  /**
   * The Lambda function destination. See Lambda below for more details.
   *
   * @schema ApplicationSpecInitProviderOutputs#lambda
   */
  readonly lambda?: ApplicationSpecInitProviderOutputsLambda[];

  /**
   * The Name of the in-application stream.
   *
   * @schema ApplicationSpecInitProviderOutputs#name
   */
  readonly name?: string;

  /**
   * The Schema format of the data written to the destination. See Destination Schema below for more details.
   *
   * @schema ApplicationSpecInitProviderOutputs#schema
   */
  readonly schema?: ApplicationSpecInitProviderOutputsSchema[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderOutputs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderOutputs(obj: ApplicationSpecInitProviderOutputs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinesisFirehose': obj.kinesisFirehose?.map(y => y),
    'kinesisStream': obj.kinesisStream?.map(y => toJson_ApplicationSpecInitProviderOutputsKinesisStream(y)),
    'lambda': obj.lambda?.map(y => toJson_ApplicationSpecInitProviderOutputsLambda(y)),
    'name': obj.name,
    'schema': obj.schema?.map(y => toJson_ApplicationSpecInitProviderOutputsSchema(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderReferenceDataSources
 */
export interface ApplicationSpecInitProviderReferenceDataSources {
  /**
   * The S3 configuration for the reference data source. See S3 Reference below for more details.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSources#s3
   */
  readonly s3?: ApplicationSpecInitProviderReferenceDataSourcesS3[];

  /**
   * The Schema format of the data in the streaming source. See Source Schema below for more details.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSources#schema
   */
  readonly schema?: ApplicationSpecInitProviderReferenceDataSourcesSchema[];

  /**
   * The in-application Table Name.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSources#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderReferenceDataSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderReferenceDataSources(obj: ApplicationSpecInitProviderReferenceDataSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3': obj.s3?.map(y => toJson_ApplicationSpecInitProviderReferenceDataSourcesS3(y)),
    'schema': obj.schema?.map(y => toJson_ApplicationSpecInitProviderReferenceDataSourcesSchema(y)),
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderConfigRefPolicy
 */
export interface ApplicationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRefPolicy(obj: ApplicationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj: ApplicationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj: ApplicationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stream in cloudwatchlogs to populate logStreamArn.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stream in cloudwatchlogs to populate logStreamArn.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRef
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRef(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelector
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelector(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsKinesisFirehose
 */
export interface ApplicationSpecForProviderInputsKinesisFirehose {
  /**
   * The ARN of the Lambda function.
   *
   * @schema ApplicationSpecForProviderInputsKinesisFirehose#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecForProviderInputsKinesisFirehose#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsKinesisFirehose' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsKinesisFirehose(obj: ApplicationSpecForProviderInputsKinesisFirehose | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsKinesisStream
 */
export interface ApplicationSpecForProviderInputsKinesisStream {
  /**
   * The ARN of the Lambda function.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStream#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a Stream in kinesis to populate resourceArn.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStream#resourceArnRef
   */
  readonly resourceArnRef?: ApplicationSpecForProviderInputsKinesisStreamResourceArnRef;

  /**
   * Selector for a Stream in kinesis to populate resourceArn.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStream#resourceArnSelector
   */
  readonly resourceArnSelector?: ApplicationSpecForProviderInputsKinesisStreamResourceArnSelector;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStream#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStream#roleArnRef
   */
  readonly roleArnRef?: ApplicationSpecForProviderInputsKinesisStreamRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStream#roleArnSelector
   */
  readonly roleArnSelector?: ApplicationSpecForProviderInputsKinesisStreamRoleArnSelector;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsKinesisStream' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsKinesisStream(obj: ApplicationSpecForProviderInputsKinesisStream | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_ApplicationSpecForProviderInputsKinesisStreamResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_ApplicationSpecForProviderInputsKinesisStreamResourceArnSelector(obj.resourceArnSelector),
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ApplicationSpecForProviderInputsKinesisStreamRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ApplicationSpecForProviderInputsKinesisStreamRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsParallelism
 */
export interface ApplicationSpecForProviderInputsParallelism {
  /**
   * The Count of streams.
   *
   * @schema ApplicationSpecForProviderInputsParallelism#count
   */
  readonly count?: number;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsParallelism' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsParallelism(obj: ApplicationSpecForProviderInputsParallelism | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsProcessingConfiguration
 */
export interface ApplicationSpecForProviderInputsProcessingConfiguration {
  /**
   * The Lambda function configuration. See Lambda below for more details.
   *
   * @schema ApplicationSpecForProviderInputsProcessingConfiguration#lambda
   */
  readonly lambda?: ApplicationSpecForProviderInputsProcessingConfigurationLambda[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsProcessingConfiguration(obj: ApplicationSpecForProviderInputsProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambda': obj.lambda?.map(y => toJson_ApplicationSpecForProviderInputsProcessingConfigurationLambda(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsSchema
 */
export interface ApplicationSpecForProviderInputsSchema {
  /**
   * The Record Column mapping for the streaming source data element. See Record Columns below for more details.
   *
   * @schema ApplicationSpecForProviderInputsSchema#recordColumns
   */
  readonly recordColumns?: ApplicationSpecForProviderInputsSchemaRecordColumns[];

  /**
   * The Encoding of the record in the streaming source.
   *
   * @schema ApplicationSpecForProviderInputsSchema#recordEncoding
   */
  readonly recordEncoding?: string;

  /**
   * The Record Format and mapping information to schematize a record. See Record Format below for more details.
   *
   * @schema ApplicationSpecForProviderInputsSchema#recordFormat
   */
  readonly recordFormat?: ApplicationSpecForProviderInputsSchemaRecordFormat[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsSchema(obj: ApplicationSpecForProviderInputsSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumns': obj.recordColumns?.map(y => toJson_ApplicationSpecForProviderInputsSchemaRecordColumns(y)),
    'recordEncoding': obj.recordEncoding,
    'recordFormat': obj.recordFormat?.map(y => toJson_ApplicationSpecForProviderInputsSchemaRecordFormat(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsStartingPositionConfiguration
 */
export interface ApplicationSpecForProviderInputsStartingPositionConfiguration {
  /**
   * The starting position on the stream. Valid values: LAST_STOPPED_POINT, NOW, TRIM_HORIZON.
   *
   * @schema ApplicationSpecForProviderInputsStartingPositionConfiguration#startingPosition
   */
  readonly startingPosition?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsStartingPositionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsStartingPositionConfiguration(obj: ApplicationSpecForProviderInputsStartingPositionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'startingPosition': obj.startingPosition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderOutputsKinesisFirehose
 */
export interface ApplicationSpecForProviderOutputsKinesisFirehose {
  /**
   * The ARN of the Lambda function.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehose#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a DeliveryStream in firehose to populate resourceArn.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehose#resourceArnRef
   */
  readonly resourceArnRef?: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRef;

  /**
   * Selector for a DeliveryStream in firehose to populate resourceArn.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehose#resourceArnSelector
   */
  readonly resourceArnSelector?: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelector;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehose#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehose#roleArnRef
   */
  readonly roleArnRef?: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehose#roleArnSelector
   */
  readonly roleArnSelector?: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelector;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsKinesisFirehose' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsKinesisFirehose(obj: ApplicationSpecForProviderOutputsKinesisFirehose | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelector(obj.resourceArnSelector),
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderOutputsKinesisStream
 */
export interface ApplicationSpecForProviderOutputsKinesisStream {
  /**
   * The ARN of the Lambda function.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisStream#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisStream#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsKinesisStream' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsKinesisStream(obj: ApplicationSpecForProviderOutputsKinesisStream | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderOutputsLambda
 */
export interface ApplicationSpecForProviderOutputsLambda {
  /**
   * The ARN of the Lambda function.
   *
   * @schema ApplicationSpecForProviderOutputsLambda#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecForProviderOutputsLambda#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsLambda' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsLambda(obj: ApplicationSpecForProviderOutputsLambda | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderOutputsSchema
 */
export interface ApplicationSpecForProviderOutputsSchema {
  /**
   * The Format Type of the records on the output stream. Can be CSV or JSON.
   *
   * @schema ApplicationSpecForProviderOutputsSchema#recordFormatType
   */
  readonly recordFormatType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsSchema(obj: ApplicationSpecForProviderOutputsSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordFormatType': obj.recordFormatType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderReferenceDataSourcesS3
 */
export interface ApplicationSpecForProviderReferenceDataSourcesS3 {
  /**
   * The S3 Bucket ARN.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesS3#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * The File Key name containing reference data.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesS3#fileKey
   */
  readonly fileKey?: string;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesS3#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderReferenceDataSourcesS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderReferenceDataSourcesS3(obj: ApplicationSpecForProviderReferenceDataSourcesS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketArn': obj.bucketArn,
    'fileKey': obj.fileKey,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderReferenceDataSourcesSchema
 */
export interface ApplicationSpecForProviderReferenceDataSourcesSchema {
  /**
   * The Record Column mapping for the streaming source data element. See Record Columns below for more details.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchema#recordColumns
   */
  readonly recordColumns?: ApplicationSpecForProviderReferenceDataSourcesSchemaRecordColumns[];

  /**
   * The Encoding of the record in the streaming source.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchema#recordEncoding
   */
  readonly recordEncoding?: string;

  /**
   * The Record Format and mapping information to schematize a record. See Record Format below for more details.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchema#recordFormat
   */
  readonly recordFormat?: ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormat[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderReferenceDataSourcesSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderReferenceDataSourcesSchema(obj: ApplicationSpecForProviderReferenceDataSourcesSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumns': obj.recordColumns?.map(y => toJson_ApplicationSpecForProviderReferenceDataSourcesSchemaRecordColumns(y)),
    'recordEncoding': obj.recordEncoding,
    'recordFormat': obj.recordFormat?.map(y => toJson_ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormat(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsKinesisFirehose
 */
export interface ApplicationSpecInitProviderInputsKinesisFirehose {
  /**
   * The ARN of the Lambda function.
   *
   * @schema ApplicationSpecInitProviderInputsKinesisFirehose#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecInitProviderInputsKinesisFirehose#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsKinesisFirehose' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsKinesisFirehose(obj: ApplicationSpecInitProviderInputsKinesisFirehose | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsParallelism
 */
export interface ApplicationSpecInitProviderInputsParallelism {
  /**
   * The Count of streams.
   *
   * @schema ApplicationSpecInitProviderInputsParallelism#count
   */
  readonly count?: number;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsParallelism' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsParallelism(obj: ApplicationSpecInitProviderInputsParallelism | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsProcessingConfiguration
 */
export interface ApplicationSpecInitProviderInputsProcessingConfiguration {
  /**
   * The Lambda function configuration. See Lambda below for more details.
   *
   * @schema ApplicationSpecInitProviderInputsProcessingConfiguration#lambda
   */
  readonly lambda?: ApplicationSpecInitProviderInputsProcessingConfigurationLambda[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsProcessingConfiguration(obj: ApplicationSpecInitProviderInputsProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambda': obj.lambda?.map(y => toJson_ApplicationSpecInitProviderInputsProcessingConfigurationLambda(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsSchema
 */
export interface ApplicationSpecInitProviderInputsSchema {
  /**
   * The Record Column mapping for the streaming source data element. See Record Columns below for more details.
   *
   * @schema ApplicationSpecInitProviderInputsSchema#recordColumns
   */
  readonly recordColumns?: ApplicationSpecInitProviderInputsSchemaRecordColumns[];

  /**
   * The Encoding of the record in the streaming source.
   *
   * @schema ApplicationSpecInitProviderInputsSchema#recordEncoding
   */
  readonly recordEncoding?: string;

  /**
   * The Record Format and mapping information to schematize a record. See Record Format below for more details.
   *
   * @schema ApplicationSpecInitProviderInputsSchema#recordFormat
   */
  readonly recordFormat?: ApplicationSpecInitProviderInputsSchemaRecordFormat[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsSchema(obj: ApplicationSpecInitProviderInputsSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumns': obj.recordColumns?.map(y => toJson_ApplicationSpecInitProviderInputsSchemaRecordColumns(y)),
    'recordEncoding': obj.recordEncoding,
    'recordFormat': obj.recordFormat?.map(y => toJson_ApplicationSpecInitProviderInputsSchemaRecordFormat(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsStartingPositionConfiguration
 */
export interface ApplicationSpecInitProviderInputsStartingPositionConfiguration {
  /**
   * The starting position on the stream. Valid values: LAST_STOPPED_POINT, NOW, TRIM_HORIZON.
   *
   * @schema ApplicationSpecInitProviderInputsStartingPositionConfiguration#startingPosition
   */
  readonly startingPosition?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsStartingPositionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsStartingPositionConfiguration(obj: ApplicationSpecInitProviderInputsStartingPositionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'startingPosition': obj.startingPosition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderOutputsKinesisStream
 */
export interface ApplicationSpecInitProviderOutputsKinesisStream {
  /**
   * The ARN of the Lambda function.
   *
   * @schema ApplicationSpecInitProviderOutputsKinesisStream#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecInitProviderOutputsKinesisStream#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderOutputsKinesisStream' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderOutputsKinesisStream(obj: ApplicationSpecInitProviderOutputsKinesisStream | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderOutputsLambda
 */
export interface ApplicationSpecInitProviderOutputsLambda {
  /**
   * The ARN of the Lambda function.
   *
   * @schema ApplicationSpecInitProviderOutputsLambda#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecInitProviderOutputsLambda#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderOutputsLambda' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderOutputsLambda(obj: ApplicationSpecInitProviderOutputsLambda | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderOutputsSchema
 */
export interface ApplicationSpecInitProviderOutputsSchema {
  /**
   * The Format Type of the records on the output stream. Can be CSV or JSON.
   *
   * @schema ApplicationSpecInitProviderOutputsSchema#recordFormatType
   */
  readonly recordFormatType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderOutputsSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderOutputsSchema(obj: ApplicationSpecInitProviderOutputsSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordFormatType': obj.recordFormatType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderReferenceDataSourcesS3
 */
export interface ApplicationSpecInitProviderReferenceDataSourcesS3 {
  /**
   * The S3 Bucket ARN.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesS3#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * The File Key name containing reference data.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesS3#fileKey
   */
  readonly fileKey?: string;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesS3#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderReferenceDataSourcesS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderReferenceDataSourcesS3(obj: ApplicationSpecInitProviderReferenceDataSourcesS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketArn': obj.bucketArn,
    'fileKey': obj.fileKey,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderReferenceDataSourcesSchema
 */
export interface ApplicationSpecInitProviderReferenceDataSourcesSchema {
  /**
   * The Record Column mapping for the streaming source data element. See Record Columns below for more details.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchema#recordColumns
   */
  readonly recordColumns?: ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordColumns[];

  /**
   * The Encoding of the record in the streaming source.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchema#recordEncoding
   */
  readonly recordEncoding?: string;

  /**
   * The Record Format and mapping information to schematize a record. See Record Format below for more details.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchema#recordFormat
   */
  readonly recordFormat?: ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormat[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderReferenceDataSourcesSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderReferenceDataSourcesSchema(obj: ApplicationSpecInitProviderReferenceDataSourcesSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumns': obj.recordColumns?.map(y => toJson_ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordColumns(y)),
    'recordEncoding': obj.recordEncoding,
    'recordFormat': obj.recordFormat?.map(y => toJson_ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormat(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicy
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicy(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicy
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicy(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stream in kinesis to populate resourceArn.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnRef
 */
export interface ApplicationSpecForProviderInputsKinesisStreamResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsKinesisStreamResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsKinesisStreamResourceArnRef(obj: ApplicationSpecForProviderInputsKinesisStreamResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stream in kinesis to populate resourceArn.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnSelector
 */
export interface ApplicationSpecForProviderInputsKinesisStreamResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsKinesisStreamResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsKinesisStreamResourceArnSelector(obj: ApplicationSpecForProviderInputsKinesisStreamResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnRef
 */
export interface ApplicationSpecForProviderInputsKinesisStreamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsKinesisStreamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsKinesisStreamRoleArnRef(obj: ApplicationSpecForProviderInputsKinesisStreamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnSelector
 */
export interface ApplicationSpecForProviderInputsKinesisStreamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsKinesisStreamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsKinesisStreamRoleArnSelector(obj: ApplicationSpecForProviderInputsKinesisStreamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsProcessingConfigurationLambda
 */
export interface ApplicationSpecForProviderInputsProcessingConfigurationLambda {
  /**
   * The ARN of the Lambda function.
   *
   * @schema ApplicationSpecForProviderInputsProcessingConfigurationLambda#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecForProviderInputsProcessingConfigurationLambda#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsProcessingConfigurationLambda' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsProcessingConfigurationLambda(obj: ApplicationSpecForProviderInputsProcessingConfigurationLambda | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsSchemaRecordColumns
 */
export interface ApplicationSpecForProviderInputsSchemaRecordColumns {
  /**
   * The Mapping reference to the data element.
   *
   * @schema ApplicationSpecForProviderInputsSchemaRecordColumns#mapping
   */
  readonly mapping?: string;

  /**
   * Name of the column.
   *
   * @schema ApplicationSpecForProviderInputsSchemaRecordColumns#name
   */
  readonly name?: string;

  /**
   * The SQL Type of the column.
   *
   * @schema ApplicationSpecForProviderInputsSchemaRecordColumns#sqlType
   */
  readonly sqlType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsSchemaRecordColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsSchemaRecordColumns(obj: ApplicationSpecForProviderInputsSchemaRecordColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mapping': obj.mapping,
    'name': obj.name,
    'sqlType': obj.sqlType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsSchemaRecordFormat
 */
export interface ApplicationSpecForProviderInputsSchemaRecordFormat {
  /**
   * The Mapping Information for the record format. See Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecForProviderInputsSchemaRecordFormat#mappingParameters
   */
  readonly mappingParameters?: ApplicationSpecForProviderInputsSchemaRecordFormatMappingParameters[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsSchemaRecordFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsSchemaRecordFormat(obj: ApplicationSpecForProviderInputsSchemaRecordFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mappingParameters': obj.mappingParameters?.map(y => toJson_ApplicationSpecForProviderInputsSchemaRecordFormatMappingParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DeliveryStream in firehose to populate resourceArn.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRef
 */
export interface ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRef(obj: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DeliveryStream in firehose to populate resourceArn.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelector
 */
export interface ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelector(obj: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRef
 */
export interface ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRef(obj: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelector
 */
export interface ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelector(obj: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordColumns
 */
export interface ApplicationSpecForProviderReferenceDataSourcesSchemaRecordColumns {
  /**
   * The Mapping reference to the data element.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordColumns#mapping
   */
  readonly mapping?: string;

  /**
   * Name of the column.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordColumns#name
   */
  readonly name?: string;

  /**
   * The SQL Type of the column.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordColumns#sqlType
   */
  readonly sqlType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderReferenceDataSourcesSchemaRecordColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderReferenceDataSourcesSchemaRecordColumns(obj: ApplicationSpecForProviderReferenceDataSourcesSchemaRecordColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mapping': obj.mapping,
    'name': obj.name,
    'sqlType': obj.sqlType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormat
 */
export interface ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormat {
  /**
   * The Mapping Information for the record format. See Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormat#mappingParameters
   */
  readonly mappingParameters?: ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParameters[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormat(obj: ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mappingParameters': obj.mappingParameters?.map(y => toJson_ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsProcessingConfigurationLambda
 */
export interface ApplicationSpecInitProviderInputsProcessingConfigurationLambda {
  /**
   * The ARN of the Lambda function.
   *
   * @schema ApplicationSpecInitProviderInputsProcessingConfigurationLambda#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * The IAM Role ARN to read the data.
   *
   * @schema ApplicationSpecInitProviderInputsProcessingConfigurationLambda#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsProcessingConfigurationLambda' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsProcessingConfigurationLambda(obj: ApplicationSpecInitProviderInputsProcessingConfigurationLambda | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsSchemaRecordColumns
 */
export interface ApplicationSpecInitProviderInputsSchemaRecordColumns {
  /**
   * The Mapping reference to the data element.
   *
   * @schema ApplicationSpecInitProviderInputsSchemaRecordColumns#mapping
   */
  readonly mapping?: string;

  /**
   * Name of the column.
   *
   * @schema ApplicationSpecInitProviderInputsSchemaRecordColumns#name
   */
  readonly name?: string;

  /**
   * The SQL Type of the column.
   *
   * @schema ApplicationSpecInitProviderInputsSchemaRecordColumns#sqlType
   */
  readonly sqlType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsSchemaRecordColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsSchemaRecordColumns(obj: ApplicationSpecInitProviderInputsSchemaRecordColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mapping': obj.mapping,
    'name': obj.name,
    'sqlType': obj.sqlType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsSchemaRecordFormat
 */
export interface ApplicationSpecInitProviderInputsSchemaRecordFormat {
  /**
   * The Mapping Information for the record format. See Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecInitProviderInputsSchemaRecordFormat#mappingParameters
   */
  readonly mappingParameters?: ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParameters[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsSchemaRecordFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsSchemaRecordFormat(obj: ApplicationSpecInitProviderInputsSchemaRecordFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mappingParameters': obj.mappingParameters?.map(y => toJson_ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordColumns
 */
export interface ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordColumns {
  /**
   * The Mapping reference to the data element.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordColumns#mapping
   */
  readonly mapping?: string;

  /**
   * Name of the column.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordColumns#name
   */
  readonly name?: string;

  /**
   * The SQL Type of the column.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordColumns#sqlType
   */
  readonly sqlType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordColumns(obj: ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mapping': obj.mapping,
    'name': obj.name,
    'sqlType': obj.sqlType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormat
 */
export interface ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormat {
  /**
   * The Mapping Information for the record format. See Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormat#mappingParameters
   */
  readonly mappingParameters?: ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParameters[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormat(obj: ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mappingParameters': obj.mappingParameters?.map(y => toJson_ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicy
 */
export interface ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicy(obj: ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicy
 */
export interface ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicy(obj: ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicy
 */
export interface ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicy(obj: ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicy
 */
export interface ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicy(obj: ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsSchemaRecordFormatMappingParameters
 */
export interface ApplicationSpecForProviderInputsSchemaRecordFormatMappingParameters {
  /**
   * Mapping information when the record format uses delimiters. See CSV Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecForProviderInputsSchemaRecordFormatMappingParameters#csv
   */
  readonly csv?: ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersCsv[];

  /**
   * Mapping information when JSON is the record format on the streaming source. See JSON Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecForProviderInputsSchemaRecordFormatMappingParameters#json
   */
  readonly json?: ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersJson[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsSchemaRecordFormatMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsSchemaRecordFormatMappingParameters(obj: ApplicationSpecForProviderInputsSchemaRecordFormatMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csv': obj.csv?.map(y => toJson_ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersCsv(y)),
    'json': obj.json?.map(y => toJson_ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersJson(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicy
 */
export interface ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicy(obj: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicy
 */
export interface ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicy(obj: ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicy
 */
export interface ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicy(obj: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicy
 */
export interface ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicy(obj: ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParameters
 */
export interface ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParameters {
  /**
   * Mapping information when the record format uses delimiters. See CSV Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParameters#csv
   */
  readonly csv?: ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv[];

  /**
   * Mapping information when JSON is the record format on the streaming source. See JSON Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParameters#json
   */
  readonly json?: ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParameters(obj: ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csv': obj.csv?.map(y => toJson_ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv(y)),
    'json': obj.json?.map(y => toJson_ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParameters
 */
export interface ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParameters {
  /**
   * Mapping information when the record format uses delimiters. See CSV Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParameters#csv
   */
  readonly csv?: ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersCsv[];

  /**
   * Mapping information when JSON is the record format on the streaming source. See JSON Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParameters#json
   */
  readonly json?: ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersJson[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParameters(obj: ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csv': obj.csv?.map(y => toJson_ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersCsv(y)),
    'json': obj.json?.map(y => toJson_ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersJson(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParameters
 */
export interface ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParameters {
  /**
   * Mapping information when the record format uses delimiters. See CSV Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParameters#csv
   */
  readonly csv?: ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv[];

  /**
   * Mapping information when JSON is the record format on the streaming source. See JSON Mapping Parameters below for more details.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParameters#json
   */
  readonly json?: ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParameters(obj: ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csv': obj.csv?.map(y => toJson_ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv(y)),
    'json': obj.json?.map(y => toJson_ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderInputsKinesisStreamResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderInputsKinesisStreamResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderInputsKinesisStreamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderInputsKinesisStreamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersCsv
 */
export interface ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersCsv {
  /**
   * The Column Delimiter.
   *
   * @schema ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersCsv#recordColumnDelimiter
   */
  readonly recordColumnDelimiter?: string;

  /**
   * The Row Delimiter.
   *
   * @schema ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersCsv#recordRowDelimiter
   */
  readonly recordRowDelimiter?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersCsv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersCsv(obj: ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersCsv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumnDelimiter': obj.recordColumnDelimiter,
    'recordRowDelimiter': obj.recordRowDelimiter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersJson
 */
export interface ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersJson {
  /**
   * Path to the top-level parent that contains the records.
   *
   * @schema ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersJson#recordRowPath
   */
  readonly recordRowPath?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersJson' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersJson(obj: ApplicationSpecForProviderInputsSchemaRecordFormatMappingParametersJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordRowPath': obj.recordRowPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderOutputsKinesisFirehoseResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderOutputsKinesisFirehoseRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv
 */
export interface ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv {
  /**
   * The Column Delimiter.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv#recordColumnDelimiter
   */
  readonly recordColumnDelimiter?: string;

  /**
   * The Row Delimiter.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv#recordRowDelimiter
   */
  readonly recordRowDelimiter?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv(obj: ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumnDelimiter': obj.recordColumnDelimiter,
    'recordRowDelimiter': obj.recordRowDelimiter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson
 */
export interface ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson {
  /**
   * Path to the top-level parent that contains the records.
   *
   * @schema ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson#recordRowPath
   */
  readonly recordRowPath?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson(obj: ApplicationSpecForProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordRowPath': obj.recordRowPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersCsv
 */
export interface ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersCsv {
  /**
   * The Column Delimiter.
   *
   * @schema ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersCsv#recordColumnDelimiter
   */
  readonly recordColumnDelimiter?: string;

  /**
   * The Row Delimiter.
   *
   * @schema ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersCsv#recordRowDelimiter
   */
  readonly recordRowDelimiter?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersCsv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersCsv(obj: ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersCsv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumnDelimiter': obj.recordColumnDelimiter,
    'recordRowDelimiter': obj.recordRowDelimiter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersJson
 */
export interface ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersJson {
  /**
   * Path to the top-level parent that contains the records.
   *
   * @schema ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersJson#recordRowPath
   */
  readonly recordRowPath?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersJson' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersJson(obj: ApplicationSpecInitProviderInputsSchemaRecordFormatMappingParametersJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordRowPath': obj.recordRowPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv
 */
export interface ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv {
  /**
   * The Column Delimiter.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv#recordColumnDelimiter
   */
  readonly recordColumnDelimiter?: string;

  /**
   * The Row Delimiter.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv#recordRowDelimiter
   */
  readonly recordRowDelimiter?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv(obj: ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersCsv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumnDelimiter': obj.recordColumnDelimiter,
    'recordRowDelimiter': obj.recordRowDelimiter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson
 */
export interface ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson {
  /**
   * Path to the top-level parent that contains the records.
   *
   * @schema ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson#recordRowPath
   */
  readonly recordRowPath?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson(obj: ApplicationSpecInitProviderReferenceDataSourcesSchemaRecordFormatMappingParametersJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordRowPath': obj.recordRowPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

