// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Alias is the Schema for the Aliass API. Provides a display name for a customer master key.
 *
 * @schema Alias
 */
export class Alias extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Alias"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.aws.upbound.io/v1beta1',
    kind: 'Alias',
  }

  /**
   * Renders a Kubernetes manifest for "Alias".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AliasProps): any {
    return {
      ...Alias.GVK,
      ...toJson_AliasProps(props),
    };
  }

  /**
   * Defines a "Alias" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AliasProps) {
    super(scope, id, {
      ...Alias.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Alias.GVK,
      ...toJson_AliasProps(resolved),
    };
  }
}

/**
 * Alias is the Schema for the Aliass API. Provides a display name for a customer master key.
 *
 * @schema Alias
 */
export interface AliasProps {
  /**
   * @schema Alias#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AliasSpec defines the desired state of Alias
   *
   * @schema Alias#spec
   */
  readonly spec: AliasSpec;

}

/**
 * Converts an object of type 'AliasProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasProps(obj: AliasProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AliasSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AliasSpec defines the desired state of Alias
 *
 * @schema AliasSpec
 */
export interface AliasSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AliasSpec#deletionPolicy
   */
  readonly deletionPolicy?: AliasSpecDeletionPolicy;

  /**
   * @schema AliasSpec#forProvider
   */
  readonly forProvider: AliasSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AliasSpec#managementPolicy
   */
  readonly managementPolicy?: AliasSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AliasSpec#providerConfigRef
   */
  readonly providerConfigRef?: AliasSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AliasSpec#providerRef
   */
  readonly providerRef?: AliasSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AliasSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AliasSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AliasSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AliasSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AliasSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpec(obj: AliasSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AliasSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AliasSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AliasSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AliasSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AliasSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AliasSpecDeletionPolicy
 */
export enum AliasSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AliasSpecForProvider
 */
export interface AliasSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AliasSpecForProvider#region
   */
  readonly region: string;

  /**
   * Identifier for the key for which the alias is for, can be either an ARN or key_id.
   *
   * @schema AliasSpecForProvider#targetKeyId
   */
  readonly targetKeyId?: string;

  /**
   * Reference to a Key to populate targetKeyId.
   *
   * @schema AliasSpecForProvider#targetKeyIdRef
   */
  readonly targetKeyIdRef?: AliasSpecForProviderTargetKeyIdRef;

  /**
   * Selector for a Key to populate targetKeyId.
   *
   * @schema AliasSpecForProvider#targetKeyIdSelector
   */
  readonly targetKeyIdSelector?: AliasSpecForProviderTargetKeyIdSelector;

}

/**
 * Converts an object of type 'AliasSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProvider(obj: AliasSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'targetKeyId': obj.targetKeyId,
    'targetKeyIdRef': toJson_AliasSpecForProviderTargetKeyIdRef(obj.targetKeyIdRef),
    'targetKeyIdSelector': toJson_AliasSpecForProviderTargetKeyIdSelector(obj.targetKeyIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AliasSpecManagementPolicy
 */
export enum AliasSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AliasSpecProviderConfigRef
 */
export interface AliasSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecProviderConfigRef#policy
   */
  readonly policy?: AliasSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderConfigRef(obj: AliasSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AliasSpecProviderRef
 */
export interface AliasSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecProviderRef#policy
   */
  readonly policy?: AliasSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderRef(obj: AliasSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AliasSpecPublishConnectionDetailsTo
 */
export interface AliasSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AliasSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AliasSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AliasSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsTo(obj: AliasSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AliasSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AliasSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AliasSpecWriteConnectionSecretToRef
 */
export interface AliasSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AliasSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AliasSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AliasSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecWriteConnectionSecretToRef(obj: AliasSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key to populate targetKeyId.
 *
 * @schema AliasSpecForProviderTargetKeyIdRef
 */
export interface AliasSpecForProviderTargetKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecForProviderTargetKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecForProviderTargetKeyIdRef#policy
   */
  readonly policy?: AliasSpecForProviderTargetKeyIdRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecForProviderTargetKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderTargetKeyIdRef(obj: AliasSpecForProviderTargetKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecForProviderTargetKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key to populate targetKeyId.
 *
 * @schema AliasSpecForProviderTargetKeyIdSelector
 */
export interface AliasSpecForProviderTargetKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AliasSpecForProviderTargetKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AliasSpecForProviderTargetKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AliasSpecForProviderTargetKeyIdSelector#policy
   */
  readonly policy?: AliasSpecForProviderTargetKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'AliasSpecForProviderTargetKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderTargetKeyIdSelector(obj: AliasSpecForProviderTargetKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AliasSpecForProviderTargetKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AliasSpecProviderConfigRefPolicy
 */
export interface AliasSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AliasSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AliasSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderConfigRefPolicy(obj: AliasSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AliasSpecProviderRefPolicy
 */
export interface AliasSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AliasSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AliasSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecProviderRefPolicy(obj: AliasSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRef
 */
export interface AliasSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AliasSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToConfigRef(obj: AliasSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AliasSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AliasSpecPublishConnectionDetailsToMetadata
 */
export interface AliasSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AliasSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToMetadata(obj: AliasSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AliasSpecForProviderTargetKeyIdRefPolicy
 */
export interface AliasSpecForProviderTargetKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecForProviderTargetKeyIdRefPolicy#resolution
   */
  readonly resolution?: AliasSpecForProviderTargetKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecForProviderTargetKeyIdRefPolicy#resolve
   */
  readonly resolve?: AliasSpecForProviderTargetKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecForProviderTargetKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderTargetKeyIdRefPolicy(obj: AliasSpecForProviderTargetKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AliasSpecForProviderTargetKeyIdSelectorPolicy
 */
export interface AliasSpecForProviderTargetKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecForProviderTargetKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: AliasSpecForProviderTargetKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecForProviderTargetKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: AliasSpecForProviderTargetKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecForProviderTargetKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecForProviderTargetKeyIdSelectorPolicy(obj: AliasSpecForProviderTargetKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecProviderConfigRefPolicyResolution
 */
export enum AliasSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecProviderConfigRefPolicyResolve
 */
export enum AliasSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecProviderRefPolicyResolution
 */
export enum AliasSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecProviderRefPolicyResolve
 */
export enum AliasSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AliasSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AliasSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecPublishConnectionDetailsToConfigRefPolicy(obj: AliasSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecForProviderTargetKeyIdRefPolicyResolution
 */
export enum AliasSpecForProviderTargetKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecForProviderTargetKeyIdRefPolicyResolve
 */
export enum AliasSpecForProviderTargetKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecForProviderTargetKeyIdSelectorPolicyResolution
 */
export enum AliasSpecForProviderTargetKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecForProviderTargetKeyIdSelectorPolicyResolve
 */
export enum AliasSpecForProviderTargetKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AliasSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AliasSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Ciphertext is the Schema for the Ciphertexts API. Provides ciphertext encrypted using a KMS key
 *
 * @schema Ciphertext
 */
export class Ciphertext extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Ciphertext"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.aws.upbound.io/v1beta1',
    kind: 'Ciphertext',
  }

  /**
   * Renders a Kubernetes manifest for "Ciphertext".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiphertextProps): any {
    return {
      ...Ciphertext.GVK,
      ...toJson_CiphertextProps(props),
    };
  }

  /**
   * Defines a "Ciphertext" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiphertextProps) {
    super(scope, id, {
      ...Ciphertext.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Ciphertext.GVK,
      ...toJson_CiphertextProps(resolved),
    };
  }
}

/**
 * Ciphertext is the Schema for the Ciphertexts API. Provides ciphertext encrypted using a KMS key
 *
 * @schema Ciphertext
 */
export interface CiphertextProps {
  /**
   * @schema Ciphertext#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CiphertextSpec defines the desired state of Ciphertext
   *
   * @schema Ciphertext#spec
   */
  readonly spec: CiphertextSpec;

}

/**
 * Converts an object of type 'CiphertextProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextProps(obj: CiphertextProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiphertextSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CiphertextSpec defines the desired state of Ciphertext
 *
 * @schema CiphertextSpec
 */
export interface CiphertextSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CiphertextSpec#deletionPolicy
   */
  readonly deletionPolicy?: CiphertextSpecDeletionPolicy;

  /**
   * @schema CiphertextSpec#forProvider
   */
  readonly forProvider: CiphertextSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CiphertextSpec#managementPolicy
   */
  readonly managementPolicy?: CiphertextSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CiphertextSpec#providerConfigRef
   */
  readonly providerConfigRef?: CiphertextSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CiphertextSpec#providerRef
   */
  readonly providerRef?: CiphertextSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CiphertextSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CiphertextSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CiphertextSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CiphertextSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CiphertextSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpec(obj: CiphertextSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CiphertextSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CiphertextSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CiphertextSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CiphertextSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CiphertextSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CiphertextSpecDeletionPolicy
 */
export enum CiphertextSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CiphertextSpecForProvider
 */
export interface CiphertextSpecForProvider {
  /**
   * An optional mapping that makes up the encryption context.
   *
   * @schema CiphertextSpecForProvider#context
   */
  readonly context?: { [key: string]: string };

  /**
   * Globally unique key ID for the customer master key.
   *
   * @schema CiphertextSpecForProvider#keyId
   */
  readonly keyId?: string;

  /**
   * Reference to a Key to populate keyId.
   *
   * @schema CiphertextSpecForProvider#keyIdRef
   */
  readonly keyIdRef?: CiphertextSpecForProviderKeyIdRef;

  /**
   * Selector for a Key to populate keyId.
   *
   * @schema CiphertextSpecForProvider#keyIdSelector
   */
  readonly keyIdSelector?: CiphertextSpecForProviderKeyIdSelector;

  /**
   * Data to be encrypted. Note that this may show up in logs, and it will be stored in the state file.
   *
   * @schema CiphertextSpecForProvider#plaintextSecretRef
   */
  readonly plaintextSecretRef?: CiphertextSpecForProviderPlaintextSecretRef;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CiphertextSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'CiphertextSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecForProvider(obj: CiphertextSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': ((obj.context) === undefined) ? undefined : (Object.entries(obj.context).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'keyId': obj.keyId,
    'keyIdRef': toJson_CiphertextSpecForProviderKeyIdRef(obj.keyIdRef),
    'keyIdSelector': toJson_CiphertextSpecForProviderKeyIdSelector(obj.keyIdSelector),
    'plaintextSecretRef': toJson_CiphertextSpecForProviderPlaintextSecretRef(obj.plaintextSecretRef),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CiphertextSpecManagementPolicy
 */
export enum CiphertextSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CiphertextSpecProviderConfigRef
 */
export interface CiphertextSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CiphertextSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CiphertextSpecProviderConfigRef#policy
   */
  readonly policy?: CiphertextSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CiphertextSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecProviderConfigRef(obj: CiphertextSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CiphertextSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CiphertextSpecProviderRef
 */
export interface CiphertextSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CiphertextSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CiphertextSpecProviderRef#policy
   */
  readonly policy?: CiphertextSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CiphertextSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecProviderRef(obj: CiphertextSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CiphertextSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CiphertextSpecPublishConnectionDetailsTo
 */
export interface CiphertextSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CiphertextSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CiphertextSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CiphertextSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CiphertextSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CiphertextSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiphertextSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecPublishConnectionDetailsTo(obj: CiphertextSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CiphertextSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CiphertextSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CiphertextSpecWriteConnectionSecretToRef
 */
export interface CiphertextSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CiphertextSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CiphertextSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CiphertextSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecWriteConnectionSecretToRef(obj: CiphertextSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key to populate keyId.
 *
 * @schema CiphertextSpecForProviderKeyIdRef
 */
export interface CiphertextSpecForProviderKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema CiphertextSpecForProviderKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CiphertextSpecForProviderKeyIdRef#policy
   */
  readonly policy?: CiphertextSpecForProviderKeyIdRefPolicy;

}

/**
 * Converts an object of type 'CiphertextSpecForProviderKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecForProviderKeyIdRef(obj: CiphertextSpecForProviderKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CiphertextSpecForProviderKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key to populate keyId.
 *
 * @schema CiphertextSpecForProviderKeyIdSelector
 */
export interface CiphertextSpecForProviderKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CiphertextSpecForProviderKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CiphertextSpecForProviderKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CiphertextSpecForProviderKeyIdSelector#policy
   */
  readonly policy?: CiphertextSpecForProviderKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'CiphertextSpecForProviderKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecForProviderKeyIdSelector(obj: CiphertextSpecForProviderKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CiphertextSpecForProviderKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Data to be encrypted. Note that this may show up in logs, and it will be stored in the state file.
 *
 * @schema CiphertextSpecForProviderPlaintextSecretRef
 */
export interface CiphertextSpecForProviderPlaintextSecretRef {
  /**
   * The key to select.
   *
   * @schema CiphertextSpecForProviderPlaintextSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema CiphertextSpecForProviderPlaintextSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CiphertextSpecForProviderPlaintextSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CiphertextSpecForProviderPlaintextSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecForProviderPlaintextSecretRef(obj: CiphertextSpecForProviderPlaintextSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CiphertextSpecProviderConfigRefPolicy
 */
export interface CiphertextSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CiphertextSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CiphertextSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CiphertextSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CiphertextSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CiphertextSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecProviderConfigRefPolicy(obj: CiphertextSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CiphertextSpecProviderRefPolicy
 */
export interface CiphertextSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CiphertextSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CiphertextSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CiphertextSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CiphertextSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CiphertextSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecProviderRefPolicy(obj: CiphertextSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CiphertextSpecPublishConnectionDetailsToConfigRef
 */
export interface CiphertextSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CiphertextSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CiphertextSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CiphertextSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CiphertextSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecPublishConnectionDetailsToConfigRef(obj: CiphertextSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CiphertextSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CiphertextSpecPublishConnectionDetailsToMetadata
 */
export interface CiphertextSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CiphertextSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CiphertextSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CiphertextSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CiphertextSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecPublishConnectionDetailsToMetadata(obj: CiphertextSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CiphertextSpecForProviderKeyIdRefPolicy
 */
export interface CiphertextSpecForProviderKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CiphertextSpecForProviderKeyIdRefPolicy#resolution
   */
  readonly resolution?: CiphertextSpecForProviderKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CiphertextSpecForProviderKeyIdRefPolicy#resolve
   */
  readonly resolve?: CiphertextSpecForProviderKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'CiphertextSpecForProviderKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecForProviderKeyIdRefPolicy(obj: CiphertextSpecForProviderKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CiphertextSpecForProviderKeyIdSelectorPolicy
 */
export interface CiphertextSpecForProviderKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CiphertextSpecForProviderKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: CiphertextSpecForProviderKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CiphertextSpecForProviderKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: CiphertextSpecForProviderKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CiphertextSpecForProviderKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecForProviderKeyIdSelectorPolicy(obj: CiphertextSpecForProviderKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CiphertextSpecProviderConfigRefPolicyResolution
 */
export enum CiphertextSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CiphertextSpecProviderConfigRefPolicyResolve
 */
export enum CiphertextSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CiphertextSpecProviderRefPolicyResolution
 */
export enum CiphertextSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CiphertextSpecProviderRefPolicyResolve
 */
export enum CiphertextSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CiphertextSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CiphertextSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CiphertextSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CiphertextSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CiphertextSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiphertextSpecPublishConnectionDetailsToConfigRefPolicy(obj: CiphertextSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CiphertextSpecForProviderKeyIdRefPolicyResolution
 */
export enum CiphertextSpecForProviderKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CiphertextSpecForProviderKeyIdRefPolicyResolve
 */
export enum CiphertextSpecForProviderKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CiphertextSpecForProviderKeyIdSelectorPolicyResolution
 */
export enum CiphertextSpecForProviderKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CiphertextSpecForProviderKeyIdSelectorPolicyResolve
 */
export enum CiphertextSpecForProviderKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CiphertextSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ExternalKey is the Schema for the ExternalKeys API. Manages a single-Region or multi-Region primary KMS key that uses external key material.
 *
 * @schema ExternalKey
 */
export class ExternalKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExternalKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.aws.upbound.io/v1beta1',
    kind: 'ExternalKey',
  }

  /**
   * Renders a Kubernetes manifest for "ExternalKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExternalKeyProps): any {
    return {
      ...ExternalKey.GVK,
      ...toJson_ExternalKeyProps(props),
    };
  }

  /**
   * Defines a "ExternalKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExternalKeyProps) {
    super(scope, id, {
      ...ExternalKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExternalKey.GVK,
      ...toJson_ExternalKeyProps(resolved),
    };
  }
}

/**
 * ExternalKey is the Schema for the ExternalKeys API. Manages a single-Region or multi-Region primary KMS key that uses external key material.
 *
 * @schema ExternalKey
 */
export interface ExternalKeyProps {
  /**
   * @schema ExternalKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExternalKeySpec defines the desired state of ExternalKey
   *
   * @schema ExternalKey#spec
   */
  readonly spec: ExternalKeySpec;

}

/**
 * Converts an object of type 'ExternalKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeyProps(obj: ExternalKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExternalKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalKeySpec defines the desired state of ExternalKey
 *
 * @schema ExternalKeySpec
 */
export interface ExternalKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ExternalKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: ExternalKeySpecDeletionPolicy;

  /**
   * @schema ExternalKeySpec#forProvider
   */
  readonly forProvider: ExternalKeySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ExternalKeySpec#managementPolicy
   */
  readonly managementPolicy?: ExternalKeySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ExternalKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: ExternalKeySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ExternalKeySpec#providerRef
   */
  readonly providerRef?: ExternalKeySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ExternalKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ExternalKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ExternalKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ExternalKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ExternalKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpec(obj: ExternalKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ExternalKeySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ExternalKeySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ExternalKeySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ExternalKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ExternalKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ExternalKeySpecDeletionPolicy
 */
export enum ExternalKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ExternalKeySpecForProvider
 */
export interface ExternalKeySpecForProvider {
  /**
   * Specifies whether to disable the policy lockout check performed when creating or updating the key's policy. Setting this value to true increases the risk that the key becomes unmanageable. For more information, refer to the scenario in the Default Key Policy section in the AWS Key Management Service Developer Guide. Defaults to false.
   *
   * @default false.
   * @schema ExternalKeySpecForProvider#bypassPolicyLockoutSafetyCheck
   */
  readonly bypassPolicyLockoutSafetyCheck?: boolean;

  /**
   * Duration in days after which the key is deleted after destruction of the resource. Must be between 7 and 30 days. Defaults to 30.
   *
   * @default 30.
   * @schema ExternalKeySpecForProvider#deletionWindowInDays
   */
  readonly deletionWindowInDays?: number;

  /**
   * Description of the key.
   *
   * @schema ExternalKeySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies whether the key is enabled. Keys pending import can only be false. Imported keys default to true unless expired.
   *
   * @schema ExternalKeySpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Base64 encoded 256-bit symmetric encryption key material to import. The CMK is permanently associated with this key material. The same key material can be reimported, but you cannot import different key material.
   *
   * @schema ExternalKeySpecForProvider#keyMaterialBase64SecretRef
   */
  readonly keyMaterialBase64SecretRef?: ExternalKeySpecForProviderKeyMaterialBase64SecretRef;

  /**
   * Indicates whether the KMS key is a multi-Region (true) or regional (false) key. Defaults to false.
   *
   * @default false.
   * @schema ExternalKeySpecForProvider#multiRegion
   */
  readonly multiRegion?: boolean;

  /**
   * A key policy JSON document. If you do not provide a key policy, AWS KMS attaches a default key policy to the CMK.
   *
   * @schema ExternalKeySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ExternalKeySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ExternalKeySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Time at which the imported key material expires. When the key material expires, AWS KMS deletes the key material and the CMK becomes unusable. If not specified, key material does not expire. Valid values: RFC3339 time string (YYYY-MM-DDTHH:MM:SSZ)
   *
   * @schema ExternalKeySpecForProvider#validTo
   */
  readonly validTo?: string;

}

/**
 * Converts an object of type 'ExternalKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecForProvider(obj: ExternalKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassPolicyLockoutSafetyCheck': obj.bypassPolicyLockoutSafetyCheck,
    'deletionWindowInDays': obj.deletionWindowInDays,
    'description': obj.description,
    'enabled': obj.enabled,
    'keyMaterialBase64SecretRef': toJson_ExternalKeySpecForProviderKeyMaterialBase64SecretRef(obj.keyMaterialBase64SecretRef),
    'multiRegion': obj.multiRegion,
    'policy': obj.policy,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'validTo': obj.validTo,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ExternalKeySpecManagementPolicy
 */
export enum ExternalKeySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ExternalKeySpecProviderConfigRef
 */
export interface ExternalKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExternalKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExternalKeySpecProviderConfigRef#policy
   */
  readonly policy?: ExternalKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ExternalKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecProviderConfigRef(obj: ExternalKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExternalKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ExternalKeySpecProviderRef
 */
export interface ExternalKeySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExternalKeySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExternalKeySpecProviderRef#policy
   */
  readonly policy?: ExternalKeySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ExternalKeySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecProviderRef(obj: ExternalKeySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExternalKeySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ExternalKeySpecPublishConnectionDetailsTo
 */
export interface ExternalKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ExternalKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ExternalKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ExternalKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ExternalKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ExternalKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecPublishConnectionDetailsTo(obj: ExternalKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ExternalKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ExternalKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ExternalKeySpecWriteConnectionSecretToRef
 */
export interface ExternalKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ExternalKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ExternalKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ExternalKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecWriteConnectionSecretToRef(obj: ExternalKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Base64 encoded 256-bit symmetric encryption key material to import. The CMK is permanently associated with this key material. The same key material can be reimported, but you cannot import different key material.
 *
 * @schema ExternalKeySpecForProviderKeyMaterialBase64SecretRef
 */
export interface ExternalKeySpecForProviderKeyMaterialBase64SecretRef {
  /**
   * The key to select.
   *
   * @schema ExternalKeySpecForProviderKeyMaterialBase64SecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ExternalKeySpecForProviderKeyMaterialBase64SecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ExternalKeySpecForProviderKeyMaterialBase64SecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ExternalKeySpecForProviderKeyMaterialBase64SecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecForProviderKeyMaterialBase64SecretRef(obj: ExternalKeySpecForProviderKeyMaterialBase64SecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExternalKeySpecProviderConfigRefPolicy
 */
export interface ExternalKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExternalKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ExternalKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExternalKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ExternalKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ExternalKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecProviderConfigRefPolicy(obj: ExternalKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExternalKeySpecProviderRefPolicy
 */
export interface ExternalKeySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExternalKeySpecProviderRefPolicy#resolution
   */
  readonly resolution?: ExternalKeySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExternalKeySpecProviderRefPolicy#resolve
   */
  readonly resolve?: ExternalKeySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ExternalKeySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecProviderRefPolicy(obj: ExternalKeySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ExternalKeySpecPublishConnectionDetailsToConfigRef
 */
export interface ExternalKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExternalKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExternalKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ExternalKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ExternalKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecPublishConnectionDetailsToConfigRef(obj: ExternalKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExternalKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ExternalKeySpecPublishConnectionDetailsToMetadata
 */
export interface ExternalKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ExternalKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ExternalKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ExternalKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExternalKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecPublishConnectionDetailsToMetadata(obj: ExternalKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExternalKeySpecProviderConfigRefPolicyResolution
 */
export enum ExternalKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExternalKeySpecProviderConfigRefPolicyResolve
 */
export enum ExternalKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExternalKeySpecProviderRefPolicyResolution
 */
export enum ExternalKeySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExternalKeySpecProviderRefPolicyResolve
 */
export enum ExternalKeySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ExternalKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ExternalKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExternalKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExternalKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ExternalKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: ExternalKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Grant is the Schema for the Grants API. Provides a resource-based access control mechanism for KMS Customer Master Keys.
 *
 * @schema Grant
 */
export class Grant extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Grant"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.aws.upbound.io/v1beta1',
    kind: 'Grant',
  }

  /**
   * Renders a Kubernetes manifest for "Grant".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GrantProps): any {
    return {
      ...Grant.GVK,
      ...toJson_GrantProps(props),
    };
  }

  /**
   * Defines a "Grant" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GrantProps) {
    super(scope, id, {
      ...Grant.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Grant.GVK,
      ...toJson_GrantProps(resolved),
    };
  }
}

/**
 * Grant is the Schema for the Grants API. Provides a resource-based access control mechanism for KMS Customer Master Keys.
 *
 * @schema Grant
 */
export interface GrantProps {
  /**
   * @schema Grant#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GrantSpec defines the desired state of Grant
   *
   * @schema Grant#spec
   */
  readonly spec: GrantSpec;

}

/**
 * Converts an object of type 'GrantProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantProps(obj: GrantProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GrantSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GrantSpec defines the desired state of Grant
 *
 * @schema GrantSpec
 */
export interface GrantSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GrantSpec#deletionPolicy
   */
  readonly deletionPolicy?: GrantSpecDeletionPolicy;

  /**
   * @schema GrantSpec#forProvider
   */
  readonly forProvider: GrantSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GrantSpec#managementPolicy
   */
  readonly managementPolicy?: GrantSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GrantSpec#providerConfigRef
   */
  readonly providerConfigRef?: GrantSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GrantSpec#providerRef
   */
  readonly providerRef?: GrantSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GrantSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GrantSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GrantSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GrantSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GrantSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpec(obj: GrantSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GrantSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_GrantSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GrantSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GrantSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GrantSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GrantSpecDeletionPolicy
 */
export enum GrantSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GrantSpecForProvider
 */
export interface GrantSpecForProvider {
  /**
   * A structure that you can use to allow certain operations in the grant only when the desired encryption context is present. For more information about encryption context, see Encryption Context.
   *
   * @schema GrantSpecForProvider#constraints
   */
  readonly constraints?: GrantSpecForProviderConstraints[];

  /**
   * A list of grant tokens to be used when creating the grant. See Grant Tokens for more information about grant tokens.
   *
   * @schema GrantSpecForProvider#grantCreationTokens
   */
  readonly grantCreationTokens?: string[];

  /**
   * The principal that is given permission to perform the operations that the grant permits in ARN format.
   *
   * @schema GrantSpecForProvider#granteePrincipal
   */
  readonly granteePrincipal?: string;

  /**
   * Reference to a Role in iam to populate granteePrincipal.
   *
   * @schema GrantSpecForProvider#granteePrincipalRef
   */
  readonly granteePrincipalRef?: GrantSpecForProviderGranteePrincipalRef;

  /**
   * Selector for a Role in iam to populate granteePrincipal.
   *
   * @schema GrantSpecForProvider#granteePrincipalSelector
   */
  readonly granteePrincipalSelector?: GrantSpecForProviderGranteePrincipalSelector;

  /**
   * The unique identifier for the customer master key (CMK) that the grant applies to. Specify the key ID or the Amazon Resource Name (ARN) of the CMK. To specify a CMK in a different AWS account, you must use the key ARN.
   *
   * @schema GrantSpecForProvider#keyId
   */
  readonly keyId?: string;

  /**
   * Reference to a Key to populate keyId.
   *
   * @schema GrantSpecForProvider#keyIdRef
   */
  readonly keyIdRef?: GrantSpecForProviderKeyIdRef;

  /**
   * Selector for a Key to populate keyId.
   *
   * @schema GrantSpecForProvider#keyIdSelector
   */
  readonly keyIdSelector?: GrantSpecForProviderKeyIdSelector;

  /**
   * A friendly name for identifying the grant.
   *
   * @schema GrantSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A list of operations that the grant permits. The permitted values are: Decrypt, Encrypt, GenerateDataKey, GenerateDataKeyWithoutPlaintext, ReEncryptFrom, ReEncryptTo, Sign, Verify, GetPublicKey, CreateGrant, RetireGrant, DescribeKey, GenerateDataKeyPair, or GenerateDataKeyPairWithoutPlaintext.
   *
   * @schema GrantSpecForProvider#operations
   */
  readonly operations?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GrantSpecForProvider#region
   */
  readonly region: string;

  /**
   * (Defaults to false, Forces new resources) If set to false (the default) the grants will be revoked upon deletion, and if set to true the grants will try to be retired upon deletion. Note that retiring grants requires special permissions, hence why we default to revoking grants. See RetireGrant for more information.
   *
   * @default false, Forces new resources) If set to false (the default) the grants will be revoked upon deletion, and if set to true the grants will try to be retired upon deletion. Note that retiring grants requires special permissions, hence why we default to revoking grants. See RetireGrant for more information.
   * @schema GrantSpecForProvider#retireOnDelete
   */
  readonly retireOnDelete?: boolean;

  /**
   * The principal that is given permission to retire the grant by using RetireGrant operation in ARN format.
   *
   * @schema GrantSpecForProvider#retiringPrincipal
   */
  readonly retiringPrincipal?: string;

}

/**
 * Converts an object of type 'GrantSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProvider(obj: GrantSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'constraints': obj.constraints?.map(y => toJson_GrantSpecForProviderConstraints(y)),
    'grantCreationTokens': obj.grantCreationTokens?.map(y => y),
    'granteePrincipal': obj.granteePrincipal,
    'granteePrincipalRef': toJson_GrantSpecForProviderGranteePrincipalRef(obj.granteePrincipalRef),
    'granteePrincipalSelector': toJson_GrantSpecForProviderGranteePrincipalSelector(obj.granteePrincipalSelector),
    'keyId': obj.keyId,
    'keyIdRef': toJson_GrantSpecForProviderKeyIdRef(obj.keyIdRef),
    'keyIdSelector': toJson_GrantSpecForProviderKeyIdSelector(obj.keyIdSelector),
    'name': obj.name,
    'operations': obj.operations?.map(y => y),
    'region': obj.region,
    'retireOnDelete': obj.retireOnDelete,
    'retiringPrincipal': obj.retiringPrincipal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GrantSpecManagementPolicy
 */
export enum GrantSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GrantSpecProviderConfigRef
 */
export interface GrantSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GrantSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GrantSpecProviderConfigRef#policy
   */
  readonly policy?: GrantSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GrantSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecProviderConfigRef(obj: GrantSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GrantSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GrantSpecProviderRef
 */
export interface GrantSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GrantSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GrantSpecProviderRef#policy
   */
  readonly policy?: GrantSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GrantSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecProviderRef(obj: GrantSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GrantSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GrantSpecPublishConnectionDetailsTo
 */
export interface GrantSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GrantSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GrantSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GrantSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GrantSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GrantSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GrantSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecPublishConnectionDetailsTo(obj: GrantSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GrantSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GrantSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GrantSpecWriteConnectionSecretToRef
 */
export interface GrantSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GrantSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GrantSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GrantSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecWriteConnectionSecretToRef(obj: GrantSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GrantSpecForProviderConstraints
 */
export interface GrantSpecForProviderConstraints {
  /**
   * A list of key-value pairs that must match the encryption context in subsequent cryptographic operation requests. The grant allows the operation only when the encryption context in the request is the same as the encryption context specified in this constraint. Conflicts with encryption_context_subset.
   *
   * @schema GrantSpecForProviderConstraints#encryptionContextEquals
   */
  readonly encryptionContextEquals?: { [key: string]: string };

  /**
   * A list of key-value pairs that must be included in the encryption context of subsequent cryptographic operation requests. The grant allows the cryptographic operation only when the encryption context in the request includes the key-value pairs specified in this constraint, although it can include additional key-value pairs. Conflicts with encryption_context_equals.
   *
   * @schema GrantSpecForProviderConstraints#encryptionContextSubset
   */
  readonly encryptionContextSubset?: { [key: string]: string };

}

/**
 * Converts an object of type 'GrantSpecForProviderConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderConstraints(obj: GrantSpecForProviderConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionContextEquals': ((obj.encryptionContextEquals) === undefined) ? undefined : (Object.entries(obj.encryptionContextEquals).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'encryptionContextSubset': ((obj.encryptionContextSubset) === undefined) ? undefined : (Object.entries(obj.encryptionContextSubset).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate granteePrincipal.
 *
 * @schema GrantSpecForProviderGranteePrincipalRef
 */
export interface GrantSpecForProviderGranteePrincipalRef {
  /**
   * Name of the referenced object.
   *
   * @schema GrantSpecForProviderGranteePrincipalRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GrantSpecForProviderGranteePrincipalRef#policy
   */
  readonly policy?: GrantSpecForProviderGranteePrincipalRefPolicy;

}

/**
 * Converts an object of type 'GrantSpecForProviderGranteePrincipalRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderGranteePrincipalRef(obj: GrantSpecForProviderGranteePrincipalRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GrantSpecForProviderGranteePrincipalRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate granteePrincipal.
 *
 * @schema GrantSpecForProviderGranteePrincipalSelector
 */
export interface GrantSpecForProviderGranteePrincipalSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GrantSpecForProviderGranteePrincipalSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GrantSpecForProviderGranteePrincipalSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GrantSpecForProviderGranteePrincipalSelector#policy
   */
  readonly policy?: GrantSpecForProviderGranteePrincipalSelectorPolicy;

}

/**
 * Converts an object of type 'GrantSpecForProviderGranteePrincipalSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderGranteePrincipalSelector(obj: GrantSpecForProviderGranteePrincipalSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GrantSpecForProviderGranteePrincipalSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key to populate keyId.
 *
 * @schema GrantSpecForProviderKeyIdRef
 */
export interface GrantSpecForProviderKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GrantSpecForProviderKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GrantSpecForProviderKeyIdRef#policy
   */
  readonly policy?: GrantSpecForProviderKeyIdRefPolicy;

}

/**
 * Converts an object of type 'GrantSpecForProviderKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderKeyIdRef(obj: GrantSpecForProviderKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GrantSpecForProviderKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key to populate keyId.
 *
 * @schema GrantSpecForProviderKeyIdSelector
 */
export interface GrantSpecForProviderKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GrantSpecForProviderKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GrantSpecForProviderKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GrantSpecForProviderKeyIdSelector#policy
   */
  readonly policy?: GrantSpecForProviderKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'GrantSpecForProviderKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderKeyIdSelector(obj: GrantSpecForProviderKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GrantSpecForProviderKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GrantSpecProviderConfigRefPolicy
 */
export interface GrantSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GrantSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GrantSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecProviderConfigRefPolicy(obj: GrantSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GrantSpecProviderRefPolicy
 */
export interface GrantSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GrantSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GrantSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecProviderRefPolicy(obj: GrantSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GrantSpecPublishConnectionDetailsToConfigRef
 */
export interface GrantSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GrantSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GrantSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GrantSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GrantSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecPublishConnectionDetailsToConfigRef(obj: GrantSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GrantSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GrantSpecPublishConnectionDetailsToMetadata
 */
export interface GrantSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GrantSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GrantSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GrantSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GrantSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecPublishConnectionDetailsToMetadata(obj: GrantSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GrantSpecForProviderGranteePrincipalRefPolicy
 */
export interface GrantSpecForProviderGranteePrincipalRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecForProviderGranteePrincipalRefPolicy#resolution
   */
  readonly resolution?: GrantSpecForProviderGranteePrincipalRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecForProviderGranteePrincipalRefPolicy#resolve
   */
  readonly resolve?: GrantSpecForProviderGranteePrincipalRefPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecForProviderGranteePrincipalRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderGranteePrincipalRefPolicy(obj: GrantSpecForProviderGranteePrincipalRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GrantSpecForProviderGranteePrincipalSelectorPolicy
 */
export interface GrantSpecForProviderGranteePrincipalSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecForProviderGranteePrincipalSelectorPolicy#resolution
   */
  readonly resolution?: GrantSpecForProviderGranteePrincipalSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecForProviderGranteePrincipalSelectorPolicy#resolve
   */
  readonly resolve?: GrantSpecForProviderGranteePrincipalSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecForProviderGranteePrincipalSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderGranteePrincipalSelectorPolicy(obj: GrantSpecForProviderGranteePrincipalSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GrantSpecForProviderKeyIdRefPolicy
 */
export interface GrantSpecForProviderKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecForProviderKeyIdRefPolicy#resolution
   */
  readonly resolution?: GrantSpecForProviderKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecForProviderKeyIdRefPolicy#resolve
   */
  readonly resolve?: GrantSpecForProviderKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecForProviderKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderKeyIdRefPolicy(obj: GrantSpecForProviderKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GrantSpecForProviderKeyIdSelectorPolicy
 */
export interface GrantSpecForProviderKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecForProviderKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: GrantSpecForProviderKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecForProviderKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: GrantSpecForProviderKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecForProviderKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecForProviderKeyIdSelectorPolicy(obj: GrantSpecForProviderKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecProviderConfigRefPolicyResolution
 */
export enum GrantSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecProviderConfigRefPolicyResolve
 */
export enum GrantSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecProviderRefPolicyResolution
 */
export enum GrantSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecProviderRefPolicyResolve
 */
export enum GrantSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GrantSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GrantSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GrantSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GrantSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GrantSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GrantSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GrantSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GrantSpecPublishConnectionDetailsToConfigRefPolicy(obj: GrantSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecForProviderGranteePrincipalRefPolicyResolution
 */
export enum GrantSpecForProviderGranteePrincipalRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecForProviderGranteePrincipalRefPolicyResolve
 */
export enum GrantSpecForProviderGranteePrincipalRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecForProviderGranteePrincipalSelectorPolicyResolution
 */
export enum GrantSpecForProviderGranteePrincipalSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecForProviderGranteePrincipalSelectorPolicyResolve
 */
export enum GrantSpecForProviderGranteePrincipalSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecForProviderKeyIdRefPolicyResolution
 */
export enum GrantSpecForProviderKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecForProviderKeyIdRefPolicyResolve
 */
export enum GrantSpecForProviderKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecForProviderKeyIdSelectorPolicyResolution
 */
export enum GrantSpecForProviderKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecForProviderKeyIdSelectorPolicyResolve
 */
export enum GrantSpecForProviderKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GrantSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GrantSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GrantSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GrantSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Key is the Schema for the Keys API. Manages a single-Region or multi-Region primary KMS key.
 *
 * @schema Key
 */
export class Key extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Key"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.aws.upbound.io/v1beta1',
    kind: 'Key',
  }

  /**
   * Renders a Kubernetes manifest for "Key".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KeyProps): any {
    return {
      ...Key.GVK,
      ...toJson_KeyProps(props),
    };
  }

  /**
   * Defines a "Key" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KeyProps) {
    super(scope, id, {
      ...Key.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Key.GVK,
      ...toJson_KeyProps(resolved),
    };
  }
}

/**
 * Key is the Schema for the Keys API. Manages a single-Region or multi-Region primary KMS key.
 *
 * @schema Key
 */
export interface KeyProps {
  /**
   * @schema Key#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * KeySpec defines the desired state of Key
   *
   * @schema Key#spec
   */
  readonly spec: KeySpec;

}

/**
 * Converts an object of type 'KeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeyProps(obj: KeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeySpec defines the desired state of Key
 *
 * @schema KeySpec
 */
export interface KeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KeySpec#deletionPolicy
   */
  readonly deletionPolicy?: KeySpecDeletionPolicy;

  /**
   * @schema KeySpec#forProvider
   */
  readonly forProvider: KeySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema KeySpec#managementPolicy
   */
  readonly managementPolicy?: KeySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema KeySpec#providerConfigRef
   */
  readonly providerConfigRef?: KeySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema KeySpec#providerRef
   */
  readonly providerRef?: KeySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema KeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: KeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema KeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: KeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'KeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpec(obj: KeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_KeySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_KeySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_KeySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_KeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_KeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KeySpecDeletionPolicy
 */
export enum KeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema KeySpecForProvider
 */
export interface KeySpecForProvider {
  /**
   * A flag to indicate whether to bypass the key policy lockout safety check. Setting this value to true increases the risk that the KMS key becomes unmanageable. Do not set this value to true indiscriminately. For more information, refer to the scenario in the Default Key Policy section in the AWS Key Management Service Developer Guide. The default value is false.
   *
   * @schema KeySpecForProvider#bypassPolicyLockoutSafetyCheck
   */
  readonly bypassPolicyLockoutSafetyCheck?: boolean;

  /**
   * ID of the KMS Custom Key Store where the key will be stored instead of KMS (eg CloudHSM).
   *
   * @schema KeySpecForProvider#customKeyStoreId
   */
  readonly customKeyStoreId?: string;

  /**
   * Specifies whether the key contains a symmetric key or an asymmetric key pair and the encryption algorithms or signing algorithms that the key supports. Valid values: SYMMETRIC_DEFAULT,  RSA_2048, RSA_3072, RSA_4096, HMAC_256, ECC_NIST_P256, ECC_NIST_P384, ECC_NIST_P521, or ECC_SECG_P256K1. Defaults to SYMMETRIC_DEFAULT. For help with choosing a key spec, see the AWS KMS Developer Guide.
   *
   * @default SYMMETRIC_DEFAULT. For help with choosing a key spec, see the AWS KMS Developer Guide.
   * @schema KeySpecForProvider#customerMasterKeySpec
   */
  readonly customerMasterKeySpec?: string;

  /**
   * The waiting period, specified in number of days. After the waiting period ends, AWS KMS deletes the KMS key. If you specify a value, it must be between 7 and 30, inclusive. If you do not specify a value, it defaults to 30. If the KMS key is a multi-Region primary key with replicas, the waiting period begins when the last of its replica keys is deleted. Otherwise, the waiting period begins immediately.
   *
   * @schema KeySpecForProvider#deletionWindowInDays
   */
  readonly deletionWindowInDays?: number;

  /**
   * The description of the key as viewed in AWS console.
   *
   * @schema KeySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies whether key rotation is enabled. Defaults to false.
   *
   * @default false.
   * @schema KeySpecForProvider#enableKeyRotation
   */
  readonly enableKeyRotation?: boolean;

  /**
   * Specifies whether the key is enabled. Defaults to true.
   *
   * @default true.
   * @schema KeySpecForProvider#isEnabled
   */
  readonly isEnabled?: boolean;

  /**
   * Specifies the intended use of the key. Valid values: ENCRYPT_DECRYPT, SIGN_VERIFY, or GENERATE_VERIFY_MAC. Defaults to ENCRYPT_DECRYPT.
   *
   * @default ENCRYPT_DECRYPT.
   * @schema KeySpecForProvider#keyUsage
   */
  readonly keyUsage?: string;

  /**
   * Indicates whether the KMS key is a multi-Region (true) or regional (false) key. Defaults to false.
   *
   * @default false.
   * @schema KeySpecForProvider#multiRegion
   */
  readonly multiRegion?: boolean;

  /**
   * A valid policy JSON document. Although this is a key policy, not an IAM policy, an aws_iam_policy_document, in the form that designates a principal, can be used.
   *
   * @schema KeySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema KeySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema KeySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'KeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecForProvider(obj: KeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassPolicyLockoutSafetyCheck': obj.bypassPolicyLockoutSafetyCheck,
    'customKeyStoreId': obj.customKeyStoreId,
    'customerMasterKeySpec': obj.customerMasterKeySpec,
    'deletionWindowInDays': obj.deletionWindowInDays,
    'description': obj.description,
    'enableKeyRotation': obj.enableKeyRotation,
    'isEnabled': obj.isEnabled,
    'keyUsage': obj.keyUsage,
    'multiRegion': obj.multiRegion,
    'policy': obj.policy,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema KeySpecManagementPolicy
 */
export enum KeySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema KeySpecProviderConfigRef
 */
export interface KeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeySpecProviderConfigRef#policy
   */
  readonly policy?: KeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'KeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecProviderConfigRef(obj: KeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema KeySpecProviderRef
 */
export interface KeySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeySpecProviderRef#policy
   */
  readonly policy?: KeySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'KeySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecProviderRef(obj: KeySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema KeySpecPublishConnectionDetailsTo
 */
export interface KeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema KeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: KeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema KeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: KeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema KeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'KeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecPublishConnectionDetailsTo(obj: KeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_KeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_KeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema KeySpecWriteConnectionSecretToRef
 */
export interface KeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema KeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema KeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'KeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecWriteConnectionSecretToRef(obj: KeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeySpecProviderConfigRefPolicy
 */
export interface KeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: KeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: KeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecProviderConfigRefPolicy(obj: KeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema KeySpecProviderRefPolicy
 */
export interface KeySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeySpecProviderRefPolicy#resolution
   */
  readonly resolution?: KeySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeySpecProviderRefPolicy#resolve
   */
  readonly resolve?: KeySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'KeySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecProviderRefPolicy(obj: KeySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema KeySpecPublishConnectionDetailsToConfigRef
 */
export interface KeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema KeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema KeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: KeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'KeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecPublishConnectionDetailsToConfigRef(obj: KeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_KeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema KeySpecPublishConnectionDetailsToMetadata
 */
export interface KeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema KeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema KeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecPublishConnectionDetailsToMetadata(obj: KeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeySpecProviderConfigRefPolicyResolution
 */
export enum KeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeySpecProviderConfigRefPolicyResolve
 */
export enum KeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeySpecProviderRefPolicyResolution
 */
export enum KeySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeySpecProviderRefPolicyResolve
 */
export enum KeySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema KeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface KeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema KeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: KeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema KeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: KeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'KeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KeySpecPublishConnectionDetailsToConfigRefPolicy(obj: KeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema KeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum KeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema KeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum KeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReplicaExternalKey is the Schema for the ReplicaExternalKeys API. Manages a KMS multi-Region replica key that uses external key material.
 *
 * @schema ReplicaExternalKey
 */
export class ReplicaExternalKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicaExternalKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.aws.upbound.io/v1beta1',
    kind: 'ReplicaExternalKey',
  }

  /**
   * Renders a Kubernetes manifest for "ReplicaExternalKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicaExternalKeyProps): any {
    return {
      ...ReplicaExternalKey.GVK,
      ...toJson_ReplicaExternalKeyProps(props),
    };
  }

  /**
   * Defines a "ReplicaExternalKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReplicaExternalKeyProps) {
    super(scope, id, {
      ...ReplicaExternalKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicaExternalKey.GVK,
      ...toJson_ReplicaExternalKeyProps(resolved),
    };
  }
}

/**
 * ReplicaExternalKey is the Schema for the ReplicaExternalKeys API. Manages a KMS multi-Region replica key that uses external key material.
 *
 * @schema ReplicaExternalKey
 */
export interface ReplicaExternalKeyProps {
  /**
   * @schema ReplicaExternalKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReplicaExternalKeySpec defines the desired state of ReplicaExternalKey
   *
   * @schema ReplicaExternalKey#spec
   */
  readonly spec: ReplicaExternalKeySpec;

}

/**
 * Converts an object of type 'ReplicaExternalKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeyProps(obj: ReplicaExternalKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReplicaExternalKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicaExternalKeySpec defines the desired state of ReplicaExternalKey
 *
 * @schema ReplicaExternalKeySpec
 */
export interface ReplicaExternalKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicaExternalKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: ReplicaExternalKeySpecDeletionPolicy;

  /**
   * @schema ReplicaExternalKeySpec#forProvider
   */
  readonly forProvider: ReplicaExternalKeySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicaExternalKeySpec#managementPolicy
   */
  readonly managementPolicy?: ReplicaExternalKeySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReplicaExternalKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: ReplicaExternalKeySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReplicaExternalKeySpec#providerRef
   */
  readonly providerRef?: ReplicaExternalKeySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReplicaExternalKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReplicaExternalKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReplicaExternalKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReplicaExternalKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpec(obj: ReplicaExternalKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReplicaExternalKeySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ReplicaExternalKeySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReplicaExternalKeySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReplicaExternalKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReplicaExternalKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicaExternalKeySpecDeletionPolicy
 */
export enum ReplicaExternalKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReplicaExternalKeySpecForProvider
 */
export interface ReplicaExternalKeySpecForProvider {
  /**
   * A flag to indicate whether to bypass the key policy lockout safety check. Setting this value to true increases the risk that the KMS key becomes unmanageable. Do not set this value to true indiscriminately. For more information, refer to the scenario in the Default Key Policy section in the AWS Key Management Service Developer Guide. The default value is false.
   *
   * @schema ReplicaExternalKeySpecForProvider#bypassPolicyLockoutSafetyCheck
   */
  readonly bypassPolicyLockoutSafetyCheck?: boolean;

  /**
   * The waiting period, specified in number of days. After the waiting period ends, AWS KMS deletes the KMS key. If you specify a value, it must be between 7 and 30, inclusive. If you do not specify a value, it defaults to 30.
   *
   * @schema ReplicaExternalKeySpecForProvider#deletionWindowInDays
   */
  readonly deletionWindowInDays?: number;

  /**
   * A description of the KMS key.
   *
   * @schema ReplicaExternalKeySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies whether the replica key is enabled. Disabled KMS keys cannot be used in cryptographic operations. Keys pending import can only be false. Imported keys default to true unless expired.
   *
   * @schema ReplicaExternalKeySpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Base64 encoded 256-bit symmetric encryption key material to import. The KMS key is permanently associated with this key material. The same key material can be reimported, but you cannot import different key material.
   *
   * @schema ReplicaExternalKeySpecForProvider#keyMaterialBase64SecretRef
   */
  readonly keyMaterialBase64SecretRef?: ReplicaExternalKeySpecForProviderKeyMaterialBase64SecretRef;

  /**
   * The key policy to attach to the KMS key. If you do not specify a key policy, AWS KMS attaches the default key policy to the KMS key.
   *
   * @schema ReplicaExternalKeySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * The ARN of the multi-Region primary key to replicate. The primary key must be in a different AWS Region of the same AWS Partition. You can create only one replica of a given primary key in each AWS Region.
   *
   * @schema ReplicaExternalKeySpecForProvider#primaryKeyArn
   */
  readonly primaryKeyArn?: string;

  /**
   * Reference to a ExternalKey to populate primaryKeyArn.
   *
   * @schema ReplicaExternalKeySpecForProvider#primaryKeyArnRef
   */
  readonly primaryKeyArnRef?: ReplicaExternalKeySpecForProviderPrimaryKeyArnRef;

  /**
   * Selector for a ExternalKey to populate primaryKeyArn.
   *
   * @schema ReplicaExternalKeySpecForProvider#primaryKeyArnSelector
   */
  readonly primaryKeyArnSelector?: ReplicaExternalKeySpecForProviderPrimaryKeyArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ReplicaExternalKeySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ReplicaExternalKeySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Time at which the imported key material expires. When the key material expires, AWS KMS deletes the key material and the key becomes unusable. If not specified, key material does not expire. Valid values: RFC3339 time string (YYYY-MM-DDTHH:MM:SSZ)
   *
   * @schema ReplicaExternalKeySpecForProvider#validTo
   */
  readonly validTo?: string;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecForProvider(obj: ReplicaExternalKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassPolicyLockoutSafetyCheck': obj.bypassPolicyLockoutSafetyCheck,
    'deletionWindowInDays': obj.deletionWindowInDays,
    'description': obj.description,
    'enabled': obj.enabled,
    'keyMaterialBase64SecretRef': toJson_ReplicaExternalKeySpecForProviderKeyMaterialBase64SecretRef(obj.keyMaterialBase64SecretRef),
    'policy': obj.policy,
    'primaryKeyArn': obj.primaryKeyArn,
    'primaryKeyArnRef': toJson_ReplicaExternalKeySpecForProviderPrimaryKeyArnRef(obj.primaryKeyArnRef),
    'primaryKeyArnSelector': toJson_ReplicaExternalKeySpecForProviderPrimaryKeyArnSelector(obj.primaryKeyArnSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'validTo': obj.validTo,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicaExternalKeySpecManagementPolicy
 */
export enum ReplicaExternalKeySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReplicaExternalKeySpecProviderConfigRef
 */
export interface ReplicaExternalKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicaExternalKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicaExternalKeySpecProviderConfigRef#policy
   */
  readonly policy?: ReplicaExternalKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecProviderConfigRef(obj: ReplicaExternalKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicaExternalKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReplicaExternalKeySpecProviderRef
 */
export interface ReplicaExternalKeySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicaExternalKeySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicaExternalKeySpecProviderRef#policy
   */
  readonly policy?: ReplicaExternalKeySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecProviderRef(obj: ReplicaExternalKeySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicaExternalKeySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReplicaExternalKeySpecPublishConnectionDetailsTo
 */
export interface ReplicaExternalKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReplicaExternalKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReplicaExternalKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReplicaExternalKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReplicaExternalKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReplicaExternalKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecPublishConnectionDetailsTo(obj: ReplicaExternalKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReplicaExternalKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReplicaExternalKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReplicaExternalKeySpecWriteConnectionSecretToRef
 */
export interface ReplicaExternalKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReplicaExternalKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReplicaExternalKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecWriteConnectionSecretToRef(obj: ReplicaExternalKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Base64 encoded 256-bit symmetric encryption key material to import. The KMS key is permanently associated with this key material. The same key material can be reimported, but you cannot import different key material.
 *
 * @schema ReplicaExternalKeySpecForProviderKeyMaterialBase64SecretRef
 */
export interface ReplicaExternalKeySpecForProviderKeyMaterialBase64SecretRef {
  /**
   * The key to select.
   *
   * @schema ReplicaExternalKeySpecForProviderKeyMaterialBase64SecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ReplicaExternalKeySpecForProviderKeyMaterialBase64SecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReplicaExternalKeySpecForProviderKeyMaterialBase64SecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecForProviderKeyMaterialBase64SecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecForProviderKeyMaterialBase64SecretRef(obj: ReplicaExternalKeySpecForProviderKeyMaterialBase64SecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ExternalKey to populate primaryKeyArn.
 *
 * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnRef
 */
export interface ReplicaExternalKeySpecForProviderPrimaryKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnRef#policy
   */
  readonly policy?: ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicy;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecForProviderPrimaryKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecForProviderPrimaryKeyArnRef(obj: ReplicaExternalKeySpecForProviderPrimaryKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ExternalKey to populate primaryKeyArn.
 *
 * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnSelector
 */
export interface ReplicaExternalKeySpecForProviderPrimaryKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnSelector#policy
   */
  readonly policy?: ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecForProviderPrimaryKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecForProviderPrimaryKeyArnSelector(obj: ReplicaExternalKeySpecForProviderPrimaryKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicaExternalKeySpecProviderConfigRefPolicy
 */
export interface ReplicaExternalKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicaExternalKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicaExternalKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicaExternalKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicaExternalKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecProviderConfigRefPolicy(obj: ReplicaExternalKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicaExternalKeySpecProviderRefPolicy
 */
export interface ReplicaExternalKeySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicaExternalKeySpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReplicaExternalKeySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicaExternalKeySpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReplicaExternalKeySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecProviderRefPolicy(obj: ReplicaExternalKeySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReplicaExternalKeySpecPublishConnectionDetailsToConfigRef
 */
export interface ReplicaExternalKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicaExternalKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicaExternalKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecPublishConnectionDetailsToConfigRef(obj: ReplicaExternalKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReplicaExternalKeySpecPublishConnectionDetailsToMetadata
 */
export interface ReplicaExternalKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicaExternalKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicaExternalKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReplicaExternalKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecPublishConnectionDetailsToMetadata(obj: ReplicaExternalKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicy
 */
export interface ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicy#resolution
   */
  readonly resolution?: ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicy#resolve
   */
  readonly resolve?: ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicy(obj: ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicy
 */
export interface ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicy(obj: ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicaExternalKeySpecProviderConfigRefPolicyResolution
 */
export enum ReplicaExternalKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicaExternalKeySpecProviderConfigRefPolicyResolve
 */
export enum ReplicaExternalKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicaExternalKeySpecProviderRefPolicyResolution
 */
export enum ReplicaExternalKeySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicaExternalKeySpecProviderRefPolicyResolve
 */
export enum ReplicaExternalKeySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicyResolution
 */
export enum ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicyResolve
 */
export enum ReplicaExternalKeySpecForProviderPrimaryKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicyResolution
 */
export enum ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicyResolve
 */
export enum ReplicaExternalKeySpecForProviderPrimaryKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReplicaExternalKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReplicaKey is the Schema for the ReplicaKeys API. Manages a KMS multi-Region replica key.
 *
 * @schema ReplicaKey
 */
export class ReplicaKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicaKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kms.aws.upbound.io/v1beta1',
    kind: 'ReplicaKey',
  }

  /**
   * Renders a Kubernetes manifest for "ReplicaKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicaKeyProps): any {
    return {
      ...ReplicaKey.GVK,
      ...toJson_ReplicaKeyProps(props),
    };
  }

  /**
   * Defines a "ReplicaKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReplicaKeyProps) {
    super(scope, id, {
      ...ReplicaKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicaKey.GVK,
      ...toJson_ReplicaKeyProps(resolved),
    };
  }
}

/**
 * ReplicaKey is the Schema for the ReplicaKeys API. Manages a KMS multi-Region replica key.
 *
 * @schema ReplicaKey
 */
export interface ReplicaKeyProps {
  /**
   * @schema ReplicaKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReplicaKeySpec defines the desired state of ReplicaKey
   *
   * @schema ReplicaKey#spec
   */
  readonly spec: ReplicaKeySpec;

}

/**
 * Converts an object of type 'ReplicaKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeyProps(obj: ReplicaKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReplicaKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicaKeySpec defines the desired state of ReplicaKey
 *
 * @schema ReplicaKeySpec
 */
export interface ReplicaKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicaKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: ReplicaKeySpecDeletionPolicy;

  /**
   * @schema ReplicaKeySpec#forProvider
   */
  readonly forProvider: ReplicaKeySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicaKeySpec#managementPolicy
   */
  readonly managementPolicy?: ReplicaKeySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReplicaKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: ReplicaKeySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReplicaKeySpec#providerRef
   */
  readonly providerRef?: ReplicaKeySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReplicaKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReplicaKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReplicaKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReplicaKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReplicaKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpec(obj: ReplicaKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReplicaKeySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ReplicaKeySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReplicaKeySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReplicaKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReplicaKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicaKeySpecDeletionPolicy
 */
export enum ReplicaKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReplicaKeySpecForProvider
 */
export interface ReplicaKeySpecForProvider {
  /**
   * A flag to indicate whether to bypass the key policy lockout safety check. Setting this value to true increases the risk that the KMS key becomes unmanageable. Do not set this value to true indiscriminately. For more information, refer to the scenario in the Default Key Policy section in the AWS Key Management Service Developer Guide. The default value is false.
   *
   * @schema ReplicaKeySpecForProvider#bypassPolicyLockoutSafetyCheck
   */
  readonly bypassPolicyLockoutSafetyCheck?: boolean;

  /**
   * The waiting period, specified in number of days. After the waiting period ends, AWS KMS deletes the KMS key. If you specify a value, it must be between 7 and 30, inclusive. If you do not specify a value, it defaults to 30.
   *
   * @schema ReplicaKeySpecForProvider#deletionWindowInDays
   */
  readonly deletionWindowInDays?: number;

  /**
   * A description of the KMS key.
   *
   * @schema ReplicaKeySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies whether the replica key is enabled. Disabled KMS keys cannot be used in cryptographic operations. The default value is true.
   *
   * @schema ReplicaKeySpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * The key policy to attach to the KMS key. If you do not specify a key policy, AWS KMS attaches the default key policy to the KMS key.
   *
   * @schema ReplicaKeySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * The ARN of the multi-Region primary key to replicate. The primary key must be in a different AWS Region of the same AWS Partition. You can create only one replica of a given primary key in each AWS Region.
   *
   * @schema ReplicaKeySpecForProvider#primaryKeyArn
   */
  readonly primaryKeyArn?: string;

  /**
   * Reference to a Key to populate primaryKeyArn.
   *
   * @schema ReplicaKeySpecForProvider#primaryKeyArnRef
   */
  readonly primaryKeyArnRef?: ReplicaKeySpecForProviderPrimaryKeyArnRef;

  /**
   * Selector for a Key to populate primaryKeyArn.
   *
   * @schema ReplicaKeySpecForProvider#primaryKeyArnSelector
   */
  readonly primaryKeyArnSelector?: ReplicaKeySpecForProviderPrimaryKeyArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ReplicaKeySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ReplicaKeySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ReplicaKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecForProvider(obj: ReplicaKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassPolicyLockoutSafetyCheck': obj.bypassPolicyLockoutSafetyCheck,
    'deletionWindowInDays': obj.deletionWindowInDays,
    'description': obj.description,
    'enabled': obj.enabled,
    'policy': obj.policy,
    'primaryKeyArn': obj.primaryKeyArn,
    'primaryKeyArnRef': toJson_ReplicaKeySpecForProviderPrimaryKeyArnRef(obj.primaryKeyArnRef),
    'primaryKeyArnSelector': toJson_ReplicaKeySpecForProviderPrimaryKeyArnSelector(obj.primaryKeyArnSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicaKeySpecManagementPolicy
 */
export enum ReplicaKeySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReplicaKeySpecProviderConfigRef
 */
export interface ReplicaKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicaKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicaKeySpecProviderConfigRef#policy
   */
  readonly policy?: ReplicaKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicaKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecProviderConfigRef(obj: ReplicaKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicaKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReplicaKeySpecProviderRef
 */
export interface ReplicaKeySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicaKeySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicaKeySpecProviderRef#policy
   */
  readonly policy?: ReplicaKeySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReplicaKeySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecProviderRef(obj: ReplicaKeySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicaKeySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReplicaKeySpecPublishConnectionDetailsTo
 */
export interface ReplicaKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReplicaKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReplicaKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReplicaKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReplicaKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReplicaKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReplicaKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecPublishConnectionDetailsTo(obj: ReplicaKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReplicaKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReplicaKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReplicaKeySpecWriteConnectionSecretToRef
 */
export interface ReplicaKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReplicaKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReplicaKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReplicaKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecWriteConnectionSecretToRef(obj: ReplicaKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key to populate primaryKeyArn.
 *
 * @schema ReplicaKeySpecForProviderPrimaryKeyArnRef
 */
export interface ReplicaKeySpecForProviderPrimaryKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicaKeySpecForProviderPrimaryKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicaKeySpecForProviderPrimaryKeyArnRef#policy
   */
  readonly policy?: ReplicaKeySpecForProviderPrimaryKeyArnRefPolicy;

}

/**
 * Converts an object of type 'ReplicaKeySpecForProviderPrimaryKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecForProviderPrimaryKeyArnRef(obj: ReplicaKeySpecForProviderPrimaryKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicaKeySpecForProviderPrimaryKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key to populate primaryKeyArn.
 *
 * @schema ReplicaKeySpecForProviderPrimaryKeyArnSelector
 */
export interface ReplicaKeySpecForProviderPrimaryKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReplicaKeySpecForProviderPrimaryKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReplicaKeySpecForProviderPrimaryKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReplicaKeySpecForProviderPrimaryKeyArnSelector#policy
   */
  readonly policy?: ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'ReplicaKeySpecForProviderPrimaryKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecForProviderPrimaryKeyArnSelector(obj: ReplicaKeySpecForProviderPrimaryKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicaKeySpecProviderConfigRefPolicy
 */
export interface ReplicaKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicaKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicaKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicaKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicaKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicaKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecProviderConfigRefPolicy(obj: ReplicaKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicaKeySpecProviderRefPolicy
 */
export interface ReplicaKeySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicaKeySpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReplicaKeySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicaKeySpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReplicaKeySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicaKeySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecProviderRefPolicy(obj: ReplicaKeySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReplicaKeySpecPublishConnectionDetailsToConfigRef
 */
export interface ReplicaKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicaKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicaKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicaKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecPublishConnectionDetailsToConfigRef(obj: ReplicaKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReplicaKeySpecPublishConnectionDetailsToMetadata
 */
export interface ReplicaKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicaKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicaKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReplicaKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReplicaKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecPublishConnectionDetailsToMetadata(obj: ReplicaKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicaKeySpecForProviderPrimaryKeyArnRefPolicy
 */
export interface ReplicaKeySpecForProviderPrimaryKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicaKeySpecForProviderPrimaryKeyArnRefPolicy#resolution
   */
  readonly resolution?: ReplicaKeySpecForProviderPrimaryKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicaKeySpecForProviderPrimaryKeyArnRefPolicy#resolve
   */
  readonly resolve?: ReplicaKeySpecForProviderPrimaryKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicaKeySpecForProviderPrimaryKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecForProviderPrimaryKeyArnRefPolicy(obj: ReplicaKeySpecForProviderPrimaryKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicy
 */
export interface ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicy(obj: ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicaKeySpecProviderConfigRefPolicyResolution
 */
export enum ReplicaKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicaKeySpecProviderConfigRefPolicyResolve
 */
export enum ReplicaKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicaKeySpecProviderRefPolicyResolution
 */
export enum ReplicaKeySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicaKeySpecProviderRefPolicyResolve
 */
export enum ReplicaKeySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicaKeySpecForProviderPrimaryKeyArnRefPolicyResolution
 */
export enum ReplicaKeySpecForProviderPrimaryKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicaKeySpecForProviderPrimaryKeyArnRefPolicyResolve
 */
export enum ReplicaKeySpecForProviderPrimaryKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicyResolution
 */
export enum ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicyResolve
 */
export enum ReplicaKeySpecForProviderPrimaryKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReplicaKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

