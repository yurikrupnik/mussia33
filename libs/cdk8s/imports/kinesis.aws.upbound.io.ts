// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Stream is the Schema for the Streams API. Provides a AWS Kinesis Stream
 *
 * @schema Stream
 */
export class Stream extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stream"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kinesis.aws.upbound.io/v1beta1',
    kind: 'Stream',
  }

  /**
   * Renders a Kubernetes manifest for "Stream".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StreamProps): any {
    return {
      ...Stream.GVK,
      ...toJson_StreamProps(props),
    };
  }

  /**
   * Defines a "Stream" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StreamProps) {
    super(scope, id, {
      ...Stream.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stream.GVK,
      ...toJson_StreamProps(resolved),
    };
  }
}

/**
 * Stream is the Schema for the Streams API. Provides a AWS Kinesis Stream
 *
 * @schema Stream
 */
export interface StreamProps {
  /**
   * @schema Stream#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StreamSpec defines the desired state of Stream
   *
   * @schema Stream#spec
   */
  readonly spec: StreamSpec;

}

/**
 * Converts an object of type 'StreamProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamProps(obj: StreamProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StreamSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StreamSpec defines the desired state of Stream
 *
 * @schema StreamSpec
 */
export interface StreamSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StreamSpec#deletionPolicy
   */
  readonly deletionPolicy?: StreamSpecDeletionPolicy;

  /**
   * @schema StreamSpec#forProvider
   */
  readonly forProvider: StreamSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema StreamSpec#initProvider
   */
  readonly initProvider?: StreamSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StreamSpec#managementPolicies
   */
  readonly managementPolicies?: StreamSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StreamSpec#providerConfigRef
   */
  readonly providerConfigRef?: StreamSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StreamSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StreamSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StreamSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StreamSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StreamSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpec(obj: StreamSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StreamSpecForProvider(obj.forProvider),
    'initProvider': toJson_StreamSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StreamSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StreamSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StreamSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StreamSpecDeletionPolicy
 */
export enum StreamSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StreamSpecForProvider
 */
export interface StreamSpecForProvider {
  /**
   * The encryption type to use. The only acceptable values are NONE or KMS. The default value is NONE.
   *
   * @schema StreamSpecForProvider#encryptionType
   */
  readonly encryptionType?: string;

  /**
   * A boolean that indicates all registered consumers should be deregistered from the stream so that the stream can be destroyed without error. The default value is false.
   *
   * @schema StreamSpecForProvider#enforceConsumerDeletion
   */
  readonly enforceConsumerDeletion?: boolean;

  /**
   * The GUID for the customer-managed KMS key to use for encryption. You can also use a Kinesis-owned master key by specifying the alias alias/aws/kinesis.
   *
   * @schema StreamSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema StreamSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: StreamSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema StreamSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: StreamSpecForProviderKmsKeyIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StreamSpecForProvider#region
   */
  readonly region: string;

  /**
   * Length of time data records are accessible after they are added to the stream. The maximum value of a stream's retention period is 8760 hours. Minimum value is 24. Default is 24.
   *
   * @default 24.
   * @schema StreamSpecForProvider#retentionPeriod
   */
  readonly retentionPeriod?: number;

  /**
   * â€“  The number of shards that the stream will use. If the stream_mode is PROVISIONED, this field is required. Amazon has guidelines for specifying the Stream size that should be referenced when creating a Kinesis stream. See Amazon Kinesis Streams for more.
   *
   * @schema StreamSpecForProvider#shardCount
   */
  readonly shardCount?: number;

  /**
   * A list of shard-level CloudWatch metrics which can be enabled for the stream. See Monitoring with CloudWatch for more. Note that the value ALL should not be used; instead you should provide an explicit list of metrics you wish to enable.
   *
   * @schema StreamSpecForProvider#shardLevelMetrics
   */
  readonly shardLevelMetrics?: string[];

  /**
   * Indicates the capacity mode of the data stream. Detailed below.
   *
   * @schema StreamSpecForProvider#streamModeDetails
   */
  readonly streamModeDetails?: StreamSpecForProviderStreamModeDetails[];

  /**
   * Key-value map of resource tags.
   *
   * @schema StreamSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'StreamSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProvider(obj: StreamSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionType': obj.encryptionType,
    'enforceConsumerDeletion': obj.enforceConsumerDeletion,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_StreamSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_StreamSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'region': obj.region,
    'retentionPeriod': obj.retentionPeriod,
    'shardCount': obj.shardCount,
    'shardLevelMetrics': obj.shardLevelMetrics?.map(y => y),
    'streamModeDetails': obj.streamModeDetails?.map(y => toJson_StreamSpecForProviderStreamModeDetails(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema StreamSpecInitProvider
 */
export interface StreamSpecInitProvider {
  /**
   * The encryption type to use. The only acceptable values are NONE or KMS. The default value is NONE.
   *
   * @schema StreamSpecInitProvider#encryptionType
   */
  readonly encryptionType?: string;

  /**
   * A boolean that indicates all registered consumers should be deregistered from the stream so that the stream can be destroyed without error. The default value is false.
   *
   * @schema StreamSpecInitProvider#enforceConsumerDeletion
   */
  readonly enforceConsumerDeletion?: boolean;

  /**
   * Length of time data records are accessible after they are added to the stream. The maximum value of a stream's retention period is 8760 hours. Minimum value is 24. Default is 24.
   *
   * @default 24.
   * @schema StreamSpecInitProvider#retentionPeriod
   */
  readonly retentionPeriod?: number;

  /**
   * â€“  The number of shards that the stream will use. If the stream_mode is PROVISIONED, this field is required. Amazon has guidelines for specifying the Stream size that should be referenced when creating a Kinesis stream. See Amazon Kinesis Streams for more.
   *
   * @schema StreamSpecInitProvider#shardCount
   */
  readonly shardCount?: number;

  /**
   * A list of shard-level CloudWatch metrics which can be enabled for the stream. See Monitoring with CloudWatch for more. Note that the value ALL should not be used; instead you should provide an explicit list of metrics you wish to enable.
   *
   * @schema StreamSpecInitProvider#shardLevelMetrics
   */
  readonly shardLevelMetrics?: string[];

  /**
   * Indicates the capacity mode of the data stream. Detailed below.
   *
   * @schema StreamSpecInitProvider#streamModeDetails
   */
  readonly streamModeDetails?: StreamSpecInitProviderStreamModeDetails[];

  /**
   * Key-value map of resource tags.
   *
   * @schema StreamSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'StreamSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecInitProvider(obj: StreamSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionType': obj.encryptionType,
    'enforceConsumerDeletion': obj.enforceConsumerDeletion,
    'retentionPeriod': obj.retentionPeriod,
    'shardCount': obj.shardCount,
    'shardLevelMetrics': obj.shardLevelMetrics?.map(y => y),
    'streamModeDetails': obj.streamModeDetails?.map(y => toJson_StreamSpecInitProviderStreamModeDetails(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema StreamSpecManagementPolicies
 */
export enum StreamSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StreamSpecProviderConfigRef
 */
export interface StreamSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecProviderConfigRef#policy
   */
  readonly policy?: StreamSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderConfigRef(obj: StreamSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StreamSpecPublishConnectionDetailsTo
 */
export interface StreamSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StreamSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StreamSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsTo(obj: StreamSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StreamSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StreamSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StreamSpecWriteConnectionSecretToRef
 */
export interface StreamSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StreamSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StreamSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StreamSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecWriteConnectionSecretToRef(obj: StreamSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema StreamSpecForProviderKmsKeyIdRef
 */
export interface StreamSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: StreamSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyIdRef(obj: StreamSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema StreamSpecForProviderKmsKeyIdSelector
 */
export interface StreamSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StreamSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StreamSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StreamSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: StreamSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyIdSelector(obj: StreamSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StreamSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StreamSpecForProviderStreamModeDetails
 */
export interface StreamSpecForProviderStreamModeDetails {
  /**
   * Specifies the capacity mode of the stream. Must be either PROVISIONED or ON_DEMAND.
   *
   * @schema StreamSpecForProviderStreamModeDetails#streamMode
   */
  readonly streamMode?: string;

}

/**
 * Converts an object of type 'StreamSpecForProviderStreamModeDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderStreamModeDetails(obj: StreamSpecForProviderStreamModeDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'streamMode': obj.streamMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StreamSpecInitProviderStreamModeDetails
 */
export interface StreamSpecInitProviderStreamModeDetails {
  /**
   * Specifies the capacity mode of the stream. Must be either PROVISIONED or ON_DEMAND.
   *
   * @schema StreamSpecInitProviderStreamModeDetails#streamMode
   */
  readonly streamMode?: string;

}

/**
 * Converts an object of type 'StreamSpecInitProviderStreamModeDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecInitProviderStreamModeDetails(obj: StreamSpecInitProviderStreamModeDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'streamMode': obj.streamMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecProviderConfigRefPolicy
 */
export interface StreamSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StreamSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StreamSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderConfigRefPolicy(obj: StreamSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRef
 */
export interface StreamSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StreamSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToConfigRef(obj: StreamSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StreamSpecPublishConnectionDetailsToMetadata
 */
export interface StreamSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToMetadata(obj: StreamSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecForProviderKmsKeyIdRefPolicy
 */
export interface StreamSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyIdRefPolicy(obj: StreamSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StreamSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface StreamSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyIdSelectorPolicy(obj: StreamSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecProviderConfigRefPolicyResolution
 */
export enum StreamSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecProviderConfigRefPolicyResolve
 */
export enum StreamSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StreamSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToConfigRefPolicy(obj: StreamSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum StreamSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum StreamSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum StreamSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum StreamSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StreamConsumer is the Schema for the StreamConsumers API. Manages a Kinesis Stream Consumer.
 *
 * @schema StreamConsumer
 */
export class StreamConsumer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StreamConsumer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kinesis.aws.upbound.io/v1beta1',
    kind: 'StreamConsumer',
  }

  /**
   * Renders a Kubernetes manifest for "StreamConsumer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StreamConsumerProps): any {
    return {
      ...StreamConsumer.GVK,
      ...toJson_StreamConsumerProps(props),
    };
  }

  /**
   * Defines a "StreamConsumer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StreamConsumerProps) {
    super(scope, id, {
      ...StreamConsumer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StreamConsumer.GVK,
      ...toJson_StreamConsumerProps(resolved),
    };
  }
}

/**
 * StreamConsumer is the Schema for the StreamConsumers API. Manages a Kinesis Stream Consumer.
 *
 * @schema StreamConsumer
 */
export interface StreamConsumerProps {
  /**
   * @schema StreamConsumer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StreamConsumerSpec defines the desired state of StreamConsumer
   *
   * @schema StreamConsumer#spec
   */
  readonly spec: StreamConsumerSpec;

}

/**
 * Converts an object of type 'StreamConsumerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerProps(obj: StreamConsumerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StreamConsumerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StreamConsumerSpec defines the desired state of StreamConsumer
 *
 * @schema StreamConsumerSpec
 */
export interface StreamConsumerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StreamConsumerSpec#deletionPolicy
   */
  readonly deletionPolicy?: StreamConsumerSpecDeletionPolicy;

  /**
   * @schema StreamConsumerSpec#forProvider
   */
  readonly forProvider: StreamConsumerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema StreamConsumerSpec#initProvider
   */
  readonly initProvider?: StreamConsumerSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StreamConsumerSpec#managementPolicies
   */
  readonly managementPolicies?: StreamConsumerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StreamConsumerSpec#providerConfigRef
   */
  readonly providerConfigRef?: StreamConsumerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StreamConsumerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StreamConsumerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StreamConsumerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StreamConsumerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StreamConsumerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpec(obj: StreamConsumerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StreamConsumerSpecForProvider(obj.forProvider),
    'initProvider': toJson_StreamConsumerSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StreamConsumerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StreamConsumerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StreamConsumerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StreamConsumerSpecDeletionPolicy
 */
export enum StreamConsumerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StreamConsumerSpecForProvider
 */
export interface StreamConsumerSpecForProvider {
  /**
   * Name of the stream consumer.
   *
   * @schema StreamConsumerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StreamConsumerSpecForProvider#region
   */
  readonly region: string;

  /**
   * â€“  Amazon Resource Name (ARN) of the data stream the consumer is registered with.
   *
   * @schema StreamConsumerSpecForProvider#streamArn
   */
  readonly streamArn?: string;

  /**
   * Reference to a Stream in kinesis to populate streamArn.
   *
   * @schema StreamConsumerSpecForProvider#streamArnRef
   */
  readonly streamArnRef?: StreamConsumerSpecForProviderStreamArnRef;

  /**
   * Selector for a Stream in kinesis to populate streamArn.
   *
   * @schema StreamConsumerSpecForProvider#streamArnSelector
   */
  readonly streamArnSelector?: StreamConsumerSpecForProviderStreamArnSelector;

}

/**
 * Converts an object of type 'StreamConsumerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecForProvider(obj: StreamConsumerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'streamArn': obj.streamArn,
    'streamArnRef': toJson_StreamConsumerSpecForProviderStreamArnRef(obj.streamArnRef),
    'streamArnSelector': toJson_StreamConsumerSpecForProviderStreamArnSelector(obj.streamArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema StreamConsumerSpecInitProvider
 */
export interface StreamConsumerSpecInitProvider {
  /**
   * Name of the stream consumer.
   *
   * @schema StreamConsumerSpecInitProvider#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'StreamConsumerSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecInitProvider(obj: StreamConsumerSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema StreamConsumerSpecManagementPolicies
 */
export enum StreamConsumerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StreamConsumerSpecProviderConfigRef
 */
export interface StreamConsumerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamConsumerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamConsumerSpecProviderConfigRef#policy
   */
  readonly policy?: StreamConsumerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StreamConsumerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecProviderConfigRef(obj: StreamConsumerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamConsumerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StreamConsumerSpecPublishConnectionDetailsTo
 */
export interface StreamConsumerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StreamConsumerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StreamConsumerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StreamConsumerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StreamConsumerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StreamConsumerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StreamConsumerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecPublishConnectionDetailsTo(obj: StreamConsumerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StreamConsumerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StreamConsumerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StreamConsumerSpecWriteConnectionSecretToRef
 */
export interface StreamConsumerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StreamConsumerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StreamConsumerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StreamConsumerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecWriteConnectionSecretToRef(obj: StreamConsumerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stream in kinesis to populate streamArn.
 *
 * @schema StreamConsumerSpecForProviderStreamArnRef
 */
export interface StreamConsumerSpecForProviderStreamArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamConsumerSpecForProviderStreamArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamConsumerSpecForProviderStreamArnRef#policy
   */
  readonly policy?: StreamConsumerSpecForProviderStreamArnRefPolicy;

}

/**
 * Converts an object of type 'StreamConsumerSpecForProviderStreamArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecForProviderStreamArnRef(obj: StreamConsumerSpecForProviderStreamArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamConsumerSpecForProviderStreamArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stream in kinesis to populate streamArn.
 *
 * @schema StreamConsumerSpecForProviderStreamArnSelector
 */
export interface StreamConsumerSpecForProviderStreamArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StreamConsumerSpecForProviderStreamArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StreamConsumerSpecForProviderStreamArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StreamConsumerSpecForProviderStreamArnSelector#policy
   */
  readonly policy?: StreamConsumerSpecForProviderStreamArnSelectorPolicy;

}

/**
 * Converts an object of type 'StreamConsumerSpecForProviderStreamArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecForProviderStreamArnSelector(obj: StreamConsumerSpecForProviderStreamArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StreamConsumerSpecForProviderStreamArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamConsumerSpecProviderConfigRefPolicy
 */
export interface StreamConsumerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamConsumerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StreamConsumerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamConsumerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StreamConsumerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamConsumerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecProviderConfigRefPolicy(obj: StreamConsumerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StreamConsumerSpecPublishConnectionDetailsToConfigRef
 */
export interface StreamConsumerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamConsumerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamConsumerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StreamConsumerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecPublishConnectionDetailsToConfigRef(obj: StreamConsumerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StreamConsumerSpecPublishConnectionDetailsToMetadata
 */
export interface StreamConsumerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StreamConsumerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StreamConsumerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StreamConsumerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StreamConsumerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecPublishConnectionDetailsToMetadata(obj: StreamConsumerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamConsumerSpecForProviderStreamArnRefPolicy
 */
export interface StreamConsumerSpecForProviderStreamArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamConsumerSpecForProviderStreamArnRefPolicy#resolution
   */
  readonly resolution?: StreamConsumerSpecForProviderStreamArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamConsumerSpecForProviderStreamArnRefPolicy#resolve
   */
  readonly resolve?: StreamConsumerSpecForProviderStreamArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamConsumerSpecForProviderStreamArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecForProviderStreamArnRefPolicy(obj: StreamConsumerSpecForProviderStreamArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StreamConsumerSpecForProviderStreamArnSelectorPolicy
 */
export interface StreamConsumerSpecForProviderStreamArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamConsumerSpecForProviderStreamArnSelectorPolicy#resolution
   */
  readonly resolution?: StreamConsumerSpecForProviderStreamArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamConsumerSpecForProviderStreamArnSelectorPolicy#resolve
   */
  readonly resolve?: StreamConsumerSpecForProviderStreamArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StreamConsumerSpecForProviderStreamArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecForProviderStreamArnSelectorPolicy(obj: StreamConsumerSpecForProviderStreamArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamConsumerSpecProviderConfigRefPolicyResolution
 */
export enum StreamConsumerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamConsumerSpecProviderConfigRefPolicyResolve
 */
export enum StreamConsumerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicy(obj: StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamConsumerSpecForProviderStreamArnRefPolicyResolution
 */
export enum StreamConsumerSpecForProviderStreamArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamConsumerSpecForProviderStreamArnRefPolicyResolve
 */
export enum StreamConsumerSpecForProviderStreamArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamConsumerSpecForProviderStreamArnSelectorPolicyResolution
 */
export enum StreamConsumerSpecForProviderStreamArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamConsumerSpecForProviderStreamArnSelectorPolicyResolve
 */
export enum StreamConsumerSpecForProviderStreamArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StreamConsumerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

