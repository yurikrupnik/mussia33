// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LocationS3 is the Schema for the LocationS3s API. Manages an AWS DataSync S3 Location
 *
 * @schema LocationS3
 */
export class LocationS3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LocationS3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datasync.aws.upbound.io/v1beta1',
    kind: 'LocationS3',
  }

  /**
   * Renders a Kubernetes manifest for "LocationS3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LocationS3Props): any {
    return {
      ...LocationS3.GVK,
      ...toJson_LocationS3Props(props),
    };
  }

  /**
   * Defines a "LocationS3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LocationS3Props) {
    super(scope, id, {
      ...LocationS3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LocationS3.GVK,
      ...toJson_LocationS3Props(resolved),
    };
  }
}

/**
 * LocationS3 is the Schema for the LocationS3s API. Manages an AWS DataSync S3 Location
 *
 * @schema LocationS3
 */
export interface LocationS3Props {
  /**
   * @schema LocationS3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LocationS3Spec defines the desired state of LocationS3
   *
   * @schema LocationS3#spec
   */
  readonly spec: LocationS3Spec;

}

/**
 * Converts an object of type 'LocationS3Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3Props(obj: LocationS3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LocationS3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocationS3Spec defines the desired state of LocationS3
 *
 * @schema LocationS3Spec
 */
export interface LocationS3Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LocationS3Spec#deletionPolicy
   */
  readonly deletionPolicy?: LocationS3SpecDeletionPolicy;

  /**
   * @schema LocationS3Spec#forProvider
   */
  readonly forProvider: LocationS3SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema LocationS3Spec#initProvider
   */
  readonly initProvider?: LocationS3SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LocationS3Spec#managementPolicies
   */
  readonly managementPolicies?: LocationS3SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LocationS3Spec#providerConfigRef
   */
  readonly providerConfigRef?: LocationS3SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LocationS3Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LocationS3SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LocationS3Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LocationS3SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LocationS3Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3Spec(obj: LocationS3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LocationS3SpecForProvider(obj.forProvider),
    'initProvider': toJson_LocationS3SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LocationS3SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LocationS3SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LocationS3SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LocationS3SpecDeletionPolicy
 */
export enum LocationS3SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LocationS3SpecForProvider
 */
export interface LocationS3SpecForProvider {
  /**
   * A list of DataSync Agent ARNs with which this location will be associated.
   *
   * @schema LocationS3SpecForProvider#agentArns
   */
  readonly agentArns?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LocationS3SpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) of the S3 Bucket.
   *
   * @schema LocationS3SpecForProvider#s3BucketArn
   */
  readonly s3BucketArn?: string;

  /**
   * Reference to a Bucket in s3 to populate s3BucketArn.
   *
   * @schema LocationS3SpecForProvider#s3BucketArnRef
   */
  readonly s3BucketArnRef?: LocationS3SpecForProviderS3BucketArnRef;

  /**
   * Selector for a Bucket in s3 to populate s3BucketArn.
   *
   * @schema LocationS3SpecForProvider#s3BucketArnSelector
   */
  readonly s3BucketArnSelector?: LocationS3SpecForProviderS3BucketArnSelector;

  /**
   * Configuration block containing information for connecting to S3.
   *
   * @schema LocationS3SpecForProvider#s3Config
   */
  readonly s3Config?: LocationS3SpecForProviderS3Config[];

  /**
   * The Amazon S3 storage class that you want to store your files in when this location is used as a task destination. Valid values
   *
   * @schema LocationS3SpecForProvider#s3StorageClass
   */
  readonly s3StorageClass?: string;

  /**
   * Prefix to perform actions as source or destination.
   *
   * @schema LocationS3SpecForProvider#subdirectory
   */
  readonly subdirectory?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LocationS3SpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LocationS3SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecForProvider(obj: LocationS3SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agentArns': obj.agentArns?.map(y => y),
    'region': obj.region,
    's3BucketArn': obj.s3BucketArn,
    's3BucketArnRef': toJson_LocationS3SpecForProviderS3BucketArnRef(obj.s3BucketArnRef),
    's3BucketArnSelector': toJson_LocationS3SpecForProviderS3BucketArnSelector(obj.s3BucketArnSelector),
    's3Config': obj.s3Config?.map(y => toJson_LocationS3SpecForProviderS3Config(y)),
    's3StorageClass': obj.s3StorageClass,
    'subdirectory': obj.subdirectory,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema LocationS3SpecInitProvider
 */
export interface LocationS3SpecInitProvider {
  /**
   * A list of DataSync Agent ARNs with which this location will be associated.
   *
   * @schema LocationS3SpecInitProvider#agentArns
   */
  readonly agentArns?: string[];

  /**
   * Configuration block containing information for connecting to S3.
   *
   * @schema LocationS3SpecInitProvider#s3Config
   */
  readonly s3Config?: any[];

  /**
   * The Amazon S3 storage class that you want to store your files in when this location is used as a task destination. Valid values
   *
   * @schema LocationS3SpecInitProvider#s3StorageClass
   */
  readonly s3StorageClass?: string;

  /**
   * Prefix to perform actions as source or destination.
   *
   * @schema LocationS3SpecInitProvider#subdirectory
   */
  readonly subdirectory?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LocationS3SpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LocationS3SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecInitProvider(obj: LocationS3SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agentArns': obj.agentArns?.map(y => y),
    's3Config': obj.s3Config?.map(y => y),
    's3StorageClass': obj.s3StorageClass,
    'subdirectory': obj.subdirectory,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LocationS3SpecManagementPolicies
 */
export enum LocationS3SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LocationS3SpecProviderConfigRef
 */
export interface LocationS3SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LocationS3SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LocationS3SpecProviderConfigRef#policy
   */
  readonly policy?: LocationS3SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LocationS3SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecProviderConfigRef(obj: LocationS3SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LocationS3SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LocationS3SpecPublishConnectionDetailsTo
 */
export interface LocationS3SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LocationS3SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LocationS3SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LocationS3SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LocationS3SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LocationS3SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LocationS3SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecPublishConnectionDetailsTo(obj: LocationS3SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LocationS3SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LocationS3SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LocationS3SpecWriteConnectionSecretToRef
 */
export interface LocationS3SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LocationS3SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LocationS3SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LocationS3SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecWriteConnectionSecretToRef(obj: LocationS3SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate s3BucketArn.
 *
 * @schema LocationS3SpecForProviderS3BucketArnRef
 */
export interface LocationS3SpecForProviderS3BucketArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LocationS3SpecForProviderS3BucketArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LocationS3SpecForProviderS3BucketArnRef#policy
   */
  readonly policy?: LocationS3SpecForProviderS3BucketArnRefPolicy;

}

/**
 * Converts an object of type 'LocationS3SpecForProviderS3BucketArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecForProviderS3BucketArnRef(obj: LocationS3SpecForProviderS3BucketArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LocationS3SpecForProviderS3BucketArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate s3BucketArn.
 *
 * @schema LocationS3SpecForProviderS3BucketArnSelector
 */
export interface LocationS3SpecForProviderS3BucketArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LocationS3SpecForProviderS3BucketArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LocationS3SpecForProviderS3BucketArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LocationS3SpecForProviderS3BucketArnSelector#policy
   */
  readonly policy?: LocationS3SpecForProviderS3BucketArnSelectorPolicy;

}

/**
 * Converts an object of type 'LocationS3SpecForProviderS3BucketArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecForProviderS3BucketArnSelector(obj: LocationS3SpecForProviderS3BucketArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LocationS3SpecForProviderS3BucketArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LocationS3SpecForProviderS3Config
 */
export interface LocationS3SpecForProviderS3Config {
  /**
   * ARN of the IAM Role used to connect to the S3 Bucket.
   *
   * @schema LocationS3SpecForProviderS3Config#bucketAccessRoleArn
   */
  readonly bucketAccessRoleArn?: string;

  /**
   * Reference to a Role in iam to populate bucketAccessRoleArn.
   *
   * @schema LocationS3SpecForProviderS3Config#bucketAccessRoleArnRef
   */
  readonly bucketAccessRoleArnRef?: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRef;

  /**
   * Selector for a Role in iam to populate bucketAccessRoleArn.
   *
   * @schema LocationS3SpecForProviderS3Config#bucketAccessRoleArnSelector
   */
  readonly bucketAccessRoleArnSelector?: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelector;

}

/**
 * Converts an object of type 'LocationS3SpecForProviderS3Config' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecForProviderS3Config(obj: LocationS3SpecForProviderS3Config | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketAccessRoleArn': obj.bucketAccessRoleArn,
    'bucketAccessRoleArnRef': toJson_LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRef(obj.bucketAccessRoleArnRef),
    'bucketAccessRoleArnSelector': toJson_LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelector(obj.bucketAccessRoleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LocationS3SpecProviderConfigRefPolicy
 */
export interface LocationS3SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LocationS3SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LocationS3SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LocationS3SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LocationS3SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LocationS3SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecProviderConfigRefPolicy(obj: LocationS3SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LocationS3SpecPublishConnectionDetailsToConfigRef
 */
export interface LocationS3SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LocationS3SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LocationS3SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LocationS3SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LocationS3SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecPublishConnectionDetailsToConfigRef(obj: LocationS3SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LocationS3SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LocationS3SpecPublishConnectionDetailsToMetadata
 */
export interface LocationS3SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LocationS3SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LocationS3SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LocationS3SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LocationS3SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecPublishConnectionDetailsToMetadata(obj: LocationS3SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LocationS3SpecForProviderS3BucketArnRefPolicy
 */
export interface LocationS3SpecForProviderS3BucketArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LocationS3SpecForProviderS3BucketArnRefPolicy#resolution
   */
  readonly resolution?: LocationS3SpecForProviderS3BucketArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LocationS3SpecForProviderS3BucketArnRefPolicy#resolve
   */
  readonly resolve?: LocationS3SpecForProviderS3BucketArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LocationS3SpecForProviderS3BucketArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecForProviderS3BucketArnRefPolicy(obj: LocationS3SpecForProviderS3BucketArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LocationS3SpecForProviderS3BucketArnSelectorPolicy
 */
export interface LocationS3SpecForProviderS3BucketArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LocationS3SpecForProviderS3BucketArnSelectorPolicy#resolution
   */
  readonly resolution?: LocationS3SpecForProviderS3BucketArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LocationS3SpecForProviderS3BucketArnSelectorPolicy#resolve
   */
  readonly resolve?: LocationS3SpecForProviderS3BucketArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LocationS3SpecForProviderS3BucketArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecForProviderS3BucketArnSelectorPolicy(obj: LocationS3SpecForProviderS3BucketArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate bucketAccessRoleArn.
 *
 * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRef
 */
export interface LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRef#policy
   */
  readonly policy?: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicy;

}

/**
 * Converts an object of type 'LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRef(obj: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate bucketAccessRoleArn.
 *
 * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelector
 */
export interface LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelector#policy
   */
  readonly policy?: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelector(obj: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LocationS3SpecProviderConfigRefPolicyResolution
 */
export enum LocationS3SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LocationS3SpecProviderConfigRefPolicyResolve
 */
export enum LocationS3SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LocationS3SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LocationS3SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LocationS3SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LocationS3SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LocationS3SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LocationS3SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LocationS3SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecPublishConnectionDetailsToConfigRefPolicy(obj: LocationS3SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LocationS3SpecForProviderS3BucketArnRefPolicyResolution
 */
export enum LocationS3SpecForProviderS3BucketArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LocationS3SpecForProviderS3BucketArnRefPolicyResolve
 */
export enum LocationS3SpecForProviderS3BucketArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LocationS3SpecForProviderS3BucketArnSelectorPolicyResolution
 */
export enum LocationS3SpecForProviderS3BucketArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LocationS3SpecForProviderS3BucketArnSelectorPolicyResolve
 */
export enum LocationS3SpecForProviderS3BucketArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicy
 */
export interface LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicy#resolution
   */
  readonly resolution?: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicy#resolve
   */
  readonly resolve?: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicy(obj: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicy
 */
export interface LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicy(obj: LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LocationS3SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LocationS3SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LocationS3SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LocationS3SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicyResolution
 */
export enum LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicyResolve
 */
export enum LocationS3SpecForProviderS3ConfigBucketAccessRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicyResolution
 */
export enum LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicyResolve
 */
export enum LocationS3SpecForProviderS3ConfigBucketAccessRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Task is the Schema for the Tasks API. Manages an AWS DataSync Task
 *
 * @schema Task
 */
export class Task extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Task"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datasync.aws.upbound.io/v1beta1',
    kind: 'Task',
  }

  /**
   * Renders a Kubernetes manifest for "Task".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TaskProps): any {
    return {
      ...Task.GVK,
      ...toJson_TaskProps(props),
    };
  }

  /**
   * Defines a "Task" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TaskProps) {
    super(scope, id, {
      ...Task.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Task.GVK,
      ...toJson_TaskProps(resolved),
    };
  }
}

/**
 * Task is the Schema for the Tasks API. Manages an AWS DataSync Task
 *
 * @schema Task
 */
export interface TaskProps {
  /**
   * @schema Task#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TaskSpec defines the desired state of Task
   *
   * @schema Task#spec
   */
  readonly spec: TaskSpec;

}

/**
 * Converts an object of type 'TaskProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskProps(obj: TaskProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TaskSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TaskSpec defines the desired state of Task
 *
 * @schema TaskSpec
 */
export interface TaskSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TaskSpec#deletionPolicy
   */
  readonly deletionPolicy?: TaskSpecDeletionPolicy;

  /**
   * @schema TaskSpec#forProvider
   */
  readonly forProvider: TaskSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TaskSpec#initProvider
   */
  readonly initProvider?: TaskSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TaskSpec#managementPolicies
   */
  readonly managementPolicies?: TaskSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TaskSpec#providerConfigRef
   */
  readonly providerConfigRef?: TaskSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TaskSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TaskSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TaskSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TaskSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TaskSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpec(obj: TaskSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TaskSpecForProvider(obj.forProvider),
    'initProvider': toJson_TaskSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TaskSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TaskSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TaskSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TaskSpecDeletionPolicy
 */
export enum TaskSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TaskSpecForProvider
 */
export interface TaskSpecForProvider {
  /**
   * Amazon Resource Name (ARN) of the CloudWatch Log Group that is used to monitor and log events in the sync task.
   *
   * @schema TaskSpecForProvider#cloudwatchLogGroupArn
   */
  readonly cloudwatchLogGroupArn?: string;

  /**
   * Reference to a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
   *
   * @schema TaskSpecForProvider#cloudwatchLogGroupArnRef
   */
  readonly cloudwatchLogGroupArnRef?: TaskSpecForProviderCloudwatchLogGroupArnRef;

  /**
   * Selector for a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
   *
   * @schema TaskSpecForProvider#cloudwatchLogGroupArnSelector
   */
  readonly cloudwatchLogGroupArnSelector?: TaskSpecForProviderCloudwatchLogGroupArnSelector;

  /**
   * Amazon Resource Name (ARN) of destination DataSync Location.
   *
   * @schema TaskSpecForProvider#destinationLocationArn
   */
  readonly destinationLocationArn?: string;

  /**
   * Reference to a LocationS3 to populate destinationLocationArn.
   *
   * @schema TaskSpecForProvider#destinationLocationArnRef
   */
  readonly destinationLocationArnRef?: TaskSpecForProviderDestinationLocationArnRef;

  /**
   * Selector for a LocationS3 to populate destinationLocationArn.
   *
   * @schema TaskSpecForProvider#destinationLocationArnSelector
   */
  readonly destinationLocationArnSelector?: TaskSpecForProviderDestinationLocationArnSelector;

  /**
   * Filter rules that determines which files to exclude from a task.
   *
   * @schema TaskSpecForProvider#excludes
   */
  readonly excludes?: TaskSpecForProviderExcludes[];

  /**
   * Filter rules that determines which files to include in a task.
   *
   * @schema TaskSpecForProvider#includes
   */
  readonly includes?: TaskSpecForProviderIncludes[];

  /**
   * Name of the DataSync Task.
   *
   * @schema TaskSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Configuration block containing option that controls the default behavior when you start an execution of this DataSync Task. For each individual task execution, you can override these options by specifying an overriding configuration in those executions.
   *
   * @schema TaskSpecForProvider#options
   */
  readonly options?: TaskSpecForProviderOptions[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TaskSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies a schedule used to periodically transfer files from a source to a destination location.
   *
   * @schema TaskSpecForProvider#schedule
   */
  readonly schedule?: TaskSpecForProviderSchedule[];

  /**
   * Amazon Resource Name (ARN) of source DataSync Location.
   *
   * @schema TaskSpecForProvider#sourceLocationArn
   */
  readonly sourceLocationArn?: string;

  /**
   * Reference to a LocationS3 to populate sourceLocationArn.
   *
   * @schema TaskSpecForProvider#sourceLocationArnRef
   */
  readonly sourceLocationArnRef?: TaskSpecForProviderSourceLocationArnRef;

  /**
   * Selector for a LocationS3 to populate sourceLocationArn.
   *
   * @schema TaskSpecForProvider#sourceLocationArnSelector
   */
  readonly sourceLocationArnSelector?: TaskSpecForProviderSourceLocationArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema TaskSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TaskSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProvider(obj: TaskSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLogGroupArn': obj.cloudwatchLogGroupArn,
    'cloudwatchLogGroupArnRef': toJson_TaskSpecForProviderCloudwatchLogGroupArnRef(obj.cloudwatchLogGroupArnRef),
    'cloudwatchLogGroupArnSelector': toJson_TaskSpecForProviderCloudwatchLogGroupArnSelector(obj.cloudwatchLogGroupArnSelector),
    'destinationLocationArn': obj.destinationLocationArn,
    'destinationLocationArnRef': toJson_TaskSpecForProviderDestinationLocationArnRef(obj.destinationLocationArnRef),
    'destinationLocationArnSelector': toJson_TaskSpecForProviderDestinationLocationArnSelector(obj.destinationLocationArnSelector),
    'excludes': obj.excludes?.map(y => toJson_TaskSpecForProviderExcludes(y)),
    'includes': obj.includes?.map(y => toJson_TaskSpecForProviderIncludes(y)),
    'name': obj.name,
    'options': obj.options?.map(y => toJson_TaskSpecForProviderOptions(y)),
    'region': obj.region,
    'schedule': obj.schedule?.map(y => toJson_TaskSpecForProviderSchedule(y)),
    'sourceLocationArn': obj.sourceLocationArn,
    'sourceLocationArnRef': toJson_TaskSpecForProviderSourceLocationArnRef(obj.sourceLocationArnRef),
    'sourceLocationArnSelector': toJson_TaskSpecForProviderSourceLocationArnSelector(obj.sourceLocationArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TaskSpecInitProvider
 */
export interface TaskSpecInitProvider {
  /**
   * Filter rules that determines which files to exclude from a task.
   *
   * @schema TaskSpecInitProvider#excludes
   */
  readonly excludes?: TaskSpecInitProviderExcludes[];

  /**
   * Filter rules that determines which files to include in a task.
   *
   * @schema TaskSpecInitProvider#includes
   */
  readonly includes?: TaskSpecInitProviderIncludes[];

  /**
   * Name of the DataSync Task.
   *
   * @schema TaskSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Configuration block containing option that controls the default behavior when you start an execution of this DataSync Task. For each individual task execution, you can override these options by specifying an overriding configuration in those executions.
   *
   * @schema TaskSpecInitProvider#options
   */
  readonly options?: TaskSpecInitProviderOptions[];

  /**
   * Specifies a schedule used to periodically transfer files from a source to a destination location.
   *
   * @schema TaskSpecInitProvider#schedule
   */
  readonly schedule?: TaskSpecInitProviderSchedule[];

  /**
   * Key-value map of resource tags.
   *
   * @schema TaskSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TaskSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecInitProvider(obj: TaskSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludes': obj.excludes?.map(y => toJson_TaskSpecInitProviderExcludes(y)),
    'includes': obj.includes?.map(y => toJson_TaskSpecInitProviderIncludes(y)),
    'name': obj.name,
    'options': obj.options?.map(y => toJson_TaskSpecInitProviderOptions(y)),
    'schedule': obj.schedule?.map(y => toJson_TaskSpecInitProviderSchedule(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TaskSpecManagementPolicies
 */
export enum TaskSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TaskSpecProviderConfigRef
 */
export interface TaskSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskSpecProviderConfigRef#policy
   */
  readonly policy?: TaskSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TaskSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecProviderConfigRef(obj: TaskSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TaskSpecPublishConnectionDetailsTo
 */
export interface TaskSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TaskSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TaskSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TaskSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TaskSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TaskSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TaskSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecPublishConnectionDetailsTo(obj: TaskSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TaskSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TaskSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TaskSpecWriteConnectionSecretToRef
 */
export interface TaskSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TaskSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TaskSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TaskSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecWriteConnectionSecretToRef(obj: TaskSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
 *
 * @schema TaskSpecForProviderCloudwatchLogGroupArnRef
 */
export interface TaskSpecForProviderCloudwatchLogGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskSpecForProviderCloudwatchLogGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskSpecForProviderCloudwatchLogGroupArnRef#policy
   */
  readonly policy?: TaskSpecForProviderCloudwatchLogGroupArnRefPolicy;

}

/**
 * Converts an object of type 'TaskSpecForProviderCloudwatchLogGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderCloudwatchLogGroupArnRef(obj: TaskSpecForProviderCloudwatchLogGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskSpecForProviderCloudwatchLogGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
 *
 * @schema TaskSpecForProviderCloudwatchLogGroupArnSelector
 */
export interface TaskSpecForProviderCloudwatchLogGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TaskSpecForProviderCloudwatchLogGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TaskSpecForProviderCloudwatchLogGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TaskSpecForProviderCloudwatchLogGroupArnSelector#policy
   */
  readonly policy?: TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'TaskSpecForProviderCloudwatchLogGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderCloudwatchLogGroupArnSelector(obj: TaskSpecForProviderCloudwatchLogGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LocationS3 to populate destinationLocationArn.
 *
 * @schema TaskSpecForProviderDestinationLocationArnRef
 */
export interface TaskSpecForProviderDestinationLocationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskSpecForProviderDestinationLocationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskSpecForProviderDestinationLocationArnRef#policy
   */
  readonly policy?: TaskSpecForProviderDestinationLocationArnRefPolicy;

}

/**
 * Converts an object of type 'TaskSpecForProviderDestinationLocationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderDestinationLocationArnRef(obj: TaskSpecForProviderDestinationLocationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskSpecForProviderDestinationLocationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LocationS3 to populate destinationLocationArn.
 *
 * @schema TaskSpecForProviderDestinationLocationArnSelector
 */
export interface TaskSpecForProviderDestinationLocationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TaskSpecForProviderDestinationLocationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TaskSpecForProviderDestinationLocationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TaskSpecForProviderDestinationLocationArnSelector#policy
   */
  readonly policy?: TaskSpecForProviderDestinationLocationArnSelectorPolicy;

}

/**
 * Converts an object of type 'TaskSpecForProviderDestinationLocationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderDestinationLocationArnSelector(obj: TaskSpecForProviderDestinationLocationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TaskSpecForProviderDestinationLocationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskSpecForProviderExcludes
 */
export interface TaskSpecForProviderExcludes {
  /**
   * The type of filter rule to apply. Valid values: SIMPLE_PATTERN.
   *
   * @schema TaskSpecForProviderExcludes#filterType
   */
  readonly filterType?: string;

  /**
   * A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: /folder1|/folder2
   *
   * @schema TaskSpecForProviderExcludes#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TaskSpecForProviderExcludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderExcludes(obj: TaskSpecForProviderExcludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterType': obj.filterType,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskSpecForProviderIncludes
 */
export interface TaskSpecForProviderIncludes {
  /**
   * The type of filter rule to apply. Valid values: SIMPLE_PATTERN.
   *
   * @schema TaskSpecForProviderIncludes#filterType
   */
  readonly filterType?: string;

  /**
   * A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: /folder1|/folder2
   *
   * @schema TaskSpecForProviderIncludes#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TaskSpecForProviderIncludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderIncludes(obj: TaskSpecForProviderIncludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterType': obj.filterType,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskSpecForProviderOptions
 */
export interface TaskSpecForProviderOptions {
  /**
   * A file metadata that shows the last time a file was accessed (that is when the file was read or written to). If set to BEST_EFFORT, the DataSync Task attempts to preserve the original (that is, the version before sync PREPARING phase) atime attribute on all source files. Valid values: BEST_EFFORT, NONE. Default: BEST_EFFORT.
   *
   * @schema TaskSpecForProviderOptions#atime
   */
  readonly atime?: string;

  /**
   * Limits the bandwidth utilized. For example, to set a maximum of 1 MB, set this value to 1048576. Value values: -1 or greater. Default: -1 (unlimited).
   *
   * @schema TaskSpecForProviderOptions#bytesPerSecond
   */
  readonly bytesPerSecond?: number;

  /**
   * Group identifier of the file's owners. Valid values: BOTH, INT_VALUE, NAME, NONE. Default: INT_VALUE (preserve integer value of the ID).
   *
   * @schema TaskSpecForProviderOptions#gid
   */
  readonly gid?: string;

  /**
   * Determines the type of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide. Valid values: OFF, BASIC, TRANSFER. Default: OFF.
   *
   * @schema TaskSpecForProviderOptions#logLevel
   */
  readonly logLevel?: string;

  /**
   * A file metadata that indicates the last time a file was modified (written to) before the sync PREPARING phase. Value values: NONE, PRESERVE. Default: PRESERVE.
   *
   * @schema TaskSpecForProviderOptions#mtime
   */
  readonly mtime?: string;

  /**
   * Determines whether files at the destination should be overwritten or preserved when copying files. Valid values: ALWAYS, NEVER. Default: ALWAYS.
   *
   * @schema TaskSpecForProviderOptions#overwriteMode
   */
  readonly overwriteMode?: string;

  /**
   * Determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file. Valid values: NONE, PRESERVE. Default: PRESERVE.
   *
   * @schema TaskSpecForProviderOptions#posixPermissions
   */
  readonly posixPermissions?: string;

  /**
   * Whether files deleted in the source should be removed or preserved in the destination file system. Valid values: PRESERVE, REMOVE. Default: PRESERVE.
   *
   * @schema TaskSpecForProviderOptions#preserveDeletedFiles
   */
  readonly preserveDeletedFiles?: string;

  /**
   * Whether the DataSync Task should preserve the metadata of block and character devices in the source files system, and recreate the files with that device name and metadata on the destination. The DataSync Task cant sync the actual contents of such devices, because many of the devices are non-terminal and dont return an end of file (EOF) marker. Valid values: NONE, PRESERVE. Default: NONE (ignore special devices).
   *
   * @schema TaskSpecForProviderOptions#preserveDevices
   */
  readonly preserveDevices?: string;

  /**
   * Determines which components of the SMB security descriptor are copied from source to destination objects. This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations, or between two Amazon FSx for Windows File Server locations. Valid values: NONE, OWNER_DACL, OWNER_DACL_SACL.
   *
   * @schema TaskSpecForProviderOptions#securityDescriptorCopyFlags
   */
  readonly securityDescriptorCopyFlags?: string;

  /**
   * Determines whether tasks should be queued before executing the tasks. Valid values: ENABLED, DISABLED. Default ENABLED.
   *
   * @schema TaskSpecForProviderOptions#taskQueueing
   */
  readonly taskQueueing?: string;

  /**
   * Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location. Valid values: CHANGED, ALL. Default: CHANGED
   *
   * @schema TaskSpecForProviderOptions#transferMode
   */
  readonly transferMode?: string;

  /**
   * User identifier of the file's owners. Valid values: BOTH, INT_VALUE, NAME, NONE. Default: INT_VALUE (preserve integer value of the ID).
   *
   * @schema TaskSpecForProviderOptions#uid
   */
  readonly uid?: string;

  /**
   * Whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred. Valid values: NONE, POINT_IN_TIME_CONSISTENT, ONLY_FILES_TRANSFERRED. Default: POINT_IN_TIME_CONSISTENT.
   *
   * @schema TaskSpecForProviderOptions#verifyMode
   */
  readonly verifyMode?: string;

}

/**
 * Converts an object of type 'TaskSpecForProviderOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderOptions(obj: TaskSpecForProviderOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'atime': obj.atime,
    'bytesPerSecond': obj.bytesPerSecond,
    'gid': obj.gid,
    'logLevel': obj.logLevel,
    'mtime': obj.mtime,
    'overwriteMode': obj.overwriteMode,
    'posixPermissions': obj.posixPermissions,
    'preserveDeletedFiles': obj.preserveDeletedFiles,
    'preserveDevices': obj.preserveDevices,
    'securityDescriptorCopyFlags': obj.securityDescriptorCopyFlags,
    'taskQueueing': obj.taskQueueing,
    'transferMode': obj.transferMode,
    'uid': obj.uid,
    'verifyMode': obj.verifyMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskSpecForProviderSchedule
 */
export interface TaskSpecForProviderSchedule {
  /**
   * Specifies the schedule you want your task to use for repeated executions. For more information, see Schedule Expressions for Rules.
   *
   * @schema TaskSpecForProviderSchedule#scheduleExpression
   */
  readonly scheduleExpression?: string;

}

/**
 * Converts an object of type 'TaskSpecForProviderSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderSchedule(obj: TaskSpecForProviderSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scheduleExpression': obj.scheduleExpression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LocationS3 to populate sourceLocationArn.
 *
 * @schema TaskSpecForProviderSourceLocationArnRef
 */
export interface TaskSpecForProviderSourceLocationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskSpecForProviderSourceLocationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskSpecForProviderSourceLocationArnRef#policy
   */
  readonly policy?: TaskSpecForProviderSourceLocationArnRefPolicy;

}

/**
 * Converts an object of type 'TaskSpecForProviderSourceLocationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderSourceLocationArnRef(obj: TaskSpecForProviderSourceLocationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskSpecForProviderSourceLocationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LocationS3 to populate sourceLocationArn.
 *
 * @schema TaskSpecForProviderSourceLocationArnSelector
 */
export interface TaskSpecForProviderSourceLocationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TaskSpecForProviderSourceLocationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TaskSpecForProviderSourceLocationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TaskSpecForProviderSourceLocationArnSelector#policy
   */
  readonly policy?: TaskSpecForProviderSourceLocationArnSelectorPolicy;

}

/**
 * Converts an object of type 'TaskSpecForProviderSourceLocationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderSourceLocationArnSelector(obj: TaskSpecForProviderSourceLocationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TaskSpecForProviderSourceLocationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskSpecInitProviderExcludes
 */
export interface TaskSpecInitProviderExcludes {
  /**
   * The type of filter rule to apply. Valid values: SIMPLE_PATTERN.
   *
   * @schema TaskSpecInitProviderExcludes#filterType
   */
  readonly filterType?: string;

  /**
   * A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: /folder1|/folder2
   *
   * @schema TaskSpecInitProviderExcludes#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TaskSpecInitProviderExcludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecInitProviderExcludes(obj: TaskSpecInitProviderExcludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterType': obj.filterType,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskSpecInitProviderIncludes
 */
export interface TaskSpecInitProviderIncludes {
  /**
   * The type of filter rule to apply. Valid values: SIMPLE_PATTERN.
   *
   * @schema TaskSpecInitProviderIncludes#filterType
   */
  readonly filterType?: string;

  /**
   * A single filter string that consists of the patterns to exclude. The patterns are delimited by "|" (that is, a pipe), for example: /folder1|/folder2
   *
   * @schema TaskSpecInitProviderIncludes#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TaskSpecInitProviderIncludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecInitProviderIncludes(obj: TaskSpecInitProviderIncludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterType': obj.filterType,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskSpecInitProviderOptions
 */
export interface TaskSpecInitProviderOptions {
  /**
   * A file metadata that shows the last time a file was accessed (that is when the file was read or written to). If set to BEST_EFFORT, the DataSync Task attempts to preserve the original (that is, the version before sync PREPARING phase) atime attribute on all source files. Valid values: BEST_EFFORT, NONE. Default: BEST_EFFORT.
   *
   * @schema TaskSpecInitProviderOptions#atime
   */
  readonly atime?: string;

  /**
   * Limits the bandwidth utilized. For example, to set a maximum of 1 MB, set this value to 1048576. Value values: -1 or greater. Default: -1 (unlimited).
   *
   * @schema TaskSpecInitProviderOptions#bytesPerSecond
   */
  readonly bytesPerSecond?: number;

  /**
   * Group identifier of the file's owners. Valid values: BOTH, INT_VALUE, NAME, NONE. Default: INT_VALUE (preserve integer value of the ID).
   *
   * @schema TaskSpecInitProviderOptions#gid
   */
  readonly gid?: string;

  /**
   * Determines the type of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide. Valid values: OFF, BASIC, TRANSFER. Default: OFF.
   *
   * @schema TaskSpecInitProviderOptions#logLevel
   */
  readonly logLevel?: string;

  /**
   * A file metadata that indicates the last time a file was modified (written to) before the sync PREPARING phase. Value values: NONE, PRESERVE. Default: PRESERVE.
   *
   * @schema TaskSpecInitProviderOptions#mtime
   */
  readonly mtime?: string;

  /**
   * Determines whether files at the destination should be overwritten or preserved when copying files. Valid values: ALWAYS, NEVER. Default: ALWAYS.
   *
   * @schema TaskSpecInitProviderOptions#overwriteMode
   */
  readonly overwriteMode?: string;

  /**
   * Determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file. Valid values: NONE, PRESERVE. Default: PRESERVE.
   *
   * @schema TaskSpecInitProviderOptions#posixPermissions
   */
  readonly posixPermissions?: string;

  /**
   * Whether files deleted in the source should be removed or preserved in the destination file system. Valid values: PRESERVE, REMOVE. Default: PRESERVE.
   *
   * @schema TaskSpecInitProviderOptions#preserveDeletedFiles
   */
  readonly preserveDeletedFiles?: string;

  /**
   * Whether the DataSync Task should preserve the metadata of block and character devices in the source files system, and recreate the files with that device name and metadata on the destination. The DataSync Task cant sync the actual contents of such devices, because many of the devices are non-terminal and dont return an end of file (EOF) marker. Valid values: NONE, PRESERVE. Default: NONE (ignore special devices).
   *
   * @schema TaskSpecInitProviderOptions#preserveDevices
   */
  readonly preserveDevices?: string;

  /**
   * Determines which components of the SMB security descriptor are copied from source to destination objects. This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations, or between two Amazon FSx for Windows File Server locations. Valid values: NONE, OWNER_DACL, OWNER_DACL_SACL.
   *
   * @schema TaskSpecInitProviderOptions#securityDescriptorCopyFlags
   */
  readonly securityDescriptorCopyFlags?: string;

  /**
   * Determines whether tasks should be queued before executing the tasks. Valid values: ENABLED, DISABLED. Default ENABLED.
   *
   * @schema TaskSpecInitProviderOptions#taskQueueing
   */
  readonly taskQueueing?: string;

  /**
   * Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location. Valid values: CHANGED, ALL. Default: CHANGED
   *
   * @schema TaskSpecInitProviderOptions#transferMode
   */
  readonly transferMode?: string;

  /**
   * User identifier of the file's owners. Valid values: BOTH, INT_VALUE, NAME, NONE. Default: INT_VALUE (preserve integer value of the ID).
   *
   * @schema TaskSpecInitProviderOptions#uid
   */
  readonly uid?: string;

  /**
   * Whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred. Valid values: NONE, POINT_IN_TIME_CONSISTENT, ONLY_FILES_TRANSFERRED. Default: POINT_IN_TIME_CONSISTENT.
   *
   * @schema TaskSpecInitProviderOptions#verifyMode
   */
  readonly verifyMode?: string;

}

/**
 * Converts an object of type 'TaskSpecInitProviderOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecInitProviderOptions(obj: TaskSpecInitProviderOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'atime': obj.atime,
    'bytesPerSecond': obj.bytesPerSecond,
    'gid': obj.gid,
    'logLevel': obj.logLevel,
    'mtime': obj.mtime,
    'overwriteMode': obj.overwriteMode,
    'posixPermissions': obj.posixPermissions,
    'preserveDeletedFiles': obj.preserveDeletedFiles,
    'preserveDevices': obj.preserveDevices,
    'securityDescriptorCopyFlags': obj.securityDescriptorCopyFlags,
    'taskQueueing': obj.taskQueueing,
    'transferMode': obj.transferMode,
    'uid': obj.uid,
    'verifyMode': obj.verifyMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskSpecInitProviderSchedule
 */
export interface TaskSpecInitProviderSchedule {
  /**
   * Specifies the schedule you want your task to use for repeated executions. For more information, see Schedule Expressions for Rules.
   *
   * @schema TaskSpecInitProviderSchedule#scheduleExpression
   */
  readonly scheduleExpression?: string;

}

/**
 * Converts an object of type 'TaskSpecInitProviderSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecInitProviderSchedule(obj: TaskSpecInitProviderSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scheduleExpression': obj.scheduleExpression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskSpecProviderConfigRefPolicy
 */
export interface TaskSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TaskSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TaskSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecProviderConfigRefPolicy(obj: TaskSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TaskSpecPublishConnectionDetailsToConfigRef
 */
export interface TaskSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TaskSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TaskSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecPublishConnectionDetailsToConfigRef(obj: TaskSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TaskSpecPublishConnectionDetailsToMetadata
 */
export interface TaskSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TaskSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TaskSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TaskSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TaskSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecPublishConnectionDetailsToMetadata(obj: TaskSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskSpecForProviderCloudwatchLogGroupArnRefPolicy
 */
export interface TaskSpecForProviderCloudwatchLogGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskSpecForProviderCloudwatchLogGroupArnRefPolicy#resolution
   */
  readonly resolution?: TaskSpecForProviderCloudwatchLogGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskSpecForProviderCloudwatchLogGroupArnRefPolicy#resolve
   */
  readonly resolve?: TaskSpecForProviderCloudwatchLogGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskSpecForProviderCloudwatchLogGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderCloudwatchLogGroupArnRefPolicy(obj: TaskSpecForProviderCloudwatchLogGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicy
 */
export interface TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicy(obj: TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskSpecForProviderDestinationLocationArnRefPolicy
 */
export interface TaskSpecForProviderDestinationLocationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskSpecForProviderDestinationLocationArnRefPolicy#resolution
   */
  readonly resolution?: TaskSpecForProviderDestinationLocationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskSpecForProviderDestinationLocationArnRefPolicy#resolve
   */
  readonly resolve?: TaskSpecForProviderDestinationLocationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskSpecForProviderDestinationLocationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderDestinationLocationArnRefPolicy(obj: TaskSpecForProviderDestinationLocationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TaskSpecForProviderDestinationLocationArnSelectorPolicy
 */
export interface TaskSpecForProviderDestinationLocationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskSpecForProviderDestinationLocationArnSelectorPolicy#resolution
   */
  readonly resolution?: TaskSpecForProviderDestinationLocationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskSpecForProviderDestinationLocationArnSelectorPolicy#resolve
   */
  readonly resolve?: TaskSpecForProviderDestinationLocationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TaskSpecForProviderDestinationLocationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderDestinationLocationArnSelectorPolicy(obj: TaskSpecForProviderDestinationLocationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskSpecForProviderSourceLocationArnRefPolicy
 */
export interface TaskSpecForProviderSourceLocationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskSpecForProviderSourceLocationArnRefPolicy#resolution
   */
  readonly resolution?: TaskSpecForProviderSourceLocationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskSpecForProviderSourceLocationArnRefPolicy#resolve
   */
  readonly resolve?: TaskSpecForProviderSourceLocationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskSpecForProviderSourceLocationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderSourceLocationArnRefPolicy(obj: TaskSpecForProviderSourceLocationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TaskSpecForProviderSourceLocationArnSelectorPolicy
 */
export interface TaskSpecForProviderSourceLocationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskSpecForProviderSourceLocationArnSelectorPolicy#resolution
   */
  readonly resolution?: TaskSpecForProviderSourceLocationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskSpecForProviderSourceLocationArnSelectorPolicy#resolve
   */
  readonly resolve?: TaskSpecForProviderSourceLocationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TaskSpecForProviderSourceLocationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecForProviderSourceLocationArnSelectorPolicy(obj: TaskSpecForProviderSourceLocationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskSpecProviderConfigRefPolicyResolution
 */
export enum TaskSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskSpecProviderConfigRefPolicyResolve
 */
export enum TaskSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TaskSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TaskSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TaskSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TaskSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskSpecPublishConnectionDetailsToConfigRefPolicy(obj: TaskSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskSpecForProviderCloudwatchLogGroupArnRefPolicyResolution
 */
export enum TaskSpecForProviderCloudwatchLogGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskSpecForProviderCloudwatchLogGroupArnRefPolicyResolve
 */
export enum TaskSpecForProviderCloudwatchLogGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicyResolution
 */
export enum TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicyResolve
 */
export enum TaskSpecForProviderCloudwatchLogGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskSpecForProviderDestinationLocationArnRefPolicyResolution
 */
export enum TaskSpecForProviderDestinationLocationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskSpecForProviderDestinationLocationArnRefPolicyResolve
 */
export enum TaskSpecForProviderDestinationLocationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskSpecForProviderDestinationLocationArnSelectorPolicyResolution
 */
export enum TaskSpecForProviderDestinationLocationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskSpecForProviderDestinationLocationArnSelectorPolicyResolve
 */
export enum TaskSpecForProviderDestinationLocationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskSpecForProviderSourceLocationArnRefPolicyResolution
 */
export enum TaskSpecForProviderSourceLocationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskSpecForProviderSourceLocationArnRefPolicyResolve
 */
export enum TaskSpecForProviderSourceLocationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskSpecForProviderSourceLocationArnSelectorPolicyResolution
 */
export enum TaskSpecForProviderSourceLocationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskSpecForProviderSourceLocationArnSelectorPolicyResolve
 */
export enum TaskSpecForProviderSourceLocationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TaskSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TaskSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

