// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ScalingPlan is the Schema for the ScalingPlans API. Manages an AWS Auto Scaling scaling plan.
 *
 * @schema ScalingPlan
 */
export class ScalingPlan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ScalingPlan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'autoscalingplans.aws.upbound.io/v1beta1',
    kind: 'ScalingPlan',
  }

  /**
   * Renders a Kubernetes manifest for "ScalingPlan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScalingPlanProps): any {
    return {
      ...ScalingPlan.GVK,
      ...toJson_ScalingPlanProps(props),
    };
  }

  /**
   * Defines a "ScalingPlan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScalingPlanProps) {
    super(scope, id, {
      ...ScalingPlan.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ScalingPlan.GVK,
      ...toJson_ScalingPlanProps(resolved),
    };
  }
}

/**
 * ScalingPlan is the Schema for the ScalingPlans API. Manages an AWS Auto Scaling scaling plan.
 *
 * @schema ScalingPlan
 */
export interface ScalingPlanProps {
  /**
   * @schema ScalingPlan#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScalingPlanSpec defines the desired state of ScalingPlan
   *
   * @schema ScalingPlan#spec
   */
  readonly spec: ScalingPlanSpec;

}

/**
 * Converts an object of type 'ScalingPlanProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanProps(obj: ScalingPlanProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScalingPlanSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScalingPlanSpec defines the desired state of ScalingPlan
 *
 * @schema ScalingPlanSpec
 */
export interface ScalingPlanSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScalingPlanSpec#deletionPolicy
   */
  readonly deletionPolicy?: ScalingPlanSpecDeletionPolicy;

  /**
   * @schema ScalingPlanSpec#forProvider
   */
  readonly forProvider: ScalingPlanSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScalingPlanSpec#managementPolicy
   */
  readonly managementPolicy?: ScalingPlanSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ScalingPlanSpec#providerConfigRef
   */
  readonly providerConfigRef?: ScalingPlanSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ScalingPlanSpec#providerRef
   */
  readonly providerRef?: ScalingPlanSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ScalingPlanSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ScalingPlanSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ScalingPlanSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ScalingPlanSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ScalingPlanSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpec(obj: ScalingPlanSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ScalingPlanSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ScalingPlanSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ScalingPlanSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ScalingPlanSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ScalingPlanSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScalingPlanSpecDeletionPolicy
 */
export enum ScalingPlanSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ScalingPlanSpecForProvider
 */
export interface ScalingPlanSpecForProvider {
  /**
   * CloudFormation stack or set of tags. You can create one scaling plan per application source.
   *
   * @schema ScalingPlanSpecForProvider#applicationSource
   */
  readonly applicationSource?: ScalingPlanSpecForProviderApplicationSource[];

  /**
   * Name of the scaling plan. Names cannot contain vertical bars, colons, or forward slashes.
   *
   * @schema ScalingPlanSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ScalingPlanSpecForProvider#region
   */
  readonly region: string;

  /**
   * Scaling instructions. More details can be found in the AWS Auto Scaling API Reference.
   *
   * @schema ScalingPlanSpecForProvider#scalingInstruction
   */
  readonly scalingInstruction?: ScalingPlanSpecForProviderScalingInstruction[];

}

/**
 * Converts an object of type 'ScalingPlanSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecForProvider(obj: ScalingPlanSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationSource': obj.applicationSource?.map(y => toJson_ScalingPlanSpecForProviderApplicationSource(y)),
    'name': obj.name,
    'region': obj.region,
    'scalingInstruction': obj.scalingInstruction?.map(y => toJson_ScalingPlanSpecForProviderScalingInstruction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScalingPlanSpecManagementPolicy
 */
export enum ScalingPlanSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ScalingPlanSpecProviderConfigRef
 */
export interface ScalingPlanSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScalingPlanSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScalingPlanSpecProviderConfigRef#policy
   */
  readonly policy?: ScalingPlanSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ScalingPlanSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecProviderConfigRef(obj: ScalingPlanSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScalingPlanSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ScalingPlanSpecProviderRef
 */
export interface ScalingPlanSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScalingPlanSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScalingPlanSpecProviderRef#policy
   */
  readonly policy?: ScalingPlanSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ScalingPlanSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecProviderRef(obj: ScalingPlanSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScalingPlanSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ScalingPlanSpecPublishConnectionDetailsTo
 */
export interface ScalingPlanSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ScalingPlanSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ScalingPlanSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ScalingPlanSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ScalingPlanSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ScalingPlanSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ScalingPlanSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecPublishConnectionDetailsTo(obj: ScalingPlanSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ScalingPlanSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ScalingPlanSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ScalingPlanSpecWriteConnectionSecretToRef
 */
export interface ScalingPlanSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ScalingPlanSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ScalingPlanSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ScalingPlanSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecWriteConnectionSecretToRef(obj: ScalingPlanSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScalingPlanSpecForProviderApplicationSource
 */
export interface ScalingPlanSpecForProviderApplicationSource {
  /**
   * ARN of a AWS CloudFormation stack.
   *
   * @schema ScalingPlanSpecForProviderApplicationSource#cloudformationStackArn
   */
  readonly cloudformationStackArn?: string;

  /**
   * Set of tags.
   *
   * @schema ScalingPlanSpecForProviderApplicationSource#tagFilter
   */
  readonly tagFilter?: ScalingPlanSpecForProviderApplicationSourceTagFilter[];

}

/**
 * Converts an object of type 'ScalingPlanSpecForProviderApplicationSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecForProviderApplicationSource(obj: ScalingPlanSpecForProviderApplicationSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudformationStackArn': obj.cloudformationStackArn,
    'tagFilter': obj.tagFilter?.map(y => toJson_ScalingPlanSpecForProviderApplicationSourceTagFilter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScalingPlanSpecForProviderScalingInstruction
 */
export interface ScalingPlanSpecForProviderScalingInstruction {
  /**
   * Customized load metric to use for predictive scaling. You must specify either customized_load_metric_specification or predefined_load_metric_specification when configuring predictive scaling. More details can be found in the AWS Auto Scaling API Reference.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#customizedLoadMetricSpecification
   */
  readonly customizedLoadMetricSpecification?: ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification[];

  /**
   * Boolean controlling whether dynamic scaling by AWS Auto Scaling is disabled. Defaults to false.
   *
   * @default false.
   * @schema ScalingPlanSpecForProviderScalingInstruction#disableDynamicScaling
   */
  readonly disableDynamicScaling?: boolean;

  /**
   * Maximum capacity of the resource. The exception to this upper limit is if you specify a non-default setting for predictive_scaling_max_capacity_behavior.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#maxCapacity
   */
  readonly maxCapacity: number;

  /**
   * Minimum capacity of the resource.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#minCapacity
   */
  readonly minCapacity: number;

  /**
   * Predefined load metric to use for predictive scaling. You must specify either predefined_load_metric_specification or customized_load_metric_specification when configuring predictive scaling. More details can be found in the AWS Auto Scaling API Reference.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#predefinedLoadMetricSpecification
   */
  readonly predefinedLoadMetricSpecification?: ScalingPlanSpecForProviderScalingInstructionPredefinedLoadMetricSpecification[];

  /**
   * Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity specified for the resource. Valid values: SetForecastCapacityToMaxCapacity, SetMaxCapacityAboveForecastCapacity, SetMaxCapacityToForecastCapacity.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#predictiveScalingMaxCapacityBehavior
   */
  readonly predictiveScalingMaxCapacityBehavior?: string;

  /**
   * Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#predictiveScalingMaxCapacityBuffer
   */
  readonly predictiveScalingMaxCapacityBuffer?: number;

  /**
   * Predictive scaling mode. Valid values: ForecastAndScale, ForecastOnly.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#predictiveScalingMode
   */
  readonly predictiveScalingMode?: string;

  /**
   * ID of the resource. This string consists of the resource type and unique identifier.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#resourceId
   */
  readonly resourceId: string;

  /**
   * Scalable dimension associated with the resource. Valid values: autoscaling:autoScalingGroup:DesiredCapacity, dynamodb:index:ReadCapacityUnits, dynamodb:index:WriteCapacityUnits, dynamodb:table:ReadCapacityUnits, dynamodb:table:WriteCapacityUnits, ecs:service:DesiredCount, ec2:spot-fleet-request:TargetCapacity, rds:cluster:ReadReplicaCount.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#scalableDimension
   */
  readonly scalableDimension: string;

  /**
   * Controls whether a resource's externally created scaling policies are kept or replaced. Valid values: KeepExternalPolicies, ReplaceExternalPolicies. Defaults to KeepExternalPolicies.
   *
   * @default KeepExternalPolicies.
   * @schema ScalingPlanSpecForProviderScalingInstruction#scalingPolicyUpdateBehavior
   */
  readonly scalingPolicyUpdateBehavior?: string;

  /**
   * Amount of time, in seconds, to buffer the run time of scheduled scaling actions when scaling out.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#scheduledActionBufferTime
   */
  readonly scheduledActionBufferTime?: number;

  /**
   * Namespace of the AWS service. Valid values: autoscaling, dynamodb, ecs, ec2, rds.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#serviceNamespace
   */
  readonly serviceNamespace: string;

  /**
   * Structure that defines new target tracking configurations. Each of these structures includes a specific scaling metric and a target value for the metric, along with various parameters to use with dynamic scaling. More details can be found in the AWS Auto Scaling API Reference.
   *
   * @schema ScalingPlanSpecForProviderScalingInstruction#targetTrackingConfiguration
   */
  readonly targetTrackingConfiguration: ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration[];

}

/**
 * Converts an object of type 'ScalingPlanSpecForProviderScalingInstruction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecForProviderScalingInstruction(obj: ScalingPlanSpecForProviderScalingInstruction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customizedLoadMetricSpecification': obj.customizedLoadMetricSpecification?.map(y => toJson_ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification(y)),
    'disableDynamicScaling': obj.disableDynamicScaling,
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
    'predefinedLoadMetricSpecification': obj.predefinedLoadMetricSpecification?.map(y => toJson_ScalingPlanSpecForProviderScalingInstructionPredefinedLoadMetricSpecification(y)),
    'predictiveScalingMaxCapacityBehavior': obj.predictiveScalingMaxCapacityBehavior,
    'predictiveScalingMaxCapacityBuffer': obj.predictiveScalingMaxCapacityBuffer,
    'predictiveScalingMode': obj.predictiveScalingMode,
    'resourceId': obj.resourceId,
    'scalableDimension': obj.scalableDimension,
    'scalingPolicyUpdateBehavior': obj.scalingPolicyUpdateBehavior,
    'scheduledActionBufferTime': obj.scheduledActionBufferTime,
    'serviceNamespace': obj.serviceNamespace,
    'targetTrackingConfiguration': obj.targetTrackingConfiguration?.map(y => toJson_ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScalingPlanSpecProviderConfigRefPolicy
 */
export interface ScalingPlanSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScalingPlanSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ScalingPlanSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScalingPlanSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ScalingPlanSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScalingPlanSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecProviderConfigRefPolicy(obj: ScalingPlanSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScalingPlanSpecProviderRefPolicy
 */
export interface ScalingPlanSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScalingPlanSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ScalingPlanSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScalingPlanSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ScalingPlanSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ScalingPlanSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecProviderRefPolicy(obj: ScalingPlanSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ScalingPlanSpecPublishConnectionDetailsToConfigRef
 */
export interface ScalingPlanSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScalingPlanSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScalingPlanSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ScalingPlanSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecPublishConnectionDetailsToConfigRef(obj: ScalingPlanSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ScalingPlanSpecPublishConnectionDetailsToMetadata
 */
export interface ScalingPlanSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScalingPlanSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScalingPlanSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ScalingPlanSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScalingPlanSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecPublishConnectionDetailsToMetadata(obj: ScalingPlanSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScalingPlanSpecForProviderApplicationSourceTagFilter
 */
export interface ScalingPlanSpecForProviderApplicationSourceTagFilter {
  /**
   * Tag key.
   *
   * @schema ScalingPlanSpecForProviderApplicationSourceTagFilter#key
   */
  readonly key: string;

  /**
   * Tag values.
   *
   * @schema ScalingPlanSpecForProviderApplicationSourceTagFilter#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ScalingPlanSpecForProviderApplicationSourceTagFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecForProviderApplicationSourceTagFilter(obj: ScalingPlanSpecForProviderApplicationSourceTagFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification
 */
export interface ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification {
  /**
   * Dimensions of the metric.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification#dimensions
   */
  readonly dimensions?: { [key: string]: string };

  /**
   * Name of the metric.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification#metricName
   */
  readonly metricName: string;

  /**
   * Namespace of the metric.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification#namespace
   */
  readonly namespace: string;

  /**
   * Statistic of the metric. Currently, the value must always be Sum.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification#statistic
   */
  readonly statistic: string;

  /**
   * Unit of the metric.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification(obj: ScalingPlanSpecForProviderScalingInstructionCustomizedLoadMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': ((obj.dimensions) === undefined) ? undefined : (Object.entries(obj.dimensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
    'statistic': obj.statistic,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScalingPlanSpecForProviderScalingInstructionPredefinedLoadMetricSpecification
 */
export interface ScalingPlanSpecForProviderScalingInstructionPredefinedLoadMetricSpecification {
  /**
   * Metric type. Valid values: ALBTargetGroupRequestCount, ASGTotalCPUUtilization, ASGTotalNetworkIn, ASGTotalNetworkOut.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionPredefinedLoadMetricSpecification#predefinedLoadMetricType
   */
  readonly predefinedLoadMetricType: string;

  /**
   * Identifies the resource associated with the metric type.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionPredefinedLoadMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'ScalingPlanSpecForProviderScalingInstructionPredefinedLoadMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecForProviderScalingInstructionPredefinedLoadMetricSpecification(obj: ScalingPlanSpecForProviderScalingInstructionPredefinedLoadMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedLoadMetricType': obj.predefinedLoadMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration
 */
export interface ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration {
  /**
   * Customized metric. You can specify either customized_scaling_metric_specification or predefined_scaling_metric_specification. More details can be found in the AWS Auto Scaling API Reference.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration#customizedScalingMetricSpecification
   */
  readonly customizedScalingMetricSpecification?: ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification[];

  /**
   * Boolean indicating whether scale in by the target tracking scaling policy is disabled. Defaults to false.
   *
   * @default false.
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration#disableScaleIn
   */
  readonly disableScaleIn?: boolean;

  /**
   * Estimated time, in seconds, until a newly launched instance can contribute to the CloudWatch metrics. This value is used only if the resource is an Auto Scaling group.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration#estimatedInstanceWarmup
   */
  readonly estimatedInstanceWarmup?: number;

  /**
   * Predefined metric. You can specify either predefined_scaling_metric_specification or customized_scaling_metric_specification. More details can be found in the AWS Auto Scaling API Reference.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration#predefinedScalingMetricSpecification
   */
  readonly predefinedScalingMetricSpecification?: ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification[];

  /**
   * Amount of time, in seconds, after a scale in activity completes before another scale in activity can start. This value is not used if the scalable resource is an Auto Scaling group.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration#scaleInCooldown
   */
  readonly scaleInCooldown?: number;

  /**
   * Amount of time, in seconds, after a scale-out activity completes before another scale-out activity can start. This value is not used if the scalable resource is an Auto Scaling group.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration#scaleOutCooldown
   */
  readonly scaleOutCooldown?: number;

  /**
   * Target value for the metric.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration#targetValue
   */
  readonly targetValue: number;

}

/**
 * Converts an object of type 'ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration(obj: ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customizedScalingMetricSpecification': obj.customizedScalingMetricSpecification?.map(y => toJson_ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification(y)),
    'disableScaleIn': obj.disableScaleIn,
    'estimatedInstanceWarmup': obj.estimatedInstanceWarmup,
    'predefinedScalingMetricSpecification': obj.predefinedScalingMetricSpecification?.map(y => toJson_ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification(y)),
    'scaleInCooldown': obj.scaleInCooldown,
    'scaleOutCooldown': obj.scaleOutCooldown,
    'targetValue': obj.targetValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScalingPlanSpecProviderConfigRefPolicyResolution
 */
export enum ScalingPlanSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScalingPlanSpecProviderConfigRefPolicyResolve
 */
export enum ScalingPlanSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScalingPlanSpecProviderRefPolicyResolution
 */
export enum ScalingPlanSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScalingPlanSpecProviderRefPolicyResolve
 */
export enum ScalingPlanSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicy(obj: ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification
 */
export interface ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification {
  /**
   * Dimensions of the metric.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification#dimensions
   */
  readonly dimensions?: { [key: string]: string };

  /**
   * Name of the metric.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification#metricName
   */
  readonly metricName: string;

  /**
   * Namespace of the metric.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification#namespace
   */
  readonly namespace: string;

  /**
   * Statistic of the metric. Currently, the value must always be Sum.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification#statistic
   */
  readonly statistic: string;

  /**
   * Unit of the metric.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification(obj: ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationCustomizedScalingMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': ((obj.dimensions) === undefined) ? undefined : (Object.entries(obj.dimensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
    'statistic': obj.statistic,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification
 */
export interface ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification {
  /**
   * Metric type. Valid values: ALBRequestCountPerTarget, ASGAverageCPUUtilization, ASGAverageNetworkIn, ASGAverageNetworkOut, DynamoDBReadCapacityUtilization, DynamoDBWriteCapacityUtilization, ECSServiceAverageCPUUtilization, ECSServiceAverageMemoryUtilization, EC2SpotFleetRequestAverageCPUUtilization, EC2SpotFleetRequestAverageNetworkIn, EC2SpotFleetRequestAverageNetworkOut, RDSReaderAverageCPUUtilization, RDSReaderAverageDatabaseConnections.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification#predefinedScalingMetricType
   */
  readonly predefinedScalingMetricType: string;

  /**
   * Identifies the resource associated with the metric type.
   *
   * @schema ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification(obj: ScalingPlanSpecForProviderScalingInstructionTargetTrackingConfigurationPredefinedScalingMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedScalingMetricType': obj.predefinedScalingMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ScalingPlanSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

