// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Backup is the Schema for the Backups API. Manages a FSx Backup.
 *
 * @schema Backup
 */
export class Backup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Backup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'fsx.aws.upbound.io/v1beta1',
    kind: 'Backup',
  }

  /**
   * Renders a Kubernetes manifest for "Backup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupProps): any {
    return {
      ...Backup.GVK,
      ...toJson_BackupProps(props),
    };
  }

  /**
   * Defines a "Backup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupProps) {
    super(scope, id, {
      ...Backup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Backup.GVK,
      ...toJson_BackupProps(resolved),
    };
  }
}

/**
 * Backup is the Schema for the Backups API. Manages a FSx Backup.
 *
 * @schema Backup
 */
export interface BackupProps {
  /**
   * @schema Backup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupSpec defines the desired state of Backup
   *
   * @schema Backup#spec
   */
  readonly spec: BackupSpec;

}

/**
 * Converts an object of type 'BackupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupProps(obj: BackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupSpec defines the desired state of Backup
 *
 * @schema BackupSpec
 */
export interface BackupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BackupSpec#deletionPolicy
   */
  readonly deletionPolicy?: BackupSpecDeletionPolicy;

  /**
   * @schema BackupSpec#forProvider
   */
  readonly forProvider: BackupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BackupSpec#managementPolicy
   */
  readonly managementPolicy?: BackupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BackupSpec#providerConfigRef
   */
  readonly providerConfigRef?: BackupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BackupSpec#providerRef
   */
  readonly providerRef?: BackupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BackupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BackupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BackupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BackupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BackupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpec(obj: BackupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BackupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_BackupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BackupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BackupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BackupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BackupSpecDeletionPolicy
 */
export enum BackupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BackupSpecForProvider
 */
export interface BackupSpecForProvider {
  /**
   * The ID of the file system to back up. Required if backing up Lustre or Windows file systems.
   *
   * @schema BackupSpecForProvider#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * Reference to a LustreFileSystem in fsx to populate fileSystemId.
   *
   * @schema BackupSpecForProvider#fileSystemIdRef
   */
  readonly fileSystemIdRef?: BackupSpecForProviderFileSystemIdRef;

  /**
   * Selector for a LustreFileSystem in fsx to populate fileSystemId.
   *
   * @schema BackupSpecForProvider#fileSystemIdSelector
   */
  readonly fileSystemIdSelector?: BackupSpecForProviderFileSystemIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BackupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema BackupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The ID of the volume to back up. Required if backing up a ONTAP Volume.
   *
   * @schema BackupSpecForProvider#volumeId
   */
  readonly volumeId?: string;

}

/**
 * Converts an object of type 'BackupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProvider(obj: BackupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'fileSystemIdRef': toJson_BackupSpecForProviderFileSystemIdRef(obj.fileSystemIdRef),
    'fileSystemIdSelector': toJson_BackupSpecForProviderFileSystemIdSelector(obj.fileSystemIdSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'volumeId': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BackupSpecManagementPolicy
 */
export enum BackupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BackupSpecProviderConfigRef
 */
export interface BackupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupSpecProviderConfigRef#policy
   */
  readonly policy?: BackupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BackupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecProviderConfigRef(obj: BackupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BackupSpecProviderRef
 */
export interface BackupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupSpecProviderRef#policy
   */
  readonly policy?: BackupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BackupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecProviderRef(obj: BackupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BackupSpecPublishConnectionDetailsTo
 */
export interface BackupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BackupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BackupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BackupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BackupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BackupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsTo(obj: BackupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BackupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BackupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BackupSpecWriteConnectionSecretToRef
 */
export interface BackupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BackupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BackupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BackupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecWriteConnectionSecretToRef(obj: BackupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LustreFileSystem in fsx to populate fileSystemId.
 *
 * @schema BackupSpecForProviderFileSystemIdRef
 */
export interface BackupSpecForProviderFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupSpecForProviderFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupSpecForProviderFileSystemIdRef#policy
   */
  readonly policy?: BackupSpecForProviderFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'BackupSpecForProviderFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderFileSystemIdRef(obj: BackupSpecForProviderFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupSpecForProviderFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LustreFileSystem in fsx to populate fileSystemId.
 *
 * @schema BackupSpecForProviderFileSystemIdSelector
 */
export interface BackupSpecForProviderFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BackupSpecForProviderFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BackupSpecForProviderFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BackupSpecForProviderFileSystemIdSelector#policy
   */
  readonly policy?: BackupSpecForProviderFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'BackupSpecForProviderFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderFileSystemIdSelector(obj: BackupSpecForProviderFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BackupSpecForProviderFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupSpecProviderConfigRefPolicy
 */
export interface BackupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BackupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BackupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecProviderConfigRefPolicy(obj: BackupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupSpecProviderRefPolicy
 */
export interface BackupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BackupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BackupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecProviderRefPolicy(obj: BackupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRef
 */
export interface BackupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BackupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsToConfigRef(obj: BackupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BackupSpecPublishConnectionDetailsToMetadata
 */
export interface BackupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BackupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsToMetadata(obj: BackupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupSpecForProviderFileSystemIdRefPolicy
 */
export interface BackupSpecForProviderFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecForProviderFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: BackupSpecForProviderFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecForProviderFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: BackupSpecForProviderFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecForProviderFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderFileSystemIdRefPolicy(obj: BackupSpecForProviderFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BackupSpecForProviderFileSystemIdSelectorPolicy
 */
export interface BackupSpecForProviderFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecForProviderFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: BackupSpecForProviderFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecForProviderFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: BackupSpecForProviderFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecForProviderFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderFileSystemIdSelectorPolicy(obj: BackupSpecForProviderFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecProviderConfigRefPolicyResolution
 */
export enum BackupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecProviderConfigRefPolicyResolve
 */
export enum BackupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecProviderRefPolicyResolution
 */
export enum BackupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecProviderRefPolicyResolve
 */
export enum BackupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BackupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BackupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BackupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsToConfigRefPolicy(obj: BackupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecForProviderFileSystemIdRefPolicyResolution
 */
export enum BackupSpecForProviderFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecForProviderFileSystemIdRefPolicyResolve
 */
export enum BackupSpecForProviderFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecForProviderFileSystemIdSelectorPolicyResolution
 */
export enum BackupSpecForProviderFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecForProviderFileSystemIdSelectorPolicyResolve
 */
export enum BackupSpecForProviderFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BackupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BackupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DataRepositoryAssociation is the Schema for the DataRepositoryAssociations API. Manages a FSx for Lustre Data Repository Association.
 *
 * @schema DataRepositoryAssociation
 */
export class DataRepositoryAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DataRepositoryAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'fsx.aws.upbound.io/v1beta1',
    kind: 'DataRepositoryAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "DataRepositoryAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DataRepositoryAssociationProps): any {
    return {
      ...DataRepositoryAssociation.GVK,
      ...toJson_DataRepositoryAssociationProps(props),
    };
  }

  /**
   * Defines a "DataRepositoryAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DataRepositoryAssociationProps) {
    super(scope, id, {
      ...DataRepositoryAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DataRepositoryAssociation.GVK,
      ...toJson_DataRepositoryAssociationProps(resolved),
    };
  }
}

/**
 * DataRepositoryAssociation is the Schema for the DataRepositoryAssociations API. Manages a FSx for Lustre Data Repository Association.
 *
 * @schema DataRepositoryAssociation
 */
export interface DataRepositoryAssociationProps {
  /**
   * @schema DataRepositoryAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DataRepositoryAssociationSpec defines the desired state of DataRepositoryAssociation
   *
   * @schema DataRepositoryAssociation#spec
   */
  readonly spec: DataRepositoryAssociationSpec;

}

/**
 * Converts an object of type 'DataRepositoryAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationProps(obj: DataRepositoryAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DataRepositoryAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataRepositoryAssociationSpec defines the desired state of DataRepositoryAssociation
 *
 * @schema DataRepositoryAssociationSpec
 */
export interface DataRepositoryAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DataRepositoryAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: DataRepositoryAssociationSpecDeletionPolicy;

  /**
   * @schema DataRepositoryAssociationSpec#forProvider
   */
  readonly forProvider: DataRepositoryAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DataRepositoryAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: DataRepositoryAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DataRepositoryAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: DataRepositoryAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DataRepositoryAssociationSpec#providerRef
   */
  readonly providerRef?: DataRepositoryAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DataRepositoryAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DataRepositoryAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DataRepositoryAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DataRepositoryAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpec(obj: DataRepositoryAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DataRepositoryAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DataRepositoryAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DataRepositoryAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DataRepositoryAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DataRepositoryAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DataRepositoryAssociationSpecDeletionPolicy
 */
export enum DataRepositoryAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DataRepositoryAssociationSpecForProvider
 */
export interface DataRepositoryAssociationSpecForProvider {
  /**
   * Set to true to run an import data repository task to import metadata from the data repository to the file system after the data repository association is created. Defaults to false.
   *
   * @default false.
   * @schema DataRepositoryAssociationSpecForProvider#batchImportMetaDataOnCreate
   */
  readonly batchImportMetaDataOnCreate?: boolean;

  /**
   * The path to the Amazon S3 data repository that will be linked to the file system. The path must be an S3 bucket s3://myBucket/myPrefix/. This path specifies where in the S3 data repository files will be imported from or exported to. The same S3 bucket cannot be linked more than once to the same file system.
   *
   * @schema DataRepositoryAssociationSpecForProvider#dataRepositoryPath
   */
  readonly dataRepositoryPath?: string;

  /**
   * Set to true to delete files from the file system upon deleting this data repository association. Defaults to false.
   *
   * @default false.
   * @schema DataRepositoryAssociationSpecForProvider#deleteDataInFilesystem
   */
  readonly deleteDataInFilesystem?: boolean;

  /**
   * The ID of the Amazon FSx file system to on which to create a data repository association.
   *
   * @schema DataRepositoryAssociationSpecForProvider#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * Reference to a LustreFileSystem in fsx to populate fileSystemId.
   *
   * @schema DataRepositoryAssociationSpecForProvider#fileSystemIdRef
   */
  readonly fileSystemIdRef?: DataRepositoryAssociationSpecForProviderFileSystemIdRef;

  /**
   * Selector for a LustreFileSystem in fsx to populate fileSystemId.
   *
   * @schema DataRepositoryAssociationSpecForProvider#fileSystemIdSelector
   */
  readonly fileSystemIdSelector?: DataRepositoryAssociationSpecForProviderFileSystemIdSelector;

  /**
   * A path on the file system that points to a high-level directory (such as /ns1/) or subdirectory (such as /ns1/subdir/) that will be mapped 1-1 with data_repository_path. The leading forward slash in the name is required. Two data repository associations cannot have overlapping file system paths. For example, if a data repository is associated with file system path /ns1/, then you cannot link another data repository with file system path /ns1/ns2. This path specifies where in your file system files will be exported from or imported to. This file system directory can be linked to only one Amazon S3 bucket, and no other S3 bucket can be linked to the directory.
   *
   * @schema DataRepositoryAssociationSpecForProvider#fileSystemPath
   */
  readonly fileSystemPath?: string;

  /**
   * For files imported from a data repository, this value determines the stripe count and maximum amount of data per file (in MiB) stored on a single physical disk. The maximum number of disks that a single file can be striped across is limited by the total number of disks that make up the file system.
   *
   * @schema DataRepositoryAssociationSpecForProvider#importedFileChunkSize
   */
  readonly importedFileChunkSize?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DataRepositoryAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * See the s3 configuration block. Max of 1. The configuration for an Amazon S3 data repository linked to an Amazon FSx Lustre file system with a data repository association. The configuration defines which file events (new, changed, or deleted files or directories) are automatically imported from the linked data repository to the file system or automatically exported from the file system to the data repository.
   *
   * @schema DataRepositoryAssociationSpecForProvider#s3
   */
  readonly s3?: DataRepositoryAssociationSpecForProviderS3[];

  /**
   * Key-value map of resource tags.
   *
   * @schema DataRepositoryAssociationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecForProvider(obj: DataRepositoryAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchImportMetaDataOnCreate': obj.batchImportMetaDataOnCreate,
    'dataRepositoryPath': obj.dataRepositoryPath,
    'deleteDataInFilesystem': obj.deleteDataInFilesystem,
    'fileSystemId': obj.fileSystemId,
    'fileSystemIdRef': toJson_DataRepositoryAssociationSpecForProviderFileSystemIdRef(obj.fileSystemIdRef),
    'fileSystemIdSelector': toJson_DataRepositoryAssociationSpecForProviderFileSystemIdSelector(obj.fileSystemIdSelector),
    'fileSystemPath': obj.fileSystemPath,
    'importedFileChunkSize': obj.importedFileChunkSize,
    'region': obj.region,
    's3': obj.s3?.map(y => toJson_DataRepositoryAssociationSpecForProviderS3(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DataRepositoryAssociationSpecManagementPolicy
 */
export enum DataRepositoryAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DataRepositoryAssociationSpecProviderConfigRef
 */
export interface DataRepositoryAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataRepositoryAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataRepositoryAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: DataRepositoryAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecProviderConfigRef(obj: DataRepositoryAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataRepositoryAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DataRepositoryAssociationSpecProviderRef
 */
export interface DataRepositoryAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataRepositoryAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataRepositoryAssociationSpecProviderRef#policy
   */
  readonly policy?: DataRepositoryAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecProviderRef(obj: DataRepositoryAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataRepositoryAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DataRepositoryAssociationSpecPublishConnectionDetailsTo
 */
export interface DataRepositoryAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DataRepositoryAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DataRepositoryAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DataRepositoryAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DataRepositoryAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecPublishConnectionDetailsTo(obj: DataRepositoryAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DataRepositoryAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DataRepositoryAssociationSpecWriteConnectionSecretToRef
 */
export interface DataRepositoryAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DataRepositoryAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DataRepositoryAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecWriteConnectionSecretToRef(obj: DataRepositoryAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LustreFileSystem in fsx to populate fileSystemId.
 *
 * @schema DataRepositoryAssociationSpecForProviderFileSystemIdRef
 */
export interface DataRepositoryAssociationSpecForProviderFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataRepositoryAssociationSpecForProviderFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataRepositoryAssociationSpecForProviderFileSystemIdRef#policy
   */
  readonly policy?: DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecForProviderFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecForProviderFileSystemIdRef(obj: DataRepositoryAssociationSpecForProviderFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LustreFileSystem in fsx to populate fileSystemId.
 *
 * @schema DataRepositoryAssociationSpecForProviderFileSystemIdSelector
 */
export interface DataRepositoryAssociationSpecForProviderFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DataRepositoryAssociationSpecForProviderFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DataRepositoryAssociationSpecForProviderFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DataRepositoryAssociationSpecForProviderFileSystemIdSelector#policy
   */
  readonly policy?: DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecForProviderFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecForProviderFileSystemIdSelector(obj: DataRepositoryAssociationSpecForProviderFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataRepositoryAssociationSpecForProviderS3
 */
export interface DataRepositoryAssociationSpecForProviderS3 {
  /**
   * Specifies the type of updated objects that will be automatically exported from your file system to the linked S3 bucket. See the events configuration block.
   *
   * @schema DataRepositoryAssociationSpecForProviderS3#autoExportPolicy
   */
  readonly autoExportPolicy?: DataRepositoryAssociationSpecForProviderS3AutoExportPolicy[];

  /**
   * Specifies the type of updated objects that will be automatically imported from the linked S3 bucket to your file system. See the events configuration block.
   *
   * @schema DataRepositoryAssociationSpecForProviderS3#autoImportPolicy
   */
  readonly autoImportPolicy?: DataRepositoryAssociationSpecForProviderS3AutoImportPolicy[];

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecForProviderS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecForProviderS3(obj: DataRepositoryAssociationSpecForProviderS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoExportPolicy': obj.autoExportPolicy?.map(y => toJson_DataRepositoryAssociationSpecForProviderS3AutoExportPolicy(y)),
    'autoImportPolicy': obj.autoImportPolicy?.map(y => toJson_DataRepositoryAssociationSpecForProviderS3AutoImportPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataRepositoryAssociationSpecProviderConfigRefPolicy
 */
export interface DataRepositoryAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataRepositoryAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DataRepositoryAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataRepositoryAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DataRepositoryAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecProviderConfigRefPolicy(obj: DataRepositoryAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataRepositoryAssociationSpecProviderRefPolicy
 */
export interface DataRepositoryAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataRepositoryAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DataRepositoryAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataRepositoryAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DataRepositoryAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecProviderRefPolicy(obj: DataRepositoryAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRef(obj: DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface DataRepositoryAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecPublishConnectionDetailsToMetadata(obj: DataRepositoryAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicy
 */
export interface DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicy(obj: DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicy
 */
export interface DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicy(obj: DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataRepositoryAssociationSpecForProviderS3AutoExportPolicy
 */
export interface DataRepositoryAssociationSpecForProviderS3AutoExportPolicy {
  /**
   * A list of file event types to automatically export to your linked S3 bucket or import from the linked S3 bucket. Valid values are NEW, CHANGED, DELETED. Max of 3.
   *
   * @schema DataRepositoryAssociationSpecForProviderS3AutoExportPolicy#events
   */
  readonly events?: string[];

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecForProviderS3AutoExportPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecForProviderS3AutoExportPolicy(obj: DataRepositoryAssociationSpecForProviderS3AutoExportPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataRepositoryAssociationSpecForProviderS3AutoImportPolicy
 */
export interface DataRepositoryAssociationSpecForProviderS3AutoImportPolicy {
  /**
   * A list of file event types to automatically export to your linked S3 bucket or import from the linked S3 bucket. Valid values are NEW, CHANGED, DELETED. Max of 3.
   *
   * @schema DataRepositoryAssociationSpecForProviderS3AutoImportPolicy#events
   */
  readonly events?: string[];

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecForProviderS3AutoImportPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecForProviderS3AutoImportPolicy(obj: DataRepositoryAssociationSpecForProviderS3AutoImportPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataRepositoryAssociationSpecProviderConfigRefPolicyResolution
 */
export enum DataRepositoryAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataRepositoryAssociationSpecProviderConfigRefPolicyResolve
 */
export enum DataRepositoryAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataRepositoryAssociationSpecProviderRefPolicyResolution
 */
export enum DataRepositoryAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataRepositoryAssociationSpecProviderRefPolicyResolve
 */
export enum DataRepositoryAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicyResolution
 */
export enum DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicyResolve
 */
export enum DataRepositoryAssociationSpecForProviderFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicyResolution
 */
export enum DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicyResolve
 */
export enum DataRepositoryAssociationSpecForProviderFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DataRepositoryAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LustreFileSystem is the Schema for the LustreFileSystems API. Manages a FSx Lustre File System.
 *
 * @schema LustreFileSystem
 */
export class LustreFileSystem extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LustreFileSystem"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'fsx.aws.upbound.io/v1beta1',
    kind: 'LustreFileSystem',
  }

  /**
   * Renders a Kubernetes manifest for "LustreFileSystem".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LustreFileSystemProps): any {
    return {
      ...LustreFileSystem.GVK,
      ...toJson_LustreFileSystemProps(props),
    };
  }

  /**
   * Defines a "LustreFileSystem" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LustreFileSystemProps) {
    super(scope, id, {
      ...LustreFileSystem.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LustreFileSystem.GVK,
      ...toJson_LustreFileSystemProps(resolved),
    };
  }
}

/**
 * LustreFileSystem is the Schema for the LustreFileSystems API. Manages a FSx Lustre File System.
 *
 * @schema LustreFileSystem
 */
export interface LustreFileSystemProps {
  /**
   * @schema LustreFileSystem#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LustreFileSystemSpec defines the desired state of LustreFileSystem
   *
   * @schema LustreFileSystem#spec
   */
  readonly spec: LustreFileSystemSpec;

}

/**
 * Converts an object of type 'LustreFileSystemProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemProps(obj: LustreFileSystemProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LustreFileSystemSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LustreFileSystemSpec defines the desired state of LustreFileSystem
 *
 * @schema LustreFileSystemSpec
 */
export interface LustreFileSystemSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LustreFileSystemSpec#deletionPolicy
   */
  readonly deletionPolicy?: LustreFileSystemSpecDeletionPolicy;

  /**
   * @schema LustreFileSystemSpec#forProvider
   */
  readonly forProvider: LustreFileSystemSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LustreFileSystemSpec#managementPolicy
   */
  readonly managementPolicy?: LustreFileSystemSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LustreFileSystemSpec#providerConfigRef
   */
  readonly providerConfigRef?: LustreFileSystemSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LustreFileSystemSpec#providerRef
   */
  readonly providerRef?: LustreFileSystemSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LustreFileSystemSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LustreFileSystemSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LustreFileSystemSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LustreFileSystemSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LustreFileSystemSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpec(obj: LustreFileSystemSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LustreFileSystemSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LustreFileSystemSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LustreFileSystemSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LustreFileSystemSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LustreFileSystemSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LustreFileSystemSpecDeletionPolicy
 */
export enum LustreFileSystemSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LustreFileSystemSpecForProvider
 */
export interface LustreFileSystemSpecForProvider {
  /**
   * How Amazon FSx keeps your file and directory listings up to date as you add or modify objects in your linked S3 bucket. see Auto Import Data Repo for more details. Only supported on PERSISTENT_1 deployment types.
   *
   * @schema LustreFileSystemSpecForProvider#autoImportPolicy
   */
  readonly autoImportPolicy?: string;

  /**
   * The number of days to retain automatic backups. Setting this to 0 disables automatic backups. You can retain automatic backups for a maximum of 90 days. only valid for PERSISTENT_1 and PERSISTENT_2 deployment_type.
   *
   * @schema LustreFileSystemSpecForProvider#automaticBackupRetentionDays
   */
  readonly automaticBackupRetentionDays?: number;

  /**
   * The ID of the source backup to create the filesystem from.
   *
   * @schema LustreFileSystemSpecForProvider#backupId
   */
  readonly backupId?: string;

  /**
   * A boolean flag indicating whether tags for the file system should be copied to backups. Applicable for PERSISTENT_1 and PERSISTENT_2 deployment_type. The default value is false.
   *
   * @schema LustreFileSystemSpecForProvider#copyTagsToBackups
   */
  readonly copyTagsToBackups?: boolean;

  /**
   * A recurring daily time, in the format HH:MM. HH is the zero-padded hour of the day (0-23), and MM is the zero-padded minute of the hour. For example, 05:00 specifies 5 AM daily. only valid for PERSISTENT_1 and PERSISTENT_2 deployment_type. Requires automatic_backup_retention_days to be set.
   *
   * @schema LustreFileSystemSpecForProvider#dailyAutomaticBackupStartTime
   */
  readonly dailyAutomaticBackupStartTime?: string;

  /**
   * Sets the data compression configuration for the file system. Valid values are LZ4 and NONE. Default value is NONE. Unsetting this value reverts the compression type back to NONE.
   *
   * @schema LustreFileSystemSpecForProvider#dataCompressionType
   */
  readonly dataCompressionType?: string;

  /**
   * - The filesystem deployment type. One of: SCRATCH_1, SCRATCH_2, PERSISTENT_1, PERSISTENT_2.
   *
   * @schema LustreFileSystemSpecForProvider#deploymentType
   */
  readonly deploymentType?: string;

  /**
   * - The type of drive cache used by PERSISTENT_1 filesystems that are provisioned with HDD storage_type. Required for HDD storage_type, set to either READ or NONE.
   *
   * @schema LustreFileSystemSpecForProvider#driveCacheType
   */
  readonly driveCacheType?: string;

  /**
   * S3 URI (with optional prefix) where the root of your Amazon FSx file system is exported. Can only be specified with import_path argument and the path must use the same Amazon S3 bucket as specified in import_path. Set equal to import_path to overwrite files on export. Defaults to s3://{IMPORT BUCKET}/FSxLustre{CREATION TIMESTAMP}. Only supported on PERSISTENT_1 deployment types.
   *
   * @default s3://{IMPORT BUCKET}/FSxLustre{CREATION TIMESTAMP}. Only supported on PERSISTENT_1 deployment types.
   * @schema LustreFileSystemSpecForProvider#exportPath
   */
  readonly exportPath?: string;

  /**
   * Sets the Lustre version for the file system that you're creating. Valid values are 2.10 for SCRATCH_1, SCRATCH_2 and PERSISTENT_1 deployment types. Valid values for 2.12 include all deployment types.
   *
   * @schema LustreFileSystemSpecForProvider#fileSystemTypeVersion
   */
  readonly fileSystemTypeVersion?: string;

  /**
   * S3 URI (with optional prefix) that you're using as the data repository for your FSx for Lustre file system. For example, s3://example-bucket/optional-prefix/. Only supported on PERSISTENT_1 deployment types.
   *
   * @schema LustreFileSystemSpecForProvider#importPath
   */
  readonly importPath?: string;

  /**
   * For files imported from a data repository, this value determines the stripe count and maximum amount of data per file (in MiB) stored on a single physical disk. Can only be specified with import_path argument. Defaults to 1024. Minimum of 1 and maximum of 512000. Only supported on PERSISTENT_1 deployment types.
   *
   * @default 1024. Minimum of 1 and maximum of 512000. Only supported on PERSISTENT_1 deployment types.
   * @schema LustreFileSystemSpecForProvider#importedFileChunkSize
   */
  readonly importedFileChunkSize?: number;

  /**
   * ARN for the KMS Key to encrypt the file system at rest, applicable for PERSISTENT_1 and PERSISTENT_2 deployment_type. Defaults to an AWS managed KMS Key.
   *
   * @default an AWS managed KMS Key.
   * @schema LustreFileSystemSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema LustreFileSystemSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: LustreFileSystemSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema LustreFileSystemSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: LustreFileSystemSpecForProviderKmsKeyIdSelector;

  /**
   * The Lustre logging configuration used when creating an Amazon FSx for Lustre file system. When logging is enabled, Lustre logs error and warning events for data repositories associated with your file system to Amazon CloudWatch Logs.
   *
   * @schema LustreFileSystemSpecForProvider#logConfiguration
   */
  readonly logConfiguration?: LustreFileSystemSpecForProviderLogConfiguration[];

  /**
   * - Describes the amount of read and write throughput for each 1 tebibyte of storage, in MB/s/TiB, required for the PERSISTENT_1 and PERSISTENT_2 deployment_type. Valid values for PERSISTENT_1 deployment_type and SSD storage_type are 50, 100, 200. Valid values for PERSISTENT_1 deployment_type and HDD storage_type are 12, 40. Valid values for PERSISTENT_2 deployment_type and  SSD storage_type are 125, 250, 500, 1000.
   *
   * @schema LustreFileSystemSpecForProvider#perUnitStorageThroughput
   */
  readonly perUnitStorageThroughput?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LustreFileSystemSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Lustre root squash configuration used when creating an Amazon FSx for Lustre file system. When enabled, root squash restricts root-level access from clients that try to access your file system as a root user.
   *
   * @schema LustreFileSystemSpecForProvider#rootSquashConfiguration
   */
  readonly rootSquashConfiguration?: LustreFileSystemSpecForProviderRootSquashConfiguration[];

  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema LustreFileSystemSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: LustreFileSystemSpecForProviderSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema LustreFileSystemSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: LustreFileSystemSpecForProviderSecurityGroupIdSelector;

  /**
   * A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups will apply to all network interfaces.
   *
   * @schema LustreFileSystemSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * The storage capacity (GiB) of the file system. Minimum of 1200. See more details at Allowed values for Fsx storage capacity. Update is allowed only for SCRATCH_2, PERSISTENT_1 and PERSISTENT_2 deployment types, See more details at Fsx Storage Capacity Update. Required when not creating filesystem for a backup.
   *
   * @schema LustreFileSystemSpecForProvider#storageCapacity
   */
  readonly storageCapacity?: number;

  /**
   * - The filesystem storage type. Either SSD or HDD, defaults to SSD. HDD is only supported on PERSISTENT_1 deployment types.
   *
   * @schema LustreFileSystemSpecForProvider#storageType
   */
  readonly storageType?: string;

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema LustreFileSystemSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: LustreFileSystemSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema LustreFileSystemSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: LustreFileSystemSpecForProviderSubnetIdSelector;

  /**
   * A list of IDs for the subnets that the file system will be accessible from. File systems currently support only one subnet. The file server is also launched in that subnet's Availability Zone.
   *
   * @schema LustreFileSystemSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema LustreFileSystemSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The preferred start time (in d:HH:MM format) to perform weekly maintenance, in the UTC time zone.
   *
   * @schema LustreFileSystemSpecForProvider#weeklyMaintenanceStartTime
   */
  readonly weeklyMaintenanceStartTime?: string;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProvider(obj: LustreFileSystemSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoImportPolicy': obj.autoImportPolicy,
    'automaticBackupRetentionDays': obj.automaticBackupRetentionDays,
    'backupId': obj.backupId,
    'copyTagsToBackups': obj.copyTagsToBackups,
    'dailyAutomaticBackupStartTime': obj.dailyAutomaticBackupStartTime,
    'dataCompressionType': obj.dataCompressionType,
    'deploymentType': obj.deploymentType,
    'driveCacheType': obj.driveCacheType,
    'exportPath': obj.exportPath,
    'fileSystemTypeVersion': obj.fileSystemTypeVersion,
    'importPath': obj.importPath,
    'importedFileChunkSize': obj.importedFileChunkSize,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_LustreFileSystemSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_LustreFileSystemSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'logConfiguration': obj.logConfiguration?.map(y => toJson_LustreFileSystemSpecForProviderLogConfiguration(y)),
    'perUnitStorageThroughput': obj.perUnitStorageThroughput,
    'region': obj.region,
    'rootSquashConfiguration': obj.rootSquashConfiguration?.map(y => toJson_LustreFileSystemSpecForProviderRootSquashConfiguration(y)),
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_LustreFileSystemSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_LustreFileSystemSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'storageCapacity': obj.storageCapacity,
    'storageType': obj.storageType,
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_LustreFileSystemSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_LustreFileSystemSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'weeklyMaintenanceStartTime': obj.weeklyMaintenanceStartTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LustreFileSystemSpecManagementPolicy
 */
export enum LustreFileSystemSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LustreFileSystemSpecProviderConfigRef
 */
export interface LustreFileSystemSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LustreFileSystemSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LustreFileSystemSpecProviderConfigRef#policy
   */
  readonly policy?: LustreFileSystemSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LustreFileSystemSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecProviderConfigRef(obj: LustreFileSystemSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LustreFileSystemSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LustreFileSystemSpecProviderRef
 */
export interface LustreFileSystemSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LustreFileSystemSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LustreFileSystemSpecProviderRef#policy
   */
  readonly policy?: LustreFileSystemSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LustreFileSystemSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecProviderRef(obj: LustreFileSystemSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LustreFileSystemSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LustreFileSystemSpecPublishConnectionDetailsTo
 */
export interface LustreFileSystemSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LustreFileSystemSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LustreFileSystemSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LustreFileSystemSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LustreFileSystemSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LustreFileSystemSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LustreFileSystemSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecPublishConnectionDetailsTo(obj: LustreFileSystemSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LustreFileSystemSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LustreFileSystemSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LustreFileSystemSpecWriteConnectionSecretToRef
 */
export interface LustreFileSystemSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LustreFileSystemSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LustreFileSystemSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LustreFileSystemSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecWriteConnectionSecretToRef(obj: LustreFileSystemSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema LustreFileSystemSpecForProviderKmsKeyIdRef
 */
export interface LustreFileSystemSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LustreFileSystemSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LustreFileSystemSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: LustreFileSystemSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderKmsKeyIdRef(obj: LustreFileSystemSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LustreFileSystemSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema LustreFileSystemSpecForProviderKmsKeyIdSelector
 */
export interface LustreFileSystemSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LustreFileSystemSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LustreFileSystemSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LustreFileSystemSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderKmsKeyIdSelector(obj: LustreFileSystemSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LustreFileSystemSpecForProviderLogConfiguration
 */
export interface LustreFileSystemSpecForProviderLogConfiguration {
  /**
   * The Amazon Resource Name (ARN) that specifies the destination of the logs. The name of the Amazon CloudWatch Logs log group must begin with the /aws/fsx prefix. If you do not provide a destination, Amazon FSx will create and use a log stream in the CloudWatch Logs /aws/fsx/lustre log group.
   *
   * @schema LustreFileSystemSpecForProviderLogConfiguration#destination
   */
  readonly destination?: string;

  /**
   * Sets which data repository events are logged by Amazon FSx. Valid values are WARN_ONLY, FAILURE_ONLY, ERROR_ONLY, WARN_ERROR and DISABLED. Default value is DISABLED.
   *
   * @schema LustreFileSystemSpecForProviderLogConfiguration#level
   */
  readonly level?: string;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderLogConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderLogConfiguration(obj: LustreFileSystemSpecForProviderLogConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination,
    'level': obj.level,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LustreFileSystemSpecForProviderRootSquashConfiguration
 */
export interface LustreFileSystemSpecForProviderRootSquashConfiguration {
  /**
   * When root squash is enabled, you can optionally specify an array of NIDs of clients for which root squash does not apply. A client NID is a Lustre Network Identifier used to uniquely identify a client. You can specify the NID as either a single address or a range of addresses: 1. A single address is described in standard Lustre NID format by specifying the clients IP address followed by the Lustre network ID (for example, 10.0.1.6@tcp). 2. An address range is described using a dash to separate the range (for example, 10.0.[2-10].[1-255]@tcp).
   *
   * @schema LustreFileSystemSpecForProviderRootSquashConfiguration#noSquashNids
   */
  readonly noSquashNids?: string[];

  /**
   * You enable root squash by setting a user ID (UID) and group ID (GID) for the file system in the format UID:GID (for example, 365534:65534). The UID and GID values can range from 0 to 4294967294.
   *
   * @schema LustreFileSystemSpecForProviderRootSquashConfiguration#rootSquash
   */
  readonly rootSquash?: string;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderRootSquashConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderRootSquashConfiguration(obj: LustreFileSystemSpecForProviderRootSquashConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'noSquashNids': obj.noSquashNids?.map(y => y),
    'rootSquash': obj.rootSquash,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema LustreFileSystemSpecForProviderSecurityGroupIdRefs
 */
export interface LustreFileSystemSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema LustreFileSystemSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LustreFileSystemSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderSecurityGroupIdRefs(obj: LustreFileSystemSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema LustreFileSystemSpecForProviderSecurityGroupIdSelector
 */
export interface LustreFileSystemSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LustreFileSystemSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LustreFileSystemSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LustreFileSystemSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderSecurityGroupIdSelector(obj: LustreFileSystemSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema LustreFileSystemSpecForProviderSubnetIdRefs
 */
export interface LustreFileSystemSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema LustreFileSystemSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LustreFileSystemSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: LustreFileSystemSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderSubnetIdRefs(obj: LustreFileSystemSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LustreFileSystemSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema LustreFileSystemSpecForProviderSubnetIdSelector
 */
export interface LustreFileSystemSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LustreFileSystemSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LustreFileSystemSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LustreFileSystemSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: LustreFileSystemSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderSubnetIdSelector(obj: LustreFileSystemSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LustreFileSystemSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LustreFileSystemSpecProviderConfigRefPolicy
 */
export interface LustreFileSystemSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LustreFileSystemSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LustreFileSystemSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LustreFileSystemSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LustreFileSystemSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LustreFileSystemSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecProviderConfigRefPolicy(obj: LustreFileSystemSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LustreFileSystemSpecProviderRefPolicy
 */
export interface LustreFileSystemSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LustreFileSystemSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LustreFileSystemSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LustreFileSystemSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LustreFileSystemSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LustreFileSystemSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecProviderRefPolicy(obj: LustreFileSystemSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LustreFileSystemSpecPublishConnectionDetailsToConfigRef
 */
export interface LustreFileSystemSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LustreFileSystemSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LustreFileSystemSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LustreFileSystemSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecPublishConnectionDetailsToConfigRef(obj: LustreFileSystemSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LustreFileSystemSpecPublishConnectionDetailsToMetadata
 */
export interface LustreFileSystemSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LustreFileSystemSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LustreFileSystemSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LustreFileSystemSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LustreFileSystemSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecPublishConnectionDetailsToMetadata(obj: LustreFileSystemSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LustreFileSystemSpecForProviderKmsKeyIdRefPolicy
 */
export interface LustreFileSystemSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LustreFileSystemSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: LustreFileSystemSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LustreFileSystemSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: LustreFileSystemSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderKmsKeyIdRefPolicy(obj: LustreFileSystemSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicy(obj: LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicy(obj: LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicy(obj: LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LustreFileSystemSpecForProviderSubnetIdRefsPolicy
 */
export interface LustreFileSystemSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LustreFileSystemSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: LustreFileSystemSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LustreFileSystemSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: LustreFileSystemSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderSubnetIdRefsPolicy(obj: LustreFileSystemSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LustreFileSystemSpecForProviderSubnetIdSelectorPolicy
 */
export interface LustreFileSystemSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LustreFileSystemSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: LustreFileSystemSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LustreFileSystemSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: LustreFileSystemSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LustreFileSystemSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecForProviderSubnetIdSelectorPolicy(obj: LustreFileSystemSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LustreFileSystemSpecProviderConfigRefPolicyResolution
 */
export enum LustreFileSystemSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LustreFileSystemSpecProviderConfigRefPolicyResolve
 */
export enum LustreFileSystemSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LustreFileSystemSpecProviderRefPolicyResolution
 */
export enum LustreFileSystemSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LustreFileSystemSpecProviderRefPolicyResolve
 */
export enum LustreFileSystemSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicy(obj: LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LustreFileSystemSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum LustreFileSystemSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LustreFileSystemSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum LustreFileSystemSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum LustreFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum LustreFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum LustreFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LustreFileSystemSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum LustreFileSystemSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LustreFileSystemSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum LustreFileSystemSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LustreFileSystemSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum LustreFileSystemSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LustreFileSystemSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum LustreFileSystemSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LustreFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OntapFileSystem is the Schema for the OntapFileSystems API. Manages an Amazon FSx for NetApp ONTAP file system.
 *
 * @schema OntapFileSystem
 */
export class OntapFileSystem extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OntapFileSystem"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'fsx.aws.upbound.io/v1beta1',
    kind: 'OntapFileSystem',
  }

  /**
   * Renders a Kubernetes manifest for "OntapFileSystem".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OntapFileSystemProps): any {
    return {
      ...OntapFileSystem.GVK,
      ...toJson_OntapFileSystemProps(props),
    };
  }

  /**
   * Defines a "OntapFileSystem" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OntapFileSystemProps) {
    super(scope, id, {
      ...OntapFileSystem.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OntapFileSystem.GVK,
      ...toJson_OntapFileSystemProps(resolved),
    };
  }
}

/**
 * OntapFileSystem is the Schema for the OntapFileSystems API. Manages an Amazon FSx for NetApp ONTAP file system.
 *
 * @schema OntapFileSystem
 */
export interface OntapFileSystemProps {
  /**
   * @schema OntapFileSystem#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OntapFileSystemSpec defines the desired state of OntapFileSystem
   *
   * @schema OntapFileSystem#spec
   */
  readonly spec: OntapFileSystemSpec;

}

/**
 * Converts an object of type 'OntapFileSystemProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemProps(obj: OntapFileSystemProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OntapFileSystemSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OntapFileSystemSpec defines the desired state of OntapFileSystem
 *
 * @schema OntapFileSystemSpec
 */
export interface OntapFileSystemSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OntapFileSystemSpec#deletionPolicy
   */
  readonly deletionPolicy?: OntapFileSystemSpecDeletionPolicy;

  /**
   * @schema OntapFileSystemSpec#forProvider
   */
  readonly forProvider: OntapFileSystemSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OntapFileSystemSpec#managementPolicy
   */
  readonly managementPolicy?: OntapFileSystemSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OntapFileSystemSpec#providerConfigRef
   */
  readonly providerConfigRef?: OntapFileSystemSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema OntapFileSystemSpec#providerRef
   */
  readonly providerRef?: OntapFileSystemSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OntapFileSystemSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OntapFileSystemSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OntapFileSystemSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OntapFileSystemSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OntapFileSystemSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpec(obj: OntapFileSystemSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OntapFileSystemSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_OntapFileSystemSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_OntapFileSystemSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_OntapFileSystemSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OntapFileSystemSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OntapFileSystemSpecDeletionPolicy
 */
export enum OntapFileSystemSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OntapFileSystemSpecForProvider
 */
export interface OntapFileSystemSpecForProvider {
  /**
   * The number of days to retain automatic backups. Setting this to 0 disables automatic backups. You can retain automatic backups for a maximum of 90 days.
   *
   * @schema OntapFileSystemSpecForProvider#automaticBackupRetentionDays
   */
  readonly automaticBackupRetentionDays?: number;

  /**
   * A recurring daily time, in the format HH:MM. HH is the zero-padded hour of the day (0-23), and MM is the zero-padded minute of the hour. For example, 05:00 specifies 5 AM daily. Requires automatic_backup_retention_days to be set.
   *
   * @schema OntapFileSystemSpecForProvider#dailyAutomaticBackupStartTime
   */
  readonly dailyAutomaticBackupStartTime?: string;

  /**
   * - The filesystem deployment type. Supports MULTI_AZ_1 and SINGLE_AZ_1.
   *
   * @schema OntapFileSystemSpecForProvider#deploymentType
   */
  readonly deploymentType?: string;

  /**
   * The SSD IOPS configuration for the Amazon FSx for NetApp ONTAP file system. See Disk Iops Configuration Below.
   *
   * @schema OntapFileSystemSpecForProvider#diskIopsConfiguration
   */
  readonly diskIopsConfiguration?: OntapFileSystemSpecForProviderDiskIopsConfiguration[];

  /**
   * Specifies the IP address range in which the endpoints to access your file system will be created. By default, Amazon FSx selects an unused IP address range for you from the 198.19.* range.
   *
   * @schema OntapFileSystemSpecForProvider#endpointIpAddressRange
   */
  readonly endpointIpAddressRange?: string;

  /**
   * The ONTAP administrative password for the fsxadmin user that you can use to administer your file system using the ONTAP CLI and REST API.
   *
   * @schema OntapFileSystemSpecForProvider#fsxAdminPasswordSecretRef
   */
  readonly fsxAdminPasswordSecretRef?: OntapFileSystemSpecForProviderFsxAdminPasswordSecretRef;

  /**
   * ARN for the KMS Key to encrypt the file system at rest, Defaults to an AWS managed KMS Key.
   *
   * @default an AWS managed KMS Key.
   * @schema OntapFileSystemSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema OntapFileSystemSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: OntapFileSystemSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema OntapFileSystemSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: OntapFileSystemSpecForProviderKmsKeyIdSelector;

  /**
   * The ID for a subnet. A subnet is a range of IP addresses in your virtual private cloud (VPC).
   *
   * @schema OntapFileSystemSpecForProvider#preferredSubnetId
   */
  readonly preferredSubnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate preferredSubnetId.
   *
   * @schema OntapFileSystemSpecForProvider#preferredSubnetIdRef
   */
  readonly preferredSubnetIdRef?: OntapFileSystemSpecForProviderPreferredSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate preferredSubnetId.
   *
   * @schema OntapFileSystemSpecForProvider#preferredSubnetIdSelector
   */
  readonly preferredSubnetIdSelector?: OntapFileSystemSpecForProviderPreferredSubnetIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema OntapFileSystemSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the VPC route tables in which your file system's endpoints will be created. You should specify all VPC route tables associated with the subnets in which your clients are located. By default, Amazon FSx selects your VPC's default route table.
   *
   * @schema OntapFileSystemSpecForProvider#routeTableIds
   */
  readonly routeTableIds?: string[];

  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema OntapFileSystemSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: OntapFileSystemSpecForProviderSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema OntapFileSystemSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: OntapFileSystemSpecForProviderSecurityGroupIdSelector;

  /**
   * A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups will apply to all network interfaces.
   *
   * @schema OntapFileSystemSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * The storage capacity (GiB) of the file system. Valid values between 1024 and 196608.
   *
   * @schema OntapFileSystemSpecForProvider#storageCapacity
   */
  readonly storageCapacity?: number;

  /**
   * - The filesystem storage type. defaults to SSD.
   *
   * @schema OntapFileSystemSpecForProvider#storageType
   */
  readonly storageType?: string;

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema OntapFileSystemSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: OntapFileSystemSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema OntapFileSystemSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: OntapFileSystemSpecForProviderSubnetIdSelector;

  /**
   * A list of IDs for the subnets that the file system will be accessible from. Upto 2 subnets can be provided.
   *
   * @schema OntapFileSystemSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema OntapFileSystemSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Sets the throughput capacity (in MBps) for the file system that you're creating. Valid values are 128, 256, 512, 1024, 2048, and 4096.
   *
   * @schema OntapFileSystemSpecForProvider#throughputCapacity
   */
  readonly throughputCapacity?: number;

  /**
   * The preferred start time (in d:HH:MM format) to perform weekly maintenance, in the UTC time zone.
   *
   * @schema OntapFileSystemSpecForProvider#weeklyMaintenanceStartTime
   */
  readonly weeklyMaintenanceStartTime?: string;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProvider(obj: OntapFileSystemSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automaticBackupRetentionDays': obj.automaticBackupRetentionDays,
    'dailyAutomaticBackupStartTime': obj.dailyAutomaticBackupStartTime,
    'deploymentType': obj.deploymentType,
    'diskIopsConfiguration': obj.diskIopsConfiguration?.map(y => toJson_OntapFileSystemSpecForProviderDiskIopsConfiguration(y)),
    'endpointIpAddressRange': obj.endpointIpAddressRange,
    'fsxAdminPasswordSecretRef': toJson_OntapFileSystemSpecForProviderFsxAdminPasswordSecretRef(obj.fsxAdminPasswordSecretRef),
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_OntapFileSystemSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_OntapFileSystemSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'preferredSubnetId': obj.preferredSubnetId,
    'preferredSubnetIdRef': toJson_OntapFileSystemSpecForProviderPreferredSubnetIdRef(obj.preferredSubnetIdRef),
    'preferredSubnetIdSelector': toJson_OntapFileSystemSpecForProviderPreferredSubnetIdSelector(obj.preferredSubnetIdSelector),
    'region': obj.region,
    'routeTableIds': obj.routeTableIds?.map(y => y),
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_OntapFileSystemSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_OntapFileSystemSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'storageCapacity': obj.storageCapacity,
    'storageType': obj.storageType,
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_OntapFileSystemSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_OntapFileSystemSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'throughputCapacity': obj.throughputCapacity,
    'weeklyMaintenanceStartTime': obj.weeklyMaintenanceStartTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OntapFileSystemSpecManagementPolicy
 */
export enum OntapFileSystemSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OntapFileSystemSpecProviderConfigRef
 */
export interface OntapFileSystemSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OntapFileSystemSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapFileSystemSpecProviderConfigRef#policy
   */
  readonly policy?: OntapFileSystemSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecProviderConfigRef(obj: OntapFileSystemSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapFileSystemSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema OntapFileSystemSpecProviderRef
 */
export interface OntapFileSystemSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema OntapFileSystemSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapFileSystemSpecProviderRef#policy
   */
  readonly policy?: OntapFileSystemSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecProviderRef(obj: OntapFileSystemSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapFileSystemSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OntapFileSystemSpecPublishConnectionDetailsTo
 */
export interface OntapFileSystemSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OntapFileSystemSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OntapFileSystemSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OntapFileSystemSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OntapFileSystemSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OntapFileSystemSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OntapFileSystemSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecPublishConnectionDetailsTo(obj: OntapFileSystemSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OntapFileSystemSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OntapFileSystemSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OntapFileSystemSpecWriteConnectionSecretToRef
 */
export interface OntapFileSystemSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OntapFileSystemSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OntapFileSystemSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OntapFileSystemSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecWriteConnectionSecretToRef(obj: OntapFileSystemSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OntapFileSystemSpecForProviderDiskIopsConfiguration
 */
export interface OntapFileSystemSpecForProviderDiskIopsConfiguration {
  /**
   * - The total number of SSD IOPS provisioned for the file system.
   *
   * @schema OntapFileSystemSpecForProviderDiskIopsConfiguration#iops
   */
  readonly iops?: number;

  /**
   * - Specifies whether the number of IOPS for the file system is using the system. Valid values are AUTOMATIC and USER_PROVISIONED. Default value is AUTOMATIC.
   *
   * @schema OntapFileSystemSpecForProviderDiskIopsConfiguration#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderDiskIopsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderDiskIopsConfiguration(obj: OntapFileSystemSpecForProviderDiskIopsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iops': obj.iops,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ONTAP administrative password for the fsxadmin user that you can use to administer your file system using the ONTAP CLI and REST API.
 *
 * @schema OntapFileSystemSpecForProviderFsxAdminPasswordSecretRef
 */
export interface OntapFileSystemSpecForProviderFsxAdminPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema OntapFileSystemSpecForProviderFsxAdminPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema OntapFileSystemSpecForProviderFsxAdminPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OntapFileSystemSpecForProviderFsxAdminPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderFsxAdminPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderFsxAdminPasswordSecretRef(obj: OntapFileSystemSpecForProviderFsxAdminPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema OntapFileSystemSpecForProviderKmsKeyIdRef
 */
export interface OntapFileSystemSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema OntapFileSystemSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapFileSystemSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: OntapFileSystemSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderKmsKeyIdRef(obj: OntapFileSystemSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapFileSystemSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema OntapFileSystemSpecForProviderKmsKeyIdSelector
 */
export interface OntapFileSystemSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema OntapFileSystemSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema OntapFileSystemSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema OntapFileSystemSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderKmsKeyIdSelector(obj: OntapFileSystemSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate preferredSubnetId.
 *
 * @schema OntapFileSystemSpecForProviderPreferredSubnetIdRef
 */
export interface OntapFileSystemSpecForProviderPreferredSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema OntapFileSystemSpecForProviderPreferredSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapFileSystemSpecForProviderPreferredSubnetIdRef#policy
   */
  readonly policy?: OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderPreferredSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderPreferredSubnetIdRef(obj: OntapFileSystemSpecForProviderPreferredSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate preferredSubnetId.
 *
 * @schema OntapFileSystemSpecForProviderPreferredSubnetIdSelector
 */
export interface OntapFileSystemSpecForProviderPreferredSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema OntapFileSystemSpecForProviderPreferredSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema OntapFileSystemSpecForProviderPreferredSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema OntapFileSystemSpecForProviderPreferredSubnetIdSelector#policy
   */
  readonly policy?: OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderPreferredSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderPreferredSubnetIdSelector(obj: OntapFileSystemSpecForProviderPreferredSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema OntapFileSystemSpecForProviderSecurityGroupIdRefs
 */
export interface OntapFileSystemSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema OntapFileSystemSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapFileSystemSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderSecurityGroupIdRefs(obj: OntapFileSystemSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema OntapFileSystemSpecForProviderSecurityGroupIdSelector
 */
export interface OntapFileSystemSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema OntapFileSystemSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema OntapFileSystemSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema OntapFileSystemSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderSecurityGroupIdSelector(obj: OntapFileSystemSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema OntapFileSystemSpecForProviderSubnetIdRefs
 */
export interface OntapFileSystemSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema OntapFileSystemSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapFileSystemSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: OntapFileSystemSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderSubnetIdRefs(obj: OntapFileSystemSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapFileSystemSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema OntapFileSystemSpecForProviderSubnetIdSelector
 */
export interface OntapFileSystemSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema OntapFileSystemSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema OntapFileSystemSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema OntapFileSystemSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: OntapFileSystemSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderSubnetIdSelector(obj: OntapFileSystemSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_OntapFileSystemSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OntapFileSystemSpecProviderConfigRefPolicy
 */
export interface OntapFileSystemSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecProviderConfigRefPolicy(obj: OntapFileSystemSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OntapFileSystemSpecProviderRefPolicy
 */
export interface OntapFileSystemSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecProviderRefPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecProviderRefPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecProviderRefPolicy(obj: OntapFileSystemSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OntapFileSystemSpecPublishConnectionDetailsToConfigRef
 */
export interface OntapFileSystemSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OntapFileSystemSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapFileSystemSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OntapFileSystemSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecPublishConnectionDetailsToConfigRef(obj: OntapFileSystemSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OntapFileSystemSpecPublishConnectionDetailsToMetadata
 */
export interface OntapFileSystemSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OntapFileSystemSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OntapFileSystemSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OntapFileSystemSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OntapFileSystemSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecPublishConnectionDetailsToMetadata(obj: OntapFileSystemSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OntapFileSystemSpecForProviderKmsKeyIdRefPolicy
 */
export interface OntapFileSystemSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderKmsKeyIdRefPolicy(obj: OntapFileSystemSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicy(obj: OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicy
 */
export interface OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicy(obj: OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicy
 */
export interface OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicy(obj: OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicy(obj: OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicy(obj: OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OntapFileSystemSpecForProviderSubnetIdRefsPolicy
 */
export interface OntapFileSystemSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderSubnetIdRefsPolicy(obj: OntapFileSystemSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema OntapFileSystemSpecForProviderSubnetIdSelectorPolicy
 */
export interface OntapFileSystemSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecForProviderSubnetIdSelectorPolicy(obj: OntapFileSystemSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecProviderConfigRefPolicyResolution
 */
export enum OntapFileSystemSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecProviderConfigRefPolicyResolve
 */
export enum OntapFileSystemSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecProviderRefPolicyResolution
 */
export enum OntapFileSystemSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecProviderRefPolicyResolve
 */
export enum OntapFileSystemSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicy(obj: OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum OntapFileSystemSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum OntapFileSystemSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum OntapFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicyResolution
 */
export enum OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicyResolve
 */
export enum OntapFileSystemSpecForProviderPreferredSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicyResolution
 */
export enum OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicyResolve
 */
export enum OntapFileSystemSpecForProviderPreferredSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum OntapFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum OntapFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum OntapFileSystemSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum OntapFileSystemSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum OntapFileSystemSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum OntapFileSystemSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OntapFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OntapStorageVirtualMachine is the Schema for the OntapStorageVirtualMachines API. Manages a FSx Storage Virtual Machine.
 *
 * @schema OntapStorageVirtualMachine
 */
export class OntapStorageVirtualMachine extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OntapStorageVirtualMachine"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'fsx.aws.upbound.io/v1beta1',
    kind: 'OntapStorageVirtualMachine',
  }

  /**
   * Renders a Kubernetes manifest for "OntapStorageVirtualMachine".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OntapStorageVirtualMachineProps): any {
    return {
      ...OntapStorageVirtualMachine.GVK,
      ...toJson_OntapStorageVirtualMachineProps(props),
    };
  }

  /**
   * Defines a "OntapStorageVirtualMachine" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OntapStorageVirtualMachineProps) {
    super(scope, id, {
      ...OntapStorageVirtualMachine.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OntapStorageVirtualMachine.GVK,
      ...toJson_OntapStorageVirtualMachineProps(resolved),
    };
  }
}

/**
 * OntapStorageVirtualMachine is the Schema for the OntapStorageVirtualMachines API. Manages a FSx Storage Virtual Machine.
 *
 * @schema OntapStorageVirtualMachine
 */
export interface OntapStorageVirtualMachineProps {
  /**
   * @schema OntapStorageVirtualMachine#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OntapStorageVirtualMachineSpec defines the desired state of OntapStorageVirtualMachine
   *
   * @schema OntapStorageVirtualMachine#spec
   */
  readonly spec: OntapStorageVirtualMachineSpec;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineProps(obj: OntapStorageVirtualMachineProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OntapStorageVirtualMachineSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OntapStorageVirtualMachineSpec defines the desired state of OntapStorageVirtualMachine
 *
 * @schema OntapStorageVirtualMachineSpec
 */
export interface OntapStorageVirtualMachineSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OntapStorageVirtualMachineSpec#deletionPolicy
   */
  readonly deletionPolicy?: OntapStorageVirtualMachineSpecDeletionPolicy;

  /**
   * @schema OntapStorageVirtualMachineSpec#forProvider
   */
  readonly forProvider: OntapStorageVirtualMachineSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OntapStorageVirtualMachineSpec#managementPolicy
   */
  readonly managementPolicy?: OntapStorageVirtualMachineSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OntapStorageVirtualMachineSpec#providerConfigRef
   */
  readonly providerConfigRef?: OntapStorageVirtualMachineSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema OntapStorageVirtualMachineSpec#providerRef
   */
  readonly providerRef?: OntapStorageVirtualMachineSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OntapStorageVirtualMachineSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OntapStorageVirtualMachineSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OntapStorageVirtualMachineSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OntapStorageVirtualMachineSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpec(obj: OntapStorageVirtualMachineSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OntapStorageVirtualMachineSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_OntapStorageVirtualMachineSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_OntapStorageVirtualMachineSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_OntapStorageVirtualMachineSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OntapStorageVirtualMachineSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OntapStorageVirtualMachineSpecDeletionPolicy
 */
export enum OntapStorageVirtualMachineSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OntapStorageVirtualMachineSpecForProvider
 */
export interface OntapStorageVirtualMachineSpecForProvider {
  /**
   * Configuration block that Amazon FSx uses to join the FSx ONTAP Storage Virtual Machine(SVM) to your Microsoft Active Directory (AD) directory. Detailed below.
   *
   * @schema OntapStorageVirtualMachineSpecForProvider#activeDirectoryConfiguration
   */
  readonly activeDirectoryConfiguration?: OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfiguration[];

  /**
   * The ID of the Amazon FSx ONTAP File System that this SVM will be created on.
   *
   * @schema OntapStorageVirtualMachineSpecForProvider#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * Reference to a OntapFileSystem in fsx to populate fileSystemId.
   *
   * @schema OntapStorageVirtualMachineSpecForProvider#fileSystemIdRef
   */
  readonly fileSystemIdRef?: OntapStorageVirtualMachineSpecForProviderFileSystemIdRef;

  /**
   * Selector for a OntapFileSystem in fsx to populate fileSystemId.
   *
   * @schema OntapStorageVirtualMachineSpecForProvider#fileSystemIdSelector
   */
  readonly fileSystemIdSelector?: OntapStorageVirtualMachineSpecForProviderFileSystemIdSelector;

  /**
   * The name of the SVM. You can use a maximum of 47 alphanumeric characters, plus the underscore (_) special character.
   *
   * @schema OntapStorageVirtualMachineSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema OntapStorageVirtualMachineSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the root volume security style, Valid values are UNIX, NTFS, and MIXED. All volumes created under this SVM will inherit the root security style unless the security style is specified on the volume. Default value is UNIX.
   *
   * @schema OntapStorageVirtualMachineSpecForProvider#rootVolumeSecurityStyle
   */
  readonly rootVolumeSecurityStyle?: string;

  /**
   * A SecretKeySelector is a reference to a secret key in an arbitrary namespace.
   *
   * @schema OntapStorageVirtualMachineSpecForProvider#svmAdminPasswordSecretRef
   */
  readonly svmAdminPasswordSecretRef?: OntapStorageVirtualMachineSpecForProviderSvmAdminPasswordSecretRef;

  /**
   * Key-value map of resource tags.
   *
   * @schema OntapStorageVirtualMachineSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecForProvider(obj: OntapStorageVirtualMachineSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDirectoryConfiguration': obj.activeDirectoryConfiguration?.map(y => toJson_OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfiguration(y)),
    'fileSystemId': obj.fileSystemId,
    'fileSystemIdRef': toJson_OntapStorageVirtualMachineSpecForProviderFileSystemIdRef(obj.fileSystemIdRef),
    'fileSystemIdSelector': toJson_OntapStorageVirtualMachineSpecForProviderFileSystemIdSelector(obj.fileSystemIdSelector),
    'name': obj.name,
    'region': obj.region,
    'rootVolumeSecurityStyle': obj.rootVolumeSecurityStyle,
    'svmAdminPasswordSecretRef': toJson_OntapStorageVirtualMachineSpecForProviderSvmAdminPasswordSecretRef(obj.svmAdminPasswordSecretRef),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OntapStorageVirtualMachineSpecManagementPolicy
 */
export enum OntapStorageVirtualMachineSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OntapStorageVirtualMachineSpecProviderConfigRef
 */
export interface OntapStorageVirtualMachineSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OntapStorageVirtualMachineSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapStorageVirtualMachineSpecProviderConfigRef#policy
   */
  readonly policy?: OntapStorageVirtualMachineSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecProviderConfigRef(obj: OntapStorageVirtualMachineSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapStorageVirtualMachineSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema OntapStorageVirtualMachineSpecProviderRef
 */
export interface OntapStorageVirtualMachineSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema OntapStorageVirtualMachineSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapStorageVirtualMachineSpecProviderRef#policy
   */
  readonly policy?: OntapStorageVirtualMachineSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecProviderRef(obj: OntapStorageVirtualMachineSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapStorageVirtualMachineSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsTo
 */
export interface OntapStorageVirtualMachineSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OntapStorageVirtualMachineSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecPublishConnectionDetailsTo(obj: OntapStorageVirtualMachineSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OntapStorageVirtualMachineSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OntapStorageVirtualMachineSpecWriteConnectionSecretToRef
 */
export interface OntapStorageVirtualMachineSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OntapStorageVirtualMachineSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OntapStorageVirtualMachineSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecWriteConnectionSecretToRef(obj: OntapStorageVirtualMachineSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfiguration
 */
export interface OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfiguration {
  /**
   * The NetBIOS name of the Active Directory computer object that will be created for your SVM. This is often the same as the SVM name but can be different. AWS limits to 15 characters because of standard NetBIOS naming limits.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfiguration#netbiosName
   */
  readonly netbiosName?: string;

  /**
   * Configuration block that Amazon FSx uses to join the FSx ONTAP Storage Virtual Machine(SVM) to your Microsoft Active Directory (AD) directory. Detailed below.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfiguration#selfManagedActiveDirectoryConfiguration
   */
  readonly selfManagedActiveDirectoryConfiguration?: OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration[];

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfiguration(obj: OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'netbiosName': obj.netbiosName,
    'selfManagedActiveDirectoryConfiguration': obj.selfManagedActiveDirectoryConfiguration?.map(y => toJson_OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a OntapFileSystem in fsx to populate fileSystemId.
 *
 * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdRef
 */
export interface OntapStorageVirtualMachineSpecForProviderFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdRef#policy
   */
  readonly policy?: OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecForProviderFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecForProviderFileSystemIdRef(obj: OntapStorageVirtualMachineSpecForProviderFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a OntapFileSystem in fsx to populate fileSystemId.
 *
 * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdSelector
 */
export interface OntapStorageVirtualMachineSpecForProviderFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdSelector#policy
   */
  readonly policy?: OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecForProviderFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecForProviderFileSystemIdSelector(obj: OntapStorageVirtualMachineSpecForProviderFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretKeySelector is a reference to a secret key in an arbitrary namespace.
 *
 * @schema OntapStorageVirtualMachineSpecForProviderSvmAdminPasswordSecretRef
 */
export interface OntapStorageVirtualMachineSpecForProviderSvmAdminPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderSvmAdminPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderSvmAdminPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderSvmAdminPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecForProviderSvmAdminPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecForProviderSvmAdminPasswordSecretRef(obj: OntapStorageVirtualMachineSpecForProviderSvmAdminPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OntapStorageVirtualMachineSpecProviderConfigRefPolicy
 */
export interface OntapStorageVirtualMachineSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapStorageVirtualMachineSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OntapStorageVirtualMachineSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapStorageVirtualMachineSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OntapStorageVirtualMachineSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecProviderConfigRefPolicy(obj: OntapStorageVirtualMachineSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OntapStorageVirtualMachineSpecProviderRefPolicy
 */
export interface OntapStorageVirtualMachineSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapStorageVirtualMachineSpecProviderRefPolicy#resolution
   */
  readonly resolution?: OntapStorageVirtualMachineSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapStorageVirtualMachineSpecProviderRefPolicy#resolve
   */
  readonly resolve?: OntapStorageVirtualMachineSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecProviderRefPolicy(obj: OntapStorageVirtualMachineSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRef
 */
export interface OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRef(obj: OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToMetadata
 */
export interface OntapStorageVirtualMachineSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecPublishConnectionDetailsToMetadata(obj: OntapStorageVirtualMachineSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration
 */
export interface OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration {
  /**
   * A list of up to three IP addresses of DNS servers or domain controllers in the self-managed AD directory.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration#dnsIps
   */
  readonly dnsIps: string[];

  /**
   * The fully qualified domain name of the self-managed AD directory. For example, corp.example.com.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration#domainName
   */
  readonly domainName: string;

  /**
   * The name of the domain group whose members are granted administrative privileges for the SVM. The group that you specify must already exist in your domain. Defaults to Domain Admins.
   *
   * @default Domain Admins.
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration#fileSystemAdministratorsGroup
   */
  readonly fileSystemAdministratorsGroup?: string;

  /**
   * The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, OU=FSx,DC=yourdomain,DC=corp,DC=com. Only accepts OU as the direct parent of the SVM. If none is provided, the SVM is created in the default location of your self-managed AD directory. To learn more, see RFC 2253.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration#organizationalUnitDistinguishedName
   */
  readonly organizationalUnitDistinguishedName?: string;

  /**
   * The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration#passwordSecretRef
   */
  readonly passwordSecretRef: OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationPasswordSecretRef;

  /**
   * The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration(obj: OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsIps': obj.dnsIps?.map(y => y),
    'domainName': obj.domainName,
    'fileSystemAdministratorsGroup': obj.fileSystemAdministratorsGroup,
    'organizationalUnitDistinguishedName': obj.organizationalUnitDistinguishedName,
    'passwordSecretRef': toJson_OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationPasswordSecretRef(obj.passwordSecretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicy
 */
export interface OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicy(obj: OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicy
 */
export interface OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicy(obj: OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapStorageVirtualMachineSpecProviderConfigRefPolicyResolution
 */
export enum OntapStorageVirtualMachineSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapStorageVirtualMachineSpecProviderConfigRefPolicyResolve
 */
export enum OntapStorageVirtualMachineSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapStorageVirtualMachineSpecProviderRefPolicyResolution
 */
export enum OntapStorageVirtualMachineSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapStorageVirtualMachineSpecProviderRefPolicyResolve
 */
export enum OntapStorageVirtualMachineSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicy(obj: OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
 *
 * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationPasswordSecretRef
 */
export interface OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationPasswordSecretRef(obj: OntapStorageVirtualMachineSpecForProviderActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicyResolution
 */
export enum OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicyResolve
 */
export enum OntapStorageVirtualMachineSpecForProviderFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicyResolution
 */
export enum OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicyResolve
 */
export enum OntapStorageVirtualMachineSpecForProviderFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OntapStorageVirtualMachineSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * WindowsFileSystem is the Schema for the WindowsFileSystems API. Manages a FSx Windows File System.
 *
 * @schema WindowsFileSystem
 */
export class WindowsFileSystem extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WindowsFileSystem"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'fsx.aws.upbound.io/v1beta1',
    kind: 'WindowsFileSystem',
  }

  /**
   * Renders a Kubernetes manifest for "WindowsFileSystem".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WindowsFileSystemProps): any {
    return {
      ...WindowsFileSystem.GVK,
      ...toJson_WindowsFileSystemProps(props),
    };
  }

  /**
   * Defines a "WindowsFileSystem" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WindowsFileSystemProps) {
    super(scope, id, {
      ...WindowsFileSystem.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WindowsFileSystem.GVK,
      ...toJson_WindowsFileSystemProps(resolved),
    };
  }
}

/**
 * WindowsFileSystem is the Schema for the WindowsFileSystems API. Manages a FSx Windows File System.
 *
 * @schema WindowsFileSystem
 */
export interface WindowsFileSystemProps {
  /**
   * @schema WindowsFileSystem#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WindowsFileSystemSpec defines the desired state of WindowsFileSystem
   *
   * @schema WindowsFileSystem#spec
   */
  readonly spec: WindowsFileSystemSpec;

}

/**
 * Converts an object of type 'WindowsFileSystemProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemProps(obj: WindowsFileSystemProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WindowsFileSystemSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WindowsFileSystemSpec defines the desired state of WindowsFileSystem
 *
 * @schema WindowsFileSystemSpec
 */
export interface WindowsFileSystemSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WindowsFileSystemSpec#deletionPolicy
   */
  readonly deletionPolicy?: WindowsFileSystemSpecDeletionPolicy;

  /**
   * @schema WindowsFileSystemSpec#forProvider
   */
  readonly forProvider: WindowsFileSystemSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WindowsFileSystemSpec#managementPolicy
   */
  readonly managementPolicy?: WindowsFileSystemSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WindowsFileSystemSpec#providerConfigRef
   */
  readonly providerConfigRef?: WindowsFileSystemSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WindowsFileSystemSpec#providerRef
   */
  readonly providerRef?: WindowsFileSystemSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WindowsFileSystemSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WindowsFileSystemSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WindowsFileSystemSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WindowsFileSystemSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WindowsFileSystemSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpec(obj: WindowsFileSystemSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WindowsFileSystemSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_WindowsFileSystemSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WindowsFileSystemSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WindowsFileSystemSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WindowsFileSystemSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WindowsFileSystemSpecDeletionPolicy
 */
export enum WindowsFileSystemSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WindowsFileSystemSpecForProvider
 */
export interface WindowsFileSystemSpecForProvider {
  /**
   * The ID for an existing Microsoft Active Directory instance that the file system should join when it's created. Cannot be specified with self_managed_active_directory.
   *
   * @schema WindowsFileSystemSpecForProvider#activeDirectoryId
   */
  readonly activeDirectoryId?: string;

  /**
   * Reference to a Directory in ds to populate activeDirectoryId.
   *
   * @schema WindowsFileSystemSpecForProvider#activeDirectoryIdRef
   */
  readonly activeDirectoryIdRef?: WindowsFileSystemSpecForProviderActiveDirectoryIdRef;

  /**
   * Selector for a Directory in ds to populate activeDirectoryId.
   *
   * @schema WindowsFileSystemSpecForProvider#activeDirectoryIdSelector
   */
  readonly activeDirectoryIdSelector?: WindowsFileSystemSpecForProviderActiveDirectoryIdSelector;

  /**
   * An array DNS alias names that you want to associate with the Amazon FSx file system.  For more information, see Working with DNS Aliases
   *
   * @schema WindowsFileSystemSpecForProvider#aliases
   */
  readonly aliases?: string[];

  /**
   * The configuration that Amazon FSx for Windows File Server uses to audit and log user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server file system. See below.
   *
   * @schema WindowsFileSystemSpecForProvider#auditLogConfiguration
   */
  readonly auditLogConfiguration?: WindowsFileSystemSpecForProviderAuditLogConfiguration[];

  /**
   * The number of days to retain automatic backups. Minimum of 0 and maximum of 90. Defaults to 7. Set to 0 to disable.
   *
   * @default 7. Set to 0 to disable.
   * @schema WindowsFileSystemSpecForProvider#automaticBackupRetentionDays
   */
  readonly automaticBackupRetentionDays?: number;

  /**
   * The ID of the source backup to create the filesystem from.
   *
   * @schema WindowsFileSystemSpecForProvider#backupId
   */
  readonly backupId?: string;

  /**
   * A boolean flag indicating whether tags on the file system should be copied to backups. Defaults to false.
   *
   * @default false.
   * @schema WindowsFileSystemSpecForProvider#copyTagsToBackups
   */
  readonly copyTagsToBackups?: boolean;

  /**
   * The preferred time (in HH:MM format) to take daily automatic backups, in the UTC time zone.
   *
   * @schema WindowsFileSystemSpecForProvider#dailyAutomaticBackupStartTime
   */
  readonly dailyAutomaticBackupStartTime?: string;

  /**
   * Specifies the file system deployment type, valid values are MULTI_AZ_1, SINGLE_AZ_1 and SINGLE_AZ_2. Default value is SINGLE_AZ_1.
   *
   * @schema WindowsFileSystemSpecForProvider#deploymentType
   */
  readonly deploymentType?: string;

  /**
   * ARN for the KMS Key to encrypt the file system at rest. Defaults to an AWS managed KMS Key.
   *
   * @default an AWS managed KMS Key.
   * @schema WindowsFileSystemSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema WindowsFileSystemSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: WindowsFileSystemSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema WindowsFileSystemSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: WindowsFileSystemSpecForProviderKmsKeyIdSelector;

  /**
   * Specifies the subnet in which you want the preferred file server to be located. Required for when deployment type is MULTI_AZ_1.
   *
   * @schema WindowsFileSystemSpecForProvider#preferredSubnetId
   */
  readonly preferredSubnetId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WindowsFileSystemSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema WindowsFileSystemSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: WindowsFileSystemSpecForProviderSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema WindowsFileSystemSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: WindowsFileSystemSpecForProviderSecurityGroupIdSelector;

  /**
   * A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups will apply to all network interfaces.
   *
   * @schema WindowsFileSystemSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * Configuration block that Amazon FSx uses to join the Windows File Server instance to your self-managed (including on-premises) Microsoft Active Directory (AD) directory. Cannot be specified with active_directory_id. Detailed below.
   *
   * @schema WindowsFileSystemSpecForProvider#selfManagedActiveDirectory
   */
  readonly selfManagedActiveDirectory?: WindowsFileSystemSpecForProviderSelfManagedActiveDirectory[];

  /**
   * When enabled, will skip the default final backup taken when the file system is deleted. This configuration must be applied separately before attempting to delete the resource to have the desired behavior. Defaults to false.
   *
   * @default false.
   * @schema WindowsFileSystemSpecForProvider#skipFinalBackup
   */
  readonly skipFinalBackup?: boolean;

  /**
   * Storage capacity (GiB) of the file system. Minimum of 32 and maximum of 65536. If the storage type is set to HDD the minimum value is 2000. Required when not creating filesystem for a backup.
   *
   * @schema WindowsFileSystemSpecForProvider#storageCapacity
   */
  readonly storageCapacity?: number;

  /**
   * Specifies the storage type, Valid values are SSD and HDD. HDD is supported on SINGLE_AZ_2 and MULTI_AZ_1 Windows file system deployment types. Default value is SSD.
   *
   * @schema WindowsFileSystemSpecForProvider#storageType
   */
  readonly storageType?: string;

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema WindowsFileSystemSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: WindowsFileSystemSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema WindowsFileSystemSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: WindowsFileSystemSpecForProviderSubnetIdSelector;

  /**
   * A list of IDs for the subnets that the file system will be accessible from. To specify more than a single subnet set deployment_type to MULTI_AZ_1.
   *
   * @schema WindowsFileSystemSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema WindowsFileSystemSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Throughput (megabytes per second) of the file system in power of 2 increments. Minimum of 8 and maximum of 2048.
   *
   * @schema WindowsFileSystemSpecForProvider#throughputCapacity
   */
  readonly throughputCapacity?: number;

  /**
   * The preferred start time (in d:HH:MM format) to perform weekly maintenance, in the UTC time zone.
   *
   * @schema WindowsFileSystemSpecForProvider#weeklyMaintenanceStartTime
   */
  readonly weeklyMaintenanceStartTime?: string;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProvider(obj: WindowsFileSystemSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDirectoryId': obj.activeDirectoryId,
    'activeDirectoryIdRef': toJson_WindowsFileSystemSpecForProviderActiveDirectoryIdRef(obj.activeDirectoryIdRef),
    'activeDirectoryIdSelector': toJson_WindowsFileSystemSpecForProviderActiveDirectoryIdSelector(obj.activeDirectoryIdSelector),
    'aliases': obj.aliases?.map(y => y),
    'auditLogConfiguration': obj.auditLogConfiguration?.map(y => toJson_WindowsFileSystemSpecForProviderAuditLogConfiguration(y)),
    'automaticBackupRetentionDays': obj.automaticBackupRetentionDays,
    'backupId': obj.backupId,
    'copyTagsToBackups': obj.copyTagsToBackups,
    'dailyAutomaticBackupStartTime': obj.dailyAutomaticBackupStartTime,
    'deploymentType': obj.deploymentType,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_WindowsFileSystemSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_WindowsFileSystemSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'preferredSubnetId': obj.preferredSubnetId,
    'region': obj.region,
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_WindowsFileSystemSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_WindowsFileSystemSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'selfManagedActiveDirectory': obj.selfManagedActiveDirectory?.map(y => toJson_WindowsFileSystemSpecForProviderSelfManagedActiveDirectory(y)),
    'skipFinalBackup': obj.skipFinalBackup,
    'storageCapacity': obj.storageCapacity,
    'storageType': obj.storageType,
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_WindowsFileSystemSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_WindowsFileSystemSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'throughputCapacity': obj.throughputCapacity,
    'weeklyMaintenanceStartTime': obj.weeklyMaintenanceStartTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WindowsFileSystemSpecManagementPolicy
 */
export enum WindowsFileSystemSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WindowsFileSystemSpecProviderConfigRef
 */
export interface WindowsFileSystemSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WindowsFileSystemSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WindowsFileSystemSpecProviderConfigRef#policy
   */
  readonly policy?: WindowsFileSystemSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecProviderConfigRef(obj: WindowsFileSystemSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WindowsFileSystemSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WindowsFileSystemSpecProviderRef
 */
export interface WindowsFileSystemSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WindowsFileSystemSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WindowsFileSystemSpecProviderRef#policy
   */
  readonly policy?: WindowsFileSystemSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecProviderRef(obj: WindowsFileSystemSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WindowsFileSystemSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WindowsFileSystemSpecPublishConnectionDetailsTo
 */
export interface WindowsFileSystemSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WindowsFileSystemSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WindowsFileSystemSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WindowsFileSystemSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WindowsFileSystemSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WindowsFileSystemSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecPublishConnectionDetailsTo(obj: WindowsFileSystemSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WindowsFileSystemSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WindowsFileSystemSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WindowsFileSystemSpecWriteConnectionSecretToRef
 */
export interface WindowsFileSystemSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WindowsFileSystemSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WindowsFileSystemSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecWriteConnectionSecretToRef(obj: WindowsFileSystemSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Directory in ds to populate activeDirectoryId.
 *
 * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdRef
 */
export interface WindowsFileSystemSpecForProviderActiveDirectoryIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdRef#policy
   */
  readonly policy?: WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderActiveDirectoryIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderActiveDirectoryIdRef(obj: WindowsFileSystemSpecForProviderActiveDirectoryIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Directory in ds to populate activeDirectoryId.
 *
 * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdSelector
 */
export interface WindowsFileSystemSpecForProviderActiveDirectoryIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdSelector#policy
   */
  readonly policy?: WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderActiveDirectoryIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderActiveDirectoryIdSelector(obj: WindowsFileSystemSpecForProviderActiveDirectoryIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WindowsFileSystemSpecForProviderAuditLogConfiguration
 */
export interface WindowsFileSystemSpecForProviderAuditLogConfiguration {
  /**
   * The Amazon Resource Name (ARN) for the destination of the audit logs. The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis Data Firehose delivery stream ARN. Can be specified when file_access_audit_log_level and file_share_access_audit_log_level are not set to DISABLED. The name of the Amazon CloudWatch Logs log group must begin with the /aws/fsx prefix. The name of the Amazon Kinesis Data Firehouse delivery stream must begin with the aws-fsx prefix. If you do not provide a destination in audit_log_destionation, Amazon FSx will create and use a log stream in the CloudWatch Logs /aws/fsx/windows log group.
   *
   * @schema WindowsFileSystemSpecForProviderAuditLogConfiguration#auditLogDestination
   */
  readonly auditLogDestination?: string;

  /**
   * Sets which attempt type is logged by Amazon FSx for file and folder accesses. Valid values are SUCCESS_ONLY, FAILURE_ONLY, SUCCESS_AND_FAILURE, and DISABLED. Default value is DISABLED.
   *
   * @schema WindowsFileSystemSpecForProviderAuditLogConfiguration#fileAccessAuditLogLevel
   */
  readonly fileAccessAuditLogLevel?: string;

  /**
   * Sets which attempt type is logged by Amazon FSx for file share accesses. Valid values are SUCCESS_ONLY, FAILURE_ONLY, SUCCESS_AND_FAILURE, and DISABLED. Default value is DISABLED.
   *
   * @schema WindowsFileSystemSpecForProviderAuditLogConfiguration#fileShareAccessAuditLogLevel
   */
  readonly fileShareAccessAuditLogLevel?: string;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderAuditLogConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderAuditLogConfiguration(obj: WindowsFileSystemSpecForProviderAuditLogConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auditLogDestination': obj.auditLogDestination,
    'fileAccessAuditLogLevel': obj.fileAccessAuditLogLevel,
    'fileShareAccessAuditLogLevel': obj.fileShareAccessAuditLogLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema WindowsFileSystemSpecForProviderKmsKeyIdRef
 */
export interface WindowsFileSystemSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema WindowsFileSystemSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WindowsFileSystemSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: WindowsFileSystemSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderKmsKeyIdRef(obj: WindowsFileSystemSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WindowsFileSystemSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema WindowsFileSystemSpecForProviderKmsKeyIdSelector
 */
export interface WindowsFileSystemSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WindowsFileSystemSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WindowsFileSystemSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WindowsFileSystemSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderKmsKeyIdSelector(obj: WindowsFileSystemSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema WindowsFileSystemSpecForProviderSecurityGroupIdRefs
 */
export interface WindowsFileSystemSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema WindowsFileSystemSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WindowsFileSystemSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderSecurityGroupIdRefs(obj: WindowsFileSystemSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema WindowsFileSystemSpecForProviderSecurityGroupIdSelector
 */
export interface WindowsFileSystemSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WindowsFileSystemSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WindowsFileSystemSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WindowsFileSystemSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderSecurityGroupIdSelector(obj: WindowsFileSystemSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectory
 */
export interface WindowsFileSystemSpecForProviderSelfManagedActiveDirectory {
  /**
   * A list of up to two IP addresses of DNS servers or domain controllers in the self-managed AD directory. The IP addresses need to be either in the same VPC CIDR range as the file system or in the private IP version 4 (IPv4) address ranges as specified in RFC 1918.
   *
   * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectory#dnsIps
   */
  readonly dnsIps: string[];

  /**
   * The fully qualified domain name of the self-managed AD directory. For example, corp.example.com.
   *
   * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectory#domainName
   */
  readonly domainName: string;

  /**
   * The name of the domain group whose members are granted administrative privileges for the file system. Administrative privileges include taking ownership of files and folders, and setting audit controls (audit ACLs) on files and folders. The group that you specify must already exist in your domain. Defaults to Domain Admins.
   *
   * @default Domain Admins.
   * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectory#fileSystemAdministratorsGroup
   */
  readonly fileSystemAdministratorsGroup?: string;

  /**
   * The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, OU=FSx,DC=yourdomain,DC=corp,DC=com. Only accepts OU as the direct parent of the file system. If none is provided, the FSx file system is created in the default location of your self-managed AD directory. To learn more, see RFC 2253.
   *
   * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectory#organizationalUnitDistinguishedName
   */
  readonly organizationalUnitDistinguishedName?: string;

  /**
   * The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
   *
   * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectory#passwordSecretRef
   */
  readonly passwordSecretRef: WindowsFileSystemSpecForProviderSelfManagedActiveDirectoryPasswordSecretRef;

  /**
   * The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
   *
   * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectory#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderSelfManagedActiveDirectory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderSelfManagedActiveDirectory(obj: WindowsFileSystemSpecForProviderSelfManagedActiveDirectory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsIps': obj.dnsIps?.map(y => y),
    'domainName': obj.domainName,
    'fileSystemAdministratorsGroup': obj.fileSystemAdministratorsGroup,
    'organizationalUnitDistinguishedName': obj.organizationalUnitDistinguishedName,
    'passwordSecretRef': toJson_WindowsFileSystemSpecForProviderSelfManagedActiveDirectoryPasswordSecretRef(obj.passwordSecretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema WindowsFileSystemSpecForProviderSubnetIdRefs
 */
export interface WindowsFileSystemSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema WindowsFileSystemSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WindowsFileSystemSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: WindowsFileSystemSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderSubnetIdRefs(obj: WindowsFileSystemSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WindowsFileSystemSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema WindowsFileSystemSpecForProviderSubnetIdSelector
 */
export interface WindowsFileSystemSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WindowsFileSystemSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WindowsFileSystemSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WindowsFileSystemSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: WindowsFileSystemSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderSubnetIdSelector(obj: WindowsFileSystemSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WindowsFileSystemSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WindowsFileSystemSpecProviderConfigRefPolicy
 */
export interface WindowsFileSystemSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecProviderConfigRefPolicy(obj: WindowsFileSystemSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WindowsFileSystemSpecProviderRefPolicy
 */
export interface WindowsFileSystemSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecProviderRefPolicy(obj: WindowsFileSystemSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WindowsFileSystemSpecPublishConnectionDetailsToConfigRef
 */
export interface WindowsFileSystemSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WindowsFileSystemSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WindowsFileSystemSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecPublishConnectionDetailsToConfigRef(obj: WindowsFileSystemSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WindowsFileSystemSpecPublishConnectionDetailsToMetadata
 */
export interface WindowsFileSystemSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WindowsFileSystemSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WindowsFileSystemSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WindowsFileSystemSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecPublishConnectionDetailsToMetadata(obj: WindowsFileSystemSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicy
 */
export interface WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicy(obj: WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicy
 */
export interface WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicy(obj: WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WindowsFileSystemSpecForProviderKmsKeyIdRefPolicy
 */
export interface WindowsFileSystemSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderKmsKeyIdRefPolicy(obj: WindowsFileSystemSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicy(obj: WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicy(obj: WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicy(obj: WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
 *
 * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectoryPasswordSecretRef
 */
export interface WindowsFileSystemSpecForProviderSelfManagedActiveDirectoryPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectoryPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectoryPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WindowsFileSystemSpecForProviderSelfManagedActiveDirectoryPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderSelfManagedActiveDirectoryPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderSelfManagedActiveDirectoryPasswordSecretRef(obj: WindowsFileSystemSpecForProviderSelfManagedActiveDirectoryPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WindowsFileSystemSpecForProviderSubnetIdRefsPolicy
 */
export interface WindowsFileSystemSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderSubnetIdRefsPolicy(obj: WindowsFileSystemSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WindowsFileSystemSpecForProviderSubnetIdSelectorPolicy
 */
export interface WindowsFileSystemSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecForProviderSubnetIdSelectorPolicy(obj: WindowsFileSystemSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecProviderConfigRefPolicyResolution
 */
export enum WindowsFileSystemSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecProviderConfigRefPolicyResolve
 */
export enum WindowsFileSystemSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecProviderRefPolicyResolution
 */
export enum WindowsFileSystemSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecProviderRefPolicyResolve
 */
export enum WindowsFileSystemSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicy(obj: WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicyResolution
 */
export enum WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicyResolve
 */
export enum WindowsFileSystemSpecForProviderActiveDirectoryIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicyResolution
 */
export enum WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicyResolve
 */
export enum WindowsFileSystemSpecForProviderActiveDirectoryIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum WindowsFileSystemSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum WindowsFileSystemSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum WindowsFileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum WindowsFileSystemSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum WindowsFileSystemSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum WindowsFileSystemSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum WindowsFileSystemSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum WindowsFileSystemSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum WindowsFileSystemSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WindowsFileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

