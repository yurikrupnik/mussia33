// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Ledger is the Schema for the Ledgers API. Provides an QLDB Resource resource.
 *
 * @schema Ledger
 */
export class Ledger extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Ledger"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'qldb.aws.upbound.io/v1beta1',
    kind: 'Ledger',
  }

  /**
   * Renders a Kubernetes manifest for "Ledger".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LedgerProps): any {
    return {
      ...Ledger.GVK,
      ...toJson_LedgerProps(props),
    };
  }

  /**
   * Defines a "Ledger" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LedgerProps) {
    super(scope, id, {
      ...Ledger.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Ledger.GVK,
      ...toJson_LedgerProps(resolved),
    };
  }
}

/**
 * Ledger is the Schema for the Ledgers API. Provides an QLDB Resource resource.
 *
 * @schema Ledger
 */
export interface LedgerProps {
  /**
   * @schema Ledger#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LedgerSpec defines the desired state of Ledger
   *
   * @schema Ledger#spec
   */
  readonly spec: LedgerSpec;

}

/**
 * Converts an object of type 'LedgerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerProps(obj: LedgerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LedgerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LedgerSpec defines the desired state of Ledger
 *
 * @schema LedgerSpec
 */
export interface LedgerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LedgerSpec#deletionPolicy
   */
  readonly deletionPolicy?: LedgerSpecDeletionPolicy;

  /**
   * @schema LedgerSpec#forProvider
   */
  readonly forProvider: LedgerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LedgerSpec#managementPolicy
   */
  readonly managementPolicy?: LedgerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LedgerSpec#providerConfigRef
   */
  readonly providerConfigRef?: LedgerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LedgerSpec#providerRef
   */
  readonly providerRef?: LedgerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LedgerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LedgerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LedgerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LedgerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LedgerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpec(obj: LedgerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LedgerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LedgerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LedgerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LedgerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LedgerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LedgerSpecDeletionPolicy
 */
export enum LedgerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LedgerSpecForProvider
 */
export interface LedgerSpecForProvider {
  /**
   * The deletion protection for the QLDB Ledger instance. By default it is true.
   *
   * @schema LedgerSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * The key in AWS Key Management Service (AWS KMS) to use for encryption of data at rest in the ledger. For more information, see the AWS documentation. Valid values are "AWS_OWNED_KMS_KEY" to use an AWS KMS key that is owned and managed by AWS on your behalf, or the ARN of a valid symmetric customer managed KMS key.
   *
   * @schema LedgerSpecForProvider#kmsKey
   */
  readonly kmsKey?: string;

  /**
   * Reference to a Key in kms to populate kmsKey.
   *
   * @schema LedgerSpecForProvider#kmsKeyRef
   */
  readonly kmsKeyRef?: LedgerSpecForProviderKmsKeyRef;

  /**
   * Selector for a Key in kms to populate kmsKey.
   *
   * @schema LedgerSpecForProvider#kmsKeySelector
   */
  readonly kmsKeySelector?: LedgerSpecForProviderKmsKeySelector;

  /**
   * The permissions mode for the QLDB ledger instance. Specify either ALLOW_ALL or STANDARD.
   *
   * @schema LedgerSpecForProvider#permissionsMode
   */
  readonly permissionsMode?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LedgerSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LedgerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LedgerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecForProvider(obj: LedgerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionProtection': obj.deletionProtection,
    'kmsKey': obj.kmsKey,
    'kmsKeyRef': toJson_LedgerSpecForProviderKmsKeyRef(obj.kmsKeyRef),
    'kmsKeySelector': toJson_LedgerSpecForProviderKmsKeySelector(obj.kmsKeySelector),
    'permissionsMode': obj.permissionsMode,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LedgerSpecManagementPolicy
 */
export enum LedgerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LedgerSpecProviderConfigRef
 */
export interface LedgerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LedgerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LedgerSpecProviderConfigRef#policy
   */
  readonly policy?: LedgerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LedgerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecProviderConfigRef(obj: LedgerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LedgerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LedgerSpecProviderRef
 */
export interface LedgerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LedgerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LedgerSpecProviderRef#policy
   */
  readonly policy?: LedgerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LedgerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecProviderRef(obj: LedgerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LedgerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LedgerSpecPublishConnectionDetailsTo
 */
export interface LedgerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LedgerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LedgerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LedgerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LedgerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LedgerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LedgerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecPublishConnectionDetailsTo(obj: LedgerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LedgerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LedgerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LedgerSpecWriteConnectionSecretToRef
 */
export interface LedgerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LedgerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LedgerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LedgerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecWriteConnectionSecretToRef(obj: LedgerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKey.
 *
 * @schema LedgerSpecForProviderKmsKeyRef
 */
export interface LedgerSpecForProviderKmsKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema LedgerSpecForProviderKmsKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LedgerSpecForProviderKmsKeyRef#policy
   */
  readonly policy?: LedgerSpecForProviderKmsKeyRefPolicy;

}

/**
 * Converts an object of type 'LedgerSpecForProviderKmsKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecForProviderKmsKeyRef(obj: LedgerSpecForProviderKmsKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LedgerSpecForProviderKmsKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKey.
 *
 * @schema LedgerSpecForProviderKmsKeySelector
 */
export interface LedgerSpecForProviderKmsKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LedgerSpecForProviderKmsKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LedgerSpecForProviderKmsKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LedgerSpecForProviderKmsKeySelector#policy
   */
  readonly policy?: LedgerSpecForProviderKmsKeySelectorPolicy;

}

/**
 * Converts an object of type 'LedgerSpecForProviderKmsKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecForProviderKmsKeySelector(obj: LedgerSpecForProviderKmsKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LedgerSpecForProviderKmsKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LedgerSpecProviderConfigRefPolicy
 */
export interface LedgerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LedgerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LedgerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LedgerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LedgerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LedgerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecProviderConfigRefPolicy(obj: LedgerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LedgerSpecProviderRefPolicy
 */
export interface LedgerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LedgerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LedgerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LedgerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LedgerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LedgerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecProviderRefPolicy(obj: LedgerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LedgerSpecPublishConnectionDetailsToConfigRef
 */
export interface LedgerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LedgerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LedgerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LedgerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LedgerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecPublishConnectionDetailsToConfigRef(obj: LedgerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LedgerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LedgerSpecPublishConnectionDetailsToMetadata
 */
export interface LedgerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LedgerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LedgerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LedgerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LedgerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecPublishConnectionDetailsToMetadata(obj: LedgerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LedgerSpecForProviderKmsKeyRefPolicy
 */
export interface LedgerSpecForProviderKmsKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LedgerSpecForProviderKmsKeyRefPolicy#resolution
   */
  readonly resolution?: LedgerSpecForProviderKmsKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LedgerSpecForProviderKmsKeyRefPolicy#resolve
   */
  readonly resolve?: LedgerSpecForProviderKmsKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'LedgerSpecForProviderKmsKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecForProviderKmsKeyRefPolicy(obj: LedgerSpecForProviderKmsKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LedgerSpecForProviderKmsKeySelectorPolicy
 */
export interface LedgerSpecForProviderKmsKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LedgerSpecForProviderKmsKeySelectorPolicy#resolution
   */
  readonly resolution?: LedgerSpecForProviderKmsKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LedgerSpecForProviderKmsKeySelectorPolicy#resolve
   */
  readonly resolve?: LedgerSpecForProviderKmsKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'LedgerSpecForProviderKmsKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecForProviderKmsKeySelectorPolicy(obj: LedgerSpecForProviderKmsKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LedgerSpecProviderConfigRefPolicyResolution
 */
export enum LedgerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LedgerSpecProviderConfigRefPolicyResolve
 */
export enum LedgerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LedgerSpecProviderRefPolicyResolution
 */
export enum LedgerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LedgerSpecProviderRefPolicyResolve
 */
export enum LedgerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LedgerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LedgerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LedgerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LedgerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LedgerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LedgerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LedgerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LedgerSpecPublishConnectionDetailsToConfigRefPolicy(obj: LedgerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LedgerSpecForProviderKmsKeyRefPolicyResolution
 */
export enum LedgerSpecForProviderKmsKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LedgerSpecForProviderKmsKeyRefPolicyResolve
 */
export enum LedgerSpecForProviderKmsKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LedgerSpecForProviderKmsKeySelectorPolicyResolution
 */
export enum LedgerSpecForProviderKmsKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LedgerSpecForProviderKmsKeySelectorPolicyResolve
 */
export enum LedgerSpecForProviderKmsKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LedgerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LedgerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LedgerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LedgerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Stream is the Schema for the Streams API. Provides a QLDB Stream resource.
 *
 * @schema Stream
 */
export class Stream extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stream"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'qldb.aws.upbound.io/v1beta1',
    kind: 'Stream',
  }

  /**
   * Renders a Kubernetes manifest for "Stream".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StreamProps): any {
    return {
      ...Stream.GVK,
      ...toJson_StreamProps(props),
    };
  }

  /**
   * Defines a "Stream" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StreamProps) {
    super(scope, id, {
      ...Stream.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stream.GVK,
      ...toJson_StreamProps(resolved),
    };
  }
}

/**
 * Stream is the Schema for the Streams API. Provides a QLDB Stream resource.
 *
 * @schema Stream
 */
export interface StreamProps {
  /**
   * @schema Stream#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StreamSpec defines the desired state of Stream
   *
   * @schema Stream#spec
   */
  readonly spec: StreamSpec;

}

/**
 * Converts an object of type 'StreamProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamProps(obj: StreamProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StreamSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StreamSpec defines the desired state of Stream
 *
 * @schema StreamSpec
 */
export interface StreamSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StreamSpec#deletionPolicy
   */
  readonly deletionPolicy?: StreamSpecDeletionPolicy;

  /**
   * @schema StreamSpec#forProvider
   */
  readonly forProvider: StreamSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StreamSpec#managementPolicy
   */
  readonly managementPolicy?: StreamSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StreamSpec#providerConfigRef
   */
  readonly providerConfigRef?: StreamSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StreamSpec#providerRef
   */
  readonly providerRef?: StreamSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StreamSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StreamSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StreamSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StreamSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StreamSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpec(obj: StreamSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StreamSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_StreamSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StreamSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StreamSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StreamSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StreamSpecDeletionPolicy
 */
export enum StreamSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StreamSpecForProvider
 */
export interface StreamSpecForProvider {
  /**
   * The exclusive date and time that specifies when the stream ends. If you don't define this parameter, the stream runs indefinitely until you cancel it. It must be in ISO 8601 date and time format and in Universal Coordinated Time (UTC). For example: "2019-06-13T21:36:34Z".
   *
   * @schema StreamSpecForProvider#exclusiveEndTime
   */
  readonly exclusiveEndTime?: string;

  /**
   * The inclusive start date and time from which to start streaming journal data. This parameter must be in ISO 8601 date and time format and in Universal Coordinated Time (UTC). For example: "2019-06-13T21:36:34Z".  This cannot be in the future and must be before exclusive_end_time.  If you provide a value that is before the ledger's CreationDateTime, QLDB effectively defaults it to the ledger's CreationDateTime.
   *
   * @schema StreamSpecForProvider#inclusiveStartTime
   */
  readonly inclusiveStartTime?: string;

  /**
   * The configuration settings of the Kinesis Data Streams destination for your stream request. Documented below.
   *
   * @schema StreamSpecForProvider#kinesisConfiguration
   */
  readonly kinesisConfiguration?: StreamSpecForProviderKinesisConfiguration[];

  /**
   * The name of the QLDB ledger.
   *
   * @schema StreamSpecForProvider#ledgerName
   */
  readonly ledgerName?: string;

  /**
   * Reference to a Ledger in qldb to populate ledgerName.
   *
   * @schema StreamSpecForProvider#ledgerNameRef
   */
  readonly ledgerNameRef?: StreamSpecForProviderLedgerNameRef;

  /**
   * Selector for a Ledger in qldb to populate ledgerName.
   *
   * @schema StreamSpecForProvider#ledgerNameSelector
   */
  readonly ledgerNameSelector?: StreamSpecForProviderLedgerNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StreamSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal stream to write data records to a Kinesis Data Streams resource.
   *
   * @schema StreamSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema StreamSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: StreamSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema StreamSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: StreamSpecForProviderRoleArnSelector;

  /**
   * The name that you want to assign to the QLDB journal stream. User-defined names can help identify and indicate the purpose of a stream.  Your stream name must be unique among other active streams for a given ledger. Stream names have the same naming constraints as ledger names, as defined in the Amazon QLDB Developer Guide.
   *
   * @schema StreamSpecForProvider#streamName
   */
  readonly streamName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StreamSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'StreamSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProvider(obj: StreamSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclusiveEndTime': obj.exclusiveEndTime,
    'inclusiveStartTime': obj.inclusiveStartTime,
    'kinesisConfiguration': obj.kinesisConfiguration?.map(y => toJson_StreamSpecForProviderKinesisConfiguration(y)),
    'ledgerName': obj.ledgerName,
    'ledgerNameRef': toJson_StreamSpecForProviderLedgerNameRef(obj.ledgerNameRef),
    'ledgerNameSelector': toJson_StreamSpecForProviderLedgerNameSelector(obj.ledgerNameSelector),
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_StreamSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_StreamSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'streamName': obj.streamName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StreamSpecManagementPolicy
 */
export enum StreamSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StreamSpecProviderConfigRef
 */
export interface StreamSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecProviderConfigRef#policy
   */
  readonly policy?: StreamSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderConfigRef(obj: StreamSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StreamSpecProviderRef
 */
export interface StreamSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecProviderRef#policy
   */
  readonly policy?: StreamSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderRef(obj: StreamSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StreamSpecPublishConnectionDetailsTo
 */
export interface StreamSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StreamSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StreamSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsTo(obj: StreamSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StreamSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StreamSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StreamSpecWriteConnectionSecretToRef
 */
export interface StreamSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StreamSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StreamSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StreamSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecWriteConnectionSecretToRef(obj: StreamSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StreamSpecForProviderKinesisConfiguration
 */
export interface StreamSpecForProviderKinesisConfiguration {
  /**
   * Enables QLDB to publish multiple data records in a single Kinesis Data Streams record, increasing the number of records sent per API call. Default: true.
   *
   * @schema StreamSpecForProviderKinesisConfiguration#aggregationEnabled
   */
  readonly aggregationEnabled?: boolean;

  /**
   * The Amazon Resource Name (ARN) of the Kinesis Data Streams resource.
   *
   * @schema StreamSpecForProviderKinesisConfiguration#streamArn
   */
  readonly streamArn?: string;

  /**
   * Reference to a Stream in kinesis to populate streamArn.
   *
   * @schema StreamSpecForProviderKinesisConfiguration#streamArnRef
   */
  readonly streamArnRef?: StreamSpecForProviderKinesisConfigurationStreamArnRef;

  /**
   * Selector for a Stream in kinesis to populate streamArn.
   *
   * @schema StreamSpecForProviderKinesisConfiguration#streamArnSelector
   */
  readonly streamArnSelector?: StreamSpecForProviderKinesisConfigurationStreamArnSelector;

}

/**
 * Converts an object of type 'StreamSpecForProviderKinesisConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKinesisConfiguration(obj: StreamSpecForProviderKinesisConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationEnabled': obj.aggregationEnabled,
    'streamArn': obj.streamArn,
    'streamArnRef': toJson_StreamSpecForProviderKinesisConfigurationStreamArnRef(obj.streamArnRef),
    'streamArnSelector': toJson_StreamSpecForProviderKinesisConfigurationStreamArnSelector(obj.streamArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Ledger in qldb to populate ledgerName.
 *
 * @schema StreamSpecForProviderLedgerNameRef
 */
export interface StreamSpecForProviderLedgerNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecForProviderLedgerNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecForProviderLedgerNameRef#policy
   */
  readonly policy?: StreamSpecForProviderLedgerNameRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderLedgerNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderLedgerNameRef(obj: StreamSpecForProviderLedgerNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecForProviderLedgerNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Ledger in qldb to populate ledgerName.
 *
 * @schema StreamSpecForProviderLedgerNameSelector
 */
export interface StreamSpecForProviderLedgerNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StreamSpecForProviderLedgerNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StreamSpecForProviderLedgerNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StreamSpecForProviderLedgerNameSelector#policy
   */
  readonly policy?: StreamSpecForProviderLedgerNameSelectorPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderLedgerNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderLedgerNameSelector(obj: StreamSpecForProviderLedgerNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StreamSpecForProviderLedgerNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema StreamSpecForProviderRoleArnRef
 */
export interface StreamSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecForProviderRoleArnRef#policy
   */
  readonly policy?: StreamSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderRoleArnRef(obj: StreamSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema StreamSpecForProviderRoleArnSelector
 */
export interface StreamSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StreamSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StreamSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StreamSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: StreamSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderRoleArnSelector(obj: StreamSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StreamSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecProviderConfigRefPolicy
 */
export interface StreamSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StreamSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StreamSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderConfigRefPolicy(obj: StreamSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecProviderRefPolicy
 */
export interface StreamSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StreamSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StreamSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderRefPolicy(obj: StreamSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRef
 */
export interface StreamSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StreamSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToConfigRef(obj: StreamSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StreamSpecPublishConnectionDetailsToMetadata
 */
export interface StreamSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToMetadata(obj: StreamSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stream in kinesis to populate streamArn.
 *
 * @schema StreamSpecForProviderKinesisConfigurationStreamArnRef
 */
export interface StreamSpecForProviderKinesisConfigurationStreamArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecForProviderKinesisConfigurationStreamArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecForProviderKinesisConfigurationStreamArnRef#policy
   */
  readonly policy?: StreamSpecForProviderKinesisConfigurationStreamArnRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderKinesisConfigurationStreamArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKinesisConfigurationStreamArnRef(obj: StreamSpecForProviderKinesisConfigurationStreamArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecForProviderKinesisConfigurationStreamArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stream in kinesis to populate streamArn.
 *
 * @schema StreamSpecForProviderKinesisConfigurationStreamArnSelector
 */
export interface StreamSpecForProviderKinesisConfigurationStreamArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StreamSpecForProviderKinesisConfigurationStreamArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StreamSpecForProviderKinesisConfigurationStreamArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StreamSpecForProviderKinesisConfigurationStreamArnSelector#policy
   */
  readonly policy?: StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderKinesisConfigurationStreamArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKinesisConfigurationStreamArnSelector(obj: StreamSpecForProviderKinesisConfigurationStreamArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecForProviderLedgerNameRefPolicy
 */
export interface StreamSpecForProviderLedgerNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderLedgerNameRefPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderLedgerNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderLedgerNameRefPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderLedgerNameRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderLedgerNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderLedgerNameRefPolicy(obj: StreamSpecForProviderLedgerNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StreamSpecForProviderLedgerNameSelectorPolicy
 */
export interface StreamSpecForProviderLedgerNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderLedgerNameSelectorPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderLedgerNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderLedgerNameSelectorPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderLedgerNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderLedgerNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderLedgerNameSelectorPolicy(obj: StreamSpecForProviderLedgerNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecForProviderRoleArnRefPolicy
 */
export interface StreamSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderRoleArnRefPolicy(obj: StreamSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StreamSpecForProviderRoleArnSelectorPolicy
 */
export interface StreamSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderRoleArnSelectorPolicy(obj: StreamSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecProviderConfigRefPolicyResolution
 */
export enum StreamSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecProviderConfigRefPolicyResolve
 */
export enum StreamSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecProviderRefPolicyResolution
 */
export enum StreamSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecProviderRefPolicyResolve
 */
export enum StreamSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StreamSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToConfigRefPolicy(obj: StreamSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecForProviderKinesisConfigurationStreamArnRefPolicy
 */
export interface StreamSpecForProviderKinesisConfigurationStreamArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderKinesisConfigurationStreamArnRefPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderKinesisConfigurationStreamArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderKinesisConfigurationStreamArnRefPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderKinesisConfigurationStreamArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderKinesisConfigurationStreamArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKinesisConfigurationStreamArnRefPolicy(obj: StreamSpecForProviderKinesisConfigurationStreamArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicy
 */
export interface StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicy(obj: StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderLedgerNameRefPolicyResolution
 */
export enum StreamSpecForProviderLedgerNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderLedgerNameRefPolicyResolve
 */
export enum StreamSpecForProviderLedgerNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderLedgerNameSelectorPolicyResolution
 */
export enum StreamSpecForProviderLedgerNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderLedgerNameSelectorPolicyResolve
 */
export enum StreamSpecForProviderLedgerNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderRoleArnRefPolicyResolution
 */
export enum StreamSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderRoleArnRefPolicyResolve
 */
export enum StreamSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum StreamSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum StreamSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderKinesisConfigurationStreamArnRefPolicyResolution
 */
export enum StreamSpecForProviderKinesisConfigurationStreamArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderKinesisConfigurationStreamArnRefPolicyResolve
 */
export enum StreamSpecForProviderKinesisConfigurationStreamArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicyResolution
 */
export enum StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicyResolve
 */
export enum StreamSpecForProviderKinesisConfigurationStreamArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

