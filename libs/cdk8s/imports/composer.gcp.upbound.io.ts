// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Environment is the Schema for the Environments API. An environment for running orchestration tasks.
 *
 * @schema Environment
 */
export class Environment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Environment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'composer.gcp.upbound.io/v1beta1',
    kind: 'Environment',
  }

  /**
   * Renders a Kubernetes manifest for "Environment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvironmentProps): any {
    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(props),
    };
  }

  /**
   * Defines a "Environment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvironmentProps) {
    super(scope, id, {
      ...Environment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(resolved),
    };
  }
}

/**
 * Environment is the Schema for the Environments API. An environment for running orchestration tasks.
 *
 * @schema Environment
 */
export interface EnvironmentProps {
  /**
   * @schema Environment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EnvironmentSpec defines the desired state of Environment
   *
   * @schema Environment#spec
   */
  readonly spec: EnvironmentSpec;

}

/**
 * Converts an object of type 'EnvironmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentProps(obj: EnvironmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvironmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentSpec defines the desired state of Environment
 *
 * @schema EnvironmentSpec
 */
export interface EnvironmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema EnvironmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: EnvironmentSpecDeletionPolicy;

  /**
   * @schema EnvironmentSpec#forProvider
   */
  readonly forProvider: EnvironmentSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EnvironmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: EnvironmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EnvironmentSpec#providerRef
   */
  readonly providerRef?: EnvironmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EnvironmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EnvironmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EnvironmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EnvironmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EnvironmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpec(obj: EnvironmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EnvironmentSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_EnvironmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EnvironmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EnvironmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EnvironmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema EnvironmentSpecDeletionPolicy
 */
export enum EnvironmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EnvironmentSpecForProvider
 */
export interface EnvironmentSpecForProvider {
  /**
   * Configuration parameters for this environment  Structure is documented below.
   *
   * @schema EnvironmentSpecForProvider#config
   */
  readonly config?: EnvironmentSpecForProviderConfig[];

  /**
   * User-defined labels for this environment. The labels map can contain no more than 64 entries. Entries of the labels map are UTF8 strings that comply with the following restrictions: Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?. Label values must be between 0 and 63 characters long and must conform to the regular expression ([a-z]([-a-z0-9]*[a-z0-9])?)?. No more than 64 labels can be associated with a given environment. Both keys and values must be <= 128 bytes in size.
   *
   * @schema EnvironmentSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema EnvironmentSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema EnvironmentSpecForProvider#projectRef
   */
  readonly projectRef?: EnvironmentSpecForProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema EnvironmentSpecForProvider#projectSelector
   */
  readonly projectSelector?: EnvironmentSpecForProviderProjectSelector;

  /**
   * The location or Compute Engine region for the environment.
   *
   * @schema EnvironmentSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProvider(obj: EnvironmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config?.map(y => toJson_EnvironmentSpecForProviderConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'projectRef': toJson_EnvironmentSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_EnvironmentSpecForProviderProjectSelector(obj.projectSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EnvironmentSpecProviderConfigRef
 */
export interface EnvironmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderConfigRef#policy
   */
  readonly policy?: EnvironmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRef(obj: EnvironmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EnvironmentSpecProviderRef
 */
export interface EnvironmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderRef#policy
   */
  readonly policy?: EnvironmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderRef(obj: EnvironmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsTo
 */
export interface EnvironmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EnvironmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EnvironmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsTo(obj: EnvironmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EnvironmentSpecWriteConnectionSecretToRef
 */
export interface EnvironmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EnvironmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecWriteConnectionSecretToRef(obj: EnvironmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfig
 */
export interface EnvironmentSpecForProviderConfig {
  /**
   * The configuration settings for Cloud SQL instance used internally by Apache Airflow software.
   *
   * @schema EnvironmentSpecForProviderConfig#databaseConfig
   */
  readonly databaseConfig?: EnvironmentSpecForProviderConfigDatabaseConfig[];

  /**
   * The encryption options for the Cloud Composer environment and its dependencies.
   *
   * @schema EnvironmentSpecForProviderConfig#encryptionConfig
   */
  readonly encryptionConfig?: EnvironmentSpecForProviderConfigEncryptionConfig[];

  /**
   * The environment size controls the performance parameters of the managed Cloud Composer infrastructure that includes the Airflow database. Values for environment size are ENVIRONMENT_SIZE_SMALL, ENVIRONMENT_SIZE_MEDIUM, and ENVIRONMENT_SIZE_LARGE.
   *
   * @schema EnvironmentSpecForProviderConfig#environmentSize
   */
  readonly environmentSize?: string;

  /**
   * The configuration settings for Cloud Composer maintenance windows.
   *
   * @schema EnvironmentSpecForProviderConfig#maintenanceWindow
   */
  readonly maintenanceWindow?: EnvironmentSpecForProviderConfigMaintenanceWindow[];

  /**
   * Configuration options for the master authorized networks feature. Enabled master authorized networks will disallow all external traffic to access Kubernetes master through HTTPS except traffic from the given CIDR blocks, Google Compute Engine Public IPs and Google Prod IPs. Structure is documented below.
   *
   * @schema EnvironmentSpecForProviderConfig#masterAuthorizedNetworksConfig
   */
  readonly masterAuthorizedNetworksConfig?: EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfig[];

  /**
   * The configuration used for the Kubernetes Engine cluster.  Structure is documented below.
   *
   * @schema EnvironmentSpecForProviderConfig#nodeConfig
   */
  readonly nodeConfig?: EnvironmentSpecForProviderConfigNodeConfig[];

  /**
   * The number of nodes in the Kubernetes Engine cluster of the environment.
   *
   * @schema EnvironmentSpecForProviderConfig#nodeCount
   */
  readonly nodeCount?: number;

  /**
   * The configuration used for the Private IP Cloud Composer environment. Structure is documented below.
   *
   * @schema EnvironmentSpecForProviderConfig#privateEnvironmentConfig
   */
  readonly privateEnvironmentConfig?: EnvironmentSpecForProviderConfigPrivateEnvironmentConfig[];

  /**
   * The configuration settings for recovery. Structure is documented below.
   *
   * @schema EnvironmentSpecForProviderConfig#recoveryConfig
   */
  readonly recoveryConfig?: EnvironmentSpecForProviderConfigRecoveryConfig[];

  /**
   * The configuration settings for software inside the environment.  Structure is documented below.
   *
   * @schema EnvironmentSpecForProviderConfig#softwareConfig
   */
  readonly softwareConfig?: EnvironmentSpecForProviderConfigSoftwareConfig[];

  /**
   * The configuration settings for the Airflow web server App Engine instance.
   *
   * @schema EnvironmentSpecForProviderConfig#webServerConfig
   */
  readonly webServerConfig?: EnvironmentSpecForProviderConfigWebServerConfig[];

  /**
   * The network-level access control policy for the Airflow web server. If unspecified, no network-level access restrictions are applied.
   *
   * @schema EnvironmentSpecForProviderConfig#webServerNetworkAccessControl
   */
  readonly webServerNetworkAccessControl?: EnvironmentSpecForProviderConfigWebServerNetworkAccessControl[];

  /**
   * The Kubernetes workloads configuration for GKE cluster associated with the Cloud Composer environment.
   *
   * @schema EnvironmentSpecForProviderConfig#workloadsConfig
   */
  readonly workloadsConfig?: EnvironmentSpecForProviderConfigWorkloadsConfig[];

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfig(obj: EnvironmentSpecForProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseConfig': obj.databaseConfig?.map(y => toJson_EnvironmentSpecForProviderConfigDatabaseConfig(y)),
    'encryptionConfig': obj.encryptionConfig?.map(y => toJson_EnvironmentSpecForProviderConfigEncryptionConfig(y)),
    'environmentSize': obj.environmentSize,
    'maintenanceWindow': obj.maintenanceWindow?.map(y => toJson_EnvironmentSpecForProviderConfigMaintenanceWindow(y)),
    'masterAuthorizedNetworksConfig': obj.masterAuthorizedNetworksConfig?.map(y => toJson_EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfig(y)),
    'nodeConfig': obj.nodeConfig?.map(y => toJson_EnvironmentSpecForProviderConfigNodeConfig(y)),
    'nodeCount': obj.nodeCount,
    'privateEnvironmentConfig': obj.privateEnvironmentConfig?.map(y => toJson_EnvironmentSpecForProviderConfigPrivateEnvironmentConfig(y)),
    'recoveryConfig': obj.recoveryConfig?.map(y => toJson_EnvironmentSpecForProviderConfigRecoveryConfig(y)),
    'softwareConfig': obj.softwareConfig?.map(y => toJson_EnvironmentSpecForProviderConfigSoftwareConfig(y)),
    'webServerConfig': obj.webServerConfig?.map(y => toJson_EnvironmentSpecForProviderConfigWebServerConfig(y)),
    'webServerNetworkAccessControl': obj.webServerNetworkAccessControl?.map(y => toJson_EnvironmentSpecForProviderConfigWebServerNetworkAccessControl(y)),
    'workloadsConfig': obj.workloadsConfig?.map(y => toJson_EnvironmentSpecForProviderConfigWorkloadsConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema EnvironmentSpecForProviderProjectRef
 */
export interface EnvironmentSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderProjectRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderProjectRef(obj: EnvironmentSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema EnvironmentSpecForProviderProjectSelector
 */
export interface EnvironmentSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderProjectSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderProjectSelector(obj: EnvironmentSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicy
 */
export interface EnvironmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRefPolicy(obj: EnvironmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderRefPolicy
 */
export interface EnvironmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderRefPolicy(obj: EnvironmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj: EnvironmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToMetadata
 */
export interface EnvironmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj: EnvironmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigDatabaseConfig
 */
export interface EnvironmentSpecForProviderConfigDatabaseConfig {
  /**
   * Machine type on which Airflow web server is running. It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4 or composer-n1-webserver-8. Value custom is returned only in response, if Airflow web server parameters were manually changed to a non-standard values.
   *
   * @schema EnvironmentSpecForProviderConfigDatabaseConfig#machineType
   */
  readonly machineType: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigDatabaseConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigDatabaseConfig(obj: EnvironmentSpecForProviderConfigDatabaseConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'machineType': obj.machineType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigEncryptionConfig
 */
export interface EnvironmentSpecForProviderConfigEncryptionConfig {
  /**
   * Customer-managed Encryption Key available through Google's Key Management Service. It must be the fully qualified resource name, i.e. projects/project-id/locations/location/keyRings/keyring/cryptoKeys/key. Cannot be updated.
   *
   * @schema EnvironmentSpecForProviderConfigEncryptionConfig#kmsKeyName
   */
  readonly kmsKeyName: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigEncryptionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigEncryptionConfig(obj: EnvironmentSpecForProviderConfigEncryptionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigMaintenanceWindow
 */
export interface EnvironmentSpecForProviderConfigMaintenanceWindow {
  /**
   * Maintenance window end time. It is used only to calculate the duration of the maintenance window. The value for end-time must be in the future, relative to 'start_time'.
   *
   * @schema EnvironmentSpecForProviderConfigMaintenanceWindow#endTime
   */
  readonly endTime: string;

  /**
   * Maintenance window recurrence. Format is a subset of RFC-5545 (https://tools.ietf.org/html/rfc5545) 'RRULE'. The only allowed values for 'FREQ' field are 'FREQ=DAILY' and 'FREQ=WEEKLY;BYDAY=...'. Example values: 'FREQ=WEEKLY;BYDAY=TU,WE', 'FREQ=DAILY'.
   *
   * @schema EnvironmentSpecForProviderConfigMaintenanceWindow#recurrence
   */
  readonly recurrence: string;

  /**
   * Start time of the first recurrence of the maintenance window.
   *
   * @schema EnvironmentSpecForProviderConfigMaintenanceWindow#startTime
   */
  readonly startTime: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigMaintenanceWindow(obj: EnvironmentSpecForProviderConfigMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'recurrence': obj.recurrence,
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfig
 */
export interface EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfig {
  /**
   * cidr_blocks define up to 50 external networks that could access Kubernetes master through HTTPS. Structure is documented below.
   *
   * @schema EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfig#cidrBlocks
   */
  readonly cidrBlocks?: EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfigCidrBlocks[];

  /**
   * When enabled, Cloud Composer periodically saves snapshots of your environment to a Cloud Storage bucket.
   *
   * @schema EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfig#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfig(obj: EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlocks': obj.cidrBlocks?.map(y => toJson_EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfigCidrBlocks(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigNodeConfig
 */
export interface EnvironmentSpecForProviderConfigNodeConfig {
  /**
   * The disk size in GB used for node VMs. Minimum size is 20GB. If unspecified, defaults to 100GB. Cannot be updated.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * Deploys 'ip-masq-agent' daemon set in the GKE cluster and defines nonMasqueradeCIDRs equals to pod IP range so IP masquerading is used for all destination addresses, except between pods traffic. See the documentation.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#enableIpMasqAgent
   */
  readonly enableIpMasqAgent?: boolean;

  /**
   * Configuration for controlling how IPs are allocated in the GKE cluster. Structure is documented below. Cannot be updated.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#ipAllocationPolicy
   */
  readonly ipAllocationPolicy?: EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy[];

  /**
   * Machine type on which Airflow web server is running. It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4 or composer-n1-webserver-8. Value custom is returned only in response, if Airflow web server parameters were manually changed to a non-standard values.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#machineType
   */
  readonly machineType?: string;

  /**
   * The Compute Engine network to be used for machine communications, specified as a self-link, relative resource name (for example "projects/{project}/global/networks/{network}"), by name.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#networkRef
   */
  readonly networkRef?: EnvironmentSpecForProviderConfigNodeConfigNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#networkSelector
   */
  readonly networkSelector?: EnvironmentSpecForProviderConfigNodeConfigNetworkSelector;

  /**
   * The set of Google API scopes to be made available on all node VMs. Cannot be updated. If empty, defaults to ["https://www.googleapis.com/auth/cloud-platform"].
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * The Google Cloud Platform Service Account to be used by the node VMs. If a service account is not specified, the "default" Compute Engine service account is used. Cannot be updated. If given, note that the service account must have roles/composer.worker for any GCP resources created under the Cloud Composer Environment.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#serviceAccountRef
   */
  readonly serviceAccountRef?: EnvironmentSpecForProviderConfigNodeConfigServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#serviceAccountSelector
   */
  readonly serviceAccountSelector?: EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelector;

  /**
   * The Compute Engine subnetwork to be used for machine communications, specified as a self-link, relative resource name (for example, "projects/{project}/regions/{region}/subnetworks/{subnetwork}"), or by name. If subnetwork is provided, network must also be provided and the subnetwork must belong to the enclosing environment's project and region.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#subnetwork
   */
  readonly subnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate subnetwork.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#subnetworkRef
   */
  readonly subnetworkRef?: EnvironmentSpecForProviderConfigNodeConfigSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate subnetwork.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#subnetworkSelector
   */
  readonly subnetworkSelector?: EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelector;

  /**
   * The list of instance tags applied to all node VMs. Tags are used to identify valid sources or targets for network firewalls. Each tag within the list must comply with RFC1035. Cannot be updated.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#tags
   */
  readonly tags?: string[];

  /**
   * The Compute Engine zone in which to deploy the VMs running the Apache Airflow software, specified as the zone name or relative resource name (e.g. "projects/{project}/zones/{zone}"). Must belong to the enclosing environment's project and region.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfig#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfig(obj: EnvironmentSpecForProviderConfigNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskSizeGb': obj.diskSizeGb,
    'enableIpMasqAgent': obj.enableIpMasqAgent,
    'ipAllocationPolicy': obj.ipAllocationPolicy?.map(y => toJson_EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy(y)),
    'machineType': obj.machineType,
    'network': obj.network,
    'networkRef': toJson_EnvironmentSpecForProviderConfigNodeConfigNetworkRef(obj.networkRef),
    'networkSelector': toJson_EnvironmentSpecForProviderConfigNodeConfigNetworkSelector(obj.networkSelector),
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_EnvironmentSpecForProviderConfigNodeConfigServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelector(obj.serviceAccountSelector),
    'subnetwork': obj.subnetwork,
    'subnetworkRef': toJson_EnvironmentSpecForProviderConfigNodeConfigSubnetworkRef(obj.subnetworkRef),
    'subnetworkSelector': toJson_EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelector(obj.subnetworkSelector),
    'tags': obj.tags?.map(y => y),
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigPrivateEnvironmentConfig
 */
export interface EnvironmentSpecForProviderConfigPrivateEnvironmentConfig {
  /**
   * When specified, the environment will use Private Service Connect instead of VPC peerings to connect to Cloud SQL in the Tenant Project, and the PSC endpoint in the Customer Project will use an IP address from this subnetwork. This field is supported for Cloud Composer environments in versions composer-2.*.*-airflow-*.*.* and newer.
   *
   * @schema EnvironmentSpecForProviderConfigPrivateEnvironmentConfig#cloudComposerConnectionSubnetwork
   */
  readonly cloudComposerConnectionSubnetwork?: string;

  /**
   * @schema EnvironmentSpecForProviderConfigPrivateEnvironmentConfig#cloudComposerNetworkIpv4CidrBlock
   */
  readonly cloudComposerNetworkIpv4CidrBlock?: string;

  /**
   * The CIDR block from which IP range in tenant project will be reserved for Cloud SQL. Needs to be disjoint from web_server_ipv4_cidr_block
   *
   * @schema EnvironmentSpecForProviderConfigPrivateEnvironmentConfig#cloudSqlIpv4CidrBlock
   */
  readonly cloudSqlIpv4CidrBlock?: string;

  /**
   * If true, access to the public endpoint of the GKE cluster is denied. If this field is set to true, the ip_allocation_policy.use_ip_aliases field must also be set to true for Cloud Composer 1 environments.
   *
   * @schema EnvironmentSpecForProviderConfigPrivateEnvironmentConfig#enablePrivateEndpoint
   */
  readonly enablePrivateEndpoint?: boolean;

  /**
   * When enabled, IPs from public (non-RFC1918) ranges can be used for ip_allocation_policy.cluster_ipv4_cidr_block and ip_allocation_policy.service_ipv4_cidr_block.
   *
   * @schema EnvironmentSpecForProviderConfigPrivateEnvironmentConfig#enablePrivatelyUsedPublicIps
   */
  readonly enablePrivatelyUsedPublicIps?: boolean;

  /**
   * The IP range in CIDR notation to use for the hosted master network. This range is used for assigning internal IP addresses to the cluster master or set of masters and to the internal load balancer virtual IP. This range must not overlap with any other ranges in use within the cluster's network. If left blank, the default value of is used. See documentation for default values per region.
   *
   * @schema EnvironmentSpecForProviderConfigPrivateEnvironmentConfig#masterIpv4CidrBlock
   */
  readonly masterIpv4CidrBlock?: string;

  /**
   * The CIDR block from which IP range for web server will be reserved. Needs to be disjoint from master_ipv4_cidr_block and cloud_sql_ipv4_cidr_block.
   *
   * @schema EnvironmentSpecForProviderConfigPrivateEnvironmentConfig#webServerIpv4CidrBlock
   */
  readonly webServerIpv4CidrBlock?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigPrivateEnvironmentConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigPrivateEnvironmentConfig(obj: EnvironmentSpecForProviderConfigPrivateEnvironmentConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudComposerConnectionSubnetwork': obj.cloudComposerConnectionSubnetwork,
    'cloudComposerNetworkIpv4CidrBlock': obj.cloudComposerNetworkIpv4CidrBlock,
    'cloudSqlIpv4CidrBlock': obj.cloudSqlIpv4CidrBlock,
    'enablePrivateEndpoint': obj.enablePrivateEndpoint,
    'enablePrivatelyUsedPublicIps': obj.enablePrivatelyUsedPublicIps,
    'masterIpv4CidrBlock': obj.masterIpv4CidrBlock,
    'webServerIpv4CidrBlock': obj.webServerIpv4CidrBlock,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigRecoveryConfig
 */
export interface EnvironmentSpecForProviderConfigRecoveryConfig {
  /**
   * The recovery configuration settings for the Cloud Composer environment.
   *
   * @schema EnvironmentSpecForProviderConfigRecoveryConfig#scheduledSnapshotsConfig
   */
  readonly scheduledSnapshotsConfig?: EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig[];

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigRecoveryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigRecoveryConfig(obj: EnvironmentSpecForProviderConfigRecoveryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scheduledSnapshotsConfig': obj.scheduledSnapshotsConfig?.map(y => toJson_EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigSoftwareConfig
 */
export interface EnvironmentSpecForProviderConfigSoftwareConfig {
  /**
   * Apache Airflow configuration properties to override. Property keys contain the section and property names, separated by a hyphen, for example "core-dags_are_paused_at_creation".
   *
   * @schema EnvironmentSpecForProviderConfigSoftwareConfig#airflowConfigOverrides
   */
  readonly airflowConfigOverrides?: { [key: string]: string };

  /**
   * Additional environment variables to provide to the Apache Airflow scheduler, worker, and webserver processes. Environment variable names must match the regular expression [a-zA-Z_][a-zA-Z0-9_]*. They cannot specify Apache Airflow software configuration overrides (they cannot match the regular expression AIRFLOW__[A-Z0-9_]+__[A-Z0-9_]+), and they cannot match any of the following reserved names:
   *
   * @schema EnvironmentSpecForProviderConfigSoftwareConfig#envVariables
   */
  readonly envVariables?: { [key: string]: string };

  /**
   * @schema EnvironmentSpecForProviderConfigSoftwareConfig#imageVersion
   */
  readonly imageVersion?: string;

  /**
   * Custom Python Package Index (PyPI) packages to be installed in the environment. Keys refer to the lowercase package name (e.g. "numpy"). Values are the lowercase extras and version specifier (e.g. "==1.12.0", "[devel,gcp_api]", "[devel]>=1.8.2, <1.9.2"). To specify a package without pinning it to a version specifier, use the empty string as the value.
   *
   * @schema EnvironmentSpecForProviderConfigSoftwareConfig#pypiPackages
   */
  readonly pypiPackages?: { [key: string]: string };

  /**
   * The major version of Python used to run the Apache Airflow scheduler, worker, and webserver processes. Can be set to '2' or '3'. If not specified, the default is '3'.
   *
   * @schema EnvironmentSpecForProviderConfigSoftwareConfig#pythonVersion
   */
  readonly pythonVersion?: string;

  /**
   * The number of schedulers for Airflow.
   *
   * @schema EnvironmentSpecForProviderConfigSoftwareConfig#schedulerCount
   */
  readonly schedulerCount?: number;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigSoftwareConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigSoftwareConfig(obj: EnvironmentSpecForProviderConfigSoftwareConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'airflowConfigOverrides': ((obj.airflowConfigOverrides) === undefined) ? undefined : (Object.entries(obj.airflowConfigOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'envVariables': ((obj.envVariables) === undefined) ? undefined : (Object.entries(obj.envVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'imageVersion': obj.imageVersion,
    'pypiPackages': ((obj.pypiPackages) === undefined) ? undefined : (Object.entries(obj.pypiPackages).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'pythonVersion': obj.pythonVersion,
    'schedulerCount': obj.schedulerCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigWebServerConfig
 */
export interface EnvironmentSpecForProviderConfigWebServerConfig {
  /**
   * Machine type on which Airflow web server is running. It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4 or composer-n1-webserver-8. Value custom is returned only in response, if Airflow web server parameters were manually changed to a non-standard values.
   *
   * @schema EnvironmentSpecForProviderConfigWebServerConfig#machineType
   */
  readonly machineType: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigWebServerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigWebServerConfig(obj: EnvironmentSpecForProviderConfigWebServerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'machineType': obj.machineType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigWebServerNetworkAccessControl
 */
export interface EnvironmentSpecForProviderConfigWebServerNetworkAccessControl {
  /**
   * A collection of allowed IP ranges with descriptions. Structure is documented below.
   *
   * @schema EnvironmentSpecForProviderConfigWebServerNetworkAccessControl#allowedIpRange
   */
  readonly allowedIpRange?: EnvironmentSpecForProviderConfigWebServerNetworkAccessControlAllowedIpRange[];

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigWebServerNetworkAccessControl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigWebServerNetworkAccessControl(obj: EnvironmentSpecForProviderConfigWebServerNetworkAccessControl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpRange': obj.allowedIpRange?.map(y => toJson_EnvironmentSpecForProviderConfigWebServerNetworkAccessControlAllowedIpRange(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigWorkloadsConfig
 */
export interface EnvironmentSpecForProviderConfigWorkloadsConfig {
  /**
   * Configuration for resources used by Airflow schedulers.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfig#scheduler
   */
  readonly scheduler?: EnvironmentSpecForProviderConfigWorkloadsConfigScheduler[];

  /**
   * Configuration for resources used by Airflow web server.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfig#webServer
   */
  readonly webServer?: EnvironmentSpecForProviderConfigWorkloadsConfigWebServer[];

  /**
   * Configuration for resources used by Airflow workers.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfig#worker
   */
  readonly worker?: EnvironmentSpecForProviderConfigWorkloadsConfigWorker[];

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigWorkloadsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigWorkloadsConfig(obj: EnvironmentSpecForProviderConfigWorkloadsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scheduler': obj.scheduler?.map(y => toJson_EnvironmentSpecForProviderConfigWorkloadsConfigScheduler(y)),
    'webServer': obj.webServer?.map(y => toJson_EnvironmentSpecForProviderConfigWorkloadsConfigWebServer(y)),
    'worker': obj.worker?.map(y => toJson_EnvironmentSpecForProviderConfigWorkloadsConfigWorker(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderProjectRefPolicy
 */
export interface EnvironmentSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderProjectRefPolicy(obj: EnvironmentSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderProjectSelectorPolicy
 */
export interface EnvironmentSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderProjectSelectorPolicy(obj: EnvironmentSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolution
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolve
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderRefPolicyResolution
 */
export enum EnvironmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderRefPolicyResolve
 */
export enum EnvironmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfigCidrBlocks
 */
export interface EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfigCidrBlocks {
  /**
   * `cidr_block< must be specified in CIDR notation.
   *
   * @schema EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfigCidrBlocks#cidrBlock
   */
  readonly cidrBlock: string;

  /**
   * display_name is a field for users to identify CIDR blocks.
   *
   * @schema EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfigCidrBlocks#displayName
   */
  readonly displayName?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfigCidrBlocks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfigCidrBlocks(obj: EnvironmentSpecForProviderConfigMasterAuthorizedNetworksConfigCidrBlocks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlock': obj.cidrBlock,
    'displayName': obj.displayName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy
 */
export interface EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy {
  /**
   * The IP address range used to allocate IP addresses to pods in the cluster. For Cloud Composer 1 environments, this field is applicable only when use_ip_aliases is true. Set to blank to have GKE choose a range with the default size. Set to /netmask (e.g. /14) to have GKE choose a range with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use. Specify either cluster_secondary_range_name or cluster_ipv4_cidr_block but not both.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy#clusterIpv4CidrBlock
   */
  readonly clusterIpv4CidrBlock?: string;

  /**
   * The name of the cluster's secondary range used to allocate IP addresses to pods. Specify either cluster_secondary_range_name or cluster_ipv4_cidr_block but not both. For Cloud Composer 1 environments, this field is applicable only when use_ip_aliases is true.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy#clusterSecondaryRangeName
   */
  readonly clusterSecondaryRangeName?: string;

  /**
   * The IP address range used to allocate IP addresses in this cluster. For Cloud Composer 1 environments, this field is applicable only when use_ip_aliases is true. Set to blank to have GKE choose a range with the default size. Set to /netmask (e.g. /14) to have GKE choose a range with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use. Specify either services_secondary_range_name or services_ipv4_cidr_block but not both.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy#servicesIpv4CidrBlock
   */
  readonly servicesIpv4CidrBlock?: string;

  /**
   * The name of the services' secondary range used to allocate IP addresses to the cluster. Specify either services_secondary_range_name or services_ipv4_cidr_block but not both. For Cloud Composer 1 environments, this field is applicable only when use_ip_aliases is true.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy#servicesSecondaryRangeName
   */
  readonly servicesSecondaryRangeName?: string;

  /**
   * Whether or not to enable Alias IPs in the GKE cluster. If true, a VPC-native cluster is created. Defaults to true if the ip_allocation_policy block is present in config.
   *
   * @default true if the ip_allocation_policy block is present in config.
   * @schema EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy#useIpAliases
   */
  readonly useIpAliases?: boolean;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy(obj: EnvironmentSpecForProviderConfigNodeConfigIpAllocationPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterIpv4CidrBlock': obj.clusterIpv4CidrBlock,
    'clusterSecondaryRangeName': obj.clusterSecondaryRangeName,
    'servicesIpv4CidrBlock': obj.servicesIpv4CidrBlock,
    'servicesSecondaryRangeName': obj.servicesSecondaryRangeName,
    'useIpAliases': obj.useIpAliases,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkRef
 */
export interface EnvironmentSpecForProviderConfigNodeConfigNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigNetworkRef(obj: EnvironmentSpecForProviderConfigNodeConfigNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkSelector
 */
export interface EnvironmentSpecForProviderConfigNodeConfigNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigNetworkSelector(obj: EnvironmentSpecForProviderConfigNodeConfigNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountRef
 */
export interface EnvironmentSpecForProviderConfigNodeConfigServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigServiceAccountRef(obj: EnvironmentSpecForProviderConfigNodeConfigServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelector
 */
export interface EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelector(obj: EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnetwork in compute to populate subnetwork.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkRef
 */
export interface EnvironmentSpecForProviderConfigNodeConfigSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkRef#policy
   */
  readonly policy?: EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigSubnetworkRef(obj: EnvironmentSpecForProviderConfigNodeConfigSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnetwork in compute to populate subnetwork.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelector
 */
export interface EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelector#policy
   */
  readonly policy?: EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelector(obj: EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig
 */
export interface EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig {
  /**
   * When enabled, Cloud Composer periodically saves snapshots of your environment to a Cloud Storage bucket.
   *
   * @schema EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig#enabled
   */
  readonly enabled: boolean;

  /**
   * Snapshot schedule, in the unix-cron format.
   *
   * @schema EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig#snapshotCreationSchedule
   */
  readonly snapshotCreationSchedule?: string;

  /**
   * The URI of a bucket folder where to save the snapshot.
   *
   * @schema EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig#snapshotLocation
   */
  readonly snapshotLocation?: string;

  /**
   * A time zone for the schedule. This value is a time offset and does not take into account daylight saving time changes. Valid values are from UTC-12 to UTC+12. Examples: UTC, UTC-01, UTC+03.
   *
   * @schema EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig(obj: EnvironmentSpecForProviderConfigRecoveryConfigScheduledSnapshotsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'snapshotCreationSchedule': obj.snapshotCreationSchedule,
    'snapshotLocation': obj.snapshotLocation,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigWebServerNetworkAccessControlAllowedIpRange
 */
export interface EnvironmentSpecForProviderConfigWebServerNetworkAccessControlAllowedIpRange {
  /**
   * A description of this ip range.
   *
   * @schema EnvironmentSpecForProviderConfigWebServerNetworkAccessControlAllowedIpRange#description
   */
  readonly description?: string;

  /**
   * IP address or range, defined using CIDR notation, of requests that this rule applies to. Examples: 192.168.1.1 or 192.168.0.0/16 or 2001:db8::/32 or 2001:0db8:0000:0042:0000:8a2e:0370:7334. IP range prefixes should be properly truncated. For example, 1.2.3.4/24 should be truncated to 1.2.3.0/24. Similarly, for IPv6, 2001:db8::1/32 should be truncated to 2001:db8::/32.
   *
   * @schema EnvironmentSpecForProviderConfigWebServerNetworkAccessControlAllowedIpRange#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigWebServerNetworkAccessControlAllowedIpRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigWebServerNetworkAccessControlAllowedIpRange(obj: EnvironmentSpecForProviderConfigWebServerNetworkAccessControlAllowedIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigWorkloadsConfigScheduler
 */
export interface EnvironmentSpecForProviderConfigWorkloadsConfigScheduler {
  /**
   * The number of Airflow triggerers.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigScheduler#count
   */
  readonly count?: number;

  /**
   * The number of CPUs for a single Airflow worker.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigScheduler#cpu
   */
  readonly cpu?: number;

  /**
   * The amount of memory (GB) for a single Airflow worker.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigScheduler#memoryGb
   */
  readonly memoryGb?: number;

  /**
   * The amount of storage (GB) for the Airflow web server.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigScheduler#storageGb
   */
  readonly storageGb?: number;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigWorkloadsConfigScheduler' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigWorkloadsConfigScheduler(obj: EnvironmentSpecForProviderConfigWorkloadsConfigScheduler | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'cpu': obj.cpu,
    'memoryGb': obj.memoryGb,
    'storageGb': obj.storageGb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigWorkloadsConfigWebServer
 */
export interface EnvironmentSpecForProviderConfigWorkloadsConfigWebServer {
  /**
   * The number of CPUs for a single Airflow worker.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigWebServer#cpu
   */
  readonly cpu?: number;

  /**
   * The amount of memory (GB) for a single Airflow worker.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigWebServer#memoryGb
   */
  readonly memoryGb?: number;

  /**
   * The amount of storage (GB) for the Airflow web server.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigWebServer#storageGb
   */
  readonly storageGb?: number;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigWorkloadsConfigWebServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigWorkloadsConfigWebServer(obj: EnvironmentSpecForProviderConfigWorkloadsConfigWebServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpu': obj.cpu,
    'memoryGb': obj.memoryGb,
    'storageGb': obj.storageGb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderConfigWorkloadsConfigWorker
 */
export interface EnvironmentSpecForProviderConfigWorkloadsConfigWorker {
  /**
   * The number of CPUs for a single Airflow worker.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigWorker#cpu
   */
  readonly cpu?: number;

  /**
   * The maximum number of Airflow workers that the environment can run. The number of workers in the environment does not go above this number, even if a higher number of workers is required to handle the load.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigWorker#maxCount
   */
  readonly maxCount?: number;

  /**
   * The amount of memory (GB) for a single Airflow worker.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigWorker#memoryGb
   */
  readonly memoryGb?: number;

  /**
   * The minimum number of Airflow workers that the environment can run. The number of workers in the environment does not go above this number, even if a lower number of workers can handle the load.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigWorker#minCount
   */
  readonly minCount?: number;

  /**
   * The amount of storage (GB) for the Airflow web server.
   *
   * @schema EnvironmentSpecForProviderConfigWorkloadsConfigWorker#storageGb
   */
  readonly storageGb?: number;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigWorkloadsConfigWorker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigWorkloadsConfigWorker(obj: EnvironmentSpecForProviderConfigWorkloadsConfigWorker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpu': obj.cpu,
    'maxCount': obj.maxCount,
    'memoryGb': obj.memoryGb,
    'minCount': obj.minCount,
    'storageGb': obj.storageGb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderProjectRefPolicyResolution
 */
export enum EnvironmentSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderProjectRefPolicyResolve
 */
export enum EnvironmentSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderProjectSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderProjectSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicy
 */
export interface EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicy(obj: EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicy
 */
export interface EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicy(obj: EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicy
 */
export interface EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicy(obj: EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicy
 */
export interface EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicy(obj: EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicy
 */
export interface EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicy(obj: EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicy
 */
export interface EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicy(obj: EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicyResolution
 */
export enum EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicyResolve
 */
export enum EnvironmentSpecForProviderConfigNodeConfigNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderConfigNodeConfigNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicyResolution
 */
export enum EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicyResolve
 */
export enum EnvironmentSpecForProviderConfigNodeConfigServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderConfigNodeConfigServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicyResolution
 */
export enum EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicyResolve
 */
export enum EnvironmentSpecForProviderConfigNodeConfigSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicyResolution
 */
export enum EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicyResolve
 */
export enum EnvironmentSpecForProviderConfigNodeConfigSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

