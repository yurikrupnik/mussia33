// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Application is the Schema for the Applications API. Provides an Elastic Beanstalk Application Resource
 *
 * @schema Application
 */
export class Application extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Application"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elasticbeanstalk.aws.upbound.io/v1beta1',
    kind: 'Application',
  }

  /**
   * Renders a Kubernetes manifest for "Application".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationProps): any {
    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(props),
    };
  }

  /**
   * Defines a "Application" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationProps) {
    super(scope, id, {
      ...Application.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(resolved),
    };
  }
}

/**
 * Application is the Schema for the Applications API. Provides an Elastic Beanstalk Application Resource
 *
 * @schema Application
 */
export interface ApplicationProps {
  /**
   * @schema Application#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApplicationSpec defines the desired state of Application
   *
   * @schema Application#spec
   */
  readonly spec: ApplicationSpec;

}

/**
 * Converts an object of type 'ApplicationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationProps(obj: ApplicationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSpec defines the desired state of Application
 *
 * @schema ApplicationSpec
 */
export interface ApplicationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApplicationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationSpecDeletionPolicy;

  /**
   * @schema ApplicationSpec#forProvider
   */
  readonly forProvider: ApplicationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ApplicationSpec#initProvider
   */
  readonly initProvider?: ApplicationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApplicationSpec#managementPolicies
   */
  readonly managementPolicies?: ApplicationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpec(obj: ApplicationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationSpecForProvider(obj.forProvider),
    'initProvider': toJson_ApplicationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApplicationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApplicationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApplicationSpecDeletionPolicy
 */
export enum ApplicationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApplicationSpecForProvider
 */
export interface ApplicationSpecForProvider {
  /**
   * @schema ApplicationSpecForProvider#appversionLifecycle
   */
  readonly appversionLifecycle?: ApplicationSpecForProviderAppversionLifecycle[];

  /**
   * Short description of the application
   *
   * @schema ApplicationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApplicationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProvider(obj: ApplicationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appversionLifecycle': obj.appversionLifecycle?.map(y => toJson_ApplicationSpecForProviderAppversionLifecycle(y)),
    'description': obj.description,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ApplicationSpecInitProvider
 */
export interface ApplicationSpecInitProvider {
  /**
   * @schema ApplicationSpecInitProvider#appversionLifecycle
   */
  readonly appversionLifecycle?: ApplicationSpecInitProviderAppversionLifecycle[];

  /**
   * Short description of the application
   *
   * @schema ApplicationSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProvider(obj: ApplicationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appversionLifecycle': obj.appversionLifecycle?.map(y => toJson_ApplicationSpecInitProviderAppversionLifecycle(y)),
    'description': obj.description,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApplicationSpecManagementPolicies
 */
export enum ApplicationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationSpecProviderConfigRef
 */
export interface ApplicationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRef(obj: ApplicationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationSpecPublishConnectionDetailsTo
 */
export interface ApplicationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsTo(obj: ApplicationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationSpecWriteConnectionSecretToRef
 */
export interface ApplicationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecWriteConnectionSecretToRef(obj: ApplicationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderAppversionLifecycle
 */
export interface ApplicationSpecForProviderAppversionLifecycle {
  /**
   * Set to true to delete a version's source bundle from S3 when the application version is deleted.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycle#deleteSourceFromS3
   */
  readonly deleteSourceFromS3?: boolean;

  /**
   * The number of days to retain an application version ('max_age_in_days' and 'max_count' cannot be enabled simultaneously.).
   *
   * @schema ApplicationSpecForProviderAppversionLifecycle#maxAgeInDays
   */
  readonly maxAgeInDays?: number;

  /**
   * The maximum number of application versions to retain ('max_age_in_days' and 'max_count' cannot be enabled simultaneously.).
   *
   * @schema ApplicationSpecForProviderAppversionLifecycle#maxCount
   */
  readonly maxCount?: number;

  /**
   * The ARN of an IAM service role under which the application version is deleted.  Elastic Beanstalk must have permission to assume this role.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycle#serviceRole
   */
  readonly serviceRole?: string;

  /**
   * Reference to a Role in iam to populate serviceRole.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycle#serviceRoleRef
   */
  readonly serviceRoleRef?: ApplicationSpecForProviderAppversionLifecycleServiceRoleRef;

  /**
   * Selector for a Role in iam to populate serviceRole.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycle#serviceRoleSelector
   */
  readonly serviceRoleSelector?: ApplicationSpecForProviderAppversionLifecycleServiceRoleSelector;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderAppversionLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderAppversionLifecycle(obj: ApplicationSpecForProviderAppversionLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteSourceFromS3': obj.deleteSourceFromS3,
    'maxAgeInDays': obj.maxAgeInDays,
    'maxCount': obj.maxCount,
    'serviceRole': obj.serviceRole,
    'serviceRoleRef': toJson_ApplicationSpecForProviderAppversionLifecycleServiceRoleRef(obj.serviceRoleRef),
    'serviceRoleSelector': toJson_ApplicationSpecForProviderAppversionLifecycleServiceRoleSelector(obj.serviceRoleSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderAppversionLifecycle
 */
export interface ApplicationSpecInitProviderAppversionLifecycle {
  /**
   * Set to true to delete a version's source bundle from S3 when the application version is deleted.
   *
   * @schema ApplicationSpecInitProviderAppversionLifecycle#deleteSourceFromS3
   */
  readonly deleteSourceFromS3?: boolean;

  /**
   * The number of days to retain an application version ('max_age_in_days' and 'max_count' cannot be enabled simultaneously.).
   *
   * @schema ApplicationSpecInitProviderAppversionLifecycle#maxAgeInDays
   */
  readonly maxAgeInDays?: number;

  /**
   * The maximum number of application versions to retain ('max_age_in_days' and 'max_count' cannot be enabled simultaneously.).
   *
   * @schema ApplicationSpecInitProviderAppversionLifecycle#maxCount
   */
  readonly maxCount?: number;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderAppversionLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderAppversionLifecycle(obj: ApplicationSpecInitProviderAppversionLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteSourceFromS3': obj.deleteSourceFromS3,
    'maxAgeInDays': obj.maxAgeInDays,
    'maxCount': obj.maxCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderConfigRefPolicy
 */
export interface ApplicationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRefPolicy(obj: ApplicationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj: ApplicationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj: ApplicationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate serviceRole.
 *
 * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleRef
 */
export interface ApplicationSpecForProviderAppversionLifecycleServiceRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleRef#policy
   */
  readonly policy?: ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderAppversionLifecycleServiceRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderAppversionLifecycleServiceRoleRef(obj: ApplicationSpecForProviderAppversionLifecycleServiceRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate serviceRole.
 *
 * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleSelector
 */
export interface ApplicationSpecForProviderAppversionLifecycleServiceRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderAppversionLifecycleServiceRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderAppversionLifecycleServiceRoleSelector(obj: ApplicationSpecForProviderAppversionLifecycleServiceRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicy
 */
export interface ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicy(obj: ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicy
 */
export interface ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicy(obj: ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicyResolution
 */
export enum ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicyResolve
 */
export enum ApplicationSpecForProviderAppversionLifecycleServiceRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderAppversionLifecycleServiceRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ApplicationVersion is the Schema for the ApplicationVersions API. Provides an Elastic Beanstalk Application Version Resource
 *
 * @schema ApplicationVersion
 */
export class ApplicationVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ApplicationVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elasticbeanstalk.aws.upbound.io/v1beta1',
    kind: 'ApplicationVersion',
  }

  /**
   * Renders a Kubernetes manifest for "ApplicationVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationVersionProps): any {
    return {
      ...ApplicationVersion.GVK,
      ...toJson_ApplicationVersionProps(props),
    };
  }

  /**
   * Defines a "ApplicationVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationVersionProps) {
    super(scope, id, {
      ...ApplicationVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApplicationVersion.GVK,
      ...toJson_ApplicationVersionProps(resolved),
    };
  }
}

/**
 * ApplicationVersion is the Schema for the ApplicationVersions API. Provides an Elastic Beanstalk Application Version Resource
 *
 * @schema ApplicationVersion
 */
export interface ApplicationVersionProps {
  /**
   * @schema ApplicationVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApplicationVersionSpec defines the desired state of ApplicationVersion
   *
   * @schema ApplicationVersion#spec
   */
  readonly spec: ApplicationVersionSpec;

}

/**
 * Converts an object of type 'ApplicationVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionProps(obj: ApplicationVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationVersionSpec defines the desired state of ApplicationVersion
 *
 * @schema ApplicationVersionSpec
 */
export interface ApplicationVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApplicationVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationVersionSpecDeletionPolicy;

  /**
   * @schema ApplicationVersionSpec#forProvider
   */
  readonly forProvider: ApplicationVersionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ApplicationVersionSpec#initProvider
   */
  readonly initProvider?: ApplicationVersionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApplicationVersionSpec#managementPolicies
   */
  readonly managementPolicies?: ApplicationVersionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationVersionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpec(obj: ApplicationVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationVersionSpecForProvider(obj.forProvider),
    'initProvider': toJson_ApplicationVersionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApplicationVersionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApplicationVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApplicationVersionSpecDeletionPolicy
 */
export enum ApplicationVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApplicationVersionSpecForProvider
 */
export interface ApplicationVersionSpecForProvider {
  /**
   * Name of the Beanstalk Application the version is associated with.
   *
   * @schema ApplicationVersionSpecForProvider#application
   */
  readonly application?: string;

  /**
   * S3 bucket that contains the Application Version source bundle.
   *
   * @schema ApplicationVersionSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema ApplicationVersionSpecForProvider#bucketRef
   */
  readonly bucketRef?: ApplicationVersionSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema ApplicationVersionSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: ApplicationVersionSpecForProviderBucketSelector;

  /**
   * Short description of the Application Version.
   *
   * @schema ApplicationVersionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * On delete, force an Application Version to be deleted when it may be in use by multiple Elastic Beanstalk Environments.
   *
   * @schema ApplicationVersionSpecForProvider#forceDelete
   */
  readonly forceDelete?: boolean;

  /**
   * S3 object that is the Application Version source bundle.
   *
   * @schema ApplicationVersionSpecForProvider#key
   */
  readonly key?: string;

  /**
   * Reference to a Object in s3 to populate key.
   *
   * @schema ApplicationVersionSpecForProvider#keyRef
   */
  readonly keyRef?: ApplicationVersionSpecForProviderKeyRef;

  /**
   * Selector for a Object in s3 to populate key.
   *
   * @schema ApplicationVersionSpecForProvider#keySelector
   */
  readonly keySelector?: ApplicationVersionSpecForProviderKeySelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApplicationVersionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationVersionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecForProvider(obj: ApplicationVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'application': obj.application,
    'bucket': obj.bucket,
    'bucketRef': toJson_ApplicationVersionSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_ApplicationVersionSpecForProviderBucketSelector(obj.bucketSelector),
    'description': obj.description,
    'forceDelete': obj.forceDelete,
    'key': obj.key,
    'keyRef': toJson_ApplicationVersionSpecForProviderKeyRef(obj.keyRef),
    'keySelector': toJson_ApplicationVersionSpecForProviderKeySelector(obj.keySelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ApplicationVersionSpecInitProvider
 */
export interface ApplicationVersionSpecInitProvider {
  /**
   * Name of the Beanstalk Application the version is associated with.
   *
   * @schema ApplicationVersionSpecInitProvider#application
   */
  readonly application?: string;

  /**
   * Short description of the Application Version.
   *
   * @schema ApplicationVersionSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * On delete, force an Application Version to be deleted when it may be in use by multiple Elastic Beanstalk Environments.
   *
   * @schema ApplicationVersionSpecInitProvider#forceDelete
   */
  readonly forceDelete?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationVersionSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationVersionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecInitProvider(obj: ApplicationVersionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'application': obj.application,
    'description': obj.description,
    'forceDelete': obj.forceDelete,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApplicationVersionSpecManagementPolicies
 */
export enum ApplicationVersionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationVersionSpecProviderConfigRef
 */
export interface ApplicationVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationVersionSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecProviderConfigRef(obj: ApplicationVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationVersionSpecPublishConnectionDetailsTo
 */
export interface ApplicationVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecPublishConnectionDetailsTo(obj: ApplicationVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationVersionSpecWriteConnectionSecretToRef
 */
export interface ApplicationVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecWriteConnectionSecretToRef(obj: ApplicationVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema ApplicationVersionSpecForProviderBucketRef
 */
export interface ApplicationVersionSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationVersionSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationVersionSpecForProviderBucketRef#policy
   */
  readonly policy?: ApplicationVersionSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'ApplicationVersionSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecForProviderBucketRef(obj: ApplicationVersionSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationVersionSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema ApplicationVersionSpecForProviderBucketSelector
 */
export interface ApplicationVersionSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationVersionSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationVersionSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationVersionSpecForProviderBucketSelector#policy
   */
  readonly policy?: ApplicationVersionSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationVersionSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecForProviderBucketSelector(obj: ApplicationVersionSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationVersionSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Object in s3 to populate key.
 *
 * @schema ApplicationVersionSpecForProviderKeyRef
 */
export interface ApplicationVersionSpecForProviderKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationVersionSpecForProviderKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationVersionSpecForProviderKeyRef#policy
   */
  readonly policy?: ApplicationVersionSpecForProviderKeyRefPolicy;

}

/**
 * Converts an object of type 'ApplicationVersionSpecForProviderKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecForProviderKeyRef(obj: ApplicationVersionSpecForProviderKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationVersionSpecForProviderKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Object in s3 to populate key.
 *
 * @schema ApplicationVersionSpecForProviderKeySelector
 */
export interface ApplicationVersionSpecForProviderKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationVersionSpecForProviderKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationVersionSpecForProviderKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationVersionSpecForProviderKeySelector#policy
   */
  readonly policy?: ApplicationVersionSpecForProviderKeySelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationVersionSpecForProviderKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecForProviderKeySelector(obj: ApplicationVersionSpecForProviderKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationVersionSpecForProviderKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationVersionSpecProviderConfigRefPolicy
 */
export interface ApplicationVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecProviderConfigRefPolicy(obj: ApplicationVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecPublishConnectionDetailsToConfigRef(obj: ApplicationVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationVersionSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecPublishConnectionDetailsToMetadata(obj: ApplicationVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationVersionSpecForProviderBucketRefPolicy
 */
export interface ApplicationVersionSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationVersionSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: ApplicationVersionSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationVersionSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: ApplicationVersionSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationVersionSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecForProviderBucketRefPolicy(obj: ApplicationVersionSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationVersionSpecForProviderBucketSelectorPolicy
 */
export interface ApplicationVersionSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationVersionSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationVersionSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationVersionSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationVersionSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationVersionSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecForProviderBucketSelectorPolicy(obj: ApplicationVersionSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationVersionSpecForProviderKeyRefPolicy
 */
export interface ApplicationVersionSpecForProviderKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationVersionSpecForProviderKeyRefPolicy#resolution
   */
  readonly resolution?: ApplicationVersionSpecForProviderKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationVersionSpecForProviderKeyRefPolicy#resolve
   */
  readonly resolve?: ApplicationVersionSpecForProviderKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationVersionSpecForProviderKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecForProviderKeyRefPolicy(obj: ApplicationVersionSpecForProviderKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationVersionSpecForProviderKeySelectorPolicy
 */
export interface ApplicationVersionSpecForProviderKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationVersionSpecForProviderKeySelectorPolicy#resolution
   */
  readonly resolution?: ApplicationVersionSpecForProviderKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationVersionSpecForProviderKeySelectorPolicy#resolve
   */
  readonly resolve?: ApplicationVersionSpecForProviderKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationVersionSpecForProviderKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecForProviderKeySelectorPolicy(obj: ApplicationVersionSpecForProviderKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationVersionSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationVersionSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationVersionSpecForProviderBucketRefPolicyResolution
 */
export enum ApplicationVersionSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationVersionSpecForProviderBucketRefPolicyResolve
 */
export enum ApplicationVersionSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationVersionSpecForProviderBucketSelectorPolicyResolution
 */
export enum ApplicationVersionSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationVersionSpecForProviderBucketSelectorPolicyResolve
 */
export enum ApplicationVersionSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationVersionSpecForProviderKeyRefPolicyResolution
 */
export enum ApplicationVersionSpecForProviderKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationVersionSpecForProviderKeyRefPolicyResolve
 */
export enum ApplicationVersionSpecForProviderKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationVersionSpecForProviderKeySelectorPolicyResolution
 */
export enum ApplicationVersionSpecForProviderKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationVersionSpecForProviderKeySelectorPolicyResolve
 */
export enum ApplicationVersionSpecForProviderKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ConfigurationTemplate is the Schema for the ConfigurationTemplates API. Provides an Elastic Beanstalk Configuration Template
 *
 * @schema ConfigurationTemplate
 */
export class ConfigurationTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConfigurationTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elasticbeanstalk.aws.upbound.io/v1beta1',
    kind: 'ConfigurationTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "ConfigurationTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationTemplateProps): any {
    return {
      ...ConfigurationTemplate.GVK,
      ...toJson_ConfigurationTemplateProps(props),
    };
  }

  /**
   * Defines a "ConfigurationTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationTemplateProps) {
    super(scope, id, {
      ...ConfigurationTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConfigurationTemplate.GVK,
      ...toJson_ConfigurationTemplateProps(resolved),
    };
  }
}

/**
 * ConfigurationTemplate is the Schema for the ConfigurationTemplates API. Provides an Elastic Beanstalk Configuration Template
 *
 * @schema ConfigurationTemplate
 */
export interface ConfigurationTemplateProps {
  /**
   * @schema ConfigurationTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationTemplateSpec defines the desired state of ConfigurationTemplate
   *
   * @schema ConfigurationTemplate#spec
   */
  readonly spec: ConfigurationTemplateSpec;

}

/**
 * Converts an object of type 'ConfigurationTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateProps(obj: ConfigurationTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationTemplateSpec defines the desired state of ConfigurationTemplate
 *
 * @schema ConfigurationTemplateSpec
 */
export interface ConfigurationTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConfigurationTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationTemplateSpecDeletionPolicy;

  /**
   * @schema ConfigurationTemplateSpec#forProvider
   */
  readonly forProvider: ConfigurationTemplateSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ConfigurationTemplateSpec#initProvider
   */
  readonly initProvider?: ConfigurationTemplateSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConfigurationTemplateSpec#managementPolicies
   */
  readonly managementPolicies?: ConfigurationTemplateSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationTemplateSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpec(obj: ConfigurationTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationTemplateSpecForProvider(obj.forProvider),
    'initProvider': toJson_ConfigurationTemplateSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConfigurationTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConfigurationTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConfigurationTemplateSpecDeletionPolicy
 */
export enum ConfigurationTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConfigurationTemplateSpecForProvider
 */
export interface ConfigurationTemplateSpecForProvider {
  /**
   *   name of the application to associate with this configuration template
   *
   * @schema ConfigurationTemplateSpecForProvider#application
   */
  readonly application?: string;

  /**
   * Reference to a Application in elasticbeanstalk to populate application.
   *
   * @schema ConfigurationTemplateSpecForProvider#applicationRef
   */
  readonly applicationRef?: ConfigurationTemplateSpecForProviderApplicationRef;

  /**
   * Selector for a Application in elasticbeanstalk to populate application.
   *
   * @schema ConfigurationTemplateSpecForProvider#applicationSelector
   */
  readonly applicationSelector?: ConfigurationTemplateSpecForProviderApplicationSelector;

  /**
   * Short description of the Template
   *
   * @schema ConfigurationTemplateSpecForProvider#description
   */
  readonly description?: string;

  /**
   *   The ID of the environment used with this configuration template
   *
   * @schema ConfigurationTemplateSpecForProvider#environmentId
   */
  readonly environmentId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConfigurationTemplateSpecForProvider#region
   */
  readonly region: string;

  /**
   *   Option settings to configure the new Environment. These override specific values that are set as defaults. The format is detailed below in Option Settings
   *
   * @schema ConfigurationTemplateSpecForProvider#setting
   */
  readonly setting?: ConfigurationTemplateSpecForProviderSetting[];

  /**
   *   A solution stack to base your Template off of. Example stacks can be found in the Amazon API documentation
   *
   * @schema ConfigurationTemplateSpecForProvider#solutionStackName
   */
  readonly solutionStackName?: string;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecForProvider(obj: ConfigurationTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'application': obj.application,
    'applicationRef': toJson_ConfigurationTemplateSpecForProviderApplicationRef(obj.applicationRef),
    'applicationSelector': toJson_ConfigurationTemplateSpecForProviderApplicationSelector(obj.applicationSelector),
    'description': obj.description,
    'environmentId': obj.environmentId,
    'region': obj.region,
    'setting': obj.setting?.map(y => toJson_ConfigurationTemplateSpecForProviderSetting(y)),
    'solutionStackName': obj.solutionStackName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ConfigurationTemplateSpecInitProvider
 */
export interface ConfigurationTemplateSpecInitProvider {
  /**
   * Short description of the Template
   *
   * @schema ConfigurationTemplateSpecInitProvider#description
   */
  readonly description?: string;

  /**
   *   The ID of the environment used with this configuration template
   *
   * @schema ConfigurationTemplateSpecInitProvider#environmentId
   */
  readonly environmentId?: string;

  /**
   *   Option settings to configure the new Environment. These override specific values that are set as defaults. The format is detailed below in Option Settings
   *
   * @schema ConfigurationTemplateSpecInitProvider#setting
   */
  readonly setting?: ConfigurationTemplateSpecInitProviderSetting[];

  /**
   *   A solution stack to base your Template off of. Example stacks can be found in the Amazon API documentation
   *
   * @schema ConfigurationTemplateSpecInitProvider#solutionStackName
   */
  readonly solutionStackName?: string;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecInitProvider(obj: ConfigurationTemplateSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'environmentId': obj.environmentId,
    'setting': obj.setting?.map(y => toJson_ConfigurationTemplateSpecInitProviderSetting(y)),
    'solutionStackName': obj.solutionStackName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConfigurationTemplateSpecManagementPolicies
 */
export enum ConfigurationTemplateSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationTemplateSpecProviderConfigRef
 */
export interface ConfigurationTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecProviderConfigRef(obj: ConfigurationTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationTemplateSpecPublishConnectionDetailsTo
 */
export interface ConfigurationTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecPublishConnectionDetailsTo(obj: ConfigurationTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationTemplateSpecWriteConnectionSecretToRef
 */
export interface ConfigurationTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecWriteConnectionSecretToRef(obj: ConfigurationTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Application in elasticbeanstalk to populate application.
 *
 * @schema ConfigurationTemplateSpecForProviderApplicationRef
 */
export interface ConfigurationTemplateSpecForProviderApplicationRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationTemplateSpecForProviderApplicationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationTemplateSpecForProviderApplicationRef#policy
   */
  readonly policy?: ConfigurationTemplateSpecForProviderApplicationRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecForProviderApplicationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecForProviderApplicationRef(obj: ConfigurationTemplateSpecForProviderApplicationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationTemplateSpecForProviderApplicationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Application in elasticbeanstalk to populate application.
 *
 * @schema ConfigurationTemplateSpecForProviderApplicationSelector
 */
export interface ConfigurationTemplateSpecForProviderApplicationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigurationTemplateSpecForProviderApplicationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigurationTemplateSpecForProviderApplicationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigurationTemplateSpecForProviderApplicationSelector#policy
   */
  readonly policy?: ConfigurationTemplateSpecForProviderApplicationSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecForProviderApplicationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecForProviderApplicationSelector(obj: ConfigurationTemplateSpecForProviderApplicationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigurationTemplateSpecForProviderApplicationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationTemplateSpecForProviderSetting
 */
export interface ConfigurationTemplateSpecForProviderSetting {
  /**
   * A unique name for this Template.
   *
   * @schema ConfigurationTemplateSpecForProviderSetting#name
   */
  readonly name?: string;

  /**
   * unique namespace identifying the option's associated AWS resource
   *
   * @schema ConfigurationTemplateSpecForProviderSetting#namespace
   */
  readonly namespace?: string;

  /**
   * resource name for scheduled action
   *
   * @schema ConfigurationTemplateSpecForProviderSetting#resource
   */
  readonly resource?: string;

  /**
   * value for the configuration option
   *
   * @schema ConfigurationTemplateSpecForProviderSetting#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecForProviderSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecForProviderSetting(obj: ConfigurationTemplateSpecForProviderSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'resource': obj.resource,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationTemplateSpecInitProviderSetting
 */
export interface ConfigurationTemplateSpecInitProviderSetting {
  /**
   * A unique name for this Template.
   *
   * @schema ConfigurationTemplateSpecInitProviderSetting#name
   */
  readonly name?: string;

  /**
   * unique namespace identifying the option's associated AWS resource
   *
   * @schema ConfigurationTemplateSpecInitProviderSetting#namespace
   */
  readonly namespace?: string;

  /**
   * resource name for scheduled action
   *
   * @schema ConfigurationTemplateSpecInitProviderSetting#resource
   */
  readonly resource?: string;

  /**
   * value for the configuration option
   *
   * @schema ConfigurationTemplateSpecInitProviderSetting#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecInitProviderSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecInitProviderSetting(obj: ConfigurationTemplateSpecInitProviderSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'resource': obj.resource,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationTemplateSpecProviderConfigRefPolicy
 */
export interface ConfigurationTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecProviderConfigRefPolicy(obj: ConfigurationTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecPublishConnectionDetailsToMetadata(obj: ConfigurationTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationTemplateSpecForProviderApplicationRefPolicy
 */
export interface ConfigurationTemplateSpecForProviderApplicationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationTemplateSpecForProviderApplicationRefPolicy#resolution
   */
  readonly resolution?: ConfigurationTemplateSpecForProviderApplicationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationTemplateSpecForProviderApplicationRefPolicy#resolve
   */
  readonly resolve?: ConfigurationTemplateSpecForProviderApplicationRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecForProviderApplicationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecForProviderApplicationRefPolicy(obj: ConfigurationTemplateSpecForProviderApplicationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigurationTemplateSpecForProviderApplicationSelectorPolicy
 */
export interface ConfigurationTemplateSpecForProviderApplicationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationTemplateSpecForProviderApplicationSelectorPolicy#resolution
   */
  readonly resolution?: ConfigurationTemplateSpecForProviderApplicationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationTemplateSpecForProviderApplicationSelectorPolicy#resolve
   */
  readonly resolve?: ConfigurationTemplateSpecForProviderApplicationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecForProviderApplicationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecForProviderApplicationSelectorPolicy(obj: ConfigurationTemplateSpecForProviderApplicationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationTemplateSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationTemplateSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationTemplateSpecForProviderApplicationRefPolicyResolution
 */
export enum ConfigurationTemplateSpecForProviderApplicationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationTemplateSpecForProviderApplicationRefPolicyResolve
 */
export enum ConfigurationTemplateSpecForProviderApplicationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationTemplateSpecForProviderApplicationSelectorPolicyResolution
 */
export enum ConfigurationTemplateSpecForProviderApplicationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationTemplateSpecForProviderApplicationSelectorPolicyResolve
 */
export enum ConfigurationTemplateSpecForProviderApplicationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

