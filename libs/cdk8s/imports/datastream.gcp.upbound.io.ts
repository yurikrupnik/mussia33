// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ConnectionProfile is the Schema for the ConnectionProfiles API. A set of reusable connection configurations to be used as a source or destination for a stream.
 *
 * @schema ConnectionProfile
 */
export class ConnectionProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConnectionProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datastream.gcp.upbound.io/v1beta1',
    kind: 'ConnectionProfile',
  }

  /**
   * Renders a Kubernetes manifest for "ConnectionProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectionProfileProps): any {
    return {
      ...ConnectionProfile.GVK,
      ...toJson_ConnectionProfileProps(props),
    };
  }

  /**
   * Defines a "ConnectionProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectionProfileProps) {
    super(scope, id, {
      ...ConnectionProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConnectionProfile.GVK,
      ...toJson_ConnectionProfileProps(resolved),
    };
  }
}

/**
 * ConnectionProfile is the Schema for the ConnectionProfiles API. A set of reusable connection configurations to be used as a source or destination for a stream.
 *
 * @schema ConnectionProfile
 */
export interface ConnectionProfileProps {
  /**
   * @schema ConnectionProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectionProfileSpec defines the desired state of ConnectionProfile
   *
   * @schema ConnectionProfile#spec
   */
  readonly spec: ConnectionProfileSpec;

}

/**
 * Converts an object of type 'ConnectionProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileProps(obj: ConnectionProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectionProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionProfileSpec defines the desired state of ConnectionProfile
 *
 * @schema ConnectionProfileSpec
 */
export interface ConnectionProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectionProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectionProfileSpecDeletionPolicy;

  /**
   * @schema ConnectionProfileSpec#forProvider
   */
  readonly forProvider: ConnectionProfileSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectionProfileSpec#managementPolicy
   */
  readonly managementPolicy?: ConnectionProfileSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectionProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectionProfileSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConnectionProfileSpec#providerRef
   */
  readonly providerRef?: ConnectionProfileSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectionProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectionProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectionProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectionProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectionProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpec(obj: ConnectionProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectionProfileSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ConnectionProfileSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConnectionProfileSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConnectionProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectionProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectionProfileSpecDeletionPolicy
 */
export enum ConnectionProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConnectionProfileSpecForProvider
 */
export interface ConnectionProfileSpecForProvider {
  /**
   * BigQuery warehouse profile.
   *
   * @schema ConnectionProfileSpecForProvider#bigqueryProfile
   */
  readonly bigqueryProfile?: any[];

  /**
   * Display name.
   *
   * @schema ConnectionProfileSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Forward SSH tunnel connectivity. Structure is documented below.
   *
   * @schema ConnectionProfileSpecForProvider#forwardSshConnectivity
   */
  readonly forwardSshConnectivity?: ConnectionProfileSpecForProviderForwardSshConnectivity[];

  /**
   * Cloud Storage bucket profile. Structure is documented below.
   *
   * @schema ConnectionProfileSpecForProvider#gcsProfile
   */
  readonly gcsProfile?: ConnectionProfileSpecForProviderGcsProfile[];

  /**
   * Labels.
   *
   * @schema ConnectionProfileSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of the location this connection profile is located in.
   *
   * @schema ConnectionProfileSpecForProvider#location
   */
  readonly location: string;

  /**
   * MySQL database profile. Structure is documented below.
   *
   * @schema ConnectionProfileSpecForProvider#mysqlProfile
   */
  readonly mysqlProfile?: ConnectionProfileSpecForProviderMysqlProfile[];

  /**
   * Oracle database profile. Structure is documented below.
   *
   * @schema ConnectionProfileSpecForProvider#oracleProfile
   */
  readonly oracleProfile?: ConnectionProfileSpecForProviderOracleProfile[];

  /**
   * PostgreSQL database profile. Structure is documented below.
   *
   * @schema ConnectionProfileSpecForProvider#postgresqlProfile
   */
  readonly postgresqlProfile?: ConnectionProfileSpecForProviderPostgresqlProfile[];

  /**
   * Private connectivity. Structure is documented below.
   *
   * @schema ConnectionProfileSpecForProvider#privateConnectivity
   */
  readonly privateConnectivity?: ConnectionProfileSpecForProviderPrivateConnectivity[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema ConnectionProfileSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProvider(obj: ConnectionProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigqueryProfile': obj.bigqueryProfile?.map(y => y),
    'displayName': obj.displayName,
    'forwardSshConnectivity': obj.forwardSshConnectivity?.map(y => toJson_ConnectionProfileSpecForProviderForwardSshConnectivity(y)),
    'gcsProfile': obj.gcsProfile?.map(y => toJson_ConnectionProfileSpecForProviderGcsProfile(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'mysqlProfile': obj.mysqlProfile?.map(y => toJson_ConnectionProfileSpecForProviderMysqlProfile(y)),
    'oracleProfile': obj.oracleProfile?.map(y => toJson_ConnectionProfileSpecForProviderOracleProfile(y)),
    'postgresqlProfile': obj.postgresqlProfile?.map(y => toJson_ConnectionProfileSpecForProviderPostgresqlProfile(y)),
    'privateConnectivity': obj.privateConnectivity?.map(y => toJson_ConnectionProfileSpecForProviderPrivateConnectivity(y)),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectionProfileSpecManagementPolicy
 */
export enum ConnectionProfileSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectionProfileSpecProviderConfigRef
 */
export interface ConnectionProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionProfileSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectionProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecProviderConfigRef(obj: ConnectionProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConnectionProfileSpecProviderRef
 */
export interface ConnectionProfileSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionProfileSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionProfileSpecProviderRef#policy
   */
  readonly policy?: ConnectionProfileSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecProviderRef(obj: ConnectionProfileSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionProfileSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectionProfileSpecPublishConnectionDetailsTo
 */
export interface ConnectionProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectionProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectionProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectionProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectionProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectionProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecPublishConnectionDetailsTo(obj: ConnectionProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectionProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectionProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectionProfileSpecWriteConnectionSecretToRef
 */
export interface ConnectionProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectionProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecWriteConnectionSecretToRef(obj: ConnectionProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionProfileSpecForProviderForwardSshConnectivity
 */
export interface ConnectionProfileSpecForProviderForwardSshConnectivity {
  /**
   * Hostname for the SSH tunnel.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivity#hostname
   */
  readonly hostname: string;

  /**
   * SSH password. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivity#passwordSecretRef
   */
  readonly passwordSecretRef?: ConnectionProfileSpecForProviderForwardSshConnectivityPasswordSecretRef;

  /**
   * Port for the SSH tunnel.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivity#port
   */
  readonly port?: number;

  /**
   * SSH private key. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivity#privateKeySecretRef
   */
  readonly privateKeySecretRef?: ConnectionProfileSpecForProviderForwardSshConnectivityPrivateKeySecretRef;

  /**
   * Username for the SSH tunnel.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivity#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderForwardSshConnectivity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderForwardSshConnectivity(obj: ConnectionProfileSpecForProviderForwardSshConnectivity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname,
    'passwordSecretRef': toJson_ConnectionProfileSpecForProviderForwardSshConnectivityPasswordSecretRef(obj.passwordSecretRef),
    'port': obj.port,
    'privateKeySecretRef': toJson_ConnectionProfileSpecForProviderForwardSshConnectivityPrivateKeySecretRef(obj.privateKeySecretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionProfileSpecForProviderGcsProfile
 */
export interface ConnectionProfileSpecForProviderGcsProfile {
  /**
   * The Cloud Storage bucket name.
   *
   * @schema ConnectionProfileSpecForProviderGcsProfile#bucket
   */
  readonly bucket: string;

  /**
   * The root path inside the Cloud Storage bucket.
   *
   * @schema ConnectionProfileSpecForProviderGcsProfile#rootPath
   */
  readonly rootPath?: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderGcsProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderGcsProfile(obj: ConnectionProfileSpecForProviderGcsProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'rootPath': obj.rootPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionProfileSpecForProviderMysqlProfile
 */
export interface ConnectionProfileSpecForProviderMysqlProfile {
  /**
   * Hostname for the MySQL connection.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfile#hostname
   */
  readonly hostname: string;

  /**
   * Password for the MySQL connection. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfile#passwordSecretRef
   */
  readonly passwordSecretRef: ConnectionProfileSpecForProviderMysqlProfilePasswordSecretRef;

  /**
   * Port for the MySQL connection.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfile#port
   */
  readonly port?: number;

  /**
   * SSL configuration for the MySQL connection. Structure is documented below.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfile#sslConfig
   */
  readonly sslConfig?: ConnectionProfileSpecForProviderMysqlProfileSslConfig[];

  /**
   * Username for the MySQL connection.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfile#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderMysqlProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderMysqlProfile(obj: ConnectionProfileSpecForProviderMysqlProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname,
    'passwordSecretRef': toJson_ConnectionProfileSpecForProviderMysqlProfilePasswordSecretRef(obj.passwordSecretRef),
    'port': obj.port,
    'sslConfig': obj.sslConfig?.map(y => toJson_ConnectionProfileSpecForProviderMysqlProfileSslConfig(y)),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionProfileSpecForProviderOracleProfile
 */
export interface ConnectionProfileSpecForProviderOracleProfile {
  /**
   * Connection string attributes
   *
   * @schema ConnectionProfileSpecForProviderOracleProfile#connectionAttributes
   */
  readonly connectionAttributes?: { [key: string]: string };

  /**
   * Database for the Oracle connection.
   *
   * @schema ConnectionProfileSpecForProviderOracleProfile#databaseService
   */
  readonly databaseService: string;

  /**
   * Hostname for the Oracle connection.
   *
   * @schema ConnectionProfileSpecForProviderOracleProfile#hostname
   */
  readonly hostname: string;

  /**
   * Password for the Oracle connection. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema ConnectionProfileSpecForProviderOracleProfile#passwordSecretRef
   */
  readonly passwordSecretRef: ConnectionProfileSpecForProviderOracleProfilePasswordSecretRef;

  /**
   * Port for the Oracle connection.
   *
   * @schema ConnectionProfileSpecForProviderOracleProfile#port
   */
  readonly port?: number;

  /**
   * Username for the Oracle connection.
   *
   * @schema ConnectionProfileSpecForProviderOracleProfile#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderOracleProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderOracleProfile(obj: ConnectionProfileSpecForProviderOracleProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionAttributes': ((obj.connectionAttributes) === undefined) ? undefined : (Object.entries(obj.connectionAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'databaseService': obj.databaseService,
    'hostname': obj.hostname,
    'passwordSecretRef': toJson_ConnectionProfileSpecForProviderOracleProfilePasswordSecretRef(obj.passwordSecretRef),
    'port': obj.port,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionProfileSpecForProviderPostgresqlProfile
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfile {
  /**
   * Database for the PostgreSQL connection.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#database
   */
  readonly database?: string;

  /**
   * Reference to a Database in sql to populate database.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#databaseRef
   */
  readonly databaseRef?: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRef;

  /**
   * Selector for a Database in sql to populate database.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#databaseSelector
   */
  readonly databaseSelector?: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelector;

  /**
   * Hostname for the PostgreSQL connection.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#hostname
   */
  readonly hostname?: string;

  /**
   * Reference to a DatabaseInstance in sql to populate hostname.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#hostnameRef
   */
  readonly hostnameRef?: ConnectionProfileSpecForProviderPostgresqlProfileHostnameRef;

  /**
   * Selector for a DatabaseInstance in sql to populate hostname.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#hostnameSelector
   */
  readonly hostnameSelector?: ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelector;

  /**
   * Password for the PostgreSQL connection. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#passwordSecretRef
   */
  readonly passwordSecretRef: ConnectionProfileSpecForProviderPostgresqlProfilePasswordSecretRef;

  /**
   * Port for the PostgreSQL connection.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#port
   */
  readonly port?: number;

  /**
   * Username for the PostgreSQL connection.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#username
   */
  readonly username?: string;

  /**
   * Reference to a User in sql to populate username.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#usernameRef
   */
  readonly usernameRef?: ConnectionProfileSpecForProviderPostgresqlProfileUsernameRef;

  /**
   * Selector for a User in sql to populate username.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfile#usernameSelector
   */
  readonly usernameSelector?: ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelector;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfile(obj: ConnectionProfileSpecForProviderPostgresqlProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'databaseRef': toJson_ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRef(obj.databaseRef),
    'databaseSelector': toJson_ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelector(obj.databaseSelector),
    'hostname': obj.hostname,
    'hostnameRef': toJson_ConnectionProfileSpecForProviderPostgresqlProfileHostnameRef(obj.hostnameRef),
    'hostnameSelector': toJson_ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelector(obj.hostnameSelector),
    'passwordSecretRef': toJson_ConnectionProfileSpecForProviderPostgresqlProfilePasswordSecretRef(obj.passwordSecretRef),
    'port': obj.port,
    'username': obj.username,
    'usernameRef': toJson_ConnectionProfileSpecForProviderPostgresqlProfileUsernameRef(obj.usernameRef),
    'usernameSelector': toJson_ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelector(obj.usernameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionProfileSpecForProviderPrivateConnectivity
 */
export interface ConnectionProfileSpecForProviderPrivateConnectivity {
  /**
   * A reference to a private connection resource. Format: projects/{project}/locations/{location}/privateConnections/{name}
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivity#privateConnection
   */
  readonly privateConnection?: string;

  /**
   * Reference to a PrivateConnection in datastream to populate privateConnection.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivity#privateConnectionRef
   */
  readonly privateConnectionRef?: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRef;

  /**
   * Selector for a PrivateConnection in datastream to populate privateConnection.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivity#privateConnectionSelector
   */
  readonly privateConnectionSelector?: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelector;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPrivateConnectivity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPrivateConnectivity(obj: ConnectionProfileSpecForProviderPrivateConnectivity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateConnection': obj.privateConnection,
    'privateConnectionRef': toJson_ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRef(obj.privateConnectionRef),
    'privateConnectionSelector': toJson_ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelector(obj.privateConnectionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionProfileSpecProviderConfigRefPolicy
 */
export interface ConnectionProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecProviderConfigRefPolicy(obj: ConnectionProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionProfileSpecProviderRefPolicy
 */
export interface ConnectionProfileSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecProviderRefPolicy(obj: ConnectionProfileSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectionProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectionProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecPublishConnectionDetailsToConfigRef(obj: ConnectionProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectionProfileSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectionProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectionProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecPublishConnectionDetailsToMetadata(obj: ConnectionProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SSH password. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema ConnectionProfileSpecForProviderForwardSshConnectivityPasswordSecretRef
 */
export interface ConnectionProfileSpecForProviderForwardSshConnectivityPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivityPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivityPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivityPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderForwardSshConnectivityPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderForwardSshConnectivityPasswordSecretRef(obj: ConnectionProfileSpecForProviderForwardSshConnectivityPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SSH private key. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema ConnectionProfileSpecForProviderForwardSshConnectivityPrivateKeySecretRef
 */
export interface ConnectionProfileSpecForProviderForwardSshConnectivityPrivateKeySecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivityPrivateKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivityPrivateKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionProfileSpecForProviderForwardSshConnectivityPrivateKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderForwardSshConnectivityPrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderForwardSshConnectivityPrivateKeySecretRef(obj: ConnectionProfileSpecForProviderForwardSshConnectivityPrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for the MySQL connection. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema ConnectionProfileSpecForProviderMysqlProfilePasswordSecretRef
 */
export interface ConnectionProfileSpecForProviderMysqlProfilePasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfilePasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfilePasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfilePasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderMysqlProfilePasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderMysqlProfilePasswordSecretRef(obj: ConnectionProfileSpecForProviderMysqlProfilePasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfig
 */
export interface ConnectionProfileSpecForProviderMysqlProfileSslConfig {
  /**
   * PEM-encoded certificate of the CA that signed the source database server's certificate. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfig#caCertificateSecretRef
   */
  readonly caCertificateSecretRef?: ConnectionProfileSpecForProviderMysqlProfileSslConfigCaCertificateSecretRef;

  /**
   * PEM-encoded certificate that will be used by the replica to authenticate against the source database server. If this field is used then the 'clientKey' and the 'caCertificate' fields are mandatory. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfig#clientCertificateSecretRef
   */
  readonly clientCertificateSecretRef?: ConnectionProfileSpecForProviderMysqlProfileSslConfigClientCertificateSecretRef;

  /**
   * PEM-encoded private key associated with the Client Certificate. If this field is used then the 'client_certificate' and the 'ca_certificate' fields are mandatory. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfig#clientKeySecretRef
   */
  readonly clientKeySecretRef?: ConnectionProfileSpecForProviderMysqlProfileSslConfigClientKeySecretRef;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderMysqlProfileSslConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderMysqlProfileSslConfig(obj: ConnectionProfileSpecForProviderMysqlProfileSslConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificateSecretRef': toJson_ConnectionProfileSpecForProviderMysqlProfileSslConfigCaCertificateSecretRef(obj.caCertificateSecretRef),
    'clientCertificateSecretRef': toJson_ConnectionProfileSpecForProviderMysqlProfileSslConfigClientCertificateSecretRef(obj.clientCertificateSecretRef),
    'clientKeySecretRef': toJson_ConnectionProfileSpecForProviderMysqlProfileSslConfigClientKeySecretRef(obj.clientKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for the Oracle connection. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema ConnectionProfileSpecForProviderOracleProfilePasswordSecretRef
 */
export interface ConnectionProfileSpecForProviderOracleProfilePasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionProfileSpecForProviderOracleProfilePasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionProfileSpecForProviderOracleProfilePasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionProfileSpecForProviderOracleProfilePasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderOracleProfilePasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderOracleProfilePasswordSecretRef(obj: ConnectionProfileSpecForProviderOracleProfilePasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Database in sql to populate database.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRef
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRef#policy
   */
  readonly policy?: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRef(obj: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Database in sql to populate database.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelector
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelector#policy
   */
  readonly policy?: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelector(obj: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DatabaseInstance in sql to populate hostname.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameRef
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileHostnameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameRef#policy
   */
  readonly policy?: ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileHostnameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileHostnameRef(obj: ConnectionProfileSpecForProviderPostgresqlProfileHostnameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DatabaseInstance in sql to populate hostname.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelector
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelector#policy
   */
  readonly policy?: ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelector(obj: ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for the PostgreSQL connection. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfilePasswordSecretRef
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfilePasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfilePasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfilePasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfilePasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfilePasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfilePasswordSecretRef(obj: ConnectionProfileSpecForProviderPostgresqlProfilePasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in sql to populate username.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameRef
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileUsernameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameRef#policy
   */
  readonly policy?: ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileUsernameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileUsernameRef(obj: ConnectionProfileSpecForProviderPostgresqlProfileUsernameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in sql to populate username.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelector
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelector#policy
   */
  readonly policy?: ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelector(obj: ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PrivateConnection in datastream to populate privateConnection.
 *
 * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRef
 */
export interface ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRef#policy
   */
  readonly policy?: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRef(obj: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PrivateConnection in datastream to populate privateConnection.
 *
 * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelector
 */
export interface ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelector#policy
   */
  readonly policy?: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelector(obj: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecProviderConfigRefPolicyResolution
 */
export enum ConnectionProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecProviderConfigRefPolicyResolve
 */
export enum ConnectionProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecProviderRefPolicyResolution
 */
export enum ConnectionProfileSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecProviderRefPolicyResolve
 */
export enum ConnectionProfileSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PEM-encoded certificate of the CA that signed the source database server's certificate. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigCaCertificateSecretRef
 */
export interface ConnectionProfileSpecForProviderMysqlProfileSslConfigCaCertificateSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigCaCertificateSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigCaCertificateSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigCaCertificateSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderMysqlProfileSslConfigCaCertificateSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderMysqlProfileSslConfigCaCertificateSecretRef(obj: ConnectionProfileSpecForProviderMysqlProfileSslConfigCaCertificateSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PEM-encoded certificate that will be used by the replica to authenticate against the source database server. If this field is used then the 'clientKey' and the 'caCertificate' fields are mandatory. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigClientCertificateSecretRef
 */
export interface ConnectionProfileSpecForProviderMysqlProfileSslConfigClientCertificateSecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigClientCertificateSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigClientCertificateSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigClientCertificateSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderMysqlProfileSslConfigClientCertificateSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderMysqlProfileSslConfigClientCertificateSecretRef(obj: ConnectionProfileSpecForProviderMysqlProfileSslConfigClientCertificateSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PEM-encoded private key associated with the Client Certificate. If this field is used then the 'client_certificate' and the 'ca_certificate' fields are mandatory. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigClientKeySecretRef
 */
export interface ConnectionProfileSpecForProviderMysqlProfileSslConfigClientKeySecretRef {
  /**
   * The key to select.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigClientKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigClientKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionProfileSpecForProviderMysqlProfileSslConfigClientKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderMysqlProfileSslConfigClientKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderMysqlProfileSslConfigClientKeySecretRef(obj: ConnectionProfileSpecForProviderMysqlProfileSslConfigClientKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicy
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicy(obj: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicy
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicy(obj: ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicy
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicy(obj: ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicy
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicy(obj: ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicy
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicy(obj: ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicy
 */
export interface ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicy(obj: ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicy
 */
export interface ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicy(obj: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicy
 */
export interface ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicy(obj: ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectionProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicyResolution
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicyResolve
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileDatabaseRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicyResolution
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicyResolve
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileDatabaseSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicyResolution
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicyResolve
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileHostnameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicyResolution
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicyResolve
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileHostnameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicyResolution
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicyResolve
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileUsernameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicyResolution
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicyResolve
 */
export enum ConnectionProfileSpecForProviderPostgresqlProfileUsernameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicyResolution
 */
export enum ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicyResolve
 */
export enum ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicyResolution
 */
export enum ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicyResolve
 */
export enum ConnectionProfileSpecForProviderPrivateConnectivityPrivateConnectionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PrivateConnection is the Schema for the PrivateConnections API. The PrivateConnection resource is used to establish private connectivity between Datastream and a customer's network.
 *
 * @schema PrivateConnection
 */
export class PrivateConnection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PrivateConnection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datastream.gcp.upbound.io/v1beta1',
    kind: 'PrivateConnection',
  }

  /**
   * Renders a Kubernetes manifest for "PrivateConnection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PrivateConnectionProps): any {
    return {
      ...PrivateConnection.GVK,
      ...toJson_PrivateConnectionProps(props),
    };
  }

  /**
   * Defines a "PrivateConnection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PrivateConnectionProps) {
    super(scope, id, {
      ...PrivateConnection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PrivateConnection.GVK,
      ...toJson_PrivateConnectionProps(resolved),
    };
  }
}

/**
 * PrivateConnection is the Schema for the PrivateConnections API. The PrivateConnection resource is used to establish private connectivity between Datastream and a customer's network.
 *
 * @schema PrivateConnection
 */
export interface PrivateConnectionProps {
  /**
   * @schema PrivateConnection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PrivateConnectionSpec defines the desired state of PrivateConnection
   *
   * @schema PrivateConnection#spec
   */
  readonly spec: PrivateConnectionSpec;

}

/**
 * Converts an object of type 'PrivateConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionProps(obj: PrivateConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PrivateConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrivateConnectionSpec defines the desired state of PrivateConnection
 *
 * @schema PrivateConnectionSpec
 */
export interface PrivateConnectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PrivateConnectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: PrivateConnectionSpecDeletionPolicy;

  /**
   * @schema PrivateConnectionSpec#forProvider
   */
  readonly forProvider: PrivateConnectionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PrivateConnectionSpec#managementPolicy
   */
  readonly managementPolicy?: PrivateConnectionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PrivateConnectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: PrivateConnectionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PrivateConnectionSpec#providerRef
   */
  readonly providerRef?: PrivateConnectionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PrivateConnectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PrivateConnectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PrivateConnectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PrivateConnectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PrivateConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpec(obj: PrivateConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PrivateConnectionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PrivateConnectionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PrivateConnectionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PrivateConnectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PrivateConnectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PrivateConnectionSpecDeletionPolicy
 */
export enum PrivateConnectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PrivateConnectionSpecForProvider
 */
export interface PrivateConnectionSpecForProvider {
  /**
   * Display name.
   *
   * @schema PrivateConnectionSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Labels.
   *
   * @schema PrivateConnectionSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of the location this private connection is located in.
   *
   * @schema PrivateConnectionSpecForProvider#location
   */
  readonly location: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema PrivateConnectionSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The VPC Peering configuration is used to create VPC peering between Datastream and the consumer's VPC. Structure is documented below.
   *
   * @schema PrivateConnectionSpecForProvider#vpcPeeringConfig
   */
  readonly vpcPeeringConfig?: PrivateConnectionSpecForProviderVpcPeeringConfig[];

}

/**
 * Converts an object of type 'PrivateConnectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecForProvider(obj: PrivateConnectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'project': obj.project,
    'vpcPeeringConfig': obj.vpcPeeringConfig?.map(y => toJson_PrivateConnectionSpecForProviderVpcPeeringConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PrivateConnectionSpecManagementPolicy
 */
export enum PrivateConnectionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PrivateConnectionSpecProviderConfigRef
 */
export interface PrivateConnectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateConnectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateConnectionSpecProviderConfigRef#policy
   */
  readonly policy?: PrivateConnectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PrivateConnectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecProviderConfigRef(obj: PrivateConnectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateConnectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PrivateConnectionSpecProviderRef
 */
export interface PrivateConnectionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateConnectionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateConnectionSpecProviderRef#policy
   */
  readonly policy?: PrivateConnectionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PrivateConnectionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecProviderRef(obj: PrivateConnectionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateConnectionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PrivateConnectionSpecPublishConnectionDetailsTo
 */
export interface PrivateConnectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PrivateConnectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PrivateConnectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PrivateConnectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PrivateConnectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PrivateConnectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrivateConnectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecPublishConnectionDetailsTo(obj: PrivateConnectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PrivateConnectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PrivateConnectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PrivateConnectionSpecWriteConnectionSecretToRef
 */
export interface PrivateConnectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PrivateConnectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PrivateConnectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PrivateConnectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecWriteConnectionSecretToRef(obj: PrivateConnectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrivateConnectionSpecForProviderVpcPeeringConfig
 */
export interface PrivateConnectionSpecForProviderVpcPeeringConfig {
  /**
   * A free subnet for peering. (CIDR of /29)
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfig#subnet
   */
  readonly subnet: string;

  /**
   * Fully qualified name of the VPC that Datastream will peer to. Format: projects/{project}/global/{networks}/{name}
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfig#vpc
   */
  readonly vpc?: string;

  /**
   * Reference to a Network in compute to populate vpc.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfig#vpcRef
   */
  readonly vpcRef?: PrivateConnectionSpecForProviderVpcPeeringConfigVpcRef;

  /**
   * Selector for a Network in compute to populate vpc.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfig#vpcSelector
   */
  readonly vpcSelector?: PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelector;

}

/**
 * Converts an object of type 'PrivateConnectionSpecForProviderVpcPeeringConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecForProviderVpcPeeringConfig(obj: PrivateConnectionSpecForProviderVpcPeeringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subnet': obj.subnet,
    'vpc': obj.vpc,
    'vpcRef': toJson_PrivateConnectionSpecForProviderVpcPeeringConfigVpcRef(obj.vpcRef),
    'vpcSelector': toJson_PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelector(obj.vpcSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrivateConnectionSpecProviderConfigRefPolicy
 */
export interface PrivateConnectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateConnectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PrivateConnectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateConnectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PrivateConnectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateConnectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecProviderConfigRefPolicy(obj: PrivateConnectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrivateConnectionSpecProviderRefPolicy
 */
export interface PrivateConnectionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateConnectionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PrivateConnectionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateConnectionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PrivateConnectionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateConnectionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecProviderRefPolicy(obj: PrivateConnectionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PrivateConnectionSpecPublishConnectionDetailsToConfigRef
 */
export interface PrivateConnectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateConnectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateConnectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PrivateConnectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecPublishConnectionDetailsToConfigRef(obj: PrivateConnectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PrivateConnectionSpecPublishConnectionDetailsToMetadata
 */
export interface PrivateConnectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PrivateConnectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PrivateConnectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PrivateConnectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PrivateConnectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecPublishConnectionDetailsToMetadata(obj: PrivateConnectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate vpc.
 *
 * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcRef
 */
export interface PrivateConnectionSpecForProviderVpcPeeringConfigVpcRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcRef#policy
   */
  readonly policy?: PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicy;

}

/**
 * Converts an object of type 'PrivateConnectionSpecForProviderVpcPeeringConfigVpcRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecForProviderVpcPeeringConfigVpcRef(obj: PrivateConnectionSpecForProviderVpcPeeringConfigVpcRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate vpc.
 *
 * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelector
 */
export interface PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelector#policy
   */
  readonly policy?: PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicy;

}

/**
 * Converts an object of type 'PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelector(obj: PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateConnectionSpecProviderConfigRefPolicyResolution
 */
export enum PrivateConnectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateConnectionSpecProviderConfigRefPolicyResolve
 */
export enum PrivateConnectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateConnectionSpecProviderRefPolicyResolution
 */
export enum PrivateConnectionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateConnectionSpecProviderRefPolicyResolve
 */
export enum PrivateConnectionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicy
 */
export interface PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicy#resolution
   */
  readonly resolution?: PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicy#resolve
   */
  readonly resolve?: PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicy(obj: PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicy
 */
export interface PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicy#resolution
   */
  readonly resolution?: PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicy#resolve
   */
  readonly resolve?: PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicy(obj: PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PrivateConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicyResolution
 */
export enum PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicyResolve
 */
export enum PrivateConnectionSpecForProviderVpcPeeringConfigVpcRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicyResolution
 */
export enum PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicyResolve
 */
export enum PrivateConnectionSpecForProviderVpcPeeringConfigVpcSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

